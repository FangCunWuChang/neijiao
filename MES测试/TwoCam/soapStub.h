/* soapStub.h
   Generated by gSOAP 2.8.51 for WebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20851
# error "GSOAP VERSION 20851 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__ArrayOfString;	/* WebService.h:151 */
class _ns1__GetAhsBarcode;	/* WebService.h:154 */
class _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult;	/* WebService.h:1013 */
class _ns1__GetAhsBarcodeResponse;	/* WebService.h:157 */
class _ns1__UpdAhsBarcode;	/* WebService.h:160 */
class _ns1__UpdAhsBarcodeResponse;	/* WebService.h:163 */
class _ns1__ChkWeightTime;	/* WebService.h:166 */
class _ns1__ChkWeightTimeResponse;	/* WebService.h:169 */
class _ns1__InsSNTest;	/* WebService.h:172 */
class _ns1__InsSNTestResponse;	/* WebService.h:175 */
class _ns1__SelSNTest;	/* WebService.h:178 */
class _ns1__SelSNTestResponse;	/* WebService.h:181 */
class _ns1__DelSNTest;	/* WebService.h:184 */
class _ns1__DelSNTestResponse;	/* WebService.h:187 */
class _ns1__ChkSnLinkForApple;	/* WebService.h:190 */
class _ns1__ChkSnLinkForAppleResponse;	/* WebService.h:193 */
class _ns1__doSnLinkForApple_assyDt;	/* WebService.h:1312 */
class _ns1__doSnLinkForApple;	/* WebService.h:196 */
class _ns1__doSnLinkForAppleResponse;	/* WebService.h:199 */
class _ns1__GetObeNW;	/* WebService.h:202 */
class _ns1__GetObeNWResponse;	/* WebService.h:205 */
class _ns1__GetFruitSNCheck;	/* WebService.h:208 */
class _ns1__GetFruitSNCheckResponse;	/* WebService.h:211 */
class _ns1__GetLotLinkCount;	/* WebService.h:214 */
class _ns1__GetLotLinkCountResponse;	/* WebService.h:217 */
class _ns1__doLotLinkForApple_assyDt;	/* WebService.h:1514 */
class _ns1__doLotLinkForApple;	/* WebService.h:220 */
class _ns1__doLotLinkForAppleResponse;	/* WebService.h:223 */
class _ns1__GetShippingList;	/* WebService.h:226 */
class _ns1__GetShippingListResponse_GetShippingListResult;	/* WebService.h:1609 */
class _ns1__GetShippingListResponse;	/* WebService.h:229 */
class _ns1__GetShippingBerthList;	/* WebService.h:232 */
class _ns1__GetShippingBerthListResponse_GetShippingBerthListResult;	/* WebService.h:1673 */
class _ns1__GetShippingBerthListResponse;	/* WebService.h:235 */
class _ns1__UpdShipping;	/* WebService.h:238 */
class _ns1__UpdShippingResponse;	/* WebService.h:241 */
class _ns1__GetShippingPalle;	/* WebService.h:244 */
class _ns1__GetShippingPalleResponse;	/* WebService.h:247 */
class _ns1__InsShippingPalle;	/* WebService.h:250 */
class _ns1__InsShippingPalleResponse;	/* WebService.h:253 */
class _ns1__InsShippingBerth;	/* WebService.h:256 */
class _ns1__InsShippingBerthResponse;	/* WebService.h:259 */
class _ns1__GetShippingForBerth;	/* WebService.h:262 */
class _ns1__GetShippingForBerthResponse_GetShippingForBerthResult;	/* WebService.h:1921 */
class _ns1__GetShippingForBerthResponse;	/* WebService.h:265 */
class _ns1__GetShippingWeight;	/* WebService.h:268 */
class _ns1__GetShippingWeightResponse_GetShippingWeightResult;	/* WebService.h:1991 */
class _ns1__GetShippingWeightResponse;	/* WebService.h:271 */
class _ns1__getStationByMoForTestPad;	/* WebService.h:274 */
class _ns1__getStationByMoForTestPadResponse;	/* WebService.h:277 */
class _ns1__SetFlatnessFruitRec_dt;	/* WebService.h:2086 */
class _ns1__SetFlatnessFruitRec;	/* WebService.h:280 */
class _ns1__SetFlatnessFruitRecResponse;	/* WebService.h:283 */
class _ns1__GetSNForLink;	/* WebService.h:286 */
class _ns1__GetSNForLinkResponse;	/* WebService.h:289 */
class _ns1__SetAutoLineRec;	/* WebService.h:292 */
class _ns1__SetAutoLineRecResponse;	/* WebService.h:295 */
class _ns1__HPSNLinkBasket;	/* WebService.h:298 */
class _ns1__HPSNLinkBasketResponse;	/* WebService.h:301 */
class _ns1__BasketLinkPunch;	/* WebService.h:304 */
class _ns1__BasketLinkPunchResponse;	/* WebService.h:307 */
class _ns1__PunchOut;	/* WebService.h:310 */
class _ns1__PunchOutResponse;	/* WebService.h:313 */
class _ns1__chkMoSNForAOI;	/* WebService.h:316 */
class _ns1__chkMoSNForAOIResponse;	/* WebService.h:319 */
class _ns1__InsAoiMo;	/* WebService.h:322 */
class _ns1__InsAoiMoResponse;	/* WebService.h:325 */
class _ns1__InsCLScada;	/* WebService.h:328 */
class _ns1__InsCLScadaResponse;	/* WebService.h:331 */
class _ns1__GetTestValueResult;	/* WebService.h:334 */
class _ns1__GetTestValueResultResponse;	/* WebService.h:337 */
class _ns1__GetStationNumberForSN;	/* WebService.h:340 */
class _ns1__GetStationNumberForSNResponse;	/* WebService.h:343 */
class _ns1__InsSNTestForFruit;	/* WebService.h:346 */
class _ns1__InsSNTestForFruitResponse;	/* WebService.h:349 */
class _ns1__SelSNTestForFruit;	/* WebService.h:352 */
class _ns1__SelSNTestForFruitResponse;	/* WebService.h:355 */
class _ns1__SNLinkShelf;	/* WebService.h:358 */
class _ns1__SNLinkShelfResponse;	/* WebService.h:361 */
class _ns1__SelShelfLink;	/* WebService.h:364 */
class _ns1__SelShelfLinkResponse;	/* WebService.h:367 */
class _ns1__UploadForHP;	/* WebService.h:370 */
class _ns1__UploadForHPResponse;	/* WebService.h:373 */
class _ns1__GetMachineForGroup;	/* WebService.h:376 */
class _ns1__GetMachineForGroupResponse_GetMachineForGroupResult;	/* WebService.h:2891 */
class _ns1__GetMachineForGroupResponse;	/* WebService.h:379 */
class _ns1__SetDiecastSN;	/* WebService.h:382 */
class _ns1__SetDiecastSNResponse;	/* WebService.h:385 */
class _ns1__GetNgCode;	/* WebService.h:388 */
class _ns1__GetNgCodeResponse;	/* WebService.h:391 */
class _ns1__getMoBase;	/* WebService.h:394 */
class _ns1__getMoBaseResponse;	/* WebService.h:397 */
class _ns1__SnLnkOutSN;	/* WebService.h:400 */
class _ns1__SnLnkOutSNResponse;	/* WebService.h:403 */
class _ns1__InsFruitMachineChk;	/* WebService.h:406 */
class _ns1__InsFruitMachineChkResponse;	/* WebService.h:409 */
class _ns1__GetFruitMachineChk;	/* WebService.h:412 */
class _ns1__GetFruitMachineChkResponse;	/* WebService.h:415 */
class _ns1__InsZjList;	/* WebService.h:418 */
class _ns1__InsZjListResponse;	/* WebService.h:421 */
class _ns1__checkTestData;	/* WebService.h:424 */
class _ns1__checkTestDataResponse;	/* WebService.h:427 */
class _ns1__checkEmpNo;	/* WebService.h:430 */
class _ns1__checkEmpNoResponse;	/* WebService.h:433 */
class _ns1__checkSN_USCOREStation;	/* WebService.h:436 */
class _ns1__checkSN_USCOREStationResponse;	/* WebService.h:439 */
class _ns1__sendTestData;	/* WebService.h:442 */
class _ns1__sendTestDataResponse;	/* WebService.h:445 */
class _ns1__sendTestResult;	/* WebService.h:448 */
class _ns1__sendTestResultResponse;	/* WebService.h:451 */
class _ns1__InFruitsOrtQty;	/* WebService.h:454 */
class _ns1__InFruitsOrtQtyResponse;	/* WebService.h:457 */
class _ns1__chkStationTime;	/* WebService.h:460 */
class _ns1__chkStationTimeResponse;	/* WebService.h:463 */
class _ns1__ImpMesAteTestData;	/* WebService.h:466 */
class _ns1__ImpMesAteTestDataResponse;	/* WebService.h:469 */
class _ns1__InsFlatNess;	/* WebService.h:472 */
class _ns1__InsFlatNessResponse;	/* WebService.h:475 */
class _ns1__InsFlatNessForLSD;	/* WebService.h:478 */
class _ns1__InsFlatNessForLSDResponse;	/* WebService.h:481 */
class _ns1__InsFlatNessForCL;	/* WebService.h:484 */
class _ns1__InsFlatNessForCLResponse;	/* WebService.h:487 */
class _ns1__InsWHDetection;	/* WebService.h:490 */
class _ns1__InsWHDetectionResponse;	/* WebService.h:493 */
class _ns1__InsThermal;	/* WebService.h:496 */
class _ns1__InsThermalResponse;	/* WebService.h:499 */
class _ns1__ChkSnLink;	/* WebService.h:502 */
class _ns1__ChkSnLinkResponse;	/* WebService.h:505 */
class _ns1__InsThermalNew;	/* WebService.h:508 */
class _ns1__InsThermalNewResponse;	/* WebService.h:511 */
class _ns1__getInfoByMo;	/* WebService.h:514 */
class _ns1__getInfoByMoResponse_getInfoByMoResult;	/* WebService.h:4031 */
class _ns1__getInfoByMoResponse;	/* WebService.h:517 */
class _ns1__SetEnergyStat;	/* WebService.h:520 */
class _ns1__SetEnergyStatResponse;	/* WebService.h:523 */
class _ns1__chkMoStation;	/* WebService.h:526 */
class _ns1__chkMoStationResponse;	/* WebService.h:529 */
class _ns1__ChkSnMo;	/* WebService.h:532 */
class _ns1__ChkSnMoResponse;	/* WebService.h:535 */
class _ns1__ChkSnNextMo;	/* WebService.h:538 */
class _ns1__ChkSnNextMoResponse;	/* WebService.h:541 */
class _ns1__checkSN_USCOREStationNumber;	/* WebService.h:544 */
class _ns1__checkSN_USCOREStationNumberResponse;	/* WebService.h:547 */
class _ns1__checkEmpForStationNumber;	/* WebService.h:550 */
class _ns1__checkEmpForStationNumberResponse;	/* WebService.h:553 */
class _ns1__sendDataForStationNumber;	/* WebService.h:556 */
class _ns1__sendDataForStationNumberResponse;	/* WebService.h:559 */
class _ns1__sendResultForStationNumber;	/* WebService.h:562 */
class _ns1__sendResultForStationNumberResponse;	/* WebService.h:565 */
class _ns1__eMesNextMo;	/* WebService.h:568 */
class _ns1__eMesNextMoResponse;	/* WebService.h:571 */
class _ns1__SnDoMapping;	/* WebService.h:574 */
class _ns1__SnDoMappingResponse;	/* WebService.h:577 */
class _ns1__getStationByMo;	/* WebService.h:580 */
class _ns1__getStationByMoResponse;	/* WebService.h:583 */
class _ns1__getStationTypeDesc;	/* WebService.h:586 */
class _ns1__getStationTypeDescResponse;	/* WebService.h:589 */
class _ns1__chkSnMapping;	/* WebService.h:592 */
class _ns1__chkSnMappingResponse;	/* WebService.h:595 */
class _ns1__getMoAssyList;	/* WebService.h:598 */
class _ns1__getMoAssyListResponse_getMoAssyListResult;	/* WebService.h:4697 */
class _ns1__getMoAssyListResponse;	/* WebService.h:601 */
class _ns1__getPartBomExt;	/* WebService.h:604 */
class _ns1__getPartBomExtResponse_getPartBomExtResult;	/* WebService.h:4767 */
class _ns1__getPartBomExtResponse;	/* WebService.h:607 */
class _ns1__InsPartAssy;	/* WebService.h:610 */
class _ns1__InsPartAssyResponse;	/* WebService.h:613 */
class _ns1__GetLinkOutSn;	/* WebService.h:616 */
class _ns1__GetLinkOutSnResponse_GetLinkOutSnResult;	/* WebService.h:4891 */
class _ns1__GetLinkOutSnResponse;	/* WebService.h:619 */
class _ns1__getMoAssyCount;	/* WebService.h:622 */
class _ns1__getMoAssyCountResponse;	/* WebService.h:625 */
class _ns1__getPNbySN;	/* WebService.h:628 */
class _ns1__getPNbySNResponse;	/* WebService.h:631 */
class _ns1__chkAssySN;	/* WebService.h:634 */
class _ns1__chkAssySNResponse;	/* WebService.h:637 */
class _ns1__doAssy_assyDt;	/* WebService.h:5072 */
class _ns1__doAssy;	/* WebService.h:640 */
class _ns1__doAssyResponse;	/* WebService.h:643 */
class _ns1__getPmcAssyList;	/* WebService.h:646 */
class _ns1__getPmcAssyListResponse_getPmcAssyListResult;	/* WebService.h:5171 */
class _ns1__getPmcAssyListResponse;	/* WebService.h:649 */
class _ns1__getPmcPartAssyList;	/* WebService.h:652 */
class _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult;	/* WebService.h:5241 */
class _ns1__getPmcPartAssyListResponse;	/* WebService.h:655 */
class _ns1__GetPmcSNPart;	/* WebService.h:658 */
class _ns1__GetPmcSNPartResponse;	/* WebService.h:661 */
class _ns1__doPmcSNLink_assyDt;	/* WebService.h:5330 */
class _ns1__doPmcSNLink;	/* WebService.h:664 */
class _ns1__doPmcSNLinkResponse;	/* WebService.h:667 */
class _ns1__InsZJTestData;	/* WebService.h:670 */
class _ns1__InsZJTestDataResponse;	/* WebService.h:673 */
class _ns1__SNLinkZJ;	/* WebService.h:676 */
class _ns1__SNLinkZJResponse;	/* WebService.h:679 */
class _ns1__GetLintOutQty;	/* WebService.h:682 */
class _ns1__GetLintOutQtyResponse;	/* WebService.h:685 */
class _ns1__chkOutSN;	/* WebService.h:688 */
class _ns1__chkOutSNResponse;	/* WebService.h:691 */
class _ns1__ChkLinkOutSN;	/* WebService.h:694 */
class _ns1__ChkLinkOutSNResponse;	/* WebService.h:697 */
class _ns1__doLinkOutSN_assyDt;	/* WebService.h:5628 */
class _ns1__doLinkOutSN;	/* WebService.h:700 */
class _ns1__doLinkOutSNResponse;	/* WebService.h:703 */
class _ns1__InsLinkSN;	/* WebService.h:706 */
class _ns1__InsLinkSNResponse;	/* WebService.h:709 */
class _ns1__GetLinkZJCount;	/* WebService.h:712 */
class _ns1__GetLinkZJCountResponse;	/* WebService.h:715 */
class _ns1__InsBoxNOTime;	/* WebService.h:718 */
class _ns1__InsBoxNOTimeResponse;	/* WebService.h:721 */
class _ns1__chkBoxNo;	/* WebService.h:724 */
class _ns1__chkBoxNoResponse;	/* WebService.h:727 */
class _ns1__InSNtoBox;	/* WebService.h:730 */
class _ns1__InSNtoBoxResponse;	/* WebService.h:733 */
class _ns1__EndSNtoBox;	/* WebService.h:736 */
class _ns1__EndSNtoBoxResponse;	/* WebService.h:739 */
class _ns1__InStationbyBox;	/* WebService.h:742 */
class _ns1__InStationbyBoxResponse;	/* WebService.h:745 */
class _ns1__OutStationbyBox;	/* WebService.h:748 */
class _ns1__OutStationbyBoxResponse;	/* WebService.h:751 */
class _ns1__CancelBoxLnk;	/* WebService.h:754 */
class _ns1__CancelBoxLnkResponse;	/* WebService.h:757 */
class _ns1__InsSNStationEmp;	/* WebService.h:760 */
class _ns1__InsSNStationEmpResponse;	/* WebService.h:763 */
class _ns1__InsLnkOutSN;	/* WebService.h:766 */
class _ns1__InsLnkOutSNResponse;	/* WebService.h:769 */
class _ns1__InsBoxInfo;	/* WebService.h:772 */
class _ns1__InsBoxInfoResponse;	/* WebService.h:775 */
class _ns1__UpdSnRecInfo;	/* WebService.h:778 */
class _ns1__UpdSnRecInfoResponse;	/* WebService.h:781 */
class _ns1__GetMoBase;	/* WebService.h:784 */
class _ns1__GetMoBaseResponse;	/* WebService.h:787 */
class _ns1__GetTestValue;	/* WebService.h:790 */
class _ns1__GetTestValueResponse;	/* WebService.h:793 */
class _ns1__GetLnkData;	/* WebService.h:796 */
class _ns1__GetLnkDataResponse;	/* WebService.h:799 */
class _ns1__InsIotMachineRec;	/* WebService.h:802 */
class _ns1__InsIotMachineRecResponse;	/* WebService.h:805 */
class _ns1__InsIotTestData;	/* WebService.h:808 */
class _ns1__InsIotTestDataResponse;	/* WebService.h:811 */
class _ns1__chkDispensing;	/* WebService.h:814 */
class _ns1__chkDispensingResponse;	/* WebService.h:817 */
class _ns1__chkZJSN;	/* WebService.h:820 */
class _ns1__chkZJSNResponse;	/* WebService.h:823 */
class _ns1__LnkZJSN;	/* WebService.h:826 */
class _ns1__LnkZJSNResponse;	/* WebService.h:829 */
class _ns1__LnkSideSN;	/* WebService.h:832 */
class _ns1__LnkSideSNResponse;	/* WebService.h:835 */
class _ns1__chkGrillSN;	/* WebService.h:838 */
class _ns1__chkGrillSNResponse;	/* WebService.h:841 */
class _ns1__LnkGrillSN;	/* WebService.h:844 */
class _ns1__LnkGrillSNResponse;	/* WebService.h:847 */
class _ns1__CloseGrillSN;	/* WebService.h:850 */
class _ns1__CloseGrillSNResponse;	/* WebService.h:853 */
class _ns1__InsGrillBySN;	/* WebService.h:856 */
class _ns1__InsGrillBySNResponse;	/* WebService.h:859 */
class _ns1__GetGrillTime;	/* WebService.h:862 */
class _ns1__GetGrillTimeResponse;	/* WebService.h:865 */
class _ns1__OutGrillBySN;	/* WebService.h:868 */
class _ns1__OutGrillBySNResponse;	/* WebService.h:871 */
class _ns1__CancelGrillSN;	/* WebService.h:874 */
class _ns1__CancelGrillSNResponse;	/* WebService.h:877 */
class _ns1__CancelLnkSN;	/* WebService.h:880 */
class _ns1__CancelLnkSNResponse;	/* WebService.h:883 */
class _ns1__GetWeightSet;	/* WebService.h:886 */
class _ns1__GetWeightSetResponse;	/* WebService.h:889 */
class _ns1__GetPackToWMS;	/* WebService.h:892 */
class _ns1__GetPackToWMSResponse;	/* WebService.h:895 */
class _ns1__GetPallentToWMS;	/* WebService.h:898 */
class _ns1__GetPallentToWMSResponse_GetPallentToWMSResult;	/* WebService.h:7225 */
class _ns1__GetPallentToWMSResponse;	/* WebService.h:901 */
class _ns1__SetPallentForWMS;	/* WebService.h:904 */
class _ns1__SetPallentForWMSResponse;	/* WebService.h:907 */
class _ns1__GetPackStation;	/* WebService.h:910 */
class _ns1__GetPackStationResponse;	/* WebService.h:913 */
class _ns1__GetPackWeigth;	/* WebService.h:916 */
class _ns1__GetPackWeigthResponse;	/* WebService.h:919 */
class _ns1__GetAhsMo;	/* WebService.h:922 */
class _ns1__GetAhsMoResponse_GetAhsMoResult;	/* WebService.h:7429 */
class _ns1__GetAhsMoResponse;	/* WebService.h:925 */
struct __ns1__GetAhsBarcode;	/* WebService.h:8103 */
struct __ns1__UpdAhsBarcode;	/* WebService.h:8173 */
struct __ns1__ChkWeightTime;	/* WebService.h:8243 */
struct __ns1__InsSNTest;	/* WebService.h:8313 */
struct __ns1__SelSNTest;	/* WebService.h:8383 */
struct __ns1__DelSNTest;	/* WebService.h:8453 */
struct __ns1__ChkSnLinkForApple;	/* WebService.h:8523 */
struct __ns1__doSnLinkForApple;	/* WebService.h:8593 */
struct __ns1__GetObeNW;	/* WebService.h:8663 */
struct __ns1__GetFruitSNCheck;	/* WebService.h:8733 */
struct __ns1__GetLotLinkCount;	/* WebService.h:8803 */
struct __ns1__doLotLinkForApple;	/* WebService.h:8873 */
struct __ns1__GetShippingList;	/* WebService.h:8943 */
struct __ns1__GetShippingBerthList;	/* WebService.h:9013 */
struct __ns1__UpdShipping;	/* WebService.h:9083 */
struct __ns1__GetShippingPalle;	/* WebService.h:9153 */
struct __ns1__InsShippingPalle;	/* WebService.h:9223 */
struct __ns1__InsShippingBerth;	/* WebService.h:9293 */
struct __ns1__GetShippingForBerth;	/* WebService.h:9363 */
struct __ns1__GetShippingWeight;	/* WebService.h:9433 */
struct __ns1__getStationByMoForTestPad;	/* WebService.h:9503 */
struct __ns1__SetFlatnessFruitRec;	/* WebService.h:9573 */
struct __ns1__GetSNForLink;	/* WebService.h:9643 */
struct __ns1__SetAutoLineRec;	/* WebService.h:9713 */
struct __ns1__HPSNLinkBasket;	/* WebService.h:9783 */
struct __ns1__BasketLinkPunch;	/* WebService.h:9853 */
struct __ns1__PunchOut;	/* WebService.h:9923 */
struct __ns1__chkMoSNForAOI;	/* WebService.h:9993 */
struct __ns1__InsAoiMo;	/* WebService.h:10063 */
struct __ns1__InsCLScada;	/* WebService.h:10133 */
struct __ns1__GetTestValueResult;	/* WebService.h:10203 */
struct __ns1__GetStationNumberForSN;	/* WebService.h:10273 */
struct __ns1__InsSNTestForFruit;	/* WebService.h:10343 */
struct __ns1__SelSNTestForFruit;	/* WebService.h:10413 */
struct __ns1__SNLinkShelf;	/* WebService.h:10483 */
struct __ns1__SelShelfLink;	/* WebService.h:10553 */
struct __ns1__UploadForHP;	/* WebService.h:10623 */
struct __ns1__GetMachineForGroup;	/* WebService.h:10693 */
struct __ns1__SetDiecastSN;	/* WebService.h:10763 */
struct __ns1__GetNgCode;	/* WebService.h:10833 */
struct __ns1__getMoBase;	/* WebService.h:10903 */
struct __ns1__SnLnkOutSN;	/* WebService.h:10973 */
struct __ns1__InsFruitMachineChk;	/* WebService.h:11043 */
struct __ns1__GetFruitMachineChk;	/* WebService.h:11113 */
struct __ns1__InsZjList;	/* WebService.h:11183 */
struct __ns1__checkTestData;	/* WebService.h:11253 */
struct __ns1__checkEmpNo;	/* WebService.h:11323 */
struct __ns1__checkSN_USCOREStation;	/* WebService.h:11393 */
struct __ns1__sendTestData;	/* WebService.h:11463 */
struct __ns1__sendTestResult;	/* WebService.h:11533 */
struct __ns1__InFruitsOrtQty;	/* WebService.h:11603 */
struct __ns1__chkStationTime;	/* WebService.h:11673 */
struct __ns1__ImpMesAteTestData;	/* WebService.h:11743 */
struct __ns1__InsFlatNess;	/* WebService.h:11813 */
struct __ns1__InsFlatNessForLSD;	/* WebService.h:11883 */
struct __ns1__InsFlatNessForCL;	/* WebService.h:11953 */
struct __ns1__InsWHDetection;	/* WebService.h:12023 */
struct __ns1__InsThermal;	/* WebService.h:12093 */
struct __ns1__ChkSnLink;	/* WebService.h:12163 */
struct __ns1__InsThermalNew;	/* WebService.h:12233 */
struct __ns1__getInfoByMo;	/* WebService.h:12303 */
struct __ns1__SetEnergyStat;	/* WebService.h:12373 */
struct __ns1__chkMoStation;	/* WebService.h:12443 */
struct __ns1__ChkSnMo;	/* WebService.h:12513 */
struct __ns1__ChkSnNextMo;	/* WebService.h:12583 */
struct __ns1__checkSN_USCOREStationNumber;	/* WebService.h:12653 */
struct __ns1__checkEmpForStationNumber;	/* WebService.h:12723 */
struct __ns1__sendDataForStationNumber;	/* WebService.h:12793 */
struct __ns1__sendResultForStationNumber;	/* WebService.h:12863 */
struct __ns1__eMesNextMo;	/* WebService.h:12933 */
struct __ns1__SnDoMapping;	/* WebService.h:13003 */
struct __ns1__getStationByMo;	/* WebService.h:13073 */
struct __ns1__getStationTypeDesc;	/* WebService.h:13143 */
struct __ns1__chkSnMapping;	/* WebService.h:13213 */
struct __ns1__getMoAssyList;	/* WebService.h:13283 */
struct __ns1__getPartBomExt;	/* WebService.h:13353 */
struct __ns1__InsPartAssy;	/* WebService.h:13423 */
struct __ns1__GetLinkOutSn;	/* WebService.h:13493 */
struct __ns1__getMoAssyCount;	/* WebService.h:13563 */
struct __ns1__getPNbySN;	/* WebService.h:13633 */
struct __ns1__chkAssySN;	/* WebService.h:13703 */
struct __ns1__doAssy;	/* WebService.h:13773 */
struct __ns1__getPmcAssyList;	/* WebService.h:13843 */
struct __ns1__getPmcPartAssyList;	/* WebService.h:13913 */
struct __ns1__GetPmcSNPart;	/* WebService.h:13983 */
struct __ns1__doPmcSNLink;	/* WebService.h:14053 */
struct __ns1__InsZJTestData;	/* WebService.h:14123 */
struct __ns1__SNLinkZJ;	/* WebService.h:14193 */
struct __ns1__GetLintOutQty;	/* WebService.h:14263 */
struct __ns1__chkOutSN;	/* WebService.h:14333 */
struct __ns1__ChkLinkOutSN;	/* WebService.h:14403 */
struct __ns1__doLinkOutSN;	/* WebService.h:14473 */
struct __ns1__InsLinkSN;	/* WebService.h:14543 */
struct __ns1__GetLinkZJCount;	/* WebService.h:14613 */
struct __ns1__InsBoxNOTime;	/* WebService.h:14683 */
struct __ns1__chkBoxNo;	/* WebService.h:14753 */
struct __ns1__InSNtoBox;	/* WebService.h:14823 */
struct __ns1__EndSNtoBox;	/* WebService.h:14893 */
struct __ns1__InStationbyBox;	/* WebService.h:14963 */
struct __ns1__OutStationbyBox;	/* WebService.h:15033 */
struct __ns1__CancelBoxLnk;	/* WebService.h:15103 */
struct __ns1__InsSNStationEmp;	/* WebService.h:15173 */
struct __ns1__InsLnkOutSN;	/* WebService.h:15243 */
struct __ns1__InsBoxInfo;	/* WebService.h:15313 */
struct __ns1__UpdSnRecInfo;	/* WebService.h:15383 */
struct __ns1__GetMoBase;	/* WebService.h:15453 */
struct __ns1__GetTestValue;	/* WebService.h:15523 */
struct __ns1__GetLnkData;	/* WebService.h:15593 */
struct __ns1__InsIotMachineRec;	/* WebService.h:15663 */
struct __ns1__InsIotTestData;	/* WebService.h:15733 */
struct __ns1__chkDispensing;	/* WebService.h:15803 */
struct __ns1__chkZJSN;	/* WebService.h:15873 */
struct __ns1__LnkZJSN;	/* WebService.h:15943 */
struct __ns1__LnkSideSN;	/* WebService.h:16013 */
struct __ns1__chkGrillSN;	/* WebService.h:16083 */
struct __ns1__LnkGrillSN;	/* WebService.h:16153 */
struct __ns1__CloseGrillSN;	/* WebService.h:16223 */
struct __ns1__InsGrillBySN;	/* WebService.h:16293 */
struct __ns1__GetGrillTime;	/* WebService.h:16363 */
struct __ns1__OutGrillBySN;	/* WebService.h:16433 */
struct __ns1__CancelGrillSN;	/* WebService.h:16503 */
struct __ns1__CancelLnkSN;	/* WebService.h:16573 */
struct __ns1__GetWeightSet;	/* WebService.h:16643 */
struct __ns1__GetPackToWMS;	/* WebService.h:16713 */
struct __ns1__GetPallentToWMS;	/* WebService.h:16783 */
struct __ns1__SetPallentForWMS;	/* WebService.h:16853 */
struct __ns1__GetPackStation;	/* WebService.h:16923 */
struct __ns1__GetPackWeigth;	/* WebService.h:16993 */
struct __ns1__GetAhsMo;	/* WebService.h:17063 */
struct __ns1__GetAhsBarcode_;	/* WebService.h:17133 */
struct __ns1__UpdAhsBarcode_;	/* WebService.h:17203 */
struct __ns1__ChkWeightTime_;	/* WebService.h:17273 */
struct __ns1__InsSNTest_;	/* WebService.h:17343 */
struct __ns1__SelSNTest_;	/* WebService.h:17413 */
struct __ns1__DelSNTest_;	/* WebService.h:17483 */
struct __ns1__ChkSnLinkForApple_;	/* WebService.h:17553 */
struct __ns1__doSnLinkForApple_;	/* WebService.h:17623 */
struct __ns1__GetObeNW_;	/* WebService.h:17693 */
struct __ns1__GetFruitSNCheck_;	/* WebService.h:17763 */
struct __ns1__GetLotLinkCount_;	/* WebService.h:17833 */
struct __ns1__doLotLinkForApple_;	/* WebService.h:17903 */
struct __ns1__GetShippingList_;	/* WebService.h:17973 */
struct __ns1__GetShippingBerthList_;	/* WebService.h:18043 */
struct __ns1__UpdShipping_;	/* WebService.h:18113 */
struct __ns1__GetShippingPalle_;	/* WebService.h:18183 */
struct __ns1__InsShippingPalle_;	/* WebService.h:18253 */
struct __ns1__InsShippingBerth_;	/* WebService.h:18323 */
struct __ns1__GetShippingForBerth_;	/* WebService.h:18393 */
struct __ns1__GetShippingWeight_;	/* WebService.h:18463 */
struct __ns1__getStationByMoForTestPad_;	/* WebService.h:18533 */
struct __ns1__SetFlatnessFruitRec_;	/* WebService.h:18603 */
struct __ns1__GetSNForLink_;	/* WebService.h:18673 */
struct __ns1__SetAutoLineRec_;	/* WebService.h:18743 */
struct __ns1__HPSNLinkBasket_;	/* WebService.h:18813 */
struct __ns1__BasketLinkPunch_;	/* WebService.h:18883 */
struct __ns1__PunchOut_;	/* WebService.h:18953 */
struct __ns1__chkMoSNForAOI_;	/* WebService.h:19023 */
struct __ns1__InsAoiMo_;	/* WebService.h:19093 */
struct __ns1__InsCLScada_;	/* WebService.h:19163 */
struct __ns1__GetTestValueResult_;	/* WebService.h:19233 */
struct __ns1__GetStationNumberForSN_;	/* WebService.h:19303 */
struct __ns1__InsSNTestForFruit_;	/* WebService.h:19373 */
struct __ns1__SelSNTestForFruit_;	/* WebService.h:19443 */
struct __ns1__SNLinkShelf_;	/* WebService.h:19513 */
struct __ns1__SelShelfLink_;	/* WebService.h:19583 */
struct __ns1__UploadForHP_;	/* WebService.h:19653 */
struct __ns1__GetMachineForGroup_;	/* WebService.h:19723 */
struct __ns1__SetDiecastSN_;	/* WebService.h:19793 */
struct __ns1__GetNgCode_;	/* WebService.h:19863 */
struct __ns1__getMoBase_;	/* WebService.h:19933 */
struct __ns1__SnLnkOutSN_;	/* WebService.h:20003 */
struct __ns1__InsFruitMachineChk_;	/* WebService.h:20073 */
struct __ns1__GetFruitMachineChk_;	/* WebService.h:20143 */
struct __ns1__InsZjList_;	/* WebService.h:20213 */
struct __ns1__checkTestData_;	/* WebService.h:20283 */
struct __ns1__checkEmpNo_;	/* WebService.h:20353 */
struct __ns1__checkSN_USCOREStation_;	/* WebService.h:20423 */
struct __ns1__sendTestData_;	/* WebService.h:20493 */
struct __ns1__sendTestResult_;	/* WebService.h:20563 */
struct __ns1__InFruitsOrtQty_;	/* WebService.h:20633 */
struct __ns1__chkStationTime_;	/* WebService.h:20703 */
struct __ns1__ImpMesAteTestData_;	/* WebService.h:20773 */
struct __ns1__InsFlatNess_;	/* WebService.h:20843 */
struct __ns1__InsFlatNessForLSD_;	/* WebService.h:20913 */
struct __ns1__InsFlatNessForCL_;	/* WebService.h:20983 */
struct __ns1__InsWHDetection_;	/* WebService.h:21053 */
struct __ns1__InsThermal_;	/* WebService.h:21123 */
struct __ns1__ChkSnLink_;	/* WebService.h:21193 */
struct __ns1__InsThermalNew_;	/* WebService.h:21263 */
struct __ns1__getInfoByMo_;	/* WebService.h:21333 */
struct __ns1__SetEnergyStat_;	/* WebService.h:21403 */
struct __ns1__chkMoStation_;	/* WebService.h:21473 */
struct __ns1__ChkSnMo_;	/* WebService.h:21543 */
struct __ns1__ChkSnNextMo_;	/* WebService.h:21613 */
struct __ns1__checkSN_USCOREStationNumber_;	/* WebService.h:21683 */
struct __ns1__checkEmpForStationNumber_;	/* WebService.h:21753 */
struct __ns1__sendDataForStationNumber_;	/* WebService.h:21823 */
struct __ns1__sendResultForStationNumber_;	/* WebService.h:21893 */
struct __ns1__eMesNextMo_;	/* WebService.h:21963 */
struct __ns1__SnDoMapping_;	/* WebService.h:22033 */
struct __ns1__getStationByMo_;	/* WebService.h:22103 */
struct __ns1__getStationTypeDesc_;	/* WebService.h:22173 */
struct __ns1__chkSnMapping_;	/* WebService.h:22243 */
struct __ns1__getMoAssyList_;	/* WebService.h:22313 */
struct __ns1__getPartBomExt_;	/* WebService.h:22383 */
struct __ns1__InsPartAssy_;	/* WebService.h:22453 */
struct __ns1__GetLinkOutSn_;	/* WebService.h:22523 */
struct __ns1__getMoAssyCount_;	/* WebService.h:22593 */
struct __ns1__getPNbySN_;	/* WebService.h:22663 */
struct __ns1__chkAssySN_;	/* WebService.h:22733 */
struct __ns1__doAssy_;	/* WebService.h:22803 */
struct __ns1__getPmcAssyList_;	/* WebService.h:22873 */
struct __ns1__getPmcPartAssyList_;	/* WebService.h:22943 */
struct __ns1__GetPmcSNPart_;	/* WebService.h:23013 */
struct __ns1__doPmcSNLink_;	/* WebService.h:23083 */
struct __ns1__InsZJTestData_;	/* WebService.h:23153 */
struct __ns1__SNLinkZJ_;	/* WebService.h:23223 */
struct __ns1__GetLintOutQty_;	/* WebService.h:23293 */
struct __ns1__chkOutSN_;	/* WebService.h:23363 */
struct __ns1__ChkLinkOutSN_;	/* WebService.h:23433 */
struct __ns1__doLinkOutSN_;	/* WebService.h:23503 */
struct __ns1__InsLinkSN_;	/* WebService.h:23573 */
struct __ns1__GetLinkZJCount_;	/* WebService.h:23643 */
struct __ns1__InsBoxNOTime_;	/* WebService.h:23713 */
struct __ns1__chkBoxNo_;	/* WebService.h:23783 */
struct __ns1__InSNtoBox_;	/* WebService.h:23853 */
struct __ns1__EndSNtoBox_;	/* WebService.h:23923 */
struct __ns1__InStationbyBox_;	/* WebService.h:23993 */
struct __ns1__OutStationbyBox_;	/* WebService.h:24063 */
struct __ns1__CancelBoxLnk_;	/* WebService.h:24133 */
struct __ns1__InsSNStationEmp_;	/* WebService.h:24203 */
struct __ns1__InsLnkOutSN_;	/* WebService.h:24273 */
struct __ns1__InsBoxInfo_;	/* WebService.h:24343 */
struct __ns1__UpdSnRecInfo_;	/* WebService.h:24413 */
struct __ns1__GetMoBase_;	/* WebService.h:24483 */
struct __ns1__GetTestValue_;	/* WebService.h:24553 */
struct __ns1__GetLnkData_;	/* WebService.h:24623 */
struct __ns1__InsIotMachineRec_;	/* WebService.h:24693 */
struct __ns1__InsIotTestData_;	/* WebService.h:24763 */
struct __ns1__chkDispensing_;	/* WebService.h:24833 */
struct __ns1__chkZJSN_;	/* WebService.h:24903 */
struct __ns1__LnkZJSN_;	/* WebService.h:24973 */
struct __ns1__LnkSideSN_;	/* WebService.h:25043 */
struct __ns1__chkGrillSN_;	/* WebService.h:25113 */
struct __ns1__LnkGrillSN_;	/* WebService.h:25183 */
struct __ns1__CloseGrillSN_;	/* WebService.h:25253 */
struct __ns1__InsGrillBySN_;	/* WebService.h:25323 */
struct __ns1__GetGrillTime_;	/* WebService.h:25393 */
struct __ns1__OutGrillBySN_;	/* WebService.h:25463 */
struct __ns1__CancelGrillSN_;	/* WebService.h:25533 */
struct __ns1__CancelLnkSN_;	/* WebService.h:25603 */
struct __ns1__GetWeightSet_;	/* WebService.h:25673 */
struct __ns1__GetPackToWMS_;	/* WebService.h:25743 */
struct __ns1__GetPallentToWMS_;	/* WebService.h:25813 */
struct __ns1__SetPallentForWMS_;	/* WebService.h:25883 */
struct __ns1__GetPackStation_;	/* WebService.h:25953 */
struct __ns1__GetPackWeigth_;	/* WebService.h:26023 */
struct __ns1__GetAhsMo_;	/* WebService.h:26093 */

/* WebService.h:151 */
#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (12)
/* complex XSD type 'ns1:ArrayOfString': */
class SOAP_CMAC ns1__ArrayOfString {
      public:
        /// Optional element 'ns1:string' of XSD type 'xsd:string'
        std::vector<std::string> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfString
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfString, default initialized and not managed by a soap context
        virtual ns1__ArrayOfString *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfString); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfString() : string(), soap() { }
        virtual ~ns1__ArrayOfString() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfString(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:154 */
#ifndef SOAP_TYPE__ns1__GetAhsBarcode
#define SOAP_TYPE__ns1__GetAhsBarcode (13)
/* complex XSD type 'ns1:GetAhsBarcode': */
class SOAP_CMAC _ns1__GetAhsBarcode {
      public:
        /// Optional element 'ns1:Ikey' of XSD type 'xsd:string'
        std::string *Ikey;
        /// Optional element 'ns1:VerIkey' of XSD type 'xsd:string'
        std::string *VerIkey;
        /// Optional element 'ns1:PrintType' of XSD type 'xsd:string'
        std::string *PrintType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAhsBarcode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAhsBarcode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAhsBarcode, default initialized and not managed by a soap context
        virtual _ns1__GetAhsBarcode *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAhsBarcode); }
      public:
        /// Constructor with initializations
        _ns1__GetAhsBarcode() : Ikey(), VerIkey(), PrintType(), soap() { }
        virtual ~_ns1__GetAhsBarcode() { }
        /// Friend allocator used by soap_new__ns1__GetAhsBarcode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAhsBarcode * SOAP_FMAC2 soap_instantiate__ns1__GetAhsBarcode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1013 */
#ifndef SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult
#define SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult (275)
/* complex XSD type 'ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult': */
class SOAP_CMAC _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, default initialized and not managed by a soap context
        virtual _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult); }
      public:
        /// Constructor with initializations
        _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult() : xsd__schema(), __any() { }
        virtual ~_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult() { }
        /// Friend allocator used by soap_new__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult * SOAP_FMAC2 soap_instantiate__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:157 */
#ifndef SOAP_TYPE__ns1__GetAhsBarcodeResponse
#define SOAP_TYPE__ns1__GetAhsBarcodeResponse (14)
/* complex XSD type 'ns1:GetAhsBarcodeResponse': */
class SOAP_CMAC _ns1__GetAhsBarcodeResponse {
      public:
        /// Optional element 'ns1:GetAhsBarcodeResult' of XSD type 'ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult'
        _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *GetAhsBarcodeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAhsBarcodeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAhsBarcodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAhsBarcodeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetAhsBarcodeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAhsBarcodeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetAhsBarcodeResponse() : GetAhsBarcodeResult(), soap() { }
        virtual ~_ns1__GetAhsBarcodeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetAhsBarcodeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAhsBarcodeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAhsBarcodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:160 */
#ifndef SOAP_TYPE__ns1__UpdAhsBarcode
#define SOAP_TYPE__ns1__UpdAhsBarcode (15)
/* complex XSD type 'ns1:UpdAhsBarcode': */
class SOAP_CMAC _ns1__UpdAhsBarcode {
      public:
        /// Optional element 'ns1:Ikey' of XSD type 'xsd:string'
        std::string *Ikey;
        /// Optional element 'ns1:BarcodeKey' of XSD type 'xsd:string'
        std::string *BarcodeKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdAhsBarcode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdAhsBarcode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdAhsBarcode, default initialized and not managed by a soap context
        virtual _ns1__UpdAhsBarcode *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdAhsBarcode); }
      public:
        /// Constructor with initializations
        _ns1__UpdAhsBarcode() : Ikey(), BarcodeKey(), soap() { }
        virtual ~_ns1__UpdAhsBarcode() { }
        /// Friend allocator used by soap_new__ns1__UpdAhsBarcode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdAhsBarcode * SOAP_FMAC2 soap_instantiate__ns1__UpdAhsBarcode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:163 */
#ifndef SOAP_TYPE__ns1__UpdAhsBarcodeResponse
#define SOAP_TYPE__ns1__UpdAhsBarcodeResponse (16)
/* complex XSD type 'ns1:UpdAhsBarcodeResponse': */
class SOAP_CMAC _ns1__UpdAhsBarcodeResponse {
      public:
        /// Optional element 'ns1:UpdAhsBarcodeResult' of XSD type 'xsd:string'
        std::string *UpdAhsBarcodeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdAhsBarcodeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdAhsBarcodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdAhsBarcodeResponse, default initialized and not managed by a soap context
        virtual _ns1__UpdAhsBarcodeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdAhsBarcodeResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpdAhsBarcodeResponse() : UpdAhsBarcodeResult(), soap() { }
        virtual ~_ns1__UpdAhsBarcodeResponse() { }
        /// Friend allocator used by soap_new__ns1__UpdAhsBarcodeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdAhsBarcodeResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdAhsBarcodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:166 */
#ifndef SOAP_TYPE__ns1__ChkWeightTime
#define SOAP_TYPE__ns1__ChkWeightTime (17)
/* complex XSD type 'ns1:ChkWeightTime': */
class SOAP_CMAC _ns1__ChkWeightTime {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:strType' of XSD type 'xsd:string'
        std::string *strType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkWeightTime
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkWeightTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkWeightTime, default initialized and not managed by a soap context
        virtual _ns1__ChkWeightTime *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkWeightTime); }
      public:
        /// Constructor with initializations
        _ns1__ChkWeightTime() : SN(), strType(), soap() { }
        virtual ~_ns1__ChkWeightTime() { }
        /// Friend allocator used by soap_new__ns1__ChkWeightTime(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkWeightTime * SOAP_FMAC2 soap_instantiate__ns1__ChkWeightTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:169 */
#ifndef SOAP_TYPE__ns1__ChkWeightTimeResponse
#define SOAP_TYPE__ns1__ChkWeightTimeResponse (18)
/* complex XSD type 'ns1:ChkWeightTimeResponse': */
class SOAP_CMAC _ns1__ChkWeightTimeResponse {
      public:
        /// Optional element 'ns1:ChkWeightTimeResult' of XSD type 'xsd:string'
        std::string *ChkWeightTimeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkWeightTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkWeightTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkWeightTimeResponse, default initialized and not managed by a soap context
        virtual _ns1__ChkWeightTimeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkWeightTimeResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChkWeightTimeResponse() : ChkWeightTimeResult(), soap() { }
        virtual ~_ns1__ChkWeightTimeResponse() { }
        /// Friend allocator used by soap_new__ns1__ChkWeightTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkWeightTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkWeightTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:172 */
#ifndef SOAP_TYPE__ns1__InsSNTest
#define SOAP_TYPE__ns1__InsSNTest (19)
/* complex XSD type 'ns1:InsSNTest': */
class SOAP_CMAC _ns1__InsSNTest {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:TestResult' of XSD type 'xsd:string'
        std::string *TestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsSNTest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsSNTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsSNTest, default initialized and not managed by a soap context
        virtual _ns1__InsSNTest *soap_alloc(void) const { return SOAP_NEW(_ns1__InsSNTest); }
      public:
        /// Constructor with initializations
        _ns1__InsSNTest() : SN(), TestResult(), soap() { }
        virtual ~_ns1__InsSNTest() { }
        /// Friend allocator used by soap_new__ns1__InsSNTest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsSNTest * SOAP_FMAC2 soap_instantiate__ns1__InsSNTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:175 */
#ifndef SOAP_TYPE__ns1__InsSNTestResponse
#define SOAP_TYPE__ns1__InsSNTestResponse (20)
/* complex XSD type 'ns1:InsSNTestResponse': */
class SOAP_CMAC _ns1__InsSNTestResponse {
      public:
        /// Optional element 'ns1:InsSNTestResult' of XSD type 'xsd:string'
        std::string *InsSNTestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsSNTestResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsSNTestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsSNTestResponse, default initialized and not managed by a soap context
        virtual _ns1__InsSNTestResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsSNTestResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsSNTestResponse() : InsSNTestResult(), soap() { }
        virtual ~_ns1__InsSNTestResponse() { }
        /// Friend allocator used by soap_new__ns1__InsSNTestResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsSNTestResponse * SOAP_FMAC2 soap_instantiate__ns1__InsSNTestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:178 */
#ifndef SOAP_TYPE__ns1__SelSNTest
#define SOAP_TYPE__ns1__SelSNTest (21)
/* complex XSD type 'ns1:SelSNTest': */
class SOAP_CMAC _ns1__SelSNTest {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelSNTest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelSNTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelSNTest, default initialized and not managed by a soap context
        virtual _ns1__SelSNTest *soap_alloc(void) const { return SOAP_NEW(_ns1__SelSNTest); }
      public:
        /// Constructor with initializations
        _ns1__SelSNTest() : SN(), soap() { }
        virtual ~_ns1__SelSNTest() { }
        /// Friend allocator used by soap_new__ns1__SelSNTest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelSNTest * SOAP_FMAC2 soap_instantiate__ns1__SelSNTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:181 */
#ifndef SOAP_TYPE__ns1__SelSNTestResponse
#define SOAP_TYPE__ns1__SelSNTestResponse (22)
/* complex XSD type 'ns1:SelSNTestResponse': */
class SOAP_CMAC _ns1__SelSNTestResponse {
      public:
        /// Optional element 'ns1:SelSNTestResult' of XSD type 'xsd:string'
        std::string *SelSNTestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelSNTestResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelSNTestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelSNTestResponse, default initialized and not managed by a soap context
        virtual _ns1__SelSNTestResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SelSNTestResponse); }
      public:
        /// Constructor with initializations
        _ns1__SelSNTestResponse() : SelSNTestResult(), soap() { }
        virtual ~_ns1__SelSNTestResponse() { }
        /// Friend allocator used by soap_new__ns1__SelSNTestResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelSNTestResponse * SOAP_FMAC2 soap_instantiate__ns1__SelSNTestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:184 */
#ifndef SOAP_TYPE__ns1__DelSNTest
#define SOAP_TYPE__ns1__DelSNTest (23)
/* complex XSD type 'ns1:DelSNTest': */
class SOAP_CMAC _ns1__DelSNTest {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DelSNTest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DelSNTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DelSNTest, default initialized and not managed by a soap context
        virtual _ns1__DelSNTest *soap_alloc(void) const { return SOAP_NEW(_ns1__DelSNTest); }
      public:
        /// Constructor with initializations
        _ns1__DelSNTest() : SN(), soap() { }
        virtual ~_ns1__DelSNTest() { }
        /// Friend allocator used by soap_new__ns1__DelSNTest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DelSNTest * SOAP_FMAC2 soap_instantiate__ns1__DelSNTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:187 */
#ifndef SOAP_TYPE__ns1__DelSNTestResponse
#define SOAP_TYPE__ns1__DelSNTestResponse (24)
/* complex XSD type 'ns1:DelSNTestResponse': */
class SOAP_CMAC _ns1__DelSNTestResponse {
      public:
        /// Optional element 'ns1:DelSNTestResult' of XSD type 'xsd:string'
        std::string *DelSNTestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DelSNTestResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DelSNTestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DelSNTestResponse, default initialized and not managed by a soap context
        virtual _ns1__DelSNTestResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DelSNTestResponse); }
      public:
        /// Constructor with initializations
        _ns1__DelSNTestResponse() : DelSNTestResult(), soap() { }
        virtual ~_ns1__DelSNTestResponse() { }
        /// Friend allocator used by soap_new__ns1__DelSNTestResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DelSNTestResponse * SOAP_FMAC2 soap_instantiate__ns1__DelSNTestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:190 */
#ifndef SOAP_TYPE__ns1__ChkSnLinkForApple
#define SOAP_TYPE__ns1__ChkSnLinkForApple (25)
/* complex XSD type 'ns1:ChkSnLinkForApple': */
class SOAP_CMAC _ns1__ChkSnLinkForApple {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnLinkForApple
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnLinkForApple; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnLinkForApple, default initialized and not managed by a soap context
        virtual _ns1__ChkSnLinkForApple *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnLinkForApple); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnLinkForApple() : SN(), soap() { }
        virtual ~_ns1__ChkSnLinkForApple() { }
        /// Friend allocator used by soap_new__ns1__ChkSnLinkForApple(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnLinkForApple * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLinkForApple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:193 */
#ifndef SOAP_TYPE__ns1__ChkSnLinkForAppleResponse
#define SOAP_TYPE__ns1__ChkSnLinkForAppleResponse (26)
/* complex XSD type 'ns1:ChkSnLinkForAppleResponse': */
class SOAP_CMAC _ns1__ChkSnLinkForAppleResponse {
      public:
        /// Optional element 'ns1:ChkSnLinkForAppleResult' of XSD type 'xsd:string'
        std::string *ChkSnLinkForAppleResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnLinkForAppleResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnLinkForAppleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnLinkForAppleResponse, default initialized and not managed by a soap context
        virtual _ns1__ChkSnLinkForAppleResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnLinkForAppleResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnLinkForAppleResponse() : ChkSnLinkForAppleResult(), soap() { }
        virtual ~_ns1__ChkSnLinkForAppleResponse() { }
        /// Friend allocator used by soap_new__ns1__ChkSnLinkForAppleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnLinkForAppleResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLinkForAppleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1312 */
#ifndef SOAP_TYPE__ns1__doSnLinkForApple_assyDt
#define SOAP_TYPE__ns1__doSnLinkForApple_assyDt (277)
/* complex XSD type 'ns1:doSnLinkForApple-assyDt': */
class SOAP_CMAC _ns1__doSnLinkForApple_assyDt {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doSnLinkForApple_assyDt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doSnLinkForApple_assyDt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doSnLinkForApple_assyDt, default initialized and not managed by a soap context
        virtual _ns1__doSnLinkForApple_assyDt *soap_alloc(void) const { return SOAP_NEW(_ns1__doSnLinkForApple_assyDt); }
      public:
        /// Constructor with initializations
        _ns1__doSnLinkForApple_assyDt() : __any(), __any_() { }
        virtual ~_ns1__doSnLinkForApple_assyDt() { }
        /// Friend allocator used by soap_new__ns1__doSnLinkForApple_assyDt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doSnLinkForApple_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doSnLinkForApple_assyDt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:196 */
#ifndef SOAP_TYPE__ns1__doSnLinkForApple
#define SOAP_TYPE__ns1__doSnLinkForApple (27)
/* complex XSD type 'ns1:doSnLinkForApple': */
class SOAP_CMAC _ns1__doSnLinkForApple {
      public:
        /// Optional element 'ns1:assyDt' of XSD type 'ns1:doSnLinkForApple-assyDt'
        _ns1__doSnLinkForApple_assyDt *assyDt;
        /// Optional element 'ns1:empNO' of XSD type 'xsd:string'
        std::string *empNO;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doSnLinkForApple
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doSnLinkForApple; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doSnLinkForApple, default initialized and not managed by a soap context
        virtual _ns1__doSnLinkForApple *soap_alloc(void) const { return SOAP_NEW(_ns1__doSnLinkForApple); }
      public:
        /// Constructor with initializations
        _ns1__doSnLinkForApple() : assyDt(), empNO(), SN(), Station(), soap() { }
        virtual ~_ns1__doSnLinkForApple() { }
        /// Friend allocator used by soap_new__ns1__doSnLinkForApple(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doSnLinkForApple * SOAP_FMAC2 soap_instantiate__ns1__doSnLinkForApple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:199 */
#ifndef SOAP_TYPE__ns1__doSnLinkForAppleResponse
#define SOAP_TYPE__ns1__doSnLinkForAppleResponse (28)
/* complex XSD type 'ns1:doSnLinkForAppleResponse': */
class SOAP_CMAC _ns1__doSnLinkForAppleResponse {
      public:
        /// Optional element 'ns1:doSnLinkForAppleResult' of XSD type 'xsd:string'
        std::string *doSnLinkForAppleResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doSnLinkForAppleResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doSnLinkForAppleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doSnLinkForAppleResponse, default initialized and not managed by a soap context
        virtual _ns1__doSnLinkForAppleResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__doSnLinkForAppleResponse); }
      public:
        /// Constructor with initializations
        _ns1__doSnLinkForAppleResponse() : doSnLinkForAppleResult(), soap() { }
        virtual ~_ns1__doSnLinkForAppleResponse() { }
        /// Friend allocator used by soap_new__ns1__doSnLinkForAppleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doSnLinkForAppleResponse * SOAP_FMAC2 soap_instantiate__ns1__doSnLinkForAppleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:202 */
#ifndef SOAP_TYPE__ns1__GetObeNW
#define SOAP_TYPE__ns1__GetObeNW (29)
/* complex XSD type 'ns1:GetObeNW': */
class SOAP_CMAC _ns1__GetObeNW {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetObeNW
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetObeNW; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetObeNW, default initialized and not managed by a soap context
        virtual _ns1__GetObeNW *soap_alloc(void) const { return SOAP_NEW(_ns1__GetObeNW); }
      public:
        /// Constructor with initializations
        _ns1__GetObeNW() : SN(), soap() { }
        virtual ~_ns1__GetObeNW() { }
        /// Friend allocator used by soap_new__ns1__GetObeNW(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetObeNW * SOAP_FMAC2 soap_instantiate__ns1__GetObeNW(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:205 */
#ifndef SOAP_TYPE__ns1__GetObeNWResponse
#define SOAP_TYPE__ns1__GetObeNWResponse (30)
/* complex XSD type 'ns1:GetObeNWResponse': */
class SOAP_CMAC _ns1__GetObeNWResponse {
      public:
        /// Optional element 'ns1:GetObeNWResult' of XSD type 'xsd:string'
        std::string *GetObeNWResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetObeNWResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetObeNWResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetObeNWResponse, default initialized and not managed by a soap context
        virtual _ns1__GetObeNWResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetObeNWResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetObeNWResponse() : GetObeNWResult(), soap() { }
        virtual ~_ns1__GetObeNWResponse() { }
        /// Friend allocator used by soap_new__ns1__GetObeNWResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetObeNWResponse * SOAP_FMAC2 soap_instantiate__ns1__GetObeNWResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:208 */
#ifndef SOAP_TYPE__ns1__GetFruitSNCheck
#define SOAP_TYPE__ns1__GetFruitSNCheck (31)
/* complex XSD type 'ns1:GetFruitSNCheck': */
class SOAP_CMAC _ns1__GetFruitSNCheck {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFruitSNCheck
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFruitSNCheck; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFruitSNCheck, default initialized and not managed by a soap context
        virtual _ns1__GetFruitSNCheck *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFruitSNCheck); }
      public:
        /// Constructor with initializations
        _ns1__GetFruitSNCheck() : SN(), Station(), soap() { }
        virtual ~_ns1__GetFruitSNCheck() { }
        /// Friend allocator used by soap_new__ns1__GetFruitSNCheck(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFruitSNCheck * SOAP_FMAC2 soap_instantiate__ns1__GetFruitSNCheck(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:211 */
#ifndef SOAP_TYPE__ns1__GetFruitSNCheckResponse
#define SOAP_TYPE__ns1__GetFruitSNCheckResponse (32)
/* complex XSD type 'ns1:GetFruitSNCheckResponse': */
class SOAP_CMAC _ns1__GetFruitSNCheckResponse {
      public:
        /// Optional element 'ns1:GetFruitSNCheckResult' of XSD type 'xsd:string'
        std::string *GetFruitSNCheckResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFruitSNCheckResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFruitSNCheckResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFruitSNCheckResponse, default initialized and not managed by a soap context
        virtual _ns1__GetFruitSNCheckResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFruitSNCheckResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetFruitSNCheckResponse() : GetFruitSNCheckResult(), soap() { }
        virtual ~_ns1__GetFruitSNCheckResponse() { }
        /// Friend allocator used by soap_new__ns1__GetFruitSNCheckResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFruitSNCheckResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFruitSNCheckResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:214 */
#ifndef SOAP_TYPE__ns1__GetLotLinkCount
#define SOAP_TYPE__ns1__GetLotLinkCount (33)
/* complex XSD type 'ns1:GetLotLinkCount': */
class SOAP_CMAC _ns1__GetLotLinkCount {
      public:
        /// Optional element 'ns1:OUT_PN_SN' of XSD type 'xsd:string'
        std::string *OUT_USCOREPN_USCORESN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLotLinkCount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLotLinkCount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLotLinkCount, default initialized and not managed by a soap context
        virtual _ns1__GetLotLinkCount *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLotLinkCount); }
      public:
        /// Constructor with initializations
        _ns1__GetLotLinkCount() : OUT_USCOREPN_USCORESN(), soap() { }
        virtual ~_ns1__GetLotLinkCount() { }
        /// Friend allocator used by soap_new__ns1__GetLotLinkCount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLotLinkCount * SOAP_FMAC2 soap_instantiate__ns1__GetLotLinkCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:217 */
#ifndef SOAP_TYPE__ns1__GetLotLinkCountResponse
#define SOAP_TYPE__ns1__GetLotLinkCountResponse (34)
/* complex XSD type 'ns1:GetLotLinkCountResponse': */
class SOAP_CMAC _ns1__GetLotLinkCountResponse {
      public:
        /// Required element 'ns1:GetLotLinkCountResult' of XSD type 'xsd:int'
        int GetLotLinkCountResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLotLinkCountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLotLinkCountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLotLinkCountResponse, default initialized and not managed by a soap context
        virtual _ns1__GetLotLinkCountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLotLinkCountResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetLotLinkCountResponse() : GetLotLinkCountResult(), soap() { }
        virtual ~_ns1__GetLotLinkCountResponse() { }
        /// Friend allocator used by soap_new__ns1__GetLotLinkCountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLotLinkCountResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLotLinkCountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1514 */
#ifndef SOAP_TYPE__ns1__doLotLinkForApple_assyDt
#define SOAP_TYPE__ns1__doLotLinkForApple_assyDt (280)
/* complex XSD type 'ns1:doLotLinkForApple-assyDt': */
class SOAP_CMAC _ns1__doLotLinkForApple_assyDt {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doLotLinkForApple_assyDt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doLotLinkForApple_assyDt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doLotLinkForApple_assyDt, default initialized and not managed by a soap context
        virtual _ns1__doLotLinkForApple_assyDt *soap_alloc(void) const { return SOAP_NEW(_ns1__doLotLinkForApple_assyDt); }
      public:
        /// Constructor with initializations
        _ns1__doLotLinkForApple_assyDt() : __any(), __any_() { }
        virtual ~_ns1__doLotLinkForApple_assyDt() { }
        /// Friend allocator used by soap_new__ns1__doLotLinkForApple_assyDt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doLotLinkForApple_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doLotLinkForApple_assyDt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:220 */
#ifndef SOAP_TYPE__ns1__doLotLinkForApple
#define SOAP_TYPE__ns1__doLotLinkForApple (35)
/* complex XSD type 'ns1:doLotLinkForApple': */
class SOAP_CMAC _ns1__doLotLinkForApple {
      public:
        /// Optional element 'ns1:assyDt' of XSD type 'ns1:doLotLinkForApple-assyDt'
        _ns1__doLotLinkForApple_assyDt *assyDt;
        /// Optional element 'ns1:empNO' of XSD type 'xsd:string'
        std::string *empNO;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doLotLinkForApple
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doLotLinkForApple; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doLotLinkForApple, default initialized and not managed by a soap context
        virtual _ns1__doLotLinkForApple *soap_alloc(void) const { return SOAP_NEW(_ns1__doLotLinkForApple); }
      public:
        /// Constructor with initializations
        _ns1__doLotLinkForApple() : assyDt(), empNO(), SN(), Station(), soap() { }
        virtual ~_ns1__doLotLinkForApple() { }
        /// Friend allocator used by soap_new__ns1__doLotLinkForApple(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doLotLinkForApple * SOAP_FMAC2 soap_instantiate__ns1__doLotLinkForApple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:223 */
#ifndef SOAP_TYPE__ns1__doLotLinkForAppleResponse
#define SOAP_TYPE__ns1__doLotLinkForAppleResponse (36)
/* complex XSD type 'ns1:doLotLinkForAppleResponse': */
class SOAP_CMAC _ns1__doLotLinkForAppleResponse {
      public:
        /// Optional element 'ns1:doLotLinkForAppleResult' of XSD type 'xsd:string'
        std::string *doLotLinkForAppleResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doLotLinkForAppleResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doLotLinkForAppleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doLotLinkForAppleResponse, default initialized and not managed by a soap context
        virtual _ns1__doLotLinkForAppleResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__doLotLinkForAppleResponse); }
      public:
        /// Constructor with initializations
        _ns1__doLotLinkForAppleResponse() : doLotLinkForAppleResult(), soap() { }
        virtual ~_ns1__doLotLinkForAppleResponse() { }
        /// Friend allocator used by soap_new__ns1__doLotLinkForAppleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doLotLinkForAppleResponse * SOAP_FMAC2 soap_instantiate__ns1__doLotLinkForAppleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:226 */
#ifndef SOAP_TYPE__ns1__GetShippingList
#define SOAP_TYPE__ns1__GetShippingList (37)
/* complex XSD type 'ns1:GetShippingList': */
class SOAP_CMAC _ns1__GetShippingList {
      public:
        /// Optional element 'ns1:strDate' of XSD type 'xsd:string'
        std::string *strDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingList, default initialized and not managed by a soap context
        virtual _ns1__GetShippingList *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingList); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingList() : strDate(), soap() { }
        virtual ~_ns1__GetShippingList() { }
        /// Friend allocator used by soap_new__ns1__GetShippingList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingList * SOAP_FMAC2 soap_instantiate__ns1__GetShippingList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1609 */
#ifndef SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult
#define SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult (282)
/* complex XSD type 'ns1:GetShippingListResponse-GetShippingListResult': */
class SOAP_CMAC _ns1__GetShippingListResponse_GetShippingListResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingListResponse_GetShippingListResult, default initialized and not managed by a soap context
        virtual _ns1__GetShippingListResponse_GetShippingListResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingListResponse_GetShippingListResult); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingListResponse_GetShippingListResult() : xsd__schema(), __any() { }
        virtual ~_ns1__GetShippingListResponse_GetShippingListResult() { }
        /// Friend allocator used by soap_new__ns1__GetShippingListResponse_GetShippingListResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingListResponse_GetShippingListResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingListResponse_GetShippingListResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:229 */
#ifndef SOAP_TYPE__ns1__GetShippingListResponse
#define SOAP_TYPE__ns1__GetShippingListResponse (38)
/* complex XSD type 'ns1:GetShippingListResponse': */
class SOAP_CMAC _ns1__GetShippingListResponse {
      public:
        /// Optional element 'ns1:GetShippingListResult' of XSD type 'ns1:GetShippingListResponse-GetShippingListResult'
        _ns1__GetShippingListResponse_GetShippingListResult *GetShippingListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingListResponse, default initialized and not managed by a soap context
        virtual _ns1__GetShippingListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingListResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingListResponse() : GetShippingListResult(), soap() { }
        virtual ~_ns1__GetShippingListResponse() { }
        /// Friend allocator used by soap_new__ns1__GetShippingListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:232 */
#ifndef SOAP_TYPE__ns1__GetShippingBerthList
#define SOAP_TYPE__ns1__GetShippingBerthList (39)
/* complex XSD type 'ns1:GetShippingBerthList': */
class SOAP_CMAC _ns1__GetShippingBerthList {
      public:
        /// Optional element 'ns1:strBerth' of XSD type 'xsd:string'
        std::string *strBerth;
        /// Optional element 'ns1:strCar' of XSD type 'xsd:string'
        std::string *strCar;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingBerthList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingBerthList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingBerthList, default initialized and not managed by a soap context
        virtual _ns1__GetShippingBerthList *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingBerthList); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingBerthList() : strBerth(), strCar(), soap() { }
        virtual ~_ns1__GetShippingBerthList() { }
        /// Friend allocator used by soap_new__ns1__GetShippingBerthList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingBerthList * SOAP_FMAC2 soap_instantiate__ns1__GetShippingBerthList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1673 */
#ifndef SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult
#define SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult (284)
/* complex XSD type 'ns1:GetShippingBerthListResponse-GetShippingBerthListResult': */
class SOAP_CMAC _ns1__GetShippingBerthListResponse_GetShippingBerthListResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingBerthListResponse_GetShippingBerthListResult, default initialized and not managed by a soap context
        virtual _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingBerthListResponse_GetShippingBerthListResult() : xsd__schema(), __any() { }
        virtual ~_ns1__GetShippingBerthListResponse_GetShippingBerthListResult() { }
        /// Friend allocator used by soap_new__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingBerthListResponse_GetShippingBerthListResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:235 */
#ifndef SOAP_TYPE__ns1__GetShippingBerthListResponse
#define SOAP_TYPE__ns1__GetShippingBerthListResponse (40)
/* complex XSD type 'ns1:GetShippingBerthListResponse': */
class SOAP_CMAC _ns1__GetShippingBerthListResponse {
      public:
        /// Optional element 'ns1:GetShippingBerthListResult' of XSD type 'ns1:GetShippingBerthListResponse-GetShippingBerthListResult'
        _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *GetShippingBerthListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingBerthListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingBerthListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingBerthListResponse, default initialized and not managed by a soap context
        virtual _ns1__GetShippingBerthListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingBerthListResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingBerthListResponse() : GetShippingBerthListResult(), soap() { }
        virtual ~_ns1__GetShippingBerthListResponse() { }
        /// Friend allocator used by soap_new__ns1__GetShippingBerthListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingBerthListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingBerthListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:238 */
#ifndef SOAP_TYPE__ns1__UpdShipping
#define SOAP_TYPE__ns1__UpdShipping (41)
/* complex XSD type 'ns1:UpdShipping': */
class SOAP_CMAC _ns1__UpdShipping {
      public:
        /// Optional element 'ns1:ListNo' of XSD type 'xsd:string'
        std::string *ListNo;
        /// Optional element 'ns1:CarNo' of XSD type 'xsd:string'
        std::string *CarNo;
        /// Optional element 'ns1:RealTime' of XSD type 'xsd:string'
        std::string *RealTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdShipping
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdShipping; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdShipping, default initialized and not managed by a soap context
        virtual _ns1__UpdShipping *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdShipping); }
      public:
        /// Constructor with initializations
        _ns1__UpdShipping() : ListNo(), CarNo(), RealTime(), soap() { }
        virtual ~_ns1__UpdShipping() { }
        /// Friend allocator used by soap_new__ns1__UpdShipping(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdShipping * SOAP_FMAC2 soap_instantiate__ns1__UpdShipping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:241 */
#ifndef SOAP_TYPE__ns1__UpdShippingResponse
#define SOAP_TYPE__ns1__UpdShippingResponse (42)
/* complex XSD type 'ns1:UpdShippingResponse': */
class SOAP_CMAC _ns1__UpdShippingResponse {
      public:
        /// Optional element 'ns1:UpdShippingResult' of XSD type 'xsd:string'
        std::string *UpdShippingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdShippingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdShippingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdShippingResponse, default initialized and not managed by a soap context
        virtual _ns1__UpdShippingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdShippingResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpdShippingResponse() : UpdShippingResult(), soap() { }
        virtual ~_ns1__UpdShippingResponse() { }
        /// Friend allocator used by soap_new__ns1__UpdShippingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdShippingResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdShippingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:244 */
#ifndef SOAP_TYPE__ns1__GetShippingPalle
#define SOAP_TYPE__ns1__GetShippingPalle (43)
/* complex XSD type 'ns1:GetShippingPalle': */
class SOAP_CMAC _ns1__GetShippingPalle {
      public:
        /// Optional element 'ns1:ListNo' of XSD type 'xsd:string'
        std::string *ListNo;
        /// Optional element 'ns1:CarNo' of XSD type 'xsd:string'
        std::string *CarNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingPalle
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingPalle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingPalle, default initialized and not managed by a soap context
        virtual _ns1__GetShippingPalle *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingPalle); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingPalle() : ListNo(), CarNo(), soap() { }
        virtual ~_ns1__GetShippingPalle() { }
        /// Friend allocator used by soap_new__ns1__GetShippingPalle(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingPalle * SOAP_FMAC2 soap_instantiate__ns1__GetShippingPalle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:247 */
#ifndef SOAP_TYPE__ns1__GetShippingPalleResponse
#define SOAP_TYPE__ns1__GetShippingPalleResponse (44)
/* complex XSD type 'ns1:GetShippingPalleResponse': */
class SOAP_CMAC _ns1__GetShippingPalleResponse {
      public:
        /// Optional element 'ns1:GetShippingPalleResult' of XSD type 'xsd:string'
        std::string *GetShippingPalleResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingPalleResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingPalleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingPalleResponse, default initialized and not managed by a soap context
        virtual _ns1__GetShippingPalleResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingPalleResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingPalleResponse() : GetShippingPalleResult(), soap() { }
        virtual ~_ns1__GetShippingPalleResponse() { }
        /// Friend allocator used by soap_new__ns1__GetShippingPalleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingPalleResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingPalleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:250 */
#ifndef SOAP_TYPE__ns1__InsShippingPalle
#define SOAP_TYPE__ns1__InsShippingPalle (45)
/* complex XSD type 'ns1:InsShippingPalle': */
class SOAP_CMAC _ns1__InsShippingPalle {
      public:
        /// Optional element 'ns1:ListNo' of XSD type 'xsd:string'
        std::string *ListNo;
        /// Optional element 'ns1:CarNo' of XSD type 'xsd:string'
        std::string *CarNo;
        /// Optional element 'ns1:PalQty' of XSD type 'xsd:string'
        std::string *PalQty;
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsShippingPalle
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsShippingPalle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsShippingPalle, default initialized and not managed by a soap context
        virtual _ns1__InsShippingPalle *soap_alloc(void) const { return SOAP_NEW(_ns1__InsShippingPalle); }
      public:
        /// Constructor with initializations
        _ns1__InsShippingPalle() : ListNo(), CarNo(), PalQty(), strUser(), soap() { }
        virtual ~_ns1__InsShippingPalle() { }
        /// Friend allocator used by soap_new__ns1__InsShippingPalle(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsShippingPalle * SOAP_FMAC2 soap_instantiate__ns1__InsShippingPalle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:253 */
#ifndef SOAP_TYPE__ns1__InsShippingPalleResponse
#define SOAP_TYPE__ns1__InsShippingPalleResponse (46)
/* complex XSD type 'ns1:InsShippingPalleResponse': */
class SOAP_CMAC _ns1__InsShippingPalleResponse {
      public:
        /// Optional element 'ns1:InsShippingPalleResult' of XSD type 'xsd:string'
        std::string *InsShippingPalleResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsShippingPalleResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsShippingPalleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsShippingPalleResponse, default initialized and not managed by a soap context
        virtual _ns1__InsShippingPalleResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsShippingPalleResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsShippingPalleResponse() : InsShippingPalleResult(), soap() { }
        virtual ~_ns1__InsShippingPalleResponse() { }
        /// Friend allocator used by soap_new__ns1__InsShippingPalleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsShippingPalleResponse * SOAP_FMAC2 soap_instantiate__ns1__InsShippingPalleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:256 */
#ifndef SOAP_TYPE__ns1__InsShippingBerth
#define SOAP_TYPE__ns1__InsShippingBerth (47)
/* complex XSD type 'ns1:InsShippingBerth': */
class SOAP_CMAC _ns1__InsShippingBerth {
      public:
        /// Optional element 'ns1:ListNo' of XSD type 'xsd:string'
        std::string *ListNo;
        /// Optional element 'ns1:Berth' of XSD type 'xsd:string'
        std::string *Berth;
        /// Optional element 'ns1:strTime' of XSD type 'xsd:string'
        std::string *strTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsShippingBerth
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsShippingBerth; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsShippingBerth, default initialized and not managed by a soap context
        virtual _ns1__InsShippingBerth *soap_alloc(void) const { return SOAP_NEW(_ns1__InsShippingBerth); }
      public:
        /// Constructor with initializations
        _ns1__InsShippingBerth() : ListNo(), Berth(), strTime(), soap() { }
        virtual ~_ns1__InsShippingBerth() { }
        /// Friend allocator used by soap_new__ns1__InsShippingBerth(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsShippingBerth * SOAP_FMAC2 soap_instantiate__ns1__InsShippingBerth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:259 */
#ifndef SOAP_TYPE__ns1__InsShippingBerthResponse
#define SOAP_TYPE__ns1__InsShippingBerthResponse (48)
/* complex XSD type 'ns1:InsShippingBerthResponse': */
class SOAP_CMAC _ns1__InsShippingBerthResponse {
      public:
        /// Optional element 'ns1:InsShippingBerthResult' of XSD type 'xsd:string'
        std::string *InsShippingBerthResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsShippingBerthResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsShippingBerthResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsShippingBerthResponse, default initialized and not managed by a soap context
        virtual _ns1__InsShippingBerthResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsShippingBerthResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsShippingBerthResponse() : InsShippingBerthResult(), soap() { }
        virtual ~_ns1__InsShippingBerthResponse() { }
        /// Friend allocator used by soap_new__ns1__InsShippingBerthResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsShippingBerthResponse * SOAP_FMAC2 soap_instantiate__ns1__InsShippingBerthResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:262 */
#ifndef SOAP_TYPE__ns1__GetShippingForBerth
#define SOAP_TYPE__ns1__GetShippingForBerth (49)
/* complex XSD type 'ns1:GetShippingForBerth': */
class SOAP_CMAC _ns1__GetShippingForBerth {
      public:
        /// Optional element 'ns1:Berth' of XSD type 'xsd:string'
        std::string *Berth;
        /// Optional element 'ns1:CarNo' of XSD type 'xsd:string'
        std::string *CarNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingForBerth
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingForBerth; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingForBerth, default initialized and not managed by a soap context
        virtual _ns1__GetShippingForBerth *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingForBerth); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingForBerth() : Berth(), CarNo(), soap() { }
        virtual ~_ns1__GetShippingForBerth() { }
        /// Friend allocator used by soap_new__ns1__GetShippingForBerth(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingForBerth * SOAP_FMAC2 soap_instantiate__ns1__GetShippingForBerth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1921 */
#ifndef SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult
#define SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult (286)
/* complex XSD type 'ns1:GetShippingForBerthResponse-GetShippingForBerthResult': */
class SOAP_CMAC _ns1__GetShippingForBerthResponse_GetShippingForBerthResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingForBerthResponse_GetShippingForBerthResult, default initialized and not managed by a soap context
        virtual _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingForBerthResponse_GetShippingForBerthResult() : __any(), __any_() { }
        virtual ~_ns1__GetShippingForBerthResponse_GetShippingForBerthResult() { }
        /// Friend allocator used by soap_new__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingForBerthResponse_GetShippingForBerthResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:265 */
#ifndef SOAP_TYPE__ns1__GetShippingForBerthResponse
#define SOAP_TYPE__ns1__GetShippingForBerthResponse (50)
/* complex XSD type 'ns1:GetShippingForBerthResponse': */
class SOAP_CMAC _ns1__GetShippingForBerthResponse {
      public:
        /// Optional element 'ns1:GetShippingForBerthResult' of XSD type 'ns1:GetShippingForBerthResponse-GetShippingForBerthResult'
        _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *GetShippingForBerthResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingForBerthResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingForBerthResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingForBerthResponse, default initialized and not managed by a soap context
        virtual _ns1__GetShippingForBerthResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingForBerthResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingForBerthResponse() : GetShippingForBerthResult(), soap() { }
        virtual ~_ns1__GetShippingForBerthResponse() { }
        /// Friend allocator used by soap_new__ns1__GetShippingForBerthResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingForBerthResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingForBerthResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:268 */
#ifndef SOAP_TYPE__ns1__GetShippingWeight
#define SOAP_TYPE__ns1__GetShippingWeight (51)
/* complex XSD type 'ns1:GetShippingWeight': */
class SOAP_CMAC _ns1__GetShippingWeight {
      public:
        /// Optional element 'ns1:ListNo' of XSD type 'xsd:string'
        std::string *ListNo;
        /// Optional element 'ns1:CarNo' of XSD type 'xsd:string'
        std::string *CarNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingWeight
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingWeight; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingWeight, default initialized and not managed by a soap context
        virtual _ns1__GetShippingWeight *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingWeight); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingWeight() : ListNo(), CarNo(), soap() { }
        virtual ~_ns1__GetShippingWeight() { }
        /// Friend allocator used by soap_new__ns1__GetShippingWeight(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingWeight * SOAP_FMAC2 soap_instantiate__ns1__GetShippingWeight(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1991 */
#ifndef SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult
#define SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult (288)
/* complex XSD type 'ns1:GetShippingWeightResponse-GetShippingWeightResult': */
class SOAP_CMAC _ns1__GetShippingWeightResponse_GetShippingWeightResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingWeightResponse_GetShippingWeightResult, default initialized and not managed by a soap context
        virtual _ns1__GetShippingWeightResponse_GetShippingWeightResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingWeightResponse_GetShippingWeightResult); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingWeightResponse_GetShippingWeightResult() : __any(), __any_() { }
        virtual ~_ns1__GetShippingWeightResponse_GetShippingWeightResult() { }
        /// Friend allocator used by soap_new__ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingWeightResponse_GetShippingWeightResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:271 */
#ifndef SOAP_TYPE__ns1__GetShippingWeightResponse
#define SOAP_TYPE__ns1__GetShippingWeightResponse (52)
/* complex XSD type 'ns1:GetShippingWeightResponse': */
class SOAP_CMAC _ns1__GetShippingWeightResponse {
      public:
        /// Optional element 'ns1:GetShippingWeightResult' of XSD type 'ns1:GetShippingWeightResponse-GetShippingWeightResult'
        _ns1__GetShippingWeightResponse_GetShippingWeightResult *GetShippingWeightResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShippingWeightResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetShippingWeightResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShippingWeightResponse, default initialized and not managed by a soap context
        virtual _ns1__GetShippingWeightResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetShippingWeightResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetShippingWeightResponse() : GetShippingWeightResult(), soap() { }
        virtual ~_ns1__GetShippingWeightResponse() { }
        /// Friend allocator used by soap_new__ns1__GetShippingWeightResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShippingWeightResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingWeightResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:274 */
#ifndef SOAP_TYPE__ns1__getStationByMoForTestPad
#define SOAP_TYPE__ns1__getStationByMoForTestPad (53)
/* complex XSD type 'ns1:getStationByMoForTestPad': */
class SOAP_CMAC _ns1__getStationByMoForTestPad {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:strTest' of XSD type 'xsd:string'
        std::string *strTest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getStationByMoForTestPad
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getStationByMoForTestPad; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getStationByMoForTestPad, default initialized and not managed by a soap context
        virtual _ns1__getStationByMoForTestPad *soap_alloc(void) const { return SOAP_NEW(_ns1__getStationByMoForTestPad); }
      public:
        /// Constructor with initializations
        _ns1__getStationByMoForTestPad() : MoNumber(), strTest(), soap() { }
        virtual ~_ns1__getStationByMoForTestPad() { }
        /// Friend allocator used by soap_new__ns1__getStationByMoForTestPad(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getStationByMoForTestPad * SOAP_FMAC2 soap_instantiate__ns1__getStationByMoForTestPad(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:277 */
#ifndef SOAP_TYPE__ns1__getStationByMoForTestPadResponse
#define SOAP_TYPE__ns1__getStationByMoForTestPadResponse (54)
/* complex XSD type 'ns1:getStationByMoForTestPadResponse': */
class SOAP_CMAC _ns1__getStationByMoForTestPadResponse {
      public:
        /// Optional element 'ns1:getStationByMoForTestPadResult' of XSD type 'xsd:string'
        std::string *getStationByMoForTestPadResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getStationByMoForTestPadResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getStationByMoForTestPadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getStationByMoForTestPadResponse, default initialized and not managed by a soap context
        virtual _ns1__getStationByMoForTestPadResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getStationByMoForTestPadResponse); }
      public:
        /// Constructor with initializations
        _ns1__getStationByMoForTestPadResponse() : getStationByMoForTestPadResult(), soap() { }
        virtual ~_ns1__getStationByMoForTestPadResponse() { }
        /// Friend allocator used by soap_new__ns1__getStationByMoForTestPadResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getStationByMoForTestPadResponse * SOAP_FMAC2 soap_instantiate__ns1__getStationByMoForTestPadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2086 */
#ifndef SOAP_TYPE__ns1__SetFlatnessFruitRec_dt
#define SOAP_TYPE__ns1__SetFlatnessFruitRec_dt (290)
/* complex XSD type 'ns1:SetFlatnessFruitRec-dt': */
class SOAP_CMAC _ns1__SetFlatnessFruitRec_dt {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetFlatnessFruitRec_dt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetFlatnessFruitRec_dt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetFlatnessFruitRec_dt, default initialized and not managed by a soap context
        virtual _ns1__SetFlatnessFruitRec_dt *soap_alloc(void) const { return SOAP_NEW(_ns1__SetFlatnessFruitRec_dt); }
      public:
        /// Constructor with initializations
        _ns1__SetFlatnessFruitRec_dt() : __any(), __any_() { }
        virtual ~_ns1__SetFlatnessFruitRec_dt() { }
        /// Friend allocator used by soap_new__ns1__SetFlatnessFruitRec_dt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetFlatnessFruitRec_dt * SOAP_FMAC2 soap_instantiate__ns1__SetFlatnessFruitRec_dt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:280 */
#ifndef SOAP_TYPE__ns1__SetFlatnessFruitRec
#define SOAP_TYPE__ns1__SetFlatnessFruitRec (55)
/* complex XSD type 'ns1:SetFlatnessFruitRec': */
class SOAP_CMAC _ns1__SetFlatnessFruitRec {
      public:
        /// Optional element 'ns1:Sn' of XSD type 'xsd:string'
        std::string *Sn;
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Optional element 'ns1:dt' of XSD type 'ns1:SetFlatnessFruitRec-dt'
        _ns1__SetFlatnessFruitRec_dt *dt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetFlatnessFruitRec
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetFlatnessFruitRec; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetFlatnessFruitRec, default initialized and not managed by a soap context
        virtual _ns1__SetFlatnessFruitRec *soap_alloc(void) const { return SOAP_NEW(_ns1__SetFlatnessFruitRec); }
      public:
        /// Constructor with initializations
        _ns1__SetFlatnessFruitRec() : Sn(), strUser(), dt(), soap() { }
        virtual ~_ns1__SetFlatnessFruitRec() { }
        /// Friend allocator used by soap_new__ns1__SetFlatnessFruitRec(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetFlatnessFruitRec * SOAP_FMAC2 soap_instantiate__ns1__SetFlatnessFruitRec(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:283 */
#ifndef SOAP_TYPE__ns1__SetFlatnessFruitRecResponse
#define SOAP_TYPE__ns1__SetFlatnessFruitRecResponse (56)
/* complex XSD type 'ns1:SetFlatnessFruitRecResponse': */
class SOAP_CMAC _ns1__SetFlatnessFruitRecResponse {
      public:
        /// Optional element 'ns1:SetFlatnessFruitRecResult' of XSD type 'xsd:string'
        std::string *SetFlatnessFruitRecResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetFlatnessFruitRecResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetFlatnessFruitRecResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetFlatnessFruitRecResponse, default initialized and not managed by a soap context
        virtual _ns1__SetFlatnessFruitRecResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetFlatnessFruitRecResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetFlatnessFruitRecResponse() : SetFlatnessFruitRecResult(), soap() { }
        virtual ~_ns1__SetFlatnessFruitRecResponse() { }
        /// Friend allocator used by soap_new__ns1__SetFlatnessFruitRecResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetFlatnessFruitRecResponse * SOAP_FMAC2 soap_instantiate__ns1__SetFlatnessFruitRecResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:286 */
#ifndef SOAP_TYPE__ns1__GetSNForLink
#define SOAP_TYPE__ns1__GetSNForLink (57)
/* complex XSD type 'ns1:GetSNForLink': */
class SOAP_CMAC _ns1__GetSNForLink {
      public:
        /// Optional element 'ns1:LinkSN' of XSD type 'xsd:string'
        std::string *LinkSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSNForLink
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSNForLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSNForLink, default initialized and not managed by a soap context
        virtual _ns1__GetSNForLink *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSNForLink); }
      public:
        /// Constructor with initializations
        _ns1__GetSNForLink() : LinkSN(), soap() { }
        virtual ~_ns1__GetSNForLink() { }
        /// Friend allocator used by soap_new__ns1__GetSNForLink(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSNForLink * SOAP_FMAC2 soap_instantiate__ns1__GetSNForLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:289 */
#ifndef SOAP_TYPE__ns1__GetSNForLinkResponse
#define SOAP_TYPE__ns1__GetSNForLinkResponse (58)
/* complex XSD type 'ns1:GetSNForLinkResponse': */
class SOAP_CMAC _ns1__GetSNForLinkResponse {
      public:
        /// Optional element 'ns1:GetSNForLinkResult' of XSD type 'xsd:string'
        std::string *GetSNForLinkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSNForLinkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSNForLinkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSNForLinkResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSNForLinkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSNForLinkResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSNForLinkResponse() : GetSNForLinkResult(), soap() { }
        virtual ~_ns1__GetSNForLinkResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSNForLinkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSNForLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSNForLinkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:292 */
#ifndef SOAP_TYPE__ns1__SetAutoLineRec
#define SOAP_TYPE__ns1__SetAutoLineRec (59)
/* complex XSD type 'ns1:SetAutoLineRec': */
class SOAP_CMAC _ns1__SetAutoLineRec {
      public:
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Optional element 'ns1:InData' of XSD type 'xsd:string'
        std::string *InData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAutoLineRec
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAutoLineRec; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAutoLineRec, default initialized and not managed by a soap context
        virtual _ns1__SetAutoLineRec *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAutoLineRec); }
      public:
        /// Constructor with initializations
        _ns1__SetAutoLineRec() : strUser(), InData(), soap() { }
        virtual ~_ns1__SetAutoLineRec() { }
        /// Friend allocator used by soap_new__ns1__SetAutoLineRec(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAutoLineRec * SOAP_FMAC2 soap_instantiate__ns1__SetAutoLineRec(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:295 */
#ifndef SOAP_TYPE__ns1__SetAutoLineRecResponse
#define SOAP_TYPE__ns1__SetAutoLineRecResponse (60)
/* complex XSD type 'ns1:SetAutoLineRecResponse': */
class SOAP_CMAC _ns1__SetAutoLineRecResponse {
      public:
        /// Optional element 'ns1:SetAutoLineRecResult' of XSD type 'xsd:string'
        std::string *SetAutoLineRecResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAutoLineRecResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAutoLineRecResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAutoLineRecResponse, default initialized and not managed by a soap context
        virtual _ns1__SetAutoLineRecResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAutoLineRecResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetAutoLineRecResponse() : SetAutoLineRecResult(), soap() { }
        virtual ~_ns1__SetAutoLineRecResponse() { }
        /// Friend allocator used by soap_new__ns1__SetAutoLineRecResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAutoLineRecResponse * SOAP_FMAC2 soap_instantiate__ns1__SetAutoLineRecResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:298 */
#ifndef SOAP_TYPE__ns1__HPSNLinkBasket
#define SOAP_TYPE__ns1__HPSNLinkBasket (61)
/* complex XSD type 'ns1:HPSNLinkBasket': */
class SOAP_CMAC _ns1__HPSNLinkBasket {
      public:
        /// Optional element 'ns1:HPSN' of XSD type 'xsd:string'
        std::string *HPSN;
        /// Optional element 'ns1:BasketSN' of XSD type 'xsd:string'
        std::string *BasketSN;
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__HPSNLinkBasket
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__HPSNLinkBasket; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__HPSNLinkBasket, default initialized and not managed by a soap context
        virtual _ns1__HPSNLinkBasket *soap_alloc(void) const { return SOAP_NEW(_ns1__HPSNLinkBasket); }
      public:
        /// Constructor with initializations
        _ns1__HPSNLinkBasket() : HPSN(), BasketSN(), strUser(), soap() { }
        virtual ~_ns1__HPSNLinkBasket() { }
        /// Friend allocator used by soap_new__ns1__HPSNLinkBasket(struct soap*, int)
        friend SOAP_FMAC1 _ns1__HPSNLinkBasket * SOAP_FMAC2 soap_instantiate__ns1__HPSNLinkBasket(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:301 */
#ifndef SOAP_TYPE__ns1__HPSNLinkBasketResponse
#define SOAP_TYPE__ns1__HPSNLinkBasketResponse (62)
/* complex XSD type 'ns1:HPSNLinkBasketResponse': */
class SOAP_CMAC _ns1__HPSNLinkBasketResponse {
      public:
        /// Optional element 'ns1:HPSNLinkBasketResult' of XSD type 'xsd:string'
        std::string *HPSNLinkBasketResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__HPSNLinkBasketResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__HPSNLinkBasketResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__HPSNLinkBasketResponse, default initialized and not managed by a soap context
        virtual _ns1__HPSNLinkBasketResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__HPSNLinkBasketResponse); }
      public:
        /// Constructor with initializations
        _ns1__HPSNLinkBasketResponse() : HPSNLinkBasketResult(), soap() { }
        virtual ~_ns1__HPSNLinkBasketResponse() { }
        /// Friend allocator used by soap_new__ns1__HPSNLinkBasketResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__HPSNLinkBasketResponse * SOAP_FMAC2 soap_instantiate__ns1__HPSNLinkBasketResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:304 */
#ifndef SOAP_TYPE__ns1__BasketLinkPunch
#define SOAP_TYPE__ns1__BasketLinkPunch (63)
/* complex XSD type 'ns1:BasketLinkPunch': */
class SOAP_CMAC _ns1__BasketLinkPunch {
      public:
        /// Optional element 'ns1:BasketSN' of XSD type 'xsd:string'
        std::string *BasketSN;
        /// Optional element 'ns1:PunchSN' of XSD type 'xsd:string'
        std::string *PunchSN;
        /// Optional element 'ns1:Batch' of XSD type 'xsd:string'
        std::string *Batch;
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BasketLinkPunch
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BasketLinkPunch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BasketLinkPunch, default initialized and not managed by a soap context
        virtual _ns1__BasketLinkPunch *soap_alloc(void) const { return SOAP_NEW(_ns1__BasketLinkPunch); }
      public:
        /// Constructor with initializations
        _ns1__BasketLinkPunch() : BasketSN(), PunchSN(), Batch(), strUser(), soap() { }
        virtual ~_ns1__BasketLinkPunch() { }
        /// Friend allocator used by soap_new__ns1__BasketLinkPunch(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BasketLinkPunch * SOAP_FMAC2 soap_instantiate__ns1__BasketLinkPunch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:307 */
#ifndef SOAP_TYPE__ns1__BasketLinkPunchResponse
#define SOAP_TYPE__ns1__BasketLinkPunchResponse (64)
/* complex XSD type 'ns1:BasketLinkPunchResponse': */
class SOAP_CMAC _ns1__BasketLinkPunchResponse {
      public:
        /// Optional element 'ns1:BasketLinkPunchResult' of XSD type 'xsd:string'
        std::string *BasketLinkPunchResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BasketLinkPunchResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BasketLinkPunchResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BasketLinkPunchResponse, default initialized and not managed by a soap context
        virtual _ns1__BasketLinkPunchResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__BasketLinkPunchResponse); }
      public:
        /// Constructor with initializations
        _ns1__BasketLinkPunchResponse() : BasketLinkPunchResult(), soap() { }
        virtual ~_ns1__BasketLinkPunchResponse() { }
        /// Friend allocator used by soap_new__ns1__BasketLinkPunchResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BasketLinkPunchResponse * SOAP_FMAC2 soap_instantiate__ns1__BasketLinkPunchResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:310 */
#ifndef SOAP_TYPE__ns1__PunchOut
#define SOAP_TYPE__ns1__PunchOut (65)
/* complex XSD type 'ns1:PunchOut': */
class SOAP_CMAC _ns1__PunchOut {
      public:
        /// Optional element 'ns1:BasketSN' of XSD type 'xsd:string'
        std::string *BasketSN;
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PunchOut
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PunchOut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PunchOut, default initialized and not managed by a soap context
        virtual _ns1__PunchOut *soap_alloc(void) const { return SOAP_NEW(_ns1__PunchOut); }
      public:
        /// Constructor with initializations
        _ns1__PunchOut() : BasketSN(), strUser(), soap() { }
        virtual ~_ns1__PunchOut() { }
        /// Friend allocator used by soap_new__ns1__PunchOut(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PunchOut * SOAP_FMAC2 soap_instantiate__ns1__PunchOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:313 */
#ifndef SOAP_TYPE__ns1__PunchOutResponse
#define SOAP_TYPE__ns1__PunchOutResponse (66)
/* complex XSD type 'ns1:PunchOutResponse': */
class SOAP_CMAC _ns1__PunchOutResponse {
      public:
        /// Optional element 'ns1:PunchOutResult' of XSD type 'xsd:string'
        std::string *PunchOutResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PunchOutResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PunchOutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PunchOutResponse, default initialized and not managed by a soap context
        virtual _ns1__PunchOutResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__PunchOutResponse); }
      public:
        /// Constructor with initializations
        _ns1__PunchOutResponse() : PunchOutResult(), soap() { }
        virtual ~_ns1__PunchOutResponse() { }
        /// Friend allocator used by soap_new__ns1__PunchOutResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PunchOutResponse * SOAP_FMAC2 soap_instantiate__ns1__PunchOutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:316 */
#ifndef SOAP_TYPE__ns1__chkMoSNForAOI
#define SOAP_TYPE__ns1__chkMoSNForAOI (67)
/* complex XSD type 'ns1:chkMoSNForAOI': */
class SOAP_CMAC _ns1__chkMoSNForAOI {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkMoSNForAOI
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkMoSNForAOI; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkMoSNForAOI, default initialized and not managed by a soap context
        virtual _ns1__chkMoSNForAOI *soap_alloc(void) const { return SOAP_NEW(_ns1__chkMoSNForAOI); }
      public:
        /// Constructor with initializations
        _ns1__chkMoSNForAOI() : MoNumber(), SN(), soap() { }
        virtual ~_ns1__chkMoSNForAOI() { }
        /// Friend allocator used by soap_new__ns1__chkMoSNForAOI(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkMoSNForAOI * SOAP_FMAC2 soap_instantiate__ns1__chkMoSNForAOI(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:319 */
#ifndef SOAP_TYPE__ns1__chkMoSNForAOIResponse
#define SOAP_TYPE__ns1__chkMoSNForAOIResponse (68)
/* complex XSD type 'ns1:chkMoSNForAOIResponse': */
class SOAP_CMAC _ns1__chkMoSNForAOIResponse {
      public:
        /// Optional element 'ns1:chkMoSNForAOIResult' of XSD type 'xsd:string'
        std::string *chkMoSNForAOIResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkMoSNForAOIResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkMoSNForAOIResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkMoSNForAOIResponse, default initialized and not managed by a soap context
        virtual _ns1__chkMoSNForAOIResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkMoSNForAOIResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkMoSNForAOIResponse() : chkMoSNForAOIResult(), soap() { }
        virtual ~_ns1__chkMoSNForAOIResponse() { }
        /// Friend allocator used by soap_new__ns1__chkMoSNForAOIResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkMoSNForAOIResponse * SOAP_FMAC2 soap_instantiate__ns1__chkMoSNForAOIResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:322 */
#ifndef SOAP_TYPE__ns1__InsAoiMo
#define SOAP_TYPE__ns1__InsAoiMo (69)
/* complex XSD type 'ns1:InsAoiMo': */
class SOAP_CMAC _ns1__InsAoiMo {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsAoiMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsAoiMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsAoiMo, default initialized and not managed by a soap context
        virtual _ns1__InsAoiMo *soap_alloc(void) const { return SOAP_NEW(_ns1__InsAoiMo); }
      public:
        /// Constructor with initializations
        _ns1__InsAoiMo() : MoNumber(), SN(), Station(), soap() { }
        virtual ~_ns1__InsAoiMo() { }
        /// Friend allocator used by soap_new__ns1__InsAoiMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsAoiMo * SOAP_FMAC2 soap_instantiate__ns1__InsAoiMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:325 */
#ifndef SOAP_TYPE__ns1__InsAoiMoResponse
#define SOAP_TYPE__ns1__InsAoiMoResponse (70)
/* complex XSD type 'ns1:InsAoiMoResponse': */
class SOAP_CMAC _ns1__InsAoiMoResponse {
      public:
        /// Optional element 'ns1:InsAoiMoResult' of XSD type 'xsd:string'
        std::string *InsAoiMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsAoiMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsAoiMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsAoiMoResponse, default initialized and not managed by a soap context
        virtual _ns1__InsAoiMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsAoiMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsAoiMoResponse() : InsAoiMoResult(), soap() { }
        virtual ~_ns1__InsAoiMoResponse() { }
        /// Friend allocator used by soap_new__ns1__InsAoiMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsAoiMoResponse * SOAP_FMAC2 soap_instantiate__ns1__InsAoiMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:328 */
#ifndef SOAP_TYPE__ns1__InsCLScada
#define SOAP_TYPE__ns1__InsCLScada (71)
/* complex XSD type 'ns1:InsCLScada': */
class SOAP_CMAC _ns1__InsCLScada {
      public:
        /// Optional element 'ns1:MachineNo' of XSD type 'xsd:string'
        std::string *MachineNo;
        /// Optional element 'ns1:MachineStatus' of XSD type 'xsd:string'
        std::string *MachineStatus;
        /// Optional element 'ns1:MachineErr' of XSD type 'xsd:string'
        std::string *MachineErr;
        /// Optional element 'ns1:VacuumBound' of XSD type 'xsd:string'
        std::string *VacuumBound;
        /// Optional element 'ns1:VacuumValue' of XSD type 'xsd:string'
        std::string *VacuumValue;
        /// Optional element 'ns1:TempBound' of XSD type 'xsd:string'
        std::string *TempBound;
        /// Optional element 'ns1:TempValue' of XSD type 'xsd:string'
        std::string *TempValue;
        /// Optional element 'ns1:PartSN' of XSD type 'xsd:string'
        std::string *PartSN;
        /// Optional element 'ns1:ShelfNo' of XSD type 'xsd:string'
        std::string *ShelfNo;
        /// Optional element 'ns1:ShelfSN' of XSD type 'xsd:string'
        std::string *ShelfSN;
        /// Optional element 'ns1:StartTime' of XSD type 'xsd:string'
        std::string *StartTime;
        /// Optional element 'ns1:EndTime' of XSD type 'xsd:string'
        std::string *EndTime;
        /// Optional element 'ns1:AgeTime' of XSD type 'xsd:string'
        std::string *AgeTime;
        /// Optional element 'ns1:WaveBound' of XSD type 'xsd:string'
        std::string *WaveBound;
        /// Optional element 'ns1:WaveValue' of XSD type 'xsd:string'
        std::string *WaveValue;
        /// Optional element 'ns1:VoltBound' of XSD type 'xsd:string'
        std::string *VoltBound;
        /// Optional element 'ns1:VoltValue' of XSD type 'xsd:string'
        std::string *VoltValue;
        /// Optional element 'ns1:Ch1Value' of XSD type 'xsd:string'
        std::string *Ch1Value;
        /// Optional element 'ns1:Ch2Value' of XSD type 'xsd:string'
        std::string *Ch2Value;
        /// Optional element 'ns1:Ch3Value' of XSD type 'xsd:string'
        std::string *Ch3Value;
        /// Optional element 'ns1:Ch4Value' of XSD type 'xsd:string'
        std::string *Ch4Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsCLScada
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsCLScada; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsCLScada, default initialized and not managed by a soap context
        virtual _ns1__InsCLScada *soap_alloc(void) const { return SOAP_NEW(_ns1__InsCLScada); }
      public:
        /// Constructor with initializations
        _ns1__InsCLScada() : MachineNo(), MachineStatus(), MachineErr(), VacuumBound(), VacuumValue(), TempBound(), TempValue(), PartSN(), ShelfNo(), ShelfSN(), StartTime(), EndTime(), AgeTime(), WaveBound(), WaveValue(), VoltBound(), VoltValue(), Ch1Value(), Ch2Value(), Ch3Value(), Ch4Value(), soap() { }
        virtual ~_ns1__InsCLScada() { }
        /// Friend allocator used by soap_new__ns1__InsCLScada(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsCLScada * SOAP_FMAC2 soap_instantiate__ns1__InsCLScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:331 */
#ifndef SOAP_TYPE__ns1__InsCLScadaResponse
#define SOAP_TYPE__ns1__InsCLScadaResponse (72)
/* complex XSD type 'ns1:InsCLScadaResponse': */
class SOAP_CMAC _ns1__InsCLScadaResponse {
      public:
        /// Optional element 'ns1:InsCLScadaResult' of XSD type 'xsd:string'
        std::string *InsCLScadaResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsCLScadaResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsCLScadaResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsCLScadaResponse, default initialized and not managed by a soap context
        virtual _ns1__InsCLScadaResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsCLScadaResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsCLScadaResponse() : InsCLScadaResult(), soap() { }
        virtual ~_ns1__InsCLScadaResponse() { }
        /// Friend allocator used by soap_new__ns1__InsCLScadaResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsCLScadaResponse * SOAP_FMAC2 soap_instantiate__ns1__InsCLScadaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:334 */
#ifndef SOAP_TYPE__ns1__GetTestValueResult
#define SOAP_TYPE__ns1__GetTestValueResult (73)
/* complex XSD type 'ns1:GetTestValueResult': */
class SOAP_CMAC _ns1__GetTestValueResult {
      public:
        /// Optional element 'ns1:SPC' of XSD type 'xsd:string'
        std::string *SPC;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTestValueResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTestValueResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTestValueResult, default initialized and not managed by a soap context
        virtual _ns1__GetTestValueResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTestValueResult); }
      public:
        /// Constructor with initializations
        _ns1__GetTestValueResult() : SPC(), SN(), soap() { }
        virtual ~_ns1__GetTestValueResult() { }
        /// Friend allocator used by soap_new__ns1__GetTestValueResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTestValueResult * SOAP_FMAC2 soap_instantiate__ns1__GetTestValueResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:337 */
#ifndef SOAP_TYPE__ns1__GetTestValueResultResponse
#define SOAP_TYPE__ns1__GetTestValueResultResponse (74)
/* complex XSD type 'ns1:GetTestValueResultResponse': */
class SOAP_CMAC _ns1__GetTestValueResultResponse {
      public:
        /// Optional element 'ns1:GetTestValueResultResult' of XSD type 'xsd:string'
        std::string *GetTestValueResultResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTestValueResultResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTestValueResultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTestValueResultResponse, default initialized and not managed by a soap context
        virtual _ns1__GetTestValueResultResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTestValueResultResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetTestValueResultResponse() : GetTestValueResultResult(), soap() { }
        virtual ~_ns1__GetTestValueResultResponse() { }
        /// Friend allocator used by soap_new__ns1__GetTestValueResultResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTestValueResultResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTestValueResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:340 */
#ifndef SOAP_TYPE__ns1__GetStationNumberForSN
#define SOAP_TYPE__ns1__GetStationNumberForSN (75)
/* complex XSD type 'ns1:GetStationNumberForSN': */
class SOAP_CMAC _ns1__GetStationNumberForSN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStationNumberForSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStationNumberForSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStationNumberForSN, default initialized and not managed by a soap context
        virtual _ns1__GetStationNumberForSN *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStationNumberForSN); }
      public:
        /// Constructor with initializations
        _ns1__GetStationNumberForSN() : SN(), soap() { }
        virtual ~_ns1__GetStationNumberForSN() { }
        /// Friend allocator used by soap_new__ns1__GetStationNumberForSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStationNumberForSN * SOAP_FMAC2 soap_instantiate__ns1__GetStationNumberForSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:343 */
#ifndef SOAP_TYPE__ns1__GetStationNumberForSNResponse
#define SOAP_TYPE__ns1__GetStationNumberForSNResponse (76)
/* complex XSD type 'ns1:GetStationNumberForSNResponse': */
class SOAP_CMAC _ns1__GetStationNumberForSNResponse {
      public:
        /// Optional element 'ns1:GetStationNumberForSNResult' of XSD type 'xsd:string'
        std::string *GetStationNumberForSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStationNumberForSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStationNumberForSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStationNumberForSNResponse, default initialized and not managed by a soap context
        virtual _ns1__GetStationNumberForSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStationNumberForSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetStationNumberForSNResponse() : GetStationNumberForSNResult(), soap() { }
        virtual ~_ns1__GetStationNumberForSNResponse() { }
        /// Friend allocator used by soap_new__ns1__GetStationNumberForSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStationNumberForSNResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStationNumberForSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:346 */
#ifndef SOAP_TYPE__ns1__InsSNTestForFruit
#define SOAP_TYPE__ns1__InsSNTestForFruit (77)
/* complex XSD type 'ns1:InsSNTestForFruit': */
class SOAP_CMAC _ns1__InsSNTestForFruit {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Machine' of XSD type 'xsd:string'
        std::string *Machine;
        /// Optional element 'ns1:SiteId' of XSD type 'xsd:string'
        std::string *SiteId;
        /// Optional element 'ns1:TestResult' of XSD type 'xsd:string'
        std::string *TestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsSNTestForFruit
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsSNTestForFruit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsSNTestForFruit, default initialized and not managed by a soap context
        virtual _ns1__InsSNTestForFruit *soap_alloc(void) const { return SOAP_NEW(_ns1__InsSNTestForFruit); }
      public:
        /// Constructor with initializations
        _ns1__InsSNTestForFruit() : SN(), Machine(), SiteId(), TestResult(), soap() { }
        virtual ~_ns1__InsSNTestForFruit() { }
        /// Friend allocator used by soap_new__ns1__InsSNTestForFruit(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsSNTestForFruit * SOAP_FMAC2 soap_instantiate__ns1__InsSNTestForFruit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:349 */
#ifndef SOAP_TYPE__ns1__InsSNTestForFruitResponse
#define SOAP_TYPE__ns1__InsSNTestForFruitResponse (78)
/* complex XSD type 'ns1:InsSNTestForFruitResponse': */
class SOAP_CMAC _ns1__InsSNTestForFruitResponse {
      public:
        /// Optional element 'ns1:InsSNTestForFruitResult' of XSD type 'xsd:string'
        std::string *InsSNTestForFruitResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsSNTestForFruitResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsSNTestForFruitResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsSNTestForFruitResponse, default initialized and not managed by a soap context
        virtual _ns1__InsSNTestForFruitResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsSNTestForFruitResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsSNTestForFruitResponse() : InsSNTestForFruitResult(), soap() { }
        virtual ~_ns1__InsSNTestForFruitResponse() { }
        /// Friend allocator used by soap_new__ns1__InsSNTestForFruitResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsSNTestForFruitResponse * SOAP_FMAC2 soap_instantiate__ns1__InsSNTestForFruitResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:352 */
#ifndef SOAP_TYPE__ns1__SelSNTestForFruit
#define SOAP_TYPE__ns1__SelSNTestForFruit (79)
/* complex XSD type 'ns1:SelSNTestForFruit': */
class SOAP_CMAC _ns1__SelSNTestForFruit {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelSNTestForFruit
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelSNTestForFruit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelSNTestForFruit, default initialized and not managed by a soap context
        virtual _ns1__SelSNTestForFruit *soap_alloc(void) const { return SOAP_NEW(_ns1__SelSNTestForFruit); }
      public:
        /// Constructor with initializations
        _ns1__SelSNTestForFruit() : SN(), soap() { }
        virtual ~_ns1__SelSNTestForFruit() { }
        /// Friend allocator used by soap_new__ns1__SelSNTestForFruit(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelSNTestForFruit * SOAP_FMAC2 soap_instantiate__ns1__SelSNTestForFruit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:355 */
#ifndef SOAP_TYPE__ns1__SelSNTestForFruitResponse
#define SOAP_TYPE__ns1__SelSNTestForFruitResponse (80)
/* complex XSD type 'ns1:SelSNTestForFruitResponse': */
class SOAP_CMAC _ns1__SelSNTestForFruitResponse {
      public:
        /// Optional element 'ns1:SelSNTestForFruitResult' of XSD type 'xsd:string'
        std::string *SelSNTestForFruitResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelSNTestForFruitResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelSNTestForFruitResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelSNTestForFruitResponse, default initialized and not managed by a soap context
        virtual _ns1__SelSNTestForFruitResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SelSNTestForFruitResponse); }
      public:
        /// Constructor with initializations
        _ns1__SelSNTestForFruitResponse() : SelSNTestForFruitResult(), soap() { }
        virtual ~_ns1__SelSNTestForFruitResponse() { }
        /// Friend allocator used by soap_new__ns1__SelSNTestForFruitResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelSNTestForFruitResponse * SOAP_FMAC2 soap_instantiate__ns1__SelSNTestForFruitResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:358 */
#ifndef SOAP_TYPE__ns1__SNLinkShelf
#define SOAP_TYPE__ns1__SNLinkShelf (81)
/* complex XSD type 'ns1:SNLinkShelf': */
class SOAP_CMAC _ns1__SNLinkShelf {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:ShelfSN' of XSD type 'xsd:string'
        std::string *ShelfSN;
        /// Optional element 'ns1:strUser' of XSD type 'xsd:string'
        std::string *strUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SNLinkShelf
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SNLinkShelf; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SNLinkShelf, default initialized and not managed by a soap context
        virtual _ns1__SNLinkShelf *soap_alloc(void) const { return SOAP_NEW(_ns1__SNLinkShelf); }
      public:
        /// Constructor with initializations
        _ns1__SNLinkShelf() : SN(), ShelfSN(), strUser(), soap() { }
        virtual ~_ns1__SNLinkShelf() { }
        /// Friend allocator used by soap_new__ns1__SNLinkShelf(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SNLinkShelf * SOAP_FMAC2 soap_instantiate__ns1__SNLinkShelf(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:361 */
#ifndef SOAP_TYPE__ns1__SNLinkShelfResponse
#define SOAP_TYPE__ns1__SNLinkShelfResponse (82)
/* complex XSD type 'ns1:SNLinkShelfResponse': */
class SOAP_CMAC _ns1__SNLinkShelfResponse {
      public:
        /// Optional element 'ns1:SNLinkShelfResult' of XSD type 'xsd:string'
        std::string *SNLinkShelfResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SNLinkShelfResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SNLinkShelfResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SNLinkShelfResponse, default initialized and not managed by a soap context
        virtual _ns1__SNLinkShelfResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SNLinkShelfResponse); }
      public:
        /// Constructor with initializations
        _ns1__SNLinkShelfResponse() : SNLinkShelfResult(), soap() { }
        virtual ~_ns1__SNLinkShelfResponse() { }
        /// Friend allocator used by soap_new__ns1__SNLinkShelfResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SNLinkShelfResponse * SOAP_FMAC2 soap_instantiate__ns1__SNLinkShelfResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:364 */
#ifndef SOAP_TYPE__ns1__SelShelfLink
#define SOAP_TYPE__ns1__SelShelfLink (83)
/* complex XSD type 'ns1:SelShelfLink': */
class SOAP_CMAC _ns1__SelShelfLink {
      public:
        /// Optional element 'ns1:ShelfSN' of XSD type 'xsd:string'
        std::string *ShelfSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelShelfLink
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelShelfLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelShelfLink, default initialized and not managed by a soap context
        virtual _ns1__SelShelfLink *soap_alloc(void) const { return SOAP_NEW(_ns1__SelShelfLink); }
      public:
        /// Constructor with initializations
        _ns1__SelShelfLink() : ShelfSN(), soap() { }
        virtual ~_ns1__SelShelfLink() { }
        /// Friend allocator used by soap_new__ns1__SelShelfLink(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelShelfLink * SOAP_FMAC2 soap_instantiate__ns1__SelShelfLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:367 */
#ifndef SOAP_TYPE__ns1__SelShelfLinkResponse
#define SOAP_TYPE__ns1__SelShelfLinkResponse (84)
/* complex XSD type 'ns1:SelShelfLinkResponse': */
class SOAP_CMAC _ns1__SelShelfLinkResponse {
      public:
        /// Optional element 'ns1:SelShelfLinkResult' of XSD type 'xsd:string'
        std::string *SelShelfLinkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelShelfLinkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelShelfLinkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelShelfLinkResponse, default initialized and not managed by a soap context
        virtual _ns1__SelShelfLinkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SelShelfLinkResponse); }
      public:
        /// Constructor with initializations
        _ns1__SelShelfLinkResponse() : SelShelfLinkResult(), soap() { }
        virtual ~_ns1__SelShelfLinkResponse() { }
        /// Friend allocator used by soap_new__ns1__SelShelfLinkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelShelfLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__SelShelfLinkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:370 */
#ifndef SOAP_TYPE__ns1__UploadForHP
#define SOAP_TYPE__ns1__UploadForHP (85)
/* complex XSD type 'ns1:UploadForHP': */
class SOAP_CMAC _ns1__UploadForHP {
      public:
        /// Optional element 'ns1:DT' of XSD type 'xsd:string'
        std::string *DT;
        /// Optional element 'ns1:ItemNo' of XSD type 'xsd:string'
        std::string *ItemNo;
        /// Optional element 'ns1:PartNo' of XSD type 'xsd:string'
        std::string *PartNo;
        /// Optional element 'ns1:Qty' of XSD type 'xsd:string'
        std::string *Qty;
        /// Optional element 'ns1:NgQty' of XSD type 'xsd:string'
        std::string *NgQty;
        /// Optional element 'ns1:StopDT' of XSD type 'xsd:string'
        std::string *StopDT;
        /// Optional element 'ns1:NgDesc' of XSD type 'xsd:string'
        std::string *NgDesc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UploadForHP
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UploadForHP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UploadForHP, default initialized and not managed by a soap context
        virtual _ns1__UploadForHP *soap_alloc(void) const { return SOAP_NEW(_ns1__UploadForHP); }
      public:
        /// Constructor with initializations
        _ns1__UploadForHP() : DT(), ItemNo(), PartNo(), Qty(), NgQty(), StopDT(), NgDesc(), soap() { }
        virtual ~_ns1__UploadForHP() { }
        /// Friend allocator used by soap_new__ns1__UploadForHP(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UploadForHP * SOAP_FMAC2 soap_instantiate__ns1__UploadForHP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:373 */
#ifndef SOAP_TYPE__ns1__UploadForHPResponse
#define SOAP_TYPE__ns1__UploadForHPResponse (86)
/* complex XSD type 'ns1:UploadForHPResponse': */
class SOAP_CMAC _ns1__UploadForHPResponse {
      public:
        /// Optional element 'ns1:UploadForHPResult' of XSD type 'xsd:string'
        std::string *UploadForHPResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UploadForHPResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UploadForHPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UploadForHPResponse, default initialized and not managed by a soap context
        virtual _ns1__UploadForHPResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UploadForHPResponse); }
      public:
        /// Constructor with initializations
        _ns1__UploadForHPResponse() : UploadForHPResult(), soap() { }
        virtual ~_ns1__UploadForHPResponse() { }
        /// Friend allocator used by soap_new__ns1__UploadForHPResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UploadForHPResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadForHPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:376 */
#ifndef SOAP_TYPE__ns1__GetMachineForGroup
#define SOAP_TYPE__ns1__GetMachineForGroup (87)
/* complex XSD type 'ns1:GetMachineForGroup': */
class SOAP_CMAC _ns1__GetMachineForGroup {
      public:
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:PmcNo' of XSD type 'xsd:string'
        std::string *PmcNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMachineForGroup
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetMachineForGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMachineForGroup, default initialized and not managed by a soap context
        virtual _ns1__GetMachineForGroup *soap_alloc(void) const { return SOAP_NEW(_ns1__GetMachineForGroup); }
      public:
        /// Constructor with initializations
        _ns1__GetMachineForGroup() : StationNumber(), PmcNo(), soap() { }
        virtual ~_ns1__GetMachineForGroup() { }
        /// Friend allocator used by soap_new__ns1__GetMachineForGroup(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMachineForGroup * SOAP_FMAC2 soap_instantiate__ns1__GetMachineForGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2891 */
#ifndef SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult
#define SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult (292)
/* complex XSD type 'ns1:GetMachineForGroupResponse-GetMachineForGroupResult': */
class SOAP_CMAC _ns1__GetMachineForGroupResponse_GetMachineForGroupResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMachineForGroupResponse_GetMachineForGroupResult, default initialized and not managed by a soap context
        virtual _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult); }
      public:
        /// Constructor with initializations
        _ns1__GetMachineForGroupResponse_GetMachineForGroupResult() : xsd__schema(), __any() { }
        virtual ~_ns1__GetMachineForGroupResponse_GetMachineForGroupResult() { }
        /// Friend allocator used by soap_new__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMachineForGroupResponse_GetMachineForGroupResult * SOAP_FMAC2 soap_instantiate__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:379 */
#ifndef SOAP_TYPE__ns1__GetMachineForGroupResponse
#define SOAP_TYPE__ns1__GetMachineForGroupResponse (88)
/* complex XSD type 'ns1:GetMachineForGroupResponse': */
class SOAP_CMAC _ns1__GetMachineForGroupResponse {
      public:
        /// Optional element 'ns1:GetMachineForGroupResult' of XSD type 'ns1:GetMachineForGroupResponse-GetMachineForGroupResult'
        _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *GetMachineForGroupResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMachineForGroupResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetMachineForGroupResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMachineForGroupResponse, default initialized and not managed by a soap context
        virtual _ns1__GetMachineForGroupResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetMachineForGroupResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetMachineForGroupResponse() : GetMachineForGroupResult(), soap() { }
        virtual ~_ns1__GetMachineForGroupResponse() { }
        /// Friend allocator used by soap_new__ns1__GetMachineForGroupResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMachineForGroupResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMachineForGroupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:382 */
#ifndef SOAP_TYPE__ns1__SetDiecastSN
#define SOAP_TYPE__ns1__SetDiecastSN (89)
/* complex XSD type 'ns1:SetDiecastSN': */
class SOAP_CMAC _ns1__SetDiecastSN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:strType' of XSD type 'xsd:string'
        std::string *strType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDiecastSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDiecastSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDiecastSN, default initialized and not managed by a soap context
        virtual _ns1__SetDiecastSN *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDiecastSN); }
      public:
        /// Constructor with initializations
        _ns1__SetDiecastSN() : SN(), StationNumber(), strType(), soap() { }
        virtual ~_ns1__SetDiecastSN() { }
        /// Friend allocator used by soap_new__ns1__SetDiecastSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDiecastSN * SOAP_FMAC2 soap_instantiate__ns1__SetDiecastSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:385 */
#ifndef SOAP_TYPE__ns1__SetDiecastSNResponse
#define SOAP_TYPE__ns1__SetDiecastSNResponse (90)
/* complex XSD type 'ns1:SetDiecastSNResponse': */
class SOAP_CMAC _ns1__SetDiecastSNResponse {
      public:
        /// Optional element 'ns1:SetDiecastSNResult' of XSD type 'xsd:string'
        std::string *SetDiecastSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDiecastSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDiecastSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDiecastSNResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDiecastSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDiecastSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDiecastSNResponse() : SetDiecastSNResult(), soap() { }
        virtual ~_ns1__SetDiecastSNResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDiecastSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDiecastSNResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDiecastSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:388 */
#ifndef SOAP_TYPE__ns1__GetNgCode
#define SOAP_TYPE__ns1__GetNgCode (91)
/* complex XSD type 'ns1:GetNgCode': */
class SOAP_CMAC _ns1__GetNgCode {
      public:
        /// Optional element 'ns1:NgCode' of XSD type 'xsd:string'
        std::string *NgCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNgCode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNgCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNgCode, default initialized and not managed by a soap context
        virtual _ns1__GetNgCode *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNgCode); }
      public:
        /// Constructor with initializations
        _ns1__GetNgCode() : NgCode(), soap() { }
        virtual ~_ns1__GetNgCode() { }
        /// Friend allocator used by soap_new__ns1__GetNgCode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNgCode * SOAP_FMAC2 soap_instantiate__ns1__GetNgCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:391 */
#ifndef SOAP_TYPE__ns1__GetNgCodeResponse
#define SOAP_TYPE__ns1__GetNgCodeResponse (92)
/* complex XSD type 'ns1:GetNgCodeResponse': */
class SOAP_CMAC _ns1__GetNgCodeResponse {
      public:
        /// Optional element 'ns1:GetNgCodeResult' of XSD type 'xsd:string'
        std::string *GetNgCodeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNgCodeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNgCodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNgCodeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetNgCodeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNgCodeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetNgCodeResponse() : GetNgCodeResult(), soap() { }
        virtual ~_ns1__GetNgCodeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetNgCodeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNgCodeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNgCodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:394 */
#ifndef SOAP_TYPE__ns1__getMoBase
#define SOAP_TYPE__ns1__getMoBase (93)
/* complex XSD type 'ns1:getMoBase': */
class SOAP_CMAC _ns1__getMoBase {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoBase
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoBase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoBase, default initialized and not managed by a soap context
        virtual _ns1__getMoBase *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoBase); }
      public:
        /// Constructor with initializations
        _ns1__getMoBase() : MoNumber(), soap() { }
        virtual ~_ns1__getMoBase() { }
        /// Friend allocator used by soap_new__ns1__getMoBase(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoBase * SOAP_FMAC2 soap_instantiate__ns1__getMoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:397 */
#ifndef SOAP_TYPE__ns1__getMoBaseResponse
#define SOAP_TYPE__ns1__getMoBaseResponse (94)
/* complex XSD type 'ns1:getMoBaseResponse': */
class SOAP_CMAC _ns1__getMoBaseResponse {
      public:
        /// Optional element 'ns1:getMoBaseResult' of XSD type 'xsd:string'
        std::string *getMoBaseResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoBaseResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoBaseResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoBaseResponse, default initialized and not managed by a soap context
        virtual _ns1__getMoBaseResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoBaseResponse); }
      public:
        /// Constructor with initializations
        _ns1__getMoBaseResponse() : getMoBaseResult(), soap() { }
        virtual ~_ns1__getMoBaseResponse() { }
        /// Friend allocator used by soap_new__ns1__getMoBaseResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoBaseResponse * SOAP_FMAC2 soap_instantiate__ns1__getMoBaseResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:400 */
#ifndef SOAP_TYPE__ns1__SnLnkOutSN
#define SOAP_TYPE__ns1__SnLnkOutSN (95)
/* complex XSD type 'ns1:SnLnkOutSN': */
class SOAP_CMAC _ns1__SnLnkOutSN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:LnkSN' of XSD type 'xsd:string'
        std::string *LnkSN;
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:Station_Number' of XSD type 'xsd:string'
        std::string *Station_USCORENumber;
        /// Optional element 'ns1:LnkType' of XSD type 'xsd:string'
        std::string *LnkType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnLnkOutSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnLnkOutSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnLnkOutSN, default initialized and not managed by a soap context
        virtual _ns1__SnLnkOutSN *soap_alloc(void) const { return SOAP_NEW(_ns1__SnLnkOutSN); }
      public:
        /// Constructor with initializations
        _ns1__SnLnkOutSN() : SN(), LnkSN(), Emp_USCORENo(), Station_USCORENumber(), LnkType(), soap() { }
        virtual ~_ns1__SnLnkOutSN() { }
        /// Friend allocator used by soap_new__ns1__SnLnkOutSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnLnkOutSN * SOAP_FMAC2 soap_instantiate__ns1__SnLnkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:403 */
#ifndef SOAP_TYPE__ns1__SnLnkOutSNResponse
#define SOAP_TYPE__ns1__SnLnkOutSNResponse (96)
/* complex XSD type 'ns1:SnLnkOutSNResponse': */
class SOAP_CMAC _ns1__SnLnkOutSNResponse {
      public:
        /// Optional element 'ns1:SnLnkOutSNResult' of XSD type 'xsd:string'
        std::string *SnLnkOutSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnLnkOutSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnLnkOutSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnLnkOutSNResponse, default initialized and not managed by a soap context
        virtual _ns1__SnLnkOutSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SnLnkOutSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__SnLnkOutSNResponse() : SnLnkOutSNResult(), soap() { }
        virtual ~_ns1__SnLnkOutSNResponse() { }
        /// Friend allocator used by soap_new__ns1__SnLnkOutSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnLnkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__SnLnkOutSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:406 */
#ifndef SOAP_TYPE__ns1__InsFruitMachineChk
#define SOAP_TYPE__ns1__InsFruitMachineChk (97)
/* complex XSD type 'ns1:InsFruitMachineChk': */
class SOAP_CMAC _ns1__InsFruitMachineChk {
      public:
        /// Optional element 'ns1:Sn' of XSD type 'xsd:string'
        std::string *Sn;
        /// Optional element 'ns1:Machine' of XSD type 'xsd:string'
        std::string *Machine;
        /// Optional element 'ns1:TestItem' of XSD type 'xsd:string'
        std::string *TestItem;
        /// Optional element 'ns1:TestUpper' of XSD type 'xsd:string'
        std::string *TestUpper;
        /// Optional element 'ns1:TestLower' of XSD type 'xsd:string'
        std::string *TestLower;
        /// Optional element 'ns1:TestValue' of XSD type 'xsd:string'
        std::string *TestValue;
        /// Optional element 'ns1:TestResult' of XSD type 'xsd:string'
        std::string *TestResult;
        /// Optional element 'ns1:TestTime' of XSD type 'xsd:string'
        std::string *TestTime;
        /// Optional element 'ns1:EndTime' of XSD type 'xsd:string'
        std::string *EndTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFruitMachineChk
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFruitMachineChk; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFruitMachineChk, default initialized and not managed by a soap context
        virtual _ns1__InsFruitMachineChk *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFruitMachineChk); }
      public:
        /// Constructor with initializations
        _ns1__InsFruitMachineChk() : Sn(), Machine(), TestItem(), TestUpper(), TestLower(), TestValue(), TestResult(), TestTime(), EndTime(), soap() { }
        virtual ~_ns1__InsFruitMachineChk() { }
        /// Friend allocator used by soap_new__ns1__InsFruitMachineChk(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFruitMachineChk * SOAP_FMAC2 soap_instantiate__ns1__InsFruitMachineChk(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:409 */
#ifndef SOAP_TYPE__ns1__InsFruitMachineChkResponse
#define SOAP_TYPE__ns1__InsFruitMachineChkResponse (98)
/* complex XSD type 'ns1:InsFruitMachineChkResponse': */
class SOAP_CMAC _ns1__InsFruitMachineChkResponse {
      public:
        /// Optional element 'ns1:InsFruitMachineChkResult' of XSD type 'xsd:string'
        std::string *InsFruitMachineChkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFruitMachineChkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFruitMachineChkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFruitMachineChkResponse, default initialized and not managed by a soap context
        virtual _ns1__InsFruitMachineChkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFruitMachineChkResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsFruitMachineChkResponse() : InsFruitMachineChkResult(), soap() { }
        virtual ~_ns1__InsFruitMachineChkResponse() { }
        /// Friend allocator used by soap_new__ns1__InsFruitMachineChkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFruitMachineChkResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFruitMachineChkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:412 */
#ifndef SOAP_TYPE__ns1__GetFruitMachineChk
#define SOAP_TYPE__ns1__GetFruitMachineChk (99)
/* complex XSD type 'ns1:GetFruitMachineChk': */
class SOAP_CMAC _ns1__GetFruitMachineChk {
      public:
        /// Optional element 'ns1:Sn' of XSD type 'xsd:string'
        std::string *Sn;
        /// Optional element 'ns1:Machine' of XSD type 'xsd:string'
        std::string *Machine;
        /// Optional element 'ns1:TestItem' of XSD type 'xsd:string'
        std::string *TestItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFruitMachineChk
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFruitMachineChk; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFruitMachineChk, default initialized and not managed by a soap context
        virtual _ns1__GetFruitMachineChk *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFruitMachineChk); }
      public:
        /// Constructor with initializations
        _ns1__GetFruitMachineChk() : Sn(), Machine(), TestItem(), soap() { }
        virtual ~_ns1__GetFruitMachineChk() { }
        /// Friend allocator used by soap_new__ns1__GetFruitMachineChk(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFruitMachineChk * SOAP_FMAC2 soap_instantiate__ns1__GetFruitMachineChk(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:415 */
#ifndef SOAP_TYPE__ns1__GetFruitMachineChkResponse
#define SOAP_TYPE__ns1__GetFruitMachineChkResponse (100)
/* complex XSD type 'ns1:GetFruitMachineChkResponse': */
class SOAP_CMAC _ns1__GetFruitMachineChkResponse {
      public:
        /// Optional element 'ns1:GetFruitMachineChkResult' of XSD type 'xsd:string'
        std::string *GetFruitMachineChkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFruitMachineChkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFruitMachineChkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFruitMachineChkResponse, default initialized and not managed by a soap context
        virtual _ns1__GetFruitMachineChkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFruitMachineChkResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetFruitMachineChkResponse() : GetFruitMachineChkResult(), soap() { }
        virtual ~_ns1__GetFruitMachineChkResponse() { }
        /// Friend allocator used by soap_new__ns1__GetFruitMachineChkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFruitMachineChkResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFruitMachineChkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:418 */
#ifndef SOAP_TYPE__ns1__InsZjList
#define SOAP_TYPE__ns1__InsZjList (101)
/* complex XSD type 'ns1:InsZjList': */
class SOAP_CMAC _ns1__InsZjList {
      public:
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Optional element 'ns1:Qty' of XSD type 'xsd:string'
        std::string *Qty;
        /// Optional element 'ns1:ZJQty' of XSD type 'xsd:string'
        std::string *ZJQty;
        /// Optional element 'ns1:ZJDate' of XSD type 'xsd:string'
        std::string *ZJDate;
        /// Optional element 'ns1:Mo' of XSD type 'xsd:string'
        std::string *Mo;
        /// Optional element 'ns1:Part' of XSD type 'xsd:string'
        std::string *Part;
        /// Optional element 'ns1:Line' of XSD type 'xsd:string'
        std::string *Line;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsZjList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsZjList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsZjList, default initialized and not managed by a soap context
        virtual _ns1__InsZjList *soap_alloc(void) const { return SOAP_NEW(_ns1__InsZjList); }
      public:
        /// Constructor with initializations
        _ns1__InsZjList() : ZJSN(), Qty(), ZJQty(), ZJDate(), Mo(), Part(), Line(), soap() { }
        virtual ~_ns1__InsZjList() { }
        /// Friend allocator used by soap_new__ns1__InsZjList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsZjList * SOAP_FMAC2 soap_instantiate__ns1__InsZjList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:421 */
#ifndef SOAP_TYPE__ns1__InsZjListResponse
#define SOAP_TYPE__ns1__InsZjListResponse (102)
/* complex XSD type 'ns1:InsZjListResponse': */
class SOAP_CMAC _ns1__InsZjListResponse {
      public:
        /// Optional element 'ns1:InsZjListResult' of XSD type 'xsd:string'
        std::string *InsZjListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsZjListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsZjListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsZjListResponse, default initialized and not managed by a soap context
        virtual _ns1__InsZjListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsZjListResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsZjListResponse() : InsZjListResult(), soap() { }
        virtual ~_ns1__InsZjListResponse() { }
        /// Friend allocator used by soap_new__ns1__InsZjListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsZjListResponse * SOAP_FMAC2 soap_instantiate__ns1__InsZjListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:424 */
#ifndef SOAP_TYPE__ns1__checkTestData
#define SOAP_TYPE__ns1__checkTestData (103)
/* complex XSD type 'ns1:checkTestData': */
class SOAP_CMAC _ns1__checkTestData {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:TB' of XSD type 'xsd:string'
        std::string *TB;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkTestData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkTestData, default initialized and not managed by a soap context
        virtual _ns1__checkTestData *soap_alloc(void) const { return SOAP_NEW(_ns1__checkTestData); }
      public:
        /// Constructor with initializations
        _ns1__checkTestData() : SN(), TB(), soap() { }
        virtual ~_ns1__checkTestData() { }
        /// Friend allocator used by soap_new__ns1__checkTestData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkTestData * SOAP_FMAC2 soap_instantiate__ns1__checkTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:427 */
#ifndef SOAP_TYPE__ns1__checkTestDataResponse
#define SOAP_TYPE__ns1__checkTestDataResponse (104)
/* complex XSD type 'ns1:checkTestDataResponse': */
class SOAP_CMAC _ns1__checkTestDataResponse {
      public:
        /// Optional element 'ns1:checkTestDataResult' of XSD type 'xsd:string'
        std::string *checkTestDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkTestDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkTestDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkTestDataResponse, default initialized and not managed by a soap context
        virtual _ns1__checkTestDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkTestDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkTestDataResponse() : checkTestDataResult(), soap() { }
        virtual ~_ns1__checkTestDataResponse() { }
        /// Friend allocator used by soap_new__ns1__checkTestDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__checkTestDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:430 */
#ifndef SOAP_TYPE__ns1__checkEmpNo
#define SOAP_TYPE__ns1__checkEmpNo (105)
/* complex XSD type 'ns1:checkEmpNo': */
class SOAP_CMAC _ns1__checkEmpNo {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:Station_Name' of XSD type 'xsd:string'
        std::string *Station_USCOREName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkEmpNo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkEmpNo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkEmpNo, default initialized and not managed by a soap context
        virtual _ns1__checkEmpNo *soap_alloc(void) const { return SOAP_NEW(_ns1__checkEmpNo); }
      public:
        /// Constructor with initializations
        _ns1__checkEmpNo() : Emp_USCORENo(), Station_USCOREName(), soap() { }
        virtual ~_ns1__checkEmpNo() { }
        /// Friend allocator used by soap_new__ns1__checkEmpNo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkEmpNo * SOAP_FMAC2 soap_instantiate__ns1__checkEmpNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:433 */
#ifndef SOAP_TYPE__ns1__checkEmpNoResponse
#define SOAP_TYPE__ns1__checkEmpNoResponse (106)
/* complex XSD type 'ns1:checkEmpNoResponse': */
class SOAP_CMAC _ns1__checkEmpNoResponse {
      public:
        /// Optional element 'ns1:checkEmpNoResult' of XSD type 'xsd:string'
        std::string *checkEmpNoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkEmpNoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkEmpNoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkEmpNoResponse, default initialized and not managed by a soap context
        virtual _ns1__checkEmpNoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkEmpNoResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkEmpNoResponse() : checkEmpNoResult(), soap() { }
        virtual ~_ns1__checkEmpNoResponse() { }
        /// Friend allocator used by soap_new__ns1__checkEmpNoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkEmpNoResponse * SOAP_FMAC2 soap_instantiate__ns1__checkEmpNoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:436 */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStation
#define SOAP_TYPE__ns1__checkSN_USCOREStation (107)
/* complex XSD type 'ns1:checkSN_Station': */
class SOAP_CMAC _ns1__checkSN_USCOREStation {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station_Name' of XSD type 'xsd:string'
        std::string *Station_USCOREName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSN_USCOREStation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSN_USCOREStation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSN_USCOREStation, default initialized and not managed by a soap context
        virtual _ns1__checkSN_USCOREStation *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSN_USCOREStation); }
      public:
        /// Constructor with initializations
        _ns1__checkSN_USCOREStation() : SN(), Station_USCOREName(), soap() { }
        virtual ~_ns1__checkSN_USCOREStation() { }
        /// Friend allocator used by soap_new__ns1__checkSN_USCOREStation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSN_USCOREStation * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:439 */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStationResponse
#define SOAP_TYPE__ns1__checkSN_USCOREStationResponse (108)
/* complex XSD type 'ns1:checkSN_StationResponse': */
class SOAP_CMAC _ns1__checkSN_USCOREStationResponse {
      public:
        /// Optional element 'ns1:checkSN_StationResult' of XSD type 'xsd:string'
        std::string *checkSN_USCOREStationResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSN_USCOREStationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSN_USCOREStationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSN_USCOREStationResponse, default initialized and not managed by a soap context
        virtual _ns1__checkSN_USCOREStationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSN_USCOREStationResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkSN_USCOREStationResponse() : checkSN_USCOREStationResult(), soap() { }
        virtual ~_ns1__checkSN_USCOREStationResponse() { }
        /// Friend allocator used by soap_new__ns1__checkSN_USCOREStationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSN_USCOREStationResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:442 */
#ifndef SOAP_TYPE__ns1__sendTestData
#define SOAP_TYPE__ns1__sendTestData (109)
/* complex XSD type 'ns1:sendTestData': */
class SOAP_CMAC _ns1__sendTestData {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Optional element 'ns1:TestData' of XSD type 'xsd:string'
        std::string *TestData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendTestData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendTestData, default initialized and not managed by a soap context
        virtual _ns1__sendTestData *soap_alloc(void) const { return SOAP_NEW(_ns1__sendTestData); }
      public:
        /// Constructor with initializations
        _ns1__sendTestData() : Emp_USCORENo(), SN(), Station(), TestData(), soap() { }
        virtual ~_ns1__sendTestData() { }
        /// Friend allocator used by soap_new__ns1__sendTestData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendTestData * SOAP_FMAC2 soap_instantiate__ns1__sendTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:445 */
#ifndef SOAP_TYPE__ns1__sendTestDataResponse
#define SOAP_TYPE__ns1__sendTestDataResponse (110)
/* complex XSD type 'ns1:sendTestDataResponse': */
class SOAP_CMAC _ns1__sendTestDataResponse {
      public:
        /// Optional element 'ns1:sendTestDataResult' of XSD type 'xsd:string'
        std::string *sendTestDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendTestDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendTestDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendTestDataResponse, default initialized and not managed by a soap context
        virtual _ns1__sendTestDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__sendTestDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__sendTestDataResponse() : sendTestDataResult(), soap() { }
        virtual ~_ns1__sendTestDataResponse() { }
        /// Friend allocator used by soap_new__ns1__sendTestDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__sendTestDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:448 */
#ifndef SOAP_TYPE__ns1__sendTestResult
#define SOAP_TYPE__ns1__sendTestResult (111)
/* complex XSD type 'ns1:sendTestResult': */
class SOAP_CMAC _ns1__sendTestResult {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Optional element 'ns1:TestResult' of XSD type 'xsd:string'
        std::string *TestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendTestResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendTestResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendTestResult, default initialized and not managed by a soap context
        virtual _ns1__sendTestResult *soap_alloc(void) const { return SOAP_NEW(_ns1__sendTestResult); }
      public:
        /// Constructor with initializations
        _ns1__sendTestResult() : Emp_USCORENo(), SN(), Station(), TestResult(), soap() { }
        virtual ~_ns1__sendTestResult() { }
        /// Friend allocator used by soap_new__ns1__sendTestResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendTestResult * SOAP_FMAC2 soap_instantiate__ns1__sendTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:451 */
#ifndef SOAP_TYPE__ns1__sendTestResultResponse
#define SOAP_TYPE__ns1__sendTestResultResponse (112)
/* complex XSD type 'ns1:sendTestResultResponse': */
class SOAP_CMAC _ns1__sendTestResultResponse {
      public:
        /// Optional element 'ns1:sendTestResultResult' of XSD type 'xsd:string'
        std::string *sendTestResultResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendTestResultResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendTestResultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendTestResultResponse, default initialized and not managed by a soap context
        virtual _ns1__sendTestResultResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__sendTestResultResponse); }
      public:
        /// Constructor with initializations
        _ns1__sendTestResultResponse() : sendTestResultResult(), soap() { }
        virtual ~_ns1__sendTestResultResponse() { }
        /// Friend allocator used by soap_new__ns1__sendTestResultResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendTestResultResponse * SOAP_FMAC2 soap_instantiate__ns1__sendTestResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:454 */
#ifndef SOAP_TYPE__ns1__InFruitsOrtQty
#define SOAP_TYPE__ns1__InFruitsOrtQty (113)
/* complex XSD type 'ns1:InFruitsOrtQty': */
class SOAP_CMAC _ns1__InFruitsOrtQty {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InFruitsOrtQty
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InFruitsOrtQty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InFruitsOrtQty, default initialized and not managed by a soap context
        virtual _ns1__InFruitsOrtQty *soap_alloc(void) const { return SOAP_NEW(_ns1__InFruitsOrtQty); }
      public:
        /// Constructor with initializations
        _ns1__InFruitsOrtQty() : SN(), Station(), soap() { }
        virtual ~_ns1__InFruitsOrtQty() { }
        /// Friend allocator used by soap_new__ns1__InFruitsOrtQty(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InFruitsOrtQty * SOAP_FMAC2 soap_instantiate__ns1__InFruitsOrtQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:457 */
#ifndef SOAP_TYPE__ns1__InFruitsOrtQtyResponse
#define SOAP_TYPE__ns1__InFruitsOrtQtyResponse (114)
/* complex XSD type 'ns1:InFruitsOrtQtyResponse': */
class SOAP_CMAC _ns1__InFruitsOrtQtyResponse {
      public:
        /// Optional element 'ns1:InFruitsOrtQtyResult' of XSD type 'xsd:string'
        std::string *InFruitsOrtQtyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InFruitsOrtQtyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InFruitsOrtQtyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InFruitsOrtQtyResponse, default initialized and not managed by a soap context
        virtual _ns1__InFruitsOrtQtyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InFruitsOrtQtyResponse); }
      public:
        /// Constructor with initializations
        _ns1__InFruitsOrtQtyResponse() : InFruitsOrtQtyResult(), soap() { }
        virtual ~_ns1__InFruitsOrtQtyResponse() { }
        /// Friend allocator used by soap_new__ns1__InFruitsOrtQtyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InFruitsOrtQtyResponse * SOAP_FMAC2 soap_instantiate__ns1__InFruitsOrtQtyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:460 */
#ifndef SOAP_TYPE__ns1__chkStationTime
#define SOAP_TYPE__ns1__chkStationTime (115)
/* complex XSD type 'ns1:chkStationTime': */
class SOAP_CMAC _ns1__chkStationTime {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkStationTime
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkStationTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkStationTime, default initialized and not managed by a soap context
        virtual _ns1__chkStationTime *soap_alloc(void) const { return SOAP_NEW(_ns1__chkStationTime); }
      public:
        /// Constructor with initializations
        _ns1__chkStationTime() : SN(), Station(), soap() { }
        virtual ~_ns1__chkStationTime() { }
        /// Friend allocator used by soap_new__ns1__chkStationTime(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkStationTime * SOAP_FMAC2 soap_instantiate__ns1__chkStationTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:463 */
#ifndef SOAP_TYPE__ns1__chkStationTimeResponse
#define SOAP_TYPE__ns1__chkStationTimeResponse (116)
/* complex XSD type 'ns1:chkStationTimeResponse': */
class SOAP_CMAC _ns1__chkStationTimeResponse {
      public:
        /// Optional element 'ns1:chkStationTimeResult' of XSD type 'xsd:string'
        std::string *chkStationTimeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkStationTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkStationTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkStationTimeResponse, default initialized and not managed by a soap context
        virtual _ns1__chkStationTimeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkStationTimeResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkStationTimeResponse() : chkStationTimeResult(), soap() { }
        virtual ~_ns1__chkStationTimeResponse() { }
        /// Friend allocator used by soap_new__ns1__chkStationTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkStationTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__chkStationTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:466 */
#ifndef SOAP_TYPE__ns1__ImpMesAteTestData
#define SOAP_TYPE__ns1__ImpMesAteTestData (117)
/* complex XSD type 'ns1:ImpMesAteTestData': */
class SOAP_CMAC _ns1__ImpMesAteTestData {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:Station_Name' of XSD type 'xsd:string'
        std::string *Station_USCOREName;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:TestData' of XSD type 'xsd:string'
        std::string *TestData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ImpMesAteTestData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ImpMesAteTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ImpMesAteTestData, default initialized and not managed by a soap context
        virtual _ns1__ImpMesAteTestData *soap_alloc(void) const { return SOAP_NEW(_ns1__ImpMesAteTestData); }
      public:
        /// Constructor with initializations
        _ns1__ImpMesAteTestData() : Emp_USCORENo(), Station_USCOREName(), SN(), TestData(), soap() { }
        virtual ~_ns1__ImpMesAteTestData() { }
        /// Friend allocator used by soap_new__ns1__ImpMesAteTestData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ImpMesAteTestData * SOAP_FMAC2 soap_instantiate__ns1__ImpMesAteTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:469 */
#ifndef SOAP_TYPE__ns1__ImpMesAteTestDataResponse
#define SOAP_TYPE__ns1__ImpMesAteTestDataResponse (118)
/* complex XSD type 'ns1:ImpMesAteTestDataResponse': */
class SOAP_CMAC _ns1__ImpMesAteTestDataResponse {
      public:
        /// Optional element 'ns1:ImpMesAteTestDataResult' of XSD type 'xsd:string'
        std::string *ImpMesAteTestDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ImpMesAteTestDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ImpMesAteTestDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ImpMesAteTestDataResponse, default initialized and not managed by a soap context
        virtual _ns1__ImpMesAteTestDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ImpMesAteTestDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__ImpMesAteTestDataResponse() : ImpMesAteTestDataResult(), soap() { }
        virtual ~_ns1__ImpMesAteTestDataResponse() { }
        /// Friend allocator used by soap_new__ns1__ImpMesAteTestDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ImpMesAteTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__ImpMesAteTestDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:472 */
#ifndef SOAP_TYPE__ns1__InsFlatNess
#define SOAP_TYPE__ns1__InsFlatNess (119)
/* complex XSD type 'ns1:InsFlatNess': */
class SOAP_CMAC _ns1__InsFlatNess {
      public:
        /// Optional element 'ns1:strList' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strList;
        /// Optional element 'ns1:AxisX' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisX;
        /// Optional element 'ns1:AxisY' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisY;
        /// Optional element 'ns1:AxisZ' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisZ;
        /// Optional element 'ns1:Ftype' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Ftype;
        /// Optional element 'ns1:Flat' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Flat;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFlatNess
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFlatNess; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFlatNess, default initialized and not managed by a soap context
        virtual _ns1__InsFlatNess *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFlatNess); }
      public:
        /// Constructor with initializations
        _ns1__InsFlatNess() : strList(), AxisX(), AxisY(), AxisZ(), Ftype(), Flat(), soap() { }
        virtual ~_ns1__InsFlatNess() { }
        /// Friend allocator used by soap_new__ns1__InsFlatNess(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFlatNess * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:475 */
#ifndef SOAP_TYPE__ns1__InsFlatNessResponse
#define SOAP_TYPE__ns1__InsFlatNessResponse (120)
/* complex XSD type 'ns1:InsFlatNessResponse': */
class SOAP_CMAC _ns1__InsFlatNessResponse {
      public:
        /// Optional element 'ns1:InsFlatNessResult' of XSD type 'xsd:string'
        std::string *InsFlatNessResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFlatNessResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFlatNessResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFlatNessResponse, default initialized and not managed by a soap context
        virtual _ns1__InsFlatNessResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFlatNessResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsFlatNessResponse() : InsFlatNessResult(), soap() { }
        virtual ~_ns1__InsFlatNessResponse() { }
        /// Friend allocator used by soap_new__ns1__InsFlatNessResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFlatNessResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:478 */
#ifndef SOAP_TYPE__ns1__InsFlatNessForLSD
#define SOAP_TYPE__ns1__InsFlatNessForLSD (121)
/* complex XSD type 'ns1:InsFlatNessForLSD': */
class SOAP_CMAC _ns1__InsFlatNessForLSD {
      public:
        /// Optional element 'ns1:strList' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strList;
        /// Optional element 'ns1:AxisX' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisX;
        /// Optional element 'ns1:AxisY' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisY;
        /// Optional element 'ns1:AxisZ' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisZ;
        /// Optional element 'ns1:Ftype' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Ftype;
        /// Optional element 'ns1:Flat' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Flat;
        /// Optional element 'ns1:Dsign' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Dsign;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFlatNessForLSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFlatNessForLSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFlatNessForLSD, default initialized and not managed by a soap context
        virtual _ns1__InsFlatNessForLSD *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFlatNessForLSD); }
      public:
        /// Constructor with initializations
        _ns1__InsFlatNessForLSD() : strList(), AxisX(), AxisY(), AxisZ(), Ftype(), Flat(), Dsign(), soap() { }
        virtual ~_ns1__InsFlatNessForLSD() { }
        /// Friend allocator used by soap_new__ns1__InsFlatNessForLSD(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFlatNessForLSD * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForLSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:481 */
#ifndef SOAP_TYPE__ns1__InsFlatNessForLSDResponse
#define SOAP_TYPE__ns1__InsFlatNessForLSDResponse (122)
/* complex XSD type 'ns1:InsFlatNessForLSDResponse': */
class SOAP_CMAC _ns1__InsFlatNessForLSDResponse {
      public:
        /// Optional element 'ns1:InsFlatNessForLSDResult' of XSD type 'xsd:string'
        std::string *InsFlatNessForLSDResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFlatNessForLSDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFlatNessForLSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFlatNessForLSDResponse, default initialized and not managed by a soap context
        virtual _ns1__InsFlatNessForLSDResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFlatNessForLSDResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsFlatNessForLSDResponse() : InsFlatNessForLSDResult(), soap() { }
        virtual ~_ns1__InsFlatNessForLSDResponse() { }
        /// Friend allocator used by soap_new__ns1__InsFlatNessForLSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFlatNessForLSDResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForLSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:484 */
#ifndef SOAP_TYPE__ns1__InsFlatNessForCL
#define SOAP_TYPE__ns1__InsFlatNessForCL (123)
/* complex XSD type 'ns1:InsFlatNessForCL': */
class SOAP_CMAC _ns1__InsFlatNessForCL {
      public:
        /// Optional element 'ns1:strList' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strList;
        /// Optional element 'ns1:AxisX' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisX;
        /// Optional element 'ns1:AxisY' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisY;
        /// Optional element 'ns1:AxisZ' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *AxisZ;
        /// Optional element 'ns1:Ftype' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Ftype;
        /// Optional element 'ns1:Flat' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Flat;
        /// Optional element 'ns1:Dsign' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Dsign;
        /// Optional element 'ns1:FlatX' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *FlatX;
        /// Optional element 'ns1:FlatY' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *FlatY;
        /// Optional element 'ns1:PiontX' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *PiontX;
        /// Optional element 'ns1:PiontY' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *PiontY;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFlatNessForCL
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFlatNessForCL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFlatNessForCL, default initialized and not managed by a soap context
        virtual _ns1__InsFlatNessForCL *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFlatNessForCL); }
      public:
        /// Constructor with initializations
        _ns1__InsFlatNessForCL() : strList(), AxisX(), AxisY(), AxisZ(), Ftype(), Flat(), Dsign(), FlatX(), FlatY(), PiontX(), PiontY(), soap() { }
        virtual ~_ns1__InsFlatNessForCL() { }
        /// Friend allocator used by soap_new__ns1__InsFlatNessForCL(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFlatNessForCL * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForCL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:487 */
#ifndef SOAP_TYPE__ns1__InsFlatNessForCLResponse
#define SOAP_TYPE__ns1__InsFlatNessForCLResponse (124)
/* complex XSD type 'ns1:InsFlatNessForCLResponse': */
class SOAP_CMAC _ns1__InsFlatNessForCLResponse {
      public:
        /// Optional element 'ns1:InsFlatNessForCLResult' of XSD type 'xsd:string'
        std::string *InsFlatNessForCLResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsFlatNessForCLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsFlatNessForCLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsFlatNessForCLResponse, default initialized and not managed by a soap context
        virtual _ns1__InsFlatNessForCLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsFlatNessForCLResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsFlatNessForCLResponse() : InsFlatNessForCLResult(), soap() { }
        virtual ~_ns1__InsFlatNessForCLResponse() { }
        /// Friend allocator used by soap_new__ns1__InsFlatNessForCLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsFlatNessForCLResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForCLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:490 */
#ifndef SOAP_TYPE__ns1__InsWHDetection
#define SOAP_TYPE__ns1__InsWHDetection (125)
/* complex XSD type 'ns1:InsWHDetection': */
class SOAP_CMAC _ns1__InsWHDetection {
      public:
        /// Optional element 'ns1:Wh' of XSD type 'xsd:string'
        std::string *Wh;
        /// Optional element 'ns1:Hole' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Hole;
        /// Optional element 'ns1:DateTime' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *DateTime;
        /// Optional element 'ns1:Temp' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Temp;
        /// Optional element 'ns1:Humidity' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *Humidity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsWHDetection
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsWHDetection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsWHDetection, default initialized and not managed by a soap context
        virtual _ns1__InsWHDetection *soap_alloc(void) const { return SOAP_NEW(_ns1__InsWHDetection); }
      public:
        /// Constructor with initializations
        _ns1__InsWHDetection() : Wh(), Hole(), DateTime(), Temp(), Humidity(), soap() { }
        virtual ~_ns1__InsWHDetection() { }
        /// Friend allocator used by soap_new__ns1__InsWHDetection(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsWHDetection * SOAP_FMAC2 soap_instantiate__ns1__InsWHDetection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:493 */
#ifndef SOAP_TYPE__ns1__InsWHDetectionResponse
#define SOAP_TYPE__ns1__InsWHDetectionResponse (126)
/* complex XSD type 'ns1:InsWHDetectionResponse': */
class SOAP_CMAC _ns1__InsWHDetectionResponse {
      public:
        /// Optional element 'ns1:InsWHDetectionResult' of XSD type 'xsd:string'
        std::string *InsWHDetectionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsWHDetectionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsWHDetectionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsWHDetectionResponse, default initialized and not managed by a soap context
        virtual _ns1__InsWHDetectionResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsWHDetectionResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsWHDetectionResponse() : InsWHDetectionResult(), soap() { }
        virtual ~_ns1__InsWHDetectionResponse() { }
        /// Friend allocator used by soap_new__ns1__InsWHDetectionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsWHDetectionResponse * SOAP_FMAC2 soap_instantiate__ns1__InsWHDetectionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:496 */
#ifndef SOAP_TYPE__ns1__InsThermal
#define SOAP_TYPE__ns1__InsThermal (127)
/* complex XSD type 'ns1:InsThermal': */
class SOAP_CMAC _ns1__InsThermal {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:TestDt' of XSD type 'xsd:string'
        std::string *TestDt;
        /// Optional element 'ns1:Hole' of XSD type 'xsd:string'
        std::string *Hole;
        /// Optional element 'ns1:User' of XSD type 'xsd:string'
        std::string *User;
        /// Optional element 'ns1:Result' of XSD type 'xsd:string'
        std::string *Result;
        /// Optional element 'ns1:strTemp' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strTemp;
        /// Optional element 'ns1:strErature' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strErature;
        /// Optional element 'ns1:strResult' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsThermal
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsThermal; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsThermal, default initialized and not managed by a soap context
        virtual _ns1__InsThermal *soap_alloc(void) const { return SOAP_NEW(_ns1__InsThermal); }
      public:
        /// Constructor with initializations
        _ns1__InsThermal() : SN(), TestDt(), Hole(), User(), Result(), strTemp(), strErature(), strResult(), soap() { }
        virtual ~_ns1__InsThermal() { }
        /// Friend allocator used by soap_new__ns1__InsThermal(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsThermal * SOAP_FMAC2 soap_instantiate__ns1__InsThermal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:499 */
#ifndef SOAP_TYPE__ns1__InsThermalResponse
#define SOAP_TYPE__ns1__InsThermalResponse (128)
/* complex XSD type 'ns1:InsThermalResponse': */
class SOAP_CMAC _ns1__InsThermalResponse {
      public:
        /// Optional element 'ns1:InsThermalResult' of XSD type 'xsd:string'
        std::string *InsThermalResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsThermalResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsThermalResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsThermalResponse, default initialized and not managed by a soap context
        virtual _ns1__InsThermalResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsThermalResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsThermalResponse() : InsThermalResult(), soap() { }
        virtual ~_ns1__InsThermalResponse() { }
        /// Friend allocator used by soap_new__ns1__InsThermalResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsThermalResponse * SOAP_FMAC2 soap_instantiate__ns1__InsThermalResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:502 */
#ifndef SOAP_TYPE__ns1__ChkSnLink
#define SOAP_TYPE__ns1__ChkSnLink (129)
/* complex XSD type 'ns1:ChkSnLink': */
class SOAP_CMAC _ns1__ChkSnLink {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:LinkSN' of XSD type 'xsd:string'
        std::string *LinkSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnLink
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnLink, default initialized and not managed by a soap context
        virtual _ns1__ChkSnLink *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnLink); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnLink() : SN(), LinkSN(), soap() { }
        virtual ~_ns1__ChkSnLink() { }
        /// Friend allocator used by soap_new__ns1__ChkSnLink(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnLink * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:505 */
#ifndef SOAP_TYPE__ns1__ChkSnLinkResponse
#define SOAP_TYPE__ns1__ChkSnLinkResponse (130)
/* complex XSD type 'ns1:ChkSnLinkResponse': */
class SOAP_CMAC _ns1__ChkSnLinkResponse {
      public:
        /// Optional element 'ns1:ChkSnLinkResult' of XSD type 'xsd:string'
        std::string *ChkSnLinkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnLinkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnLinkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnLinkResponse, default initialized and not managed by a soap context
        virtual _ns1__ChkSnLinkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnLinkResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnLinkResponse() : ChkSnLinkResult(), soap() { }
        virtual ~_ns1__ChkSnLinkResponse() { }
        /// Friend allocator used by soap_new__ns1__ChkSnLinkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLinkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:508 */
#ifndef SOAP_TYPE__ns1__InsThermalNew
#define SOAP_TYPE__ns1__InsThermalNew (131)
/* complex XSD type 'ns1:InsThermalNew': */
class SOAP_CMAC _ns1__InsThermalNew {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:LinkSN' of XSD type 'xsd:string'
        std::string *LinkSN;
        /// Optional element 'ns1:TestDt' of XSD type 'xsd:string'
        std::string *TestDt;
        /// Optional element 'ns1:Hole' of XSD type 'xsd:string'
        std::string *Hole;
        /// Optional element 'ns1:User' of XSD type 'xsd:string'
        std::string *User;
        /// Optional element 'ns1:Result' of XSD type 'xsd:string'
        std::string *Result;
        /// Optional element 'ns1:strTemp' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strTemp;
        /// Optional element 'ns1:strErature' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strErature;
        /// Optional element 'ns1:strResult' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsThermalNew
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsThermalNew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsThermalNew, default initialized and not managed by a soap context
        virtual _ns1__InsThermalNew *soap_alloc(void) const { return SOAP_NEW(_ns1__InsThermalNew); }
      public:
        /// Constructor with initializations
        _ns1__InsThermalNew() : SN(), LinkSN(), TestDt(), Hole(), User(), Result(), strTemp(), strErature(), strResult(), soap() { }
        virtual ~_ns1__InsThermalNew() { }
        /// Friend allocator used by soap_new__ns1__InsThermalNew(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsThermalNew * SOAP_FMAC2 soap_instantiate__ns1__InsThermalNew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:511 */
#ifndef SOAP_TYPE__ns1__InsThermalNewResponse
#define SOAP_TYPE__ns1__InsThermalNewResponse (132)
/* complex XSD type 'ns1:InsThermalNewResponse': */
class SOAP_CMAC _ns1__InsThermalNewResponse {
      public:
        /// Optional element 'ns1:InsThermalNewResult' of XSD type 'xsd:string'
        std::string *InsThermalNewResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsThermalNewResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsThermalNewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsThermalNewResponse, default initialized and not managed by a soap context
        virtual _ns1__InsThermalNewResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsThermalNewResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsThermalNewResponse() : InsThermalNewResult(), soap() { }
        virtual ~_ns1__InsThermalNewResponse() { }
        /// Friend allocator used by soap_new__ns1__InsThermalNewResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsThermalNewResponse * SOAP_FMAC2 soap_instantiate__ns1__InsThermalNewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:514 */
#ifndef SOAP_TYPE__ns1__getInfoByMo
#define SOAP_TYPE__ns1__getInfoByMo (133)
/* complex XSD type 'ns1:getInfoByMo': */
class SOAP_CMAC _ns1__getInfoByMo {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getInfoByMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getInfoByMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getInfoByMo, default initialized and not managed by a soap context
        virtual _ns1__getInfoByMo *soap_alloc(void) const { return SOAP_NEW(_ns1__getInfoByMo); }
      public:
        /// Constructor with initializations
        _ns1__getInfoByMo() : MoNumber(), soap() { }
        virtual ~_ns1__getInfoByMo() { }
        /// Friend allocator used by soap_new__ns1__getInfoByMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getInfoByMo * SOAP_FMAC2 soap_instantiate__ns1__getInfoByMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:4031 */
#ifndef SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult
#define SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult (295)
/* complex XSD type 'ns1:getInfoByMoResponse-getInfoByMoResult': */
class SOAP_CMAC _ns1__getInfoByMoResponse_getInfoByMoResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getInfoByMoResponse_getInfoByMoResult, default initialized and not managed by a soap context
        virtual _ns1__getInfoByMoResponse_getInfoByMoResult *soap_alloc(void) const { return SOAP_NEW(_ns1__getInfoByMoResponse_getInfoByMoResult); }
      public:
        /// Constructor with initializations
        _ns1__getInfoByMoResponse_getInfoByMoResult() : __any(), __any_() { }
        virtual ~_ns1__getInfoByMoResponse_getInfoByMoResult() { }
        /// Friend allocator used by soap_new__ns1__getInfoByMoResponse_getInfoByMoResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getInfoByMoResponse_getInfoByMoResult * SOAP_FMAC2 soap_instantiate__ns1__getInfoByMoResponse_getInfoByMoResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:517 */
#ifndef SOAP_TYPE__ns1__getInfoByMoResponse
#define SOAP_TYPE__ns1__getInfoByMoResponse (134)
/* complex XSD type 'ns1:getInfoByMoResponse': */
class SOAP_CMAC _ns1__getInfoByMoResponse {
      public:
        /// Optional element 'ns1:getInfoByMoResult' of XSD type 'ns1:getInfoByMoResponse-getInfoByMoResult'
        _ns1__getInfoByMoResponse_getInfoByMoResult *getInfoByMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getInfoByMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getInfoByMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getInfoByMoResponse, default initialized and not managed by a soap context
        virtual _ns1__getInfoByMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getInfoByMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__getInfoByMoResponse() : getInfoByMoResult(), soap() { }
        virtual ~_ns1__getInfoByMoResponse() { }
        /// Friend allocator used by soap_new__ns1__getInfoByMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getInfoByMoResponse * SOAP_FMAC2 soap_instantiate__ns1__getInfoByMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:520 */
#ifndef SOAP_TYPE__ns1__SetEnergyStat
#define SOAP_TYPE__ns1__SetEnergyStat (135)
/* complex XSD type 'ns1:SetEnergyStat': */
class SOAP_CMAC _ns1__SetEnergyStat {
      public:
        /// Optional element 'ns1:DateKey' of XSD type 'xsd:string'
        std::string *DateKey;
        /// Optional element 'ns1:strPower' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strPower;
        /// Optional element 'ns1:strEnergy' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *strEnergy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetEnergyStat
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetEnergyStat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetEnergyStat, default initialized and not managed by a soap context
        virtual _ns1__SetEnergyStat *soap_alloc(void) const { return SOAP_NEW(_ns1__SetEnergyStat); }
      public:
        /// Constructor with initializations
        _ns1__SetEnergyStat() : DateKey(), strPower(), strEnergy(), soap() { }
        virtual ~_ns1__SetEnergyStat() { }
        /// Friend allocator used by soap_new__ns1__SetEnergyStat(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetEnergyStat * SOAP_FMAC2 soap_instantiate__ns1__SetEnergyStat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:523 */
#ifndef SOAP_TYPE__ns1__SetEnergyStatResponse
#define SOAP_TYPE__ns1__SetEnergyStatResponse (136)
/* complex XSD type 'ns1:SetEnergyStatResponse': */
class SOAP_CMAC _ns1__SetEnergyStatResponse {
      public:
        /// Optional element 'ns1:SetEnergyStatResult' of XSD type 'xsd:string'
        std::string *SetEnergyStatResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetEnergyStatResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetEnergyStatResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetEnergyStatResponse, default initialized and not managed by a soap context
        virtual _ns1__SetEnergyStatResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetEnergyStatResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetEnergyStatResponse() : SetEnergyStatResult(), soap() { }
        virtual ~_ns1__SetEnergyStatResponse() { }
        /// Friend allocator used by soap_new__ns1__SetEnergyStatResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetEnergyStatResponse * SOAP_FMAC2 soap_instantiate__ns1__SetEnergyStatResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:526 */
#ifndef SOAP_TYPE__ns1__chkMoStation
#define SOAP_TYPE__ns1__chkMoStation (137)
/* complex XSD type 'ns1:chkMoStation': */
class SOAP_CMAC _ns1__chkMoStation {
      public:
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkMoStation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkMoStation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkMoStation, default initialized and not managed by a soap context
        virtual _ns1__chkMoStation *soap_alloc(void) const { return SOAP_NEW(_ns1__chkMoStation); }
      public:
        /// Constructor with initializations
        _ns1__chkMoStation() : MO(), StationNumber(), soap() { }
        virtual ~_ns1__chkMoStation() { }
        /// Friend allocator used by soap_new__ns1__chkMoStation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkMoStation * SOAP_FMAC2 soap_instantiate__ns1__chkMoStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:529 */
#ifndef SOAP_TYPE__ns1__chkMoStationResponse
#define SOAP_TYPE__ns1__chkMoStationResponse (138)
/* complex XSD type 'ns1:chkMoStationResponse': */
class SOAP_CMAC _ns1__chkMoStationResponse {
      public:
        /// Optional element 'ns1:chkMoStationResult' of XSD type 'xsd:string'
        std::string *chkMoStationResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkMoStationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkMoStationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkMoStationResponse, default initialized and not managed by a soap context
        virtual _ns1__chkMoStationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkMoStationResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkMoStationResponse() : chkMoStationResult(), soap() { }
        virtual ~_ns1__chkMoStationResponse() { }
        /// Friend allocator used by soap_new__ns1__chkMoStationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkMoStationResponse * SOAP_FMAC2 soap_instantiate__ns1__chkMoStationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:532 */
#ifndef SOAP_TYPE__ns1__ChkSnMo
#define SOAP_TYPE__ns1__ChkSnMo (139)
/* complex XSD type 'ns1:ChkSnMo': */
class SOAP_CMAC _ns1__ChkSnMo {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Optional element 'ns1:STATION_NUMBER' of XSD type 'xsd:string'
        std::string *STATION_USCORENUMBER;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnMo, default initialized and not managed by a soap context
        virtual _ns1__ChkSnMo *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnMo); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnMo() : SN(), MO(), STATION_USCORENUMBER(), soap() { }
        virtual ~_ns1__ChkSnMo() { }
        /// Friend allocator used by soap_new__ns1__ChkSnMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnMo * SOAP_FMAC2 soap_instantiate__ns1__ChkSnMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:535 */
#ifndef SOAP_TYPE__ns1__ChkSnMoResponse
#define SOAP_TYPE__ns1__ChkSnMoResponse (140)
/* complex XSD type 'ns1:ChkSnMoResponse': */
class SOAP_CMAC _ns1__ChkSnMoResponse {
      public:
        /// Optional element 'ns1:ChkSnMoResult' of XSD type 'xsd:string'
        std::string *ChkSnMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnMoResponse, default initialized and not managed by a soap context
        virtual _ns1__ChkSnMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnMoResponse() : ChkSnMoResult(), soap() { }
        virtual ~_ns1__ChkSnMoResponse() { }
        /// Friend allocator used by soap_new__ns1__ChkSnMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnMoResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:538 */
#ifndef SOAP_TYPE__ns1__ChkSnNextMo
#define SOAP_TYPE__ns1__ChkSnNextMo (141)
/* complex XSD type 'ns1:ChkSnNextMo': */
class SOAP_CMAC _ns1__ChkSnNextMo {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Optional element 'ns1:STATION_NUMBER' of XSD type 'xsd:string'
        std::string *STATION_USCORENUMBER;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnNextMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnNextMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnNextMo, default initialized and not managed by a soap context
        virtual _ns1__ChkSnNextMo *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnNextMo); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnNextMo() : SN(), MO(), STATION_USCORENUMBER(), soap() { }
        virtual ~_ns1__ChkSnNextMo() { }
        /// Friend allocator used by soap_new__ns1__ChkSnNextMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnNextMo * SOAP_FMAC2 soap_instantiate__ns1__ChkSnNextMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:541 */
#ifndef SOAP_TYPE__ns1__ChkSnNextMoResponse
#define SOAP_TYPE__ns1__ChkSnNextMoResponse (142)
/* complex XSD type 'ns1:ChkSnNextMoResponse': */
class SOAP_CMAC _ns1__ChkSnNextMoResponse {
      public:
        /// Optional element 'ns1:ChkSnNextMoResult' of XSD type 'xsd:string'
        std::string *ChkSnNextMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkSnNextMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkSnNextMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkSnNextMoResponse, default initialized and not managed by a soap context
        virtual _ns1__ChkSnNextMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkSnNextMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChkSnNextMoResponse() : ChkSnNextMoResult(), soap() { }
        virtual ~_ns1__ChkSnNextMoResponse() { }
        /// Friend allocator used by soap_new__ns1__ChkSnNextMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkSnNextMoResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnNextMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:544 */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStationNumber
#define SOAP_TYPE__ns1__checkSN_USCOREStationNumber (143)
/* complex XSD type 'ns1:checkSN_StationNumber': */
class SOAP_CMAC _ns1__checkSN_USCOREStationNumber {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station_Number' of XSD type 'xsd:string'
        std::string *Station_USCORENumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSN_USCOREStationNumber
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSN_USCOREStationNumber; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSN_USCOREStationNumber, default initialized and not managed by a soap context
        virtual _ns1__checkSN_USCOREStationNumber *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSN_USCOREStationNumber); }
      public:
        /// Constructor with initializations
        _ns1__checkSN_USCOREStationNumber() : SN(), Station_USCORENumber(), soap() { }
        virtual ~_ns1__checkSN_USCOREStationNumber() { }
        /// Friend allocator used by soap_new__ns1__checkSN_USCOREStationNumber(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSN_USCOREStationNumber * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:547 */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse
#define SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse (144)
/* complex XSD type 'ns1:checkSN_StationNumberResponse': */
class SOAP_CMAC _ns1__checkSN_USCOREStationNumberResponse {
      public:
        /// Optional element 'ns1:checkSN_StationNumberResult' of XSD type 'xsd:string'
        std::string *checkSN_USCOREStationNumberResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSN_USCOREStationNumberResponse, default initialized and not managed by a soap context
        virtual _ns1__checkSN_USCOREStationNumberResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSN_USCOREStationNumberResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkSN_USCOREStationNumberResponse() : checkSN_USCOREStationNumberResult(), soap() { }
        virtual ~_ns1__checkSN_USCOREStationNumberResponse() { }
        /// Friend allocator used by soap_new__ns1__checkSN_USCOREStationNumberResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSN_USCOREStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStationNumberResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:550 */
#ifndef SOAP_TYPE__ns1__checkEmpForStationNumber
#define SOAP_TYPE__ns1__checkEmpForStationNumber (145)
/* complex XSD type 'ns1:checkEmpForStationNumber': */
class SOAP_CMAC _ns1__checkEmpForStationNumber {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:Station_Number' of XSD type 'xsd:string'
        std::string *Station_USCORENumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkEmpForStationNumber
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkEmpForStationNumber; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkEmpForStationNumber, default initialized and not managed by a soap context
        virtual _ns1__checkEmpForStationNumber *soap_alloc(void) const { return SOAP_NEW(_ns1__checkEmpForStationNumber); }
      public:
        /// Constructor with initializations
        _ns1__checkEmpForStationNumber() : Emp_USCORENo(), Station_USCORENumber(), soap() { }
        virtual ~_ns1__checkEmpForStationNumber() { }
        /// Friend allocator used by soap_new__ns1__checkEmpForStationNumber(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkEmpForStationNumber * SOAP_FMAC2 soap_instantiate__ns1__checkEmpForStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:553 */
#ifndef SOAP_TYPE__ns1__checkEmpForStationNumberResponse
#define SOAP_TYPE__ns1__checkEmpForStationNumberResponse (146)
/* complex XSD type 'ns1:checkEmpForStationNumberResponse': */
class SOAP_CMAC _ns1__checkEmpForStationNumberResponse {
      public:
        /// Optional element 'ns1:checkEmpForStationNumberResult' of XSD type 'xsd:string'
        std::string *checkEmpForStationNumberResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkEmpForStationNumberResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkEmpForStationNumberResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkEmpForStationNumberResponse, default initialized and not managed by a soap context
        virtual _ns1__checkEmpForStationNumberResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkEmpForStationNumberResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkEmpForStationNumberResponse() : checkEmpForStationNumberResult(), soap() { }
        virtual ~_ns1__checkEmpForStationNumberResponse() { }
        /// Friend allocator used by soap_new__ns1__checkEmpForStationNumberResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkEmpForStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__checkEmpForStationNumberResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:556 */
#ifndef SOAP_TYPE__ns1__sendDataForStationNumber
#define SOAP_TYPE__ns1__sendDataForStationNumber (147)
/* complex XSD type 'ns1:sendDataForStationNumber': */
class SOAP_CMAC _ns1__sendDataForStationNumber {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station_Number' of XSD type 'xsd:string'
        std::string *Station_USCORENumber;
        /// Optional element 'ns1:TestData' of XSD type 'xsd:string'
        std::string *TestData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendDataForStationNumber
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendDataForStationNumber; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendDataForStationNumber, default initialized and not managed by a soap context
        virtual _ns1__sendDataForStationNumber *soap_alloc(void) const { return SOAP_NEW(_ns1__sendDataForStationNumber); }
      public:
        /// Constructor with initializations
        _ns1__sendDataForStationNumber() : Emp_USCORENo(), SN(), Station_USCORENumber(), TestData(), soap() { }
        virtual ~_ns1__sendDataForStationNumber() { }
        /// Friend allocator used by soap_new__ns1__sendDataForStationNumber(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendDataForStationNumber * SOAP_FMAC2 soap_instantiate__ns1__sendDataForStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:559 */
#ifndef SOAP_TYPE__ns1__sendDataForStationNumberResponse
#define SOAP_TYPE__ns1__sendDataForStationNumberResponse (148)
/* complex XSD type 'ns1:sendDataForStationNumberResponse': */
class SOAP_CMAC _ns1__sendDataForStationNumberResponse {
      public:
        /// Optional element 'ns1:sendDataForStationNumberResult' of XSD type 'xsd:string'
        std::string *sendDataForStationNumberResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendDataForStationNumberResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendDataForStationNumberResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendDataForStationNumberResponse, default initialized and not managed by a soap context
        virtual _ns1__sendDataForStationNumberResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__sendDataForStationNumberResponse); }
      public:
        /// Constructor with initializations
        _ns1__sendDataForStationNumberResponse() : sendDataForStationNumberResult(), soap() { }
        virtual ~_ns1__sendDataForStationNumberResponse() { }
        /// Friend allocator used by soap_new__ns1__sendDataForStationNumberResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendDataForStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__sendDataForStationNumberResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:562 */
#ifndef SOAP_TYPE__ns1__sendResultForStationNumber
#define SOAP_TYPE__ns1__sendResultForStationNumber (149)
/* complex XSD type 'ns1:sendResultForStationNumber': */
class SOAP_CMAC _ns1__sendResultForStationNumber {
      public:
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station_Number' of XSD type 'xsd:string'
        std::string *Station_USCORENumber;
        /// Optional element 'ns1:TestResult' of XSD type 'xsd:string'
        std::string *TestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendResultForStationNumber
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendResultForStationNumber; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendResultForStationNumber, default initialized and not managed by a soap context
        virtual _ns1__sendResultForStationNumber *soap_alloc(void) const { return SOAP_NEW(_ns1__sendResultForStationNumber); }
      public:
        /// Constructor with initializations
        _ns1__sendResultForStationNumber() : Emp_USCORENo(), SN(), Station_USCORENumber(), TestResult(), soap() { }
        virtual ~_ns1__sendResultForStationNumber() { }
        /// Friend allocator used by soap_new__ns1__sendResultForStationNumber(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendResultForStationNumber * SOAP_FMAC2 soap_instantiate__ns1__sendResultForStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:565 */
#ifndef SOAP_TYPE__ns1__sendResultForStationNumberResponse
#define SOAP_TYPE__ns1__sendResultForStationNumberResponse (150)
/* complex XSD type 'ns1:sendResultForStationNumberResponse': */
class SOAP_CMAC _ns1__sendResultForStationNumberResponse {
      public:
        /// Optional element 'ns1:sendResultForStationNumberResult' of XSD type 'xsd:string'
        std::string *sendResultForStationNumberResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__sendResultForStationNumberResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__sendResultForStationNumberResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__sendResultForStationNumberResponse, default initialized and not managed by a soap context
        virtual _ns1__sendResultForStationNumberResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__sendResultForStationNumberResponse); }
      public:
        /// Constructor with initializations
        _ns1__sendResultForStationNumberResponse() : sendResultForStationNumberResult(), soap() { }
        virtual ~_ns1__sendResultForStationNumberResponse() { }
        /// Friend allocator used by soap_new__ns1__sendResultForStationNumberResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__sendResultForStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__sendResultForStationNumberResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:568 */
#ifndef SOAP_TYPE__ns1__eMesNextMo
#define SOAP_TYPE__ns1__eMesNextMo (151)
/* complex XSD type 'ns1:eMesNextMo': */
class SOAP_CMAC _ns1__eMesNextMo {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:STATION_NUMBER' of XSD type 'xsd:string'
        std::string *STATION_USCORENUMBER;
        /// Optional element 'ns1:USER_NO' of XSD type 'xsd:string'
        std::string *USER_USCORENO;
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__eMesNextMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__eMesNextMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__eMesNextMo, default initialized and not managed by a soap context
        virtual _ns1__eMesNextMo *soap_alloc(void) const { return SOAP_NEW(_ns1__eMesNextMo); }
      public:
        /// Constructor with initializations
        _ns1__eMesNextMo() : SN(), STATION_USCORENUMBER(), USER_USCORENO(), MO(), soap() { }
        virtual ~_ns1__eMesNextMo() { }
        /// Friend allocator used by soap_new__ns1__eMesNextMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__eMesNextMo * SOAP_FMAC2 soap_instantiate__ns1__eMesNextMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:571 */
#ifndef SOAP_TYPE__ns1__eMesNextMoResponse
#define SOAP_TYPE__ns1__eMesNextMoResponse (152)
/* complex XSD type 'ns1:eMesNextMoResponse': */
class SOAP_CMAC _ns1__eMesNextMoResponse {
      public:
        /// Optional element 'ns1:eMesNextMoResult' of XSD type 'xsd:string'
        std::string *eMesNextMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__eMesNextMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__eMesNextMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__eMesNextMoResponse, default initialized and not managed by a soap context
        virtual _ns1__eMesNextMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__eMesNextMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__eMesNextMoResponse() : eMesNextMoResult(), soap() { }
        virtual ~_ns1__eMesNextMoResponse() { }
        /// Friend allocator used by soap_new__ns1__eMesNextMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__eMesNextMoResponse * SOAP_FMAC2 soap_instantiate__ns1__eMesNextMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:574 */
#ifndef SOAP_TYPE__ns1__SnDoMapping
#define SOAP_TYPE__ns1__SnDoMapping (153)
/* complex XSD type 'ns1:SnDoMapping': */
class SOAP_CMAC _ns1__SnDoMapping {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:CustSN' of XSD type 'xsd:string'
        std::string *CustSN;
        /// Optional element 'ns1:Emp_No' of XSD type 'xsd:string'
        std::string *Emp_USCORENo;
        /// Optional element 'ns1:Station_Number' of XSD type 'xsd:string'
        std::string *Station_USCORENumber;
        /// Optional element 'ns1:LnkType' of XSD type 'xsd:string'
        std::string *LnkType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnDoMapping
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnDoMapping; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnDoMapping, default initialized and not managed by a soap context
        virtual _ns1__SnDoMapping *soap_alloc(void) const { return SOAP_NEW(_ns1__SnDoMapping); }
      public:
        /// Constructor with initializations
        _ns1__SnDoMapping() : SN(), CustSN(), Emp_USCORENo(), Station_USCORENumber(), LnkType(), soap() { }
        virtual ~_ns1__SnDoMapping() { }
        /// Friend allocator used by soap_new__ns1__SnDoMapping(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnDoMapping * SOAP_FMAC2 soap_instantiate__ns1__SnDoMapping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:577 */
#ifndef SOAP_TYPE__ns1__SnDoMappingResponse
#define SOAP_TYPE__ns1__SnDoMappingResponse (154)
/* complex XSD type 'ns1:SnDoMappingResponse': */
class SOAP_CMAC _ns1__SnDoMappingResponse {
      public:
        /// Optional element 'ns1:SnDoMappingResult' of XSD type 'xsd:string'
        std::string *SnDoMappingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnDoMappingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnDoMappingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnDoMappingResponse, default initialized and not managed by a soap context
        virtual _ns1__SnDoMappingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SnDoMappingResponse); }
      public:
        /// Constructor with initializations
        _ns1__SnDoMappingResponse() : SnDoMappingResult(), soap() { }
        virtual ~_ns1__SnDoMappingResponse() { }
        /// Friend allocator used by soap_new__ns1__SnDoMappingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnDoMappingResponse * SOAP_FMAC2 soap_instantiate__ns1__SnDoMappingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:580 */
#ifndef SOAP_TYPE__ns1__getStationByMo
#define SOAP_TYPE__ns1__getStationByMo (155)
/* complex XSD type 'ns1:getStationByMo': */
class SOAP_CMAC _ns1__getStationByMo {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getStationByMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getStationByMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getStationByMo, default initialized and not managed by a soap context
        virtual _ns1__getStationByMo *soap_alloc(void) const { return SOAP_NEW(_ns1__getStationByMo); }
      public:
        /// Constructor with initializations
        _ns1__getStationByMo() : MoNumber(), soap() { }
        virtual ~_ns1__getStationByMo() { }
        /// Friend allocator used by soap_new__ns1__getStationByMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getStationByMo * SOAP_FMAC2 soap_instantiate__ns1__getStationByMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:583 */
#ifndef SOAP_TYPE__ns1__getStationByMoResponse
#define SOAP_TYPE__ns1__getStationByMoResponse (156)
/* complex XSD type 'ns1:getStationByMoResponse': */
class SOAP_CMAC _ns1__getStationByMoResponse {
      public:
        /// Optional element 'ns1:getStationByMoResult' of XSD type 'xsd:string'
        std::string *getStationByMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getStationByMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getStationByMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getStationByMoResponse, default initialized and not managed by a soap context
        virtual _ns1__getStationByMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getStationByMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__getStationByMoResponse() : getStationByMoResult(), soap() { }
        virtual ~_ns1__getStationByMoResponse() { }
        /// Friend allocator used by soap_new__ns1__getStationByMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getStationByMoResponse * SOAP_FMAC2 soap_instantiate__ns1__getStationByMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:586 */
#ifndef SOAP_TYPE__ns1__getStationTypeDesc
#define SOAP_TYPE__ns1__getStationTypeDesc (157)
/* complex XSD type 'ns1:getStationTypeDesc': */
class SOAP_CMAC _ns1__getStationTypeDesc {
      public:
        /// Optional element 'ns1:typeID' of XSD type 'xsd:string'
        std::string *typeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getStationTypeDesc
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getStationTypeDesc; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getStationTypeDesc, default initialized and not managed by a soap context
        virtual _ns1__getStationTypeDesc *soap_alloc(void) const { return SOAP_NEW(_ns1__getStationTypeDesc); }
      public:
        /// Constructor with initializations
        _ns1__getStationTypeDesc() : typeID(), soap() { }
        virtual ~_ns1__getStationTypeDesc() { }
        /// Friend allocator used by soap_new__ns1__getStationTypeDesc(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getStationTypeDesc * SOAP_FMAC2 soap_instantiate__ns1__getStationTypeDesc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:589 */
#ifndef SOAP_TYPE__ns1__getStationTypeDescResponse
#define SOAP_TYPE__ns1__getStationTypeDescResponse (158)
/* complex XSD type 'ns1:getStationTypeDescResponse': */
class SOAP_CMAC _ns1__getStationTypeDescResponse {
      public:
        /// Optional element 'ns1:getStationTypeDescResult' of XSD type 'xsd:string'
        std::string *getStationTypeDescResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getStationTypeDescResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getStationTypeDescResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getStationTypeDescResponse, default initialized and not managed by a soap context
        virtual _ns1__getStationTypeDescResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getStationTypeDescResponse); }
      public:
        /// Constructor with initializations
        _ns1__getStationTypeDescResponse() : getStationTypeDescResult(), soap() { }
        virtual ~_ns1__getStationTypeDescResponse() { }
        /// Friend allocator used by soap_new__ns1__getStationTypeDescResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getStationTypeDescResponse * SOAP_FMAC2 soap_instantiate__ns1__getStationTypeDescResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:592 */
#ifndef SOAP_TYPE__ns1__chkSnMapping
#define SOAP_TYPE__ns1__chkSnMapping (159)
/* complex XSD type 'ns1:chkSnMapping': */
class SOAP_CMAC _ns1__chkSnMapping {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:CustSN' of XSD type 'xsd:string'
        std::string *CustSN;
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkSnMapping
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkSnMapping; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkSnMapping, default initialized and not managed by a soap context
        virtual _ns1__chkSnMapping *soap_alloc(void) const { return SOAP_NEW(_ns1__chkSnMapping); }
      public:
        /// Constructor with initializations
        _ns1__chkSnMapping() : SN(), CustSN(), MO(), soap() { }
        virtual ~_ns1__chkSnMapping() { }
        /// Friend allocator used by soap_new__ns1__chkSnMapping(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkSnMapping * SOAP_FMAC2 soap_instantiate__ns1__chkSnMapping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:595 */
#ifndef SOAP_TYPE__ns1__chkSnMappingResponse
#define SOAP_TYPE__ns1__chkSnMappingResponse (160)
/* complex XSD type 'ns1:chkSnMappingResponse': */
class SOAP_CMAC _ns1__chkSnMappingResponse {
      public:
        /// Optional element 'ns1:chkSnMappingResult' of XSD type 'xsd:string'
        std::string *chkSnMappingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkSnMappingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkSnMappingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkSnMappingResponse, default initialized and not managed by a soap context
        virtual _ns1__chkSnMappingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkSnMappingResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkSnMappingResponse() : chkSnMappingResult(), soap() { }
        virtual ~_ns1__chkSnMappingResponse() { }
        /// Friend allocator used by soap_new__ns1__chkSnMappingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkSnMappingResponse * SOAP_FMAC2 soap_instantiate__ns1__chkSnMappingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:598 */
#ifndef SOAP_TYPE__ns1__getMoAssyList
#define SOAP_TYPE__ns1__getMoAssyList (161)
/* complex XSD type 'ns1:getMoAssyList': */
class SOAP_CMAC _ns1__getMoAssyList {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:StationType' of XSD type 'xsd:string'
        std::string *StationType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoAssyList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoAssyList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoAssyList, default initialized and not managed by a soap context
        virtual _ns1__getMoAssyList *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoAssyList); }
      public:
        /// Constructor with initializations
        _ns1__getMoAssyList() : MoNumber(), StationNumber(), StationType(), soap() { }
        virtual ~_ns1__getMoAssyList() { }
        /// Friend allocator used by soap_new__ns1__getMoAssyList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoAssyList * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:4697 */
#ifndef SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult
#define SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult (297)
/* complex XSD type 'ns1:getMoAssyListResponse-getMoAssyListResult': */
class SOAP_CMAC _ns1__getMoAssyListResponse_getMoAssyListResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoAssyListResponse_getMoAssyListResult, default initialized and not managed by a soap context
        virtual _ns1__getMoAssyListResponse_getMoAssyListResult *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoAssyListResponse_getMoAssyListResult); }
      public:
        /// Constructor with initializations
        _ns1__getMoAssyListResponse_getMoAssyListResult() : __any(), __any_() { }
        virtual ~_ns1__getMoAssyListResponse_getMoAssyListResult() { }
        /// Friend allocator used by soap_new__ns1__getMoAssyListResponse_getMoAssyListResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoAssyListResponse_getMoAssyListResult * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyListResponse_getMoAssyListResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:601 */
#ifndef SOAP_TYPE__ns1__getMoAssyListResponse
#define SOAP_TYPE__ns1__getMoAssyListResponse (162)
/* complex XSD type 'ns1:getMoAssyListResponse': */
class SOAP_CMAC _ns1__getMoAssyListResponse {
      public:
        /// Optional element 'ns1:getMoAssyListResult' of XSD type 'ns1:getMoAssyListResponse-getMoAssyListResult'
        _ns1__getMoAssyListResponse_getMoAssyListResult *getMoAssyListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoAssyListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoAssyListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoAssyListResponse, default initialized and not managed by a soap context
        virtual _ns1__getMoAssyListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoAssyListResponse); }
      public:
        /// Constructor with initializations
        _ns1__getMoAssyListResponse() : getMoAssyListResult(), soap() { }
        virtual ~_ns1__getMoAssyListResponse() { }
        /// Friend allocator used by soap_new__ns1__getMoAssyListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoAssyListResponse * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:604 */
#ifndef SOAP_TYPE__ns1__getPartBomExt
#define SOAP_TYPE__ns1__getPartBomExt (163)
/* complex XSD type 'ns1:getPartBomExt': */
class SOAP_CMAC _ns1__getPartBomExt {
      public:
        /// Optional element 'ns1:PartNo' of XSD type 'xsd:string'
        std::string *PartNo;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPartBomExt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPartBomExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPartBomExt, default initialized and not managed by a soap context
        virtual _ns1__getPartBomExt *soap_alloc(void) const { return SOAP_NEW(_ns1__getPartBomExt); }
      public:
        /// Constructor with initializations
        _ns1__getPartBomExt() : PartNo(), StationNumber(), soap() { }
        virtual ~_ns1__getPartBomExt() { }
        /// Friend allocator used by soap_new__ns1__getPartBomExt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPartBomExt * SOAP_FMAC2 soap_instantiate__ns1__getPartBomExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:4767 */
#ifndef SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult
#define SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult (299)
/* complex XSD type 'ns1:getPartBomExtResponse-getPartBomExtResult': */
class SOAP_CMAC _ns1__getPartBomExtResponse_getPartBomExtResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPartBomExtResponse_getPartBomExtResult, default initialized and not managed by a soap context
        virtual _ns1__getPartBomExtResponse_getPartBomExtResult *soap_alloc(void) const { return SOAP_NEW(_ns1__getPartBomExtResponse_getPartBomExtResult); }
      public:
        /// Constructor with initializations
        _ns1__getPartBomExtResponse_getPartBomExtResult() : __any(), __any_() { }
        virtual ~_ns1__getPartBomExtResponse_getPartBomExtResult() { }
        /// Friend allocator used by soap_new__ns1__getPartBomExtResponse_getPartBomExtResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPartBomExtResponse_getPartBomExtResult * SOAP_FMAC2 soap_instantiate__ns1__getPartBomExtResponse_getPartBomExtResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:607 */
#ifndef SOAP_TYPE__ns1__getPartBomExtResponse
#define SOAP_TYPE__ns1__getPartBomExtResponse (164)
/* complex XSD type 'ns1:getPartBomExtResponse': */
class SOAP_CMAC _ns1__getPartBomExtResponse {
      public:
        /// Optional element 'ns1:getPartBomExtResult' of XSD type 'ns1:getPartBomExtResponse-getPartBomExtResult'
        _ns1__getPartBomExtResponse_getPartBomExtResult *getPartBomExtResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPartBomExtResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPartBomExtResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPartBomExtResponse, default initialized and not managed by a soap context
        virtual _ns1__getPartBomExtResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getPartBomExtResponse); }
      public:
        /// Constructor with initializations
        _ns1__getPartBomExtResponse() : getPartBomExtResult(), soap() { }
        virtual ~_ns1__getPartBomExtResponse() { }
        /// Friend allocator used by soap_new__ns1__getPartBomExtResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPartBomExtResponse * SOAP_FMAC2 soap_instantiate__ns1__getPartBomExtResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:610 */
#ifndef SOAP_TYPE__ns1__InsPartAssy
#define SOAP_TYPE__ns1__InsPartAssy (165)
/* complex XSD type 'ns1:InsPartAssy': */
class SOAP_CMAC _ns1__InsPartAssy {
      public:
        /// Optional element 'ns1:Mo' of XSD type 'xsd:string'
        std::string *Mo;
        /// Optional element 'ns1:Part' of XSD type 'xsd:string'
        std::string *Part;
        /// Optional element 'ns1:StationNo' of XSD type 'xsd:string'
        std::string *StationNo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:SubSn' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *SubSn;
        /// Optional element 'ns1:Desc' of XSD type 'xsd:string'
        std::string *Desc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsPartAssy
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsPartAssy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsPartAssy, default initialized and not managed by a soap context
        virtual _ns1__InsPartAssy *soap_alloc(void) const { return SOAP_NEW(_ns1__InsPartAssy); }
      public:
        /// Constructor with initializations
        _ns1__InsPartAssy() : Mo(), Part(), StationNo(), SN(), SubSn(), Desc(), soap() { }
        virtual ~_ns1__InsPartAssy() { }
        /// Friend allocator used by soap_new__ns1__InsPartAssy(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsPartAssy * SOAP_FMAC2 soap_instantiate__ns1__InsPartAssy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:613 */
#ifndef SOAP_TYPE__ns1__InsPartAssyResponse
#define SOAP_TYPE__ns1__InsPartAssyResponse (166)
/* complex XSD type 'ns1:InsPartAssyResponse': */
class SOAP_CMAC _ns1__InsPartAssyResponse {
      public:
        /// Optional element 'ns1:InsPartAssyResult' of XSD type 'xsd:string'
        std::string *InsPartAssyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsPartAssyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsPartAssyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsPartAssyResponse, default initialized and not managed by a soap context
        virtual _ns1__InsPartAssyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsPartAssyResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsPartAssyResponse() : InsPartAssyResult(), soap() { }
        virtual ~_ns1__InsPartAssyResponse() { }
        /// Friend allocator used by soap_new__ns1__InsPartAssyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsPartAssyResponse * SOAP_FMAC2 soap_instantiate__ns1__InsPartAssyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:616 */
#ifndef SOAP_TYPE__ns1__GetLinkOutSn
#define SOAP_TYPE__ns1__GetLinkOutSn (167)
/* complex XSD type 'ns1:GetLinkOutSn': */
class SOAP_CMAC _ns1__GetLinkOutSn {
      public:
        /// Optional element 'ns1:Mo' of XSD type 'xsd:string'
        std::string *Mo;
        /// Optional element 'ns1:Part' of XSD type 'xsd:string'
        std::string *Part;
        /// Optional element 'ns1:OutPart' of XSD type 'xsd:string'
        std::string *OutPart;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLinkOutSn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLinkOutSn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLinkOutSn, default initialized and not managed by a soap context
        virtual _ns1__GetLinkOutSn *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLinkOutSn); }
      public:
        /// Constructor with initializations
        _ns1__GetLinkOutSn() : Mo(), Part(), OutPart(), soap() { }
        virtual ~_ns1__GetLinkOutSn() { }
        /// Friend allocator used by soap_new__ns1__GetLinkOutSn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLinkOutSn * SOAP_FMAC2 soap_instantiate__ns1__GetLinkOutSn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:4891 */
#ifndef SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult
#define SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult (301)
/* complex XSD type 'ns1:GetLinkOutSnResponse-GetLinkOutSnResult': */
class SOAP_CMAC _ns1__GetLinkOutSnResponse_GetLinkOutSnResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLinkOutSnResponse_GetLinkOutSnResult, default initialized and not managed by a soap context
        virtual _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult); }
      public:
        /// Constructor with initializations
        _ns1__GetLinkOutSnResponse_GetLinkOutSnResult() : __any(), __any_() { }
        virtual ~_ns1__GetLinkOutSnResponse_GetLinkOutSnResult() { }
        /// Friend allocator used by soap_new__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLinkOutSnResponse_GetLinkOutSnResult * SOAP_FMAC2 soap_instantiate__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:619 */
#ifndef SOAP_TYPE__ns1__GetLinkOutSnResponse
#define SOAP_TYPE__ns1__GetLinkOutSnResponse (168)
/* complex XSD type 'ns1:GetLinkOutSnResponse': */
class SOAP_CMAC _ns1__GetLinkOutSnResponse {
      public:
        /// Optional element 'ns1:GetLinkOutSnResult' of XSD type 'ns1:GetLinkOutSnResponse-GetLinkOutSnResult'
        _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *GetLinkOutSnResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLinkOutSnResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLinkOutSnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLinkOutSnResponse, default initialized and not managed by a soap context
        virtual _ns1__GetLinkOutSnResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLinkOutSnResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetLinkOutSnResponse() : GetLinkOutSnResult(), soap() { }
        virtual ~_ns1__GetLinkOutSnResponse() { }
        /// Friend allocator used by soap_new__ns1__GetLinkOutSnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLinkOutSnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLinkOutSnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:622 */
#ifndef SOAP_TYPE__ns1__getMoAssyCount
#define SOAP_TYPE__ns1__getMoAssyCount (169)
/* complex XSD type 'ns1:getMoAssyCount': */
class SOAP_CMAC _ns1__getMoAssyCount {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:StationType' of XSD type 'xsd:string'
        std::string *StationType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoAssyCount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoAssyCount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoAssyCount, default initialized and not managed by a soap context
        virtual _ns1__getMoAssyCount *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoAssyCount); }
      public:
        /// Constructor with initializations
        _ns1__getMoAssyCount() : MoNumber(), StationNumber(), StationType(), soap() { }
        virtual ~_ns1__getMoAssyCount() { }
        /// Friend allocator used by soap_new__ns1__getMoAssyCount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoAssyCount * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:625 */
#ifndef SOAP_TYPE__ns1__getMoAssyCountResponse
#define SOAP_TYPE__ns1__getMoAssyCountResponse (170)
/* complex XSD type 'ns1:getMoAssyCountResponse': */
class SOAP_CMAC _ns1__getMoAssyCountResponse {
      public:
        /// Optional element 'ns1:getMoAssyCountResult' of XSD type 'xsd:string'
        std::string *getMoAssyCountResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMoAssyCountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMoAssyCountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMoAssyCountResponse, default initialized and not managed by a soap context
        virtual _ns1__getMoAssyCountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getMoAssyCountResponse); }
      public:
        /// Constructor with initializations
        _ns1__getMoAssyCountResponse() : getMoAssyCountResult(), soap() { }
        virtual ~_ns1__getMoAssyCountResponse() { }
        /// Friend allocator used by soap_new__ns1__getMoAssyCountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMoAssyCountResponse * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyCountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:628 */
#ifndef SOAP_TYPE__ns1__getPNbySN
#define SOAP_TYPE__ns1__getPNbySN (171)
/* complex XSD type 'ns1:getPNbySN': */
class SOAP_CMAC _ns1__getPNbySN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPNbySN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPNbySN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPNbySN, default initialized and not managed by a soap context
        virtual _ns1__getPNbySN *soap_alloc(void) const { return SOAP_NEW(_ns1__getPNbySN); }
      public:
        /// Constructor with initializations
        _ns1__getPNbySN() : SN(), soap() { }
        virtual ~_ns1__getPNbySN() { }
        /// Friend allocator used by soap_new__ns1__getPNbySN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPNbySN * SOAP_FMAC2 soap_instantiate__ns1__getPNbySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:631 */
#ifndef SOAP_TYPE__ns1__getPNbySNResponse
#define SOAP_TYPE__ns1__getPNbySNResponse (172)
/* complex XSD type 'ns1:getPNbySNResponse': */
class SOAP_CMAC _ns1__getPNbySNResponse {
      public:
        /// Optional element 'ns1:getPNbySNResult' of XSD type 'xsd:string'
        std::string *getPNbySNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPNbySNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPNbySNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPNbySNResponse, default initialized and not managed by a soap context
        virtual _ns1__getPNbySNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getPNbySNResponse); }
      public:
        /// Constructor with initializations
        _ns1__getPNbySNResponse() : getPNbySNResult(), soap() { }
        virtual ~_ns1__getPNbySNResponse() { }
        /// Friend allocator used by soap_new__ns1__getPNbySNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPNbySNResponse * SOAP_FMAC2 soap_instantiate__ns1__getPNbySNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:634 */
#ifndef SOAP_TYPE__ns1__chkAssySN
#define SOAP_TYPE__ns1__chkAssySN (173)
/* complex XSD type 'ns1:chkAssySN': */
class SOAP_CMAC _ns1__chkAssySN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:KSN' of XSD type 'xsd:string'
        std::string *KSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkAssySN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkAssySN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkAssySN, default initialized and not managed by a soap context
        virtual _ns1__chkAssySN *soap_alloc(void) const { return SOAP_NEW(_ns1__chkAssySN); }
      public:
        /// Constructor with initializations
        _ns1__chkAssySN() : SN(), KSN(), StationNumber(), soap() { }
        virtual ~_ns1__chkAssySN() { }
        /// Friend allocator used by soap_new__ns1__chkAssySN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkAssySN * SOAP_FMAC2 soap_instantiate__ns1__chkAssySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:637 */
#ifndef SOAP_TYPE__ns1__chkAssySNResponse
#define SOAP_TYPE__ns1__chkAssySNResponse (174)
/* complex XSD type 'ns1:chkAssySNResponse': */
class SOAP_CMAC _ns1__chkAssySNResponse {
      public:
        /// Optional element 'ns1:chkAssySNResult' of XSD type 'xsd:string'
        std::string *chkAssySNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkAssySNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkAssySNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkAssySNResponse, default initialized and not managed by a soap context
        virtual _ns1__chkAssySNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkAssySNResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkAssySNResponse() : chkAssySNResult(), soap() { }
        virtual ~_ns1__chkAssySNResponse() { }
        /// Friend allocator used by soap_new__ns1__chkAssySNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkAssySNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkAssySNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:5072 */
#ifndef SOAP_TYPE__ns1__doAssy_assyDt
#define SOAP_TYPE__ns1__doAssy_assyDt (303)
/* complex XSD type 'ns1:doAssy-assyDt': */
class SOAP_CMAC _ns1__doAssy_assyDt {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doAssy_assyDt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doAssy_assyDt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doAssy_assyDt, default initialized and not managed by a soap context
        virtual _ns1__doAssy_assyDt *soap_alloc(void) const { return SOAP_NEW(_ns1__doAssy_assyDt); }
      public:
        /// Constructor with initializations
        _ns1__doAssy_assyDt() : __any(), __any_() { }
        virtual ~_ns1__doAssy_assyDt() { }
        /// Friend allocator used by soap_new__ns1__doAssy_assyDt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doAssy_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doAssy_assyDt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:640 */
#ifndef SOAP_TYPE__ns1__doAssy
#define SOAP_TYPE__ns1__doAssy (175)
/* complex XSD type 'ns1:doAssy': */
class SOAP_CMAC _ns1__doAssy {
      public:
        /// Optional element 'ns1:assyDt' of XSD type 'ns1:doAssy-assyDt'
        _ns1__doAssy_assyDt *assyDt;
        /// Optional element 'ns1:empNO' of XSD type 'xsd:string'
        std::string *empNO;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doAssy
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doAssy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doAssy, default initialized and not managed by a soap context
        virtual _ns1__doAssy *soap_alloc(void) const { return SOAP_NEW(_ns1__doAssy); }
      public:
        /// Constructor with initializations
        _ns1__doAssy() : assyDt(), empNO(), SN(), MO(), StationNumber(), soap() { }
        virtual ~_ns1__doAssy() { }
        /// Friend allocator used by soap_new__ns1__doAssy(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doAssy * SOAP_FMAC2 soap_instantiate__ns1__doAssy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:643 */
#ifndef SOAP_TYPE__ns1__doAssyResponse
#define SOAP_TYPE__ns1__doAssyResponse (176)
/* complex XSD type 'ns1:doAssyResponse': */
class SOAP_CMAC _ns1__doAssyResponse {
      public:
        /// Optional element 'ns1:doAssyResult' of XSD type 'xsd:string'
        std::string *doAssyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doAssyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doAssyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doAssyResponse, default initialized and not managed by a soap context
        virtual _ns1__doAssyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__doAssyResponse); }
      public:
        /// Constructor with initializations
        _ns1__doAssyResponse() : doAssyResult(), soap() { }
        virtual ~_ns1__doAssyResponse() { }
        /// Friend allocator used by soap_new__ns1__doAssyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doAssyResponse * SOAP_FMAC2 soap_instantiate__ns1__doAssyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:646 */
#ifndef SOAP_TYPE__ns1__getPmcAssyList
#define SOAP_TYPE__ns1__getPmcAssyList (177)
/* complex XSD type 'ns1:getPmcAssyList': */
class SOAP_CMAC _ns1__getPmcAssyList {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPmcAssyList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPmcAssyList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPmcAssyList, default initialized and not managed by a soap context
        virtual _ns1__getPmcAssyList *soap_alloc(void) const { return SOAP_NEW(_ns1__getPmcAssyList); }
      public:
        /// Constructor with initializations
        _ns1__getPmcAssyList() : SN(), StationNumber(), soap() { }
        virtual ~_ns1__getPmcAssyList() { }
        /// Friend allocator used by soap_new__ns1__getPmcAssyList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPmcAssyList * SOAP_FMAC2 soap_instantiate__ns1__getPmcAssyList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:5171 */
#ifndef SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult
#define SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult (305)
/* complex XSD type 'ns1:getPmcAssyListResponse-getPmcAssyListResult': */
class SOAP_CMAC _ns1__getPmcAssyListResponse_getPmcAssyListResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPmcAssyListResponse_getPmcAssyListResult, default initialized and not managed by a soap context
        virtual _ns1__getPmcAssyListResponse_getPmcAssyListResult *soap_alloc(void) const { return SOAP_NEW(_ns1__getPmcAssyListResponse_getPmcAssyListResult); }
      public:
        /// Constructor with initializations
        _ns1__getPmcAssyListResponse_getPmcAssyListResult() : __any(), __any_() { }
        virtual ~_ns1__getPmcAssyListResponse_getPmcAssyListResult() { }
        /// Friend allocator used by soap_new__ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPmcAssyListResponse_getPmcAssyListResult * SOAP_FMAC2 soap_instantiate__ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:649 */
#ifndef SOAP_TYPE__ns1__getPmcAssyListResponse
#define SOAP_TYPE__ns1__getPmcAssyListResponse (178)
/* complex XSD type 'ns1:getPmcAssyListResponse': */
class SOAP_CMAC _ns1__getPmcAssyListResponse {
      public:
        /// Optional element 'ns1:getPmcAssyListResult' of XSD type 'ns1:getPmcAssyListResponse-getPmcAssyListResult'
        _ns1__getPmcAssyListResponse_getPmcAssyListResult *getPmcAssyListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPmcAssyListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPmcAssyListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPmcAssyListResponse, default initialized and not managed by a soap context
        virtual _ns1__getPmcAssyListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getPmcAssyListResponse); }
      public:
        /// Constructor with initializations
        _ns1__getPmcAssyListResponse() : getPmcAssyListResult(), soap() { }
        virtual ~_ns1__getPmcAssyListResponse() { }
        /// Friend allocator used by soap_new__ns1__getPmcAssyListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPmcAssyListResponse * SOAP_FMAC2 soap_instantiate__ns1__getPmcAssyListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:652 */
#ifndef SOAP_TYPE__ns1__getPmcPartAssyList
#define SOAP_TYPE__ns1__getPmcPartAssyList (179)
/* complex XSD type 'ns1:getPmcPartAssyList': */
class SOAP_CMAC _ns1__getPmcPartAssyList {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPmcPartAssyList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPmcPartAssyList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPmcPartAssyList, default initialized and not managed by a soap context
        virtual _ns1__getPmcPartAssyList *soap_alloc(void) const { return SOAP_NEW(_ns1__getPmcPartAssyList); }
      public:
        /// Constructor with initializations
        _ns1__getPmcPartAssyList() : SN(), StationNumber(), soap() { }
        virtual ~_ns1__getPmcPartAssyList() { }
        /// Friend allocator used by soap_new__ns1__getPmcPartAssyList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPmcPartAssyList * SOAP_FMAC2 soap_instantiate__ns1__getPmcPartAssyList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:5241 */
#ifndef SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult
#define SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult (307)
/* complex XSD type 'ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult': */
class SOAP_CMAC _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, default initialized and not managed by a soap context
        virtual _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *soap_alloc(void) const { return SOAP_NEW(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult); }
      public:
        /// Constructor with initializations
        _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult() : __any(), __any_() { }
        virtual ~_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult() { }
        /// Friend allocator used by soap_new__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult * SOAP_FMAC2 soap_instantiate__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:655 */
#ifndef SOAP_TYPE__ns1__getPmcPartAssyListResponse
#define SOAP_TYPE__ns1__getPmcPartAssyListResponse (180)
/* complex XSD type 'ns1:getPmcPartAssyListResponse': */
class SOAP_CMAC _ns1__getPmcPartAssyListResponse {
      public:
        /// Optional element 'ns1:getPmcPartAssyListResult' of XSD type 'ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult'
        _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *getPmcPartAssyListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getPmcPartAssyListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getPmcPartAssyListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getPmcPartAssyListResponse, default initialized and not managed by a soap context
        virtual _ns1__getPmcPartAssyListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getPmcPartAssyListResponse); }
      public:
        /// Constructor with initializations
        _ns1__getPmcPartAssyListResponse() : getPmcPartAssyListResult(), soap() { }
        virtual ~_ns1__getPmcPartAssyListResponse() { }
        /// Friend allocator used by soap_new__ns1__getPmcPartAssyListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getPmcPartAssyListResponse * SOAP_FMAC2 soap_instantiate__ns1__getPmcPartAssyListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:658 */
#ifndef SOAP_TYPE__ns1__GetPmcSNPart
#define SOAP_TYPE__ns1__GetPmcSNPart (181)
/* complex XSD type 'ns1:GetPmcSNPart': */
class SOAP_CMAC _ns1__GetPmcSNPart {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPmcSNPart
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPmcSNPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPmcSNPart, default initialized and not managed by a soap context
        virtual _ns1__GetPmcSNPart *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPmcSNPart); }
      public:
        /// Constructor with initializations
        _ns1__GetPmcSNPart() : SN(), soap() { }
        virtual ~_ns1__GetPmcSNPart() { }
        /// Friend allocator used by soap_new__ns1__GetPmcSNPart(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPmcSNPart * SOAP_FMAC2 soap_instantiate__ns1__GetPmcSNPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:661 */
#ifndef SOAP_TYPE__ns1__GetPmcSNPartResponse
#define SOAP_TYPE__ns1__GetPmcSNPartResponse (182)
/* complex XSD type 'ns1:GetPmcSNPartResponse': */
class SOAP_CMAC _ns1__GetPmcSNPartResponse {
      public:
        /// Optional element 'ns1:GetPmcSNPartResult' of XSD type 'xsd:string'
        std::string *GetPmcSNPartResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPmcSNPartResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPmcSNPartResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPmcSNPartResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPmcSNPartResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPmcSNPartResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPmcSNPartResponse() : GetPmcSNPartResult(), soap() { }
        virtual ~_ns1__GetPmcSNPartResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPmcSNPartResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPmcSNPartResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPmcSNPartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:5330 */
#ifndef SOAP_TYPE__ns1__doPmcSNLink_assyDt
#define SOAP_TYPE__ns1__doPmcSNLink_assyDt (309)
/* complex XSD type 'ns1:doPmcSNLink-assyDt': */
class SOAP_CMAC _ns1__doPmcSNLink_assyDt {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doPmcSNLink_assyDt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doPmcSNLink_assyDt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doPmcSNLink_assyDt, default initialized and not managed by a soap context
        virtual _ns1__doPmcSNLink_assyDt *soap_alloc(void) const { return SOAP_NEW(_ns1__doPmcSNLink_assyDt); }
      public:
        /// Constructor with initializations
        _ns1__doPmcSNLink_assyDt() : __any(), __any_() { }
        virtual ~_ns1__doPmcSNLink_assyDt() { }
        /// Friend allocator used by soap_new__ns1__doPmcSNLink_assyDt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doPmcSNLink_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doPmcSNLink_assyDt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:664 */
#ifndef SOAP_TYPE__ns1__doPmcSNLink
#define SOAP_TYPE__ns1__doPmcSNLink (183)
/* complex XSD type 'ns1:doPmcSNLink': */
class SOAP_CMAC _ns1__doPmcSNLink {
      public:
        /// Optional element 'ns1:assyDt' of XSD type 'ns1:doPmcSNLink-assyDt'
        _ns1__doPmcSNLink_assyDt *assyDt;
        /// Optional element 'ns1:empNO' of XSD type 'xsd:string'
        std::string *empNO;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doPmcSNLink
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doPmcSNLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doPmcSNLink, default initialized and not managed by a soap context
        virtual _ns1__doPmcSNLink *soap_alloc(void) const { return SOAP_NEW(_ns1__doPmcSNLink); }
      public:
        /// Constructor with initializations
        _ns1__doPmcSNLink() : assyDt(), empNO(), SN(), StationNumber(), soap() { }
        virtual ~_ns1__doPmcSNLink() { }
        /// Friend allocator used by soap_new__ns1__doPmcSNLink(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doPmcSNLink * SOAP_FMAC2 soap_instantiate__ns1__doPmcSNLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:667 */
#ifndef SOAP_TYPE__ns1__doPmcSNLinkResponse
#define SOAP_TYPE__ns1__doPmcSNLinkResponse (184)
/* complex XSD type 'ns1:doPmcSNLinkResponse': */
class SOAP_CMAC _ns1__doPmcSNLinkResponse {
      public:
        /// Optional element 'ns1:doPmcSNLinkResult' of XSD type 'xsd:string'
        std::string *doPmcSNLinkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doPmcSNLinkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doPmcSNLinkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doPmcSNLinkResponse, default initialized and not managed by a soap context
        virtual _ns1__doPmcSNLinkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__doPmcSNLinkResponse); }
      public:
        /// Constructor with initializations
        _ns1__doPmcSNLinkResponse() : doPmcSNLinkResult(), soap() { }
        virtual ~_ns1__doPmcSNLinkResponse() { }
        /// Friend allocator used by soap_new__ns1__doPmcSNLinkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doPmcSNLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__doPmcSNLinkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:670 */
#ifndef SOAP_TYPE__ns1__InsZJTestData
#define SOAP_TYPE__ns1__InsZJTestData (185)
/* complex XSD type 'ns1:InsZJTestData': */
class SOAP_CMAC _ns1__InsZJTestData {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Optional element 'ns1:Result' of XSD type 'xsd:string'
        std::string *Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsZJTestData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsZJTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsZJTestData, default initialized and not managed by a soap context
        virtual _ns1__InsZJTestData *soap_alloc(void) const { return SOAP_NEW(_ns1__InsZJTestData); }
      public:
        /// Constructor with initializations
        _ns1__InsZJTestData() : Emp(), SN(), Station(), Result(), soap() { }
        virtual ~_ns1__InsZJTestData() { }
        /// Friend allocator used by soap_new__ns1__InsZJTestData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsZJTestData * SOAP_FMAC2 soap_instantiate__ns1__InsZJTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:673 */
#ifndef SOAP_TYPE__ns1__InsZJTestDataResponse
#define SOAP_TYPE__ns1__InsZJTestDataResponse (186)
/* complex XSD type 'ns1:InsZJTestDataResponse': */
class SOAP_CMAC _ns1__InsZJTestDataResponse {
      public:
        /// Optional element 'ns1:InsZJTestDataResult' of XSD type 'xsd:string'
        std::string *InsZJTestDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsZJTestDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsZJTestDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsZJTestDataResponse, default initialized and not managed by a soap context
        virtual _ns1__InsZJTestDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsZJTestDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsZJTestDataResponse() : InsZJTestDataResult(), soap() { }
        virtual ~_ns1__InsZJTestDataResponse() { }
        /// Friend allocator used by soap_new__ns1__InsZJTestDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsZJTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__InsZJTestDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:676 */
#ifndef SOAP_TYPE__ns1__SNLinkZJ
#define SOAP_TYPE__ns1__SNLinkZJ (187)
/* complex XSD type 'ns1:SNLinkZJ': */
class SOAP_CMAC _ns1__SNLinkZJ {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SNLinkZJ
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SNLinkZJ; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SNLinkZJ, default initialized and not managed by a soap context
        virtual _ns1__SNLinkZJ *soap_alloc(void) const { return SOAP_NEW(_ns1__SNLinkZJ); }
      public:
        /// Constructor with initializations
        _ns1__SNLinkZJ() : Emp(), SN(), Station(), ZJSN(), soap() { }
        virtual ~_ns1__SNLinkZJ() { }
        /// Friend allocator used by soap_new__ns1__SNLinkZJ(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SNLinkZJ * SOAP_FMAC2 soap_instantiate__ns1__SNLinkZJ(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:679 */
#ifndef SOAP_TYPE__ns1__SNLinkZJResponse
#define SOAP_TYPE__ns1__SNLinkZJResponse (188)
/* complex XSD type 'ns1:SNLinkZJResponse': */
class SOAP_CMAC _ns1__SNLinkZJResponse {
      public:
        /// Optional element 'ns1:SNLinkZJResult' of XSD type 'xsd:string'
        std::string *SNLinkZJResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SNLinkZJResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SNLinkZJResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SNLinkZJResponse, default initialized and not managed by a soap context
        virtual _ns1__SNLinkZJResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SNLinkZJResponse); }
      public:
        /// Constructor with initializations
        _ns1__SNLinkZJResponse() : SNLinkZJResult(), soap() { }
        virtual ~_ns1__SNLinkZJResponse() { }
        /// Friend allocator used by soap_new__ns1__SNLinkZJResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SNLinkZJResponse * SOAP_FMAC2 soap_instantiate__ns1__SNLinkZJResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:682 */
#ifndef SOAP_TYPE__ns1__GetLintOutQty
#define SOAP_TYPE__ns1__GetLintOutQty (189)
/* complex XSD type 'ns1:GetLintOutQty': */
class SOAP_CMAC _ns1__GetLintOutQty {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLintOutQty
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLintOutQty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLintOutQty, default initialized and not managed by a soap context
        virtual _ns1__GetLintOutQty *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLintOutQty); }
      public:
        /// Constructor with initializations
        _ns1__GetLintOutQty() : SN(), soap() { }
        virtual ~_ns1__GetLintOutQty() { }
        /// Friend allocator used by soap_new__ns1__GetLintOutQty(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLintOutQty * SOAP_FMAC2 soap_instantiate__ns1__GetLintOutQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:685 */
#ifndef SOAP_TYPE__ns1__GetLintOutQtyResponse
#define SOAP_TYPE__ns1__GetLintOutQtyResponse (190)
/* complex XSD type 'ns1:GetLintOutQtyResponse': */
class SOAP_CMAC _ns1__GetLintOutQtyResponse {
      public:
        /// Optional element 'ns1:GetLintOutQtyResult' of XSD type 'xsd:string'
        std::string *GetLintOutQtyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLintOutQtyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLintOutQtyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLintOutQtyResponse, default initialized and not managed by a soap context
        virtual _ns1__GetLintOutQtyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLintOutQtyResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetLintOutQtyResponse() : GetLintOutQtyResult(), soap() { }
        virtual ~_ns1__GetLintOutQtyResponse() { }
        /// Friend allocator used by soap_new__ns1__GetLintOutQtyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLintOutQtyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLintOutQtyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:688 */
#ifndef SOAP_TYPE__ns1__chkOutSN
#define SOAP_TYPE__ns1__chkOutSN (191)
/* complex XSD type 'ns1:chkOutSN': */
class SOAP_CMAC _ns1__chkOutSN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:OutSN' of XSD type 'xsd:string'
        std::string *OutSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkOutSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkOutSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkOutSN, default initialized and not managed by a soap context
        virtual _ns1__chkOutSN *soap_alloc(void) const { return SOAP_NEW(_ns1__chkOutSN); }
      public:
        /// Constructor with initializations
        _ns1__chkOutSN() : SN(), OutSN(), soap() { }
        virtual ~_ns1__chkOutSN() { }
        /// Friend allocator used by soap_new__ns1__chkOutSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkOutSN * SOAP_FMAC2 soap_instantiate__ns1__chkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:691 */
#ifndef SOAP_TYPE__ns1__chkOutSNResponse
#define SOAP_TYPE__ns1__chkOutSNResponse (192)
/* complex XSD type 'ns1:chkOutSNResponse': */
class SOAP_CMAC _ns1__chkOutSNResponse {
      public:
        /// Optional element 'ns1:chkOutSNResult' of XSD type 'xsd:string'
        std::string *chkOutSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkOutSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkOutSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkOutSNResponse, default initialized and not managed by a soap context
        virtual _ns1__chkOutSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkOutSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkOutSNResponse() : chkOutSNResult(), soap() { }
        virtual ~_ns1__chkOutSNResponse() { }
        /// Friend allocator used by soap_new__ns1__chkOutSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkOutSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:694 */
#ifndef SOAP_TYPE__ns1__ChkLinkOutSN
#define SOAP_TYPE__ns1__ChkLinkOutSN (193)
/* complex XSD type 'ns1:ChkLinkOutSN': */
class SOAP_CMAC _ns1__ChkLinkOutSN {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkLinkOutSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkLinkOutSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkLinkOutSN, default initialized and not managed by a soap context
        virtual _ns1__ChkLinkOutSN *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkLinkOutSN); }
      public:
        /// Constructor with initializations
        _ns1__ChkLinkOutSN() : SN(), soap() { }
        virtual ~_ns1__ChkLinkOutSN() { }
        /// Friend allocator used by soap_new__ns1__ChkLinkOutSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkLinkOutSN * SOAP_FMAC2 soap_instantiate__ns1__ChkLinkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:697 */
#ifndef SOAP_TYPE__ns1__ChkLinkOutSNResponse
#define SOAP_TYPE__ns1__ChkLinkOutSNResponse (194)
/* complex XSD type 'ns1:ChkLinkOutSNResponse': */
class SOAP_CMAC _ns1__ChkLinkOutSNResponse {
      public:
        /// Optional element 'ns1:ChkLinkOutSNResult' of XSD type 'xsd:string'
        std::string *ChkLinkOutSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChkLinkOutSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ChkLinkOutSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChkLinkOutSNResponse, default initialized and not managed by a soap context
        virtual _ns1__ChkLinkOutSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChkLinkOutSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChkLinkOutSNResponse() : ChkLinkOutSNResult(), soap() { }
        virtual ~_ns1__ChkLinkOutSNResponse() { }
        /// Friend allocator used by soap_new__ns1__ChkLinkOutSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChkLinkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkLinkOutSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:5628 */
#ifndef SOAP_TYPE__ns1__doLinkOutSN_assyDt
#define SOAP_TYPE__ns1__doLinkOutSN_assyDt (311)
/* complex XSD type 'ns1:doLinkOutSN-assyDt': */
class SOAP_CMAC _ns1__doLinkOutSN_assyDt {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doLinkOutSN_assyDt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doLinkOutSN_assyDt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doLinkOutSN_assyDt, default initialized and not managed by a soap context
        virtual _ns1__doLinkOutSN_assyDt *soap_alloc(void) const { return SOAP_NEW(_ns1__doLinkOutSN_assyDt); }
      public:
        /// Constructor with initializations
        _ns1__doLinkOutSN_assyDt() : __any(), __any_() { }
        virtual ~_ns1__doLinkOutSN_assyDt() { }
        /// Friend allocator used by soap_new__ns1__doLinkOutSN_assyDt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doLinkOutSN_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doLinkOutSN_assyDt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:700 */
#ifndef SOAP_TYPE__ns1__doLinkOutSN
#define SOAP_TYPE__ns1__doLinkOutSN (195)
/* complex XSD type 'ns1:doLinkOutSN': */
class SOAP_CMAC _ns1__doLinkOutSN {
      public:
        /// Optional element 'ns1:assyDt' of XSD type 'ns1:doLinkOutSN-assyDt'
        _ns1__doLinkOutSN_assyDt *assyDt;
        /// Optional element 'ns1:empNO' of XSD type 'xsd:string'
        std::string *empNO;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Optional element 'ns1:chkRep' of XSD type 'xsd:string'
        std::string *chkRep;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doLinkOutSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doLinkOutSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doLinkOutSN, default initialized and not managed by a soap context
        virtual _ns1__doLinkOutSN *soap_alloc(void) const { return SOAP_NEW(_ns1__doLinkOutSN); }
      public:
        /// Constructor with initializations
        _ns1__doLinkOutSN() : assyDt(), empNO(), SN(), Station(), chkRep(), soap() { }
        virtual ~_ns1__doLinkOutSN() { }
        /// Friend allocator used by soap_new__ns1__doLinkOutSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doLinkOutSN * SOAP_FMAC2 soap_instantiate__ns1__doLinkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:703 */
#ifndef SOAP_TYPE__ns1__doLinkOutSNResponse
#define SOAP_TYPE__ns1__doLinkOutSNResponse (196)
/* complex XSD type 'ns1:doLinkOutSNResponse': */
class SOAP_CMAC _ns1__doLinkOutSNResponse {
      public:
        /// Optional element 'ns1:doLinkOutSNResult' of XSD type 'xsd:string'
        std::string *doLinkOutSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__doLinkOutSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__doLinkOutSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__doLinkOutSNResponse, default initialized and not managed by a soap context
        virtual _ns1__doLinkOutSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__doLinkOutSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__doLinkOutSNResponse() : doLinkOutSNResult(), soap() { }
        virtual ~_ns1__doLinkOutSNResponse() { }
        /// Friend allocator used by soap_new__ns1__doLinkOutSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__doLinkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__doLinkOutSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:706 */
#ifndef SOAP_TYPE__ns1__InsLinkSN
#define SOAP_TYPE__ns1__InsLinkSN (197)
/* complex XSD type 'ns1:InsLinkSN': */
class SOAP_CMAC _ns1__InsLinkSN {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:LnkSN' of XSD type 'xsd:string'
        std::string *LnkSN;
        /// Optional element 'ns1:LnkDesc' of XSD type 'xsd:string'
        std::string *LnkDesc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsLinkSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsLinkSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsLinkSN, default initialized and not managed by a soap context
        virtual _ns1__InsLinkSN *soap_alloc(void) const { return SOAP_NEW(_ns1__InsLinkSN); }
      public:
        /// Constructor with initializations
        _ns1__InsLinkSN() : Emp(), SN(), LnkSN(), LnkDesc(), soap() { }
        virtual ~_ns1__InsLinkSN() { }
        /// Friend allocator used by soap_new__ns1__InsLinkSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsLinkSN * SOAP_FMAC2 soap_instantiate__ns1__InsLinkSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:709 */
#ifndef SOAP_TYPE__ns1__InsLinkSNResponse
#define SOAP_TYPE__ns1__InsLinkSNResponse (198)
/* complex XSD type 'ns1:InsLinkSNResponse': */
class SOAP_CMAC _ns1__InsLinkSNResponse {
      public:
        /// Optional element 'ns1:InsLinkSNResult' of XSD type 'xsd:string'
        std::string *InsLinkSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsLinkSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsLinkSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsLinkSNResponse, default initialized and not managed by a soap context
        virtual _ns1__InsLinkSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsLinkSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsLinkSNResponse() : InsLinkSNResult(), soap() { }
        virtual ~_ns1__InsLinkSNResponse() { }
        /// Friend allocator used by soap_new__ns1__InsLinkSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsLinkSNResponse * SOAP_FMAC2 soap_instantiate__ns1__InsLinkSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:712 */
#ifndef SOAP_TYPE__ns1__GetLinkZJCount
#define SOAP_TYPE__ns1__GetLinkZJCount (199)
/* complex XSD type 'ns1:GetLinkZJCount': */
class SOAP_CMAC _ns1__GetLinkZJCount {
      public:
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLinkZJCount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLinkZJCount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLinkZJCount, default initialized and not managed by a soap context
        virtual _ns1__GetLinkZJCount *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLinkZJCount); }
      public:
        /// Constructor with initializations
        _ns1__GetLinkZJCount() : ZJSN(), soap() { }
        virtual ~_ns1__GetLinkZJCount() { }
        /// Friend allocator used by soap_new__ns1__GetLinkZJCount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLinkZJCount * SOAP_FMAC2 soap_instantiate__ns1__GetLinkZJCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:715 */
#ifndef SOAP_TYPE__ns1__GetLinkZJCountResponse
#define SOAP_TYPE__ns1__GetLinkZJCountResponse (200)
/* complex XSD type 'ns1:GetLinkZJCountResponse': */
class SOAP_CMAC _ns1__GetLinkZJCountResponse {
      public:
        /// Optional element 'ns1:GetLinkZJCountResult' of XSD type 'xsd:string'
        std::string *GetLinkZJCountResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLinkZJCountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLinkZJCountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLinkZJCountResponse, default initialized and not managed by a soap context
        virtual _ns1__GetLinkZJCountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLinkZJCountResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetLinkZJCountResponse() : GetLinkZJCountResult(), soap() { }
        virtual ~_ns1__GetLinkZJCountResponse() { }
        /// Friend allocator used by soap_new__ns1__GetLinkZJCountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLinkZJCountResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLinkZJCountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:718 */
#ifndef SOAP_TYPE__ns1__InsBoxNOTime
#define SOAP_TYPE__ns1__InsBoxNOTime (201)
/* complex XSD type 'ns1:InsBoxNOTime': */
class SOAP_CMAC _ns1__InsBoxNOTime {
      public:
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsBoxNOTime
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsBoxNOTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsBoxNOTime, default initialized and not managed by a soap context
        virtual _ns1__InsBoxNOTime *soap_alloc(void) const { return SOAP_NEW(_ns1__InsBoxNOTime); }
      public:
        /// Constructor with initializations
        _ns1__InsBoxNOTime() : BoxNo(), soap() { }
        virtual ~_ns1__InsBoxNOTime() { }
        /// Friend allocator used by soap_new__ns1__InsBoxNOTime(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsBoxNOTime * SOAP_FMAC2 soap_instantiate__ns1__InsBoxNOTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:721 */
#ifndef SOAP_TYPE__ns1__InsBoxNOTimeResponse
#define SOAP_TYPE__ns1__InsBoxNOTimeResponse (202)
/* complex XSD type 'ns1:InsBoxNOTimeResponse': */
class SOAP_CMAC _ns1__InsBoxNOTimeResponse {
      public:
        /// Optional element 'ns1:InsBoxNOTimeResult' of XSD type 'xsd:string'
        std::string *InsBoxNOTimeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsBoxNOTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsBoxNOTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsBoxNOTimeResponse, default initialized and not managed by a soap context
        virtual _ns1__InsBoxNOTimeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsBoxNOTimeResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsBoxNOTimeResponse() : InsBoxNOTimeResult(), soap() { }
        virtual ~_ns1__InsBoxNOTimeResponse() { }
        /// Friend allocator used by soap_new__ns1__InsBoxNOTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsBoxNOTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__InsBoxNOTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:724 */
#ifndef SOAP_TYPE__ns1__chkBoxNo
#define SOAP_TYPE__ns1__chkBoxNo (203)
/* complex XSD type 'ns1:chkBoxNo': */
class SOAP_CMAC _ns1__chkBoxNo {
      public:
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkBoxNo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkBoxNo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkBoxNo, default initialized and not managed by a soap context
        virtual _ns1__chkBoxNo *soap_alloc(void) const { return SOAP_NEW(_ns1__chkBoxNo); }
      public:
        /// Constructor with initializations
        _ns1__chkBoxNo() : BoxNo(), soap() { }
        virtual ~_ns1__chkBoxNo() { }
        /// Friend allocator used by soap_new__ns1__chkBoxNo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkBoxNo * SOAP_FMAC2 soap_instantiate__ns1__chkBoxNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:727 */
#ifndef SOAP_TYPE__ns1__chkBoxNoResponse
#define SOAP_TYPE__ns1__chkBoxNoResponse (204)
/* complex XSD type 'ns1:chkBoxNoResponse': */
class SOAP_CMAC _ns1__chkBoxNoResponse {
      public:
        /// Optional element 'ns1:chkBoxNoResult' of XSD type 'xsd:string'
        std::string *chkBoxNoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkBoxNoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkBoxNoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkBoxNoResponse, default initialized and not managed by a soap context
        virtual _ns1__chkBoxNoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkBoxNoResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkBoxNoResponse() : chkBoxNoResult(), soap() { }
        virtual ~_ns1__chkBoxNoResponse() { }
        /// Friend allocator used by soap_new__ns1__chkBoxNoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkBoxNoResponse * SOAP_FMAC2 soap_instantiate__ns1__chkBoxNoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:730 */
#ifndef SOAP_TYPE__ns1__InSNtoBox
#define SOAP_TYPE__ns1__InSNtoBox (205)
/* complex XSD type 'ns1:InSNtoBox': */
class SOAP_CMAC _ns1__InSNtoBox {
      public:
        /// Optional element 'ns1:EmpNo' of XSD type 'xsd:string'
        std::string *EmpNo;
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InSNtoBox
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InSNtoBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InSNtoBox, default initialized and not managed by a soap context
        virtual _ns1__InSNtoBox *soap_alloc(void) const { return SOAP_NEW(_ns1__InSNtoBox); }
      public:
        /// Constructor with initializations
        _ns1__InSNtoBox() : EmpNo(), BoxNo(), SN(), soap() { }
        virtual ~_ns1__InSNtoBox() { }
        /// Friend allocator used by soap_new__ns1__InSNtoBox(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InSNtoBox * SOAP_FMAC2 soap_instantiate__ns1__InSNtoBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:733 */
#ifndef SOAP_TYPE__ns1__InSNtoBoxResponse
#define SOAP_TYPE__ns1__InSNtoBoxResponse (206)
/* complex XSD type 'ns1:InSNtoBoxResponse': */
class SOAP_CMAC _ns1__InSNtoBoxResponse {
      public:
        /// Optional element 'ns1:InSNtoBoxResult' of XSD type 'xsd:string'
        std::string *InSNtoBoxResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InSNtoBoxResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InSNtoBoxResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InSNtoBoxResponse, default initialized and not managed by a soap context
        virtual _ns1__InSNtoBoxResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InSNtoBoxResponse); }
      public:
        /// Constructor with initializations
        _ns1__InSNtoBoxResponse() : InSNtoBoxResult(), soap() { }
        virtual ~_ns1__InSNtoBoxResponse() { }
        /// Friend allocator used by soap_new__ns1__InSNtoBoxResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InSNtoBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__InSNtoBoxResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:736 */
#ifndef SOAP_TYPE__ns1__EndSNtoBox
#define SOAP_TYPE__ns1__EndSNtoBox (207)
/* complex XSD type 'ns1:EndSNtoBox': */
class SOAP_CMAC _ns1__EndSNtoBox {
      public:
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EndSNtoBox
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EndSNtoBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EndSNtoBox, default initialized and not managed by a soap context
        virtual _ns1__EndSNtoBox *soap_alloc(void) const { return SOAP_NEW(_ns1__EndSNtoBox); }
      public:
        /// Constructor with initializations
        _ns1__EndSNtoBox() : BoxNo(), soap() { }
        virtual ~_ns1__EndSNtoBox() { }
        /// Friend allocator used by soap_new__ns1__EndSNtoBox(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EndSNtoBox * SOAP_FMAC2 soap_instantiate__ns1__EndSNtoBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:739 */
#ifndef SOAP_TYPE__ns1__EndSNtoBoxResponse
#define SOAP_TYPE__ns1__EndSNtoBoxResponse (208)
/* complex XSD type 'ns1:EndSNtoBoxResponse': */
class SOAP_CMAC _ns1__EndSNtoBoxResponse {
      public:
        /// Optional element 'ns1:EndSNtoBoxResult' of XSD type 'xsd:string'
        std::string *EndSNtoBoxResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EndSNtoBoxResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EndSNtoBoxResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EndSNtoBoxResponse, default initialized and not managed by a soap context
        virtual _ns1__EndSNtoBoxResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__EndSNtoBoxResponse); }
      public:
        /// Constructor with initializations
        _ns1__EndSNtoBoxResponse() : EndSNtoBoxResult(), soap() { }
        virtual ~_ns1__EndSNtoBoxResponse() { }
        /// Friend allocator used by soap_new__ns1__EndSNtoBoxResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EndSNtoBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__EndSNtoBoxResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:742 */
#ifndef SOAP_TYPE__ns1__InStationbyBox
#define SOAP_TYPE__ns1__InStationbyBox (209)
/* complex XSD type 'ns1:InStationbyBox': */
class SOAP_CMAC _ns1__InStationbyBox {
      public:
        /// Optional element 'ns1:EmpNo' of XSD type 'xsd:string'
        std::string *EmpNo;
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InStationbyBox
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InStationbyBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InStationbyBox, default initialized and not managed by a soap context
        virtual _ns1__InStationbyBox *soap_alloc(void) const { return SOAP_NEW(_ns1__InStationbyBox); }
      public:
        /// Constructor with initializations
        _ns1__InStationbyBox() : EmpNo(), BoxNo(), Station(), soap() { }
        virtual ~_ns1__InStationbyBox() { }
        /// Friend allocator used by soap_new__ns1__InStationbyBox(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InStationbyBox * SOAP_FMAC2 soap_instantiate__ns1__InStationbyBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:745 */
#ifndef SOAP_TYPE__ns1__InStationbyBoxResponse
#define SOAP_TYPE__ns1__InStationbyBoxResponse (210)
/* complex XSD type 'ns1:InStationbyBoxResponse': */
class SOAP_CMAC _ns1__InStationbyBoxResponse {
      public:
        /// Optional element 'ns1:InStationbyBoxResult' of XSD type 'xsd:string'
        std::string *InStationbyBoxResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InStationbyBoxResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InStationbyBoxResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InStationbyBoxResponse, default initialized and not managed by a soap context
        virtual _ns1__InStationbyBoxResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InStationbyBoxResponse); }
      public:
        /// Constructor with initializations
        _ns1__InStationbyBoxResponse() : InStationbyBoxResult(), soap() { }
        virtual ~_ns1__InStationbyBoxResponse() { }
        /// Friend allocator used by soap_new__ns1__InStationbyBoxResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InStationbyBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__InStationbyBoxResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:748 */
#ifndef SOAP_TYPE__ns1__OutStationbyBox
#define SOAP_TYPE__ns1__OutStationbyBox (211)
/* complex XSD type 'ns1:OutStationbyBox': */
class SOAP_CMAC _ns1__OutStationbyBox {
      public:
        /// Optional element 'ns1:EmpNo' of XSD type 'xsd:string'
        std::string *EmpNo;
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutStationbyBox
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OutStationbyBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutStationbyBox, default initialized and not managed by a soap context
        virtual _ns1__OutStationbyBox *soap_alloc(void) const { return SOAP_NEW(_ns1__OutStationbyBox); }
      public:
        /// Constructor with initializations
        _ns1__OutStationbyBox() : EmpNo(), BoxNo(), Station(), soap() { }
        virtual ~_ns1__OutStationbyBox() { }
        /// Friend allocator used by soap_new__ns1__OutStationbyBox(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutStationbyBox * SOAP_FMAC2 soap_instantiate__ns1__OutStationbyBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:751 */
#ifndef SOAP_TYPE__ns1__OutStationbyBoxResponse
#define SOAP_TYPE__ns1__OutStationbyBoxResponse (212)
/* complex XSD type 'ns1:OutStationbyBoxResponse': */
class SOAP_CMAC _ns1__OutStationbyBoxResponse {
      public:
        /// Optional element 'ns1:OutStationbyBoxResult' of XSD type 'xsd:string'
        std::string *OutStationbyBoxResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutStationbyBoxResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OutStationbyBoxResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutStationbyBoxResponse, default initialized and not managed by a soap context
        virtual _ns1__OutStationbyBoxResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__OutStationbyBoxResponse); }
      public:
        /// Constructor with initializations
        _ns1__OutStationbyBoxResponse() : OutStationbyBoxResult(), soap() { }
        virtual ~_ns1__OutStationbyBoxResponse() { }
        /// Friend allocator used by soap_new__ns1__OutStationbyBoxResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutStationbyBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__OutStationbyBoxResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:754 */
#ifndef SOAP_TYPE__ns1__CancelBoxLnk
#define SOAP_TYPE__ns1__CancelBoxLnk (213)
/* complex XSD type 'ns1:CancelBoxLnk': */
class SOAP_CMAC _ns1__CancelBoxLnk {
      public:
        /// Optional element 'ns1:EmpNo' of XSD type 'xsd:string'
        std::string *EmpNo;
        /// Optional element 'ns1:BoxNo' of XSD type 'xsd:string'
        std::string *BoxNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelBoxLnk
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelBoxLnk; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelBoxLnk, default initialized and not managed by a soap context
        virtual _ns1__CancelBoxLnk *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelBoxLnk); }
      public:
        /// Constructor with initializations
        _ns1__CancelBoxLnk() : EmpNo(), BoxNo(), soap() { }
        virtual ~_ns1__CancelBoxLnk() { }
        /// Friend allocator used by soap_new__ns1__CancelBoxLnk(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelBoxLnk * SOAP_FMAC2 soap_instantiate__ns1__CancelBoxLnk(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:757 */
#ifndef SOAP_TYPE__ns1__CancelBoxLnkResponse
#define SOAP_TYPE__ns1__CancelBoxLnkResponse (214)
/* complex XSD type 'ns1:CancelBoxLnkResponse': */
class SOAP_CMAC _ns1__CancelBoxLnkResponse {
      public:
        /// Optional element 'ns1:CancelBoxLnkResult' of XSD type 'xsd:string'
        std::string *CancelBoxLnkResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelBoxLnkResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelBoxLnkResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelBoxLnkResponse, default initialized and not managed by a soap context
        virtual _ns1__CancelBoxLnkResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelBoxLnkResponse); }
      public:
        /// Constructor with initializations
        _ns1__CancelBoxLnkResponse() : CancelBoxLnkResult(), soap() { }
        virtual ~_ns1__CancelBoxLnkResponse() { }
        /// Friend allocator used by soap_new__ns1__CancelBoxLnkResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelBoxLnkResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelBoxLnkResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:760 */
#ifndef SOAP_TYPE__ns1__InsSNStationEmp
#define SOAP_TYPE__ns1__InsSNStationEmp (215)
/* complex XSD type 'ns1:InsSNStationEmp': */
class SOAP_CMAC _ns1__InsSNStationEmp {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:EmpNo' of XSD type 'xsd:string'
        std::string *EmpNo;
        /// Optional element 'ns1:Station' of XSD type 'xsd:string'
        std::string *Station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsSNStationEmp
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsSNStationEmp; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsSNStationEmp, default initialized and not managed by a soap context
        virtual _ns1__InsSNStationEmp *soap_alloc(void) const { return SOAP_NEW(_ns1__InsSNStationEmp); }
      public:
        /// Constructor with initializations
        _ns1__InsSNStationEmp() : SN(), EmpNo(), Station(), soap() { }
        virtual ~_ns1__InsSNStationEmp() { }
        /// Friend allocator used by soap_new__ns1__InsSNStationEmp(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsSNStationEmp * SOAP_FMAC2 soap_instantiate__ns1__InsSNStationEmp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:763 */
#ifndef SOAP_TYPE__ns1__InsSNStationEmpResponse
#define SOAP_TYPE__ns1__InsSNStationEmpResponse (216)
/* complex XSD type 'ns1:InsSNStationEmpResponse': */
class SOAP_CMAC _ns1__InsSNStationEmpResponse {
      public:
        /// Optional element 'ns1:InsSNStationEmpResult' of XSD type 'xsd:string'
        std::string *InsSNStationEmpResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsSNStationEmpResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsSNStationEmpResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsSNStationEmpResponse, default initialized and not managed by a soap context
        virtual _ns1__InsSNStationEmpResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsSNStationEmpResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsSNStationEmpResponse() : InsSNStationEmpResult(), soap() { }
        virtual ~_ns1__InsSNStationEmpResponse() { }
        /// Friend allocator used by soap_new__ns1__InsSNStationEmpResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsSNStationEmpResponse * SOAP_FMAC2 soap_instantiate__ns1__InsSNStationEmpResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:766 */
#ifndef SOAP_TYPE__ns1__InsLnkOutSN
#define SOAP_TYPE__ns1__InsLnkOutSN (217)
/* complex XSD type 'ns1:InsLnkOutSN': */
class SOAP_CMAC _ns1__InsLnkOutSN {
      public:
        /// Optional element 'ns1:empNO' of XSD type 'xsd:string'
        std::string *empNO;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:LnkSN' of XSD type 'xsd:string'
        std::string *LnkSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsLnkOutSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsLnkOutSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsLnkOutSN, default initialized and not managed by a soap context
        virtual _ns1__InsLnkOutSN *soap_alloc(void) const { return SOAP_NEW(_ns1__InsLnkOutSN); }
      public:
        /// Constructor with initializations
        _ns1__InsLnkOutSN() : empNO(), SN(), LnkSN(), soap() { }
        virtual ~_ns1__InsLnkOutSN() { }
        /// Friend allocator used by soap_new__ns1__InsLnkOutSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsLnkOutSN * SOAP_FMAC2 soap_instantiate__ns1__InsLnkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:769 */
#ifndef SOAP_TYPE__ns1__InsLnkOutSNResponse
#define SOAP_TYPE__ns1__InsLnkOutSNResponse (218)
/* complex XSD type 'ns1:InsLnkOutSNResponse': */
class SOAP_CMAC _ns1__InsLnkOutSNResponse {
      public:
        /// Optional element 'ns1:InsLnkOutSNResult' of XSD type 'xsd:string'
        std::string *InsLnkOutSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsLnkOutSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsLnkOutSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsLnkOutSNResponse, default initialized and not managed by a soap context
        virtual _ns1__InsLnkOutSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsLnkOutSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsLnkOutSNResponse() : InsLnkOutSNResult(), soap() { }
        virtual ~_ns1__InsLnkOutSNResponse() { }
        /// Friend allocator used by soap_new__ns1__InsLnkOutSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsLnkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__InsLnkOutSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:772 */
#ifndef SOAP_TYPE__ns1__InsBoxInfo
#define SOAP_TYPE__ns1__InsBoxInfo (219)
/* complex XSD type 'ns1:InsBoxInfo': */
class SOAP_CMAC _ns1__InsBoxInfo {
      public:
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Optional element 'ns1:PartNo' of XSD type 'xsd:string'
        std::string *PartNo;
        /// Optional element 'ns1:VD' of XSD type 'xsd:string'
        std::string *VD;
        /// Optional element 'ns1:StationNo' of XSD type 'xsd:string'
        std::string *StationNo;
        /// Optional element 'ns1:BoxSN' of XSD type 'xsd:string'
        std::string *BoxSN;
        /// Required element 'ns1:TargetQty' of XSD type 'xsd:int'
        int TargetQty;
        /// Required element 'ns1:PkgQty' of XSD type 'xsd:int'
        int PkgQty;
        /// Optional element 'ns1:CrePkgTime' of XSD type 'xsd:string'
        std::string *CrePkgTime;
        /// Optional element 'ns1:EndPkgTime' of XSD type 'xsd:string'
        std::string *EndPkgTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsBoxInfo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsBoxInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsBoxInfo, default initialized and not managed by a soap context
        virtual _ns1__InsBoxInfo *soap_alloc(void) const { return SOAP_NEW(_ns1__InsBoxInfo); }
      public:
        /// Constructor with initializations
        _ns1__InsBoxInfo() : MO(), PartNo(), VD(), StationNo(), BoxSN(), TargetQty(), PkgQty(), CrePkgTime(), EndPkgTime(), soap() { }
        virtual ~_ns1__InsBoxInfo() { }
        /// Friend allocator used by soap_new__ns1__InsBoxInfo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsBoxInfo * SOAP_FMAC2 soap_instantiate__ns1__InsBoxInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:775 */
#ifndef SOAP_TYPE__ns1__InsBoxInfoResponse
#define SOAP_TYPE__ns1__InsBoxInfoResponse (220)
/* complex XSD type 'ns1:InsBoxInfoResponse': */
class SOAP_CMAC _ns1__InsBoxInfoResponse {
      public:
        /// Optional element 'ns1:InsBoxInfoResult' of XSD type 'xsd:string'
        std::string *InsBoxInfoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsBoxInfoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsBoxInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsBoxInfoResponse, default initialized and not managed by a soap context
        virtual _ns1__InsBoxInfoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsBoxInfoResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsBoxInfoResponse() : InsBoxInfoResult(), soap() { }
        virtual ~_ns1__InsBoxInfoResponse() { }
        /// Friend allocator used by soap_new__ns1__InsBoxInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsBoxInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InsBoxInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:778 */
#ifndef SOAP_TYPE__ns1__UpdSnRecInfo
#define SOAP_TYPE__ns1__UpdSnRecInfo (221)
/* complex XSD type 'ns1:UpdSnRecInfo': */
class SOAP_CMAC _ns1__UpdSnRecInfo {
      public:
        /// Optional element 'ns1:MO' of XSD type 'xsd:string'
        std::string *MO;
        /// Optional element 'ns1:PartNo' of XSD type 'xsd:string'
        std::string *PartNo;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:VD' of XSD type 'xsd:string'
        std::string *VD;
        /// Optional element 'ns1:StationNo' of XSD type 'xsd:string'
        std::string *StationNo;
        /// Optional element 'ns1:BoxSN' of XSD type 'xsd:string'
        std::string *BoxSN;
        /// Optional element 'ns1:PkgTime' of XSD type 'xsd:string'
        std::string *PkgTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdSnRecInfo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdSnRecInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdSnRecInfo, default initialized and not managed by a soap context
        virtual _ns1__UpdSnRecInfo *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdSnRecInfo); }
      public:
        /// Constructor with initializations
        _ns1__UpdSnRecInfo() : MO(), PartNo(), SN(), VD(), StationNo(), BoxSN(), PkgTime(), soap() { }
        virtual ~_ns1__UpdSnRecInfo() { }
        /// Friend allocator used by soap_new__ns1__UpdSnRecInfo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdSnRecInfo * SOAP_FMAC2 soap_instantiate__ns1__UpdSnRecInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:781 */
#ifndef SOAP_TYPE__ns1__UpdSnRecInfoResponse
#define SOAP_TYPE__ns1__UpdSnRecInfoResponse (222)
/* complex XSD type 'ns1:UpdSnRecInfoResponse': */
class SOAP_CMAC _ns1__UpdSnRecInfoResponse {
      public:
        /// Optional element 'ns1:UpdSnRecInfoResult' of XSD type 'xsd:string'
        std::string *UpdSnRecInfoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdSnRecInfoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdSnRecInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdSnRecInfoResponse, default initialized and not managed by a soap context
        virtual _ns1__UpdSnRecInfoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdSnRecInfoResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpdSnRecInfoResponse() : UpdSnRecInfoResult(), soap() { }
        virtual ~_ns1__UpdSnRecInfoResponse() { }
        /// Friend allocator used by soap_new__ns1__UpdSnRecInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdSnRecInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdSnRecInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:784 */
#ifndef SOAP_TYPE__ns1__GetMoBase
#define SOAP_TYPE__ns1__GetMoBase (223)
/* complex XSD type 'ns1:GetMoBase': */
class SOAP_CMAC _ns1__GetMoBase {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMoBase
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetMoBase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMoBase, default initialized and not managed by a soap context
        virtual _ns1__GetMoBase *soap_alloc(void) const { return SOAP_NEW(_ns1__GetMoBase); }
      public:
        /// Constructor with initializations
        _ns1__GetMoBase() : MoNumber(), soap() { }
        virtual ~_ns1__GetMoBase() { }
        /// Friend allocator used by soap_new__ns1__GetMoBase(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMoBase * SOAP_FMAC2 soap_instantiate__ns1__GetMoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:787 */
#ifndef SOAP_TYPE__ns1__GetMoBaseResponse
#define SOAP_TYPE__ns1__GetMoBaseResponse (224)
/* complex XSD type 'ns1:GetMoBaseResponse': */
class SOAP_CMAC _ns1__GetMoBaseResponse {
      public:
        /// Optional element 'ns1:GetMoBaseResult' of XSD type 'xsd:string'
        std::string *GetMoBaseResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMoBaseResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetMoBaseResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMoBaseResponse, default initialized and not managed by a soap context
        virtual _ns1__GetMoBaseResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetMoBaseResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetMoBaseResponse() : GetMoBaseResult(), soap() { }
        virtual ~_ns1__GetMoBaseResponse() { }
        /// Friend allocator used by soap_new__ns1__GetMoBaseResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMoBaseResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMoBaseResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:790 */
#ifndef SOAP_TYPE__ns1__GetTestValue
#define SOAP_TYPE__ns1__GetTestValue (225)
/* complex XSD type 'ns1:GetTestValue': */
class SOAP_CMAC _ns1__GetTestValue {
      public:
        /// Optional element 'ns1:SPC' of XSD type 'xsd:string'
        std::string *SPC;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTestValue
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTestValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTestValue, default initialized and not managed by a soap context
        virtual _ns1__GetTestValue *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTestValue); }
      public:
        /// Constructor with initializations
        _ns1__GetTestValue() : SPC(), SN(), soap() { }
        virtual ~_ns1__GetTestValue() { }
        /// Friend allocator used by soap_new__ns1__GetTestValue(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTestValue * SOAP_FMAC2 soap_instantiate__ns1__GetTestValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:793 */
#ifndef SOAP_TYPE__ns1__GetTestValueResponse
#define SOAP_TYPE__ns1__GetTestValueResponse (226)
/* complex XSD type 'ns1:GetTestValueResponse': */
class SOAP_CMAC _ns1__GetTestValueResponse {
      public:
        /// Optional element 'ns1:GetTestValueResult' of XSD type 'xsd:string'
        std::string *GetTestValueResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTestValueResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTestValueResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTestValueResponse, default initialized and not managed by a soap context
        virtual _ns1__GetTestValueResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTestValueResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetTestValueResponse() : GetTestValueResult(), soap() { }
        virtual ~_ns1__GetTestValueResponse() { }
        /// Friend allocator used by soap_new__ns1__GetTestValueResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTestValueResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTestValueResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:796 */
#ifndef SOAP_TYPE__ns1__GetLnkData
#define SOAP_TYPE__ns1__GetLnkData (227)
/* complex XSD type 'ns1:GetLnkData': */
class SOAP_CMAC _ns1__GetLnkData {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLnkData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLnkData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLnkData, default initialized and not managed by a soap context
        virtual _ns1__GetLnkData *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLnkData); }
      public:
        /// Constructor with initializations
        _ns1__GetLnkData() : SN(), soap() { }
        virtual ~_ns1__GetLnkData() { }
        /// Friend allocator used by soap_new__ns1__GetLnkData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLnkData * SOAP_FMAC2 soap_instantiate__ns1__GetLnkData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:799 */
#ifndef SOAP_TYPE__ns1__GetLnkDataResponse
#define SOAP_TYPE__ns1__GetLnkDataResponse (228)
/* complex XSD type 'ns1:GetLnkDataResponse': */
class SOAP_CMAC _ns1__GetLnkDataResponse {
      public:
        /// Optional element 'ns1:GetLnkDataResult' of XSD type 'xsd:string'
        std::string *GetLnkDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLnkDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLnkDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLnkDataResponse, default initialized and not managed by a soap context
        virtual _ns1__GetLnkDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLnkDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetLnkDataResponse() : GetLnkDataResult(), soap() { }
        virtual ~_ns1__GetLnkDataResponse() { }
        /// Friend allocator used by soap_new__ns1__GetLnkDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLnkDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLnkDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:802 */
#ifndef SOAP_TYPE__ns1__InsIotMachineRec
#define SOAP_TYPE__ns1__InsIotMachineRec (229)
/* complex XSD type 'ns1:InsIotMachineRec': */
class SOAP_CMAC _ns1__InsIotMachineRec {
      public:
        /// Optional element 'ns1:Machine' of XSD type 'xsd:string'
        std::string *Machine;
        /// Optional element 'ns1:Hole' of XSD type 'xsd:string'
        std::string *Hole;
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:strStatus' of XSD type 'xsd:string'
        std::string *strStatus;
        /// Optional element 'ns1:ErrCode' of XSD type 'xsd:string'
        std::string *ErrCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsIotMachineRec
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsIotMachineRec; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsIotMachineRec, default initialized and not managed by a soap context
        virtual _ns1__InsIotMachineRec *soap_alloc(void) const { return SOAP_NEW(_ns1__InsIotMachineRec); }
      public:
        /// Constructor with initializations
        _ns1__InsIotMachineRec() : Machine(), Hole(), MoNumber(), strStatus(), ErrCode(), soap() { }
        virtual ~_ns1__InsIotMachineRec() { }
        /// Friend allocator used by soap_new__ns1__InsIotMachineRec(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsIotMachineRec * SOAP_FMAC2 soap_instantiate__ns1__InsIotMachineRec(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:805 */
#ifndef SOAP_TYPE__ns1__InsIotMachineRecResponse
#define SOAP_TYPE__ns1__InsIotMachineRecResponse (230)
/* complex XSD type 'ns1:InsIotMachineRecResponse': */
class SOAP_CMAC _ns1__InsIotMachineRecResponse {
      public:
        /// Optional element 'ns1:InsIotMachineRecResult' of XSD type 'xsd:string'
        std::string *InsIotMachineRecResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsIotMachineRecResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsIotMachineRecResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsIotMachineRecResponse, default initialized and not managed by a soap context
        virtual _ns1__InsIotMachineRecResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsIotMachineRecResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsIotMachineRecResponse() : InsIotMachineRecResult(), soap() { }
        virtual ~_ns1__InsIotMachineRecResponse() { }
        /// Friend allocator used by soap_new__ns1__InsIotMachineRecResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsIotMachineRecResponse * SOAP_FMAC2 soap_instantiate__ns1__InsIotMachineRecResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:808 */
#ifndef SOAP_TYPE__ns1__InsIotTestData
#define SOAP_TYPE__ns1__InsIotTestData (231)
/* complex XSD type 'ns1:InsIotTestData': */
class SOAP_CMAC _ns1__InsIotTestData {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:PartNo' of XSD type 'xsd:string'
        std::string *PartNo;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:Barcode' of XSD type 'xsd:string'
        std::string *Barcode;
        /// Optional element 'ns1:Machine' of XSD type 'xsd:string'
        std::string *Machine;
        /// Optional element 'ns1:Hole' of XSD type 'xsd:string'
        std::string *Hole;
        /// Optional element 'ns1:TestTime' of XSD type 'xsd:string'
        std::string *TestTime;
        /// Optional element 'ns1:strResult' of XSD type 'xsd:string'
        std::string *strResult;
        /// Optional element 'ns1:ErrCode' of XSD type 'xsd:string'
        std::string *ErrCode;
        /// Optional element 'ns1:TC1' of XSD type 'xsd:string'
        std::string *TC1;
        /// Optional element 'ns1:TC2' of XSD type 'xsd:string'
        std::string *TC2;
        /// Optional element 'ns1:TC3' of XSD type 'xsd:string'
        std::string *TC3;
        /// Optional element 'ns1:TC4' of XSD type 'xsd:string'
        std::string *TC4;
        /// Optional element 'ns1:DT1' of XSD type 'xsd:string'
        std::string *DT1;
        /// Optional element 'ns1:DT2' of XSD type 'xsd:string'
        std::string *DT2;
        /// Optional element 'ns1:DT3' of XSD type 'xsd:string'
        std::string *DT3;
        /// Optional element 'ns1:DT4' of XSD type 'xsd:string'
        std::string *DT4;
        /// Optional element 'ns1:TotalTestTime' of XSD type 'xsd:string'
        std::string *TotalTestTime;
        /// Optional element 'ns1:UserID' of XSD type 'xsd:string'
        std::string *UserID;
        /// Optional element 'ns1:Memo1' of XSD type 'xsd:string'
        std::string *Memo1;
        /// Optional element 'ns1:Memo2' of XSD type 'xsd:string'
        std::string *Memo2;
        /// Optional element 'ns1:Memo3' of XSD type 'xsd:string'
        std::string *Memo3;
        /// Optional element 'ns1:Memo4' of XSD type 'xsd:string'
        std::string *Memo4;
        /// Optional element 'ns1:Memo5' of XSD type 'xsd:string'
        std::string *Memo5;
        /// Optional element 'ns1:Memo6' of XSD type 'xsd:string'
        std::string *Memo6;
        /// Optional element 'ns1:Memo7' of XSD type 'xsd:string'
        std::string *Memo7;
        /// Optional element 'ns1:Memo8' of XSD type 'xsd:string'
        std::string *Memo8;
        /// Optional element 'ns1:Memo9' of XSD type 'xsd:string'
        std::string *Memo9;
        /// Optional element 'ns1:Memo10' of XSD type 'xsd:string'
        std::string *Memo10;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsIotTestData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsIotTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsIotTestData, default initialized and not managed by a soap context
        virtual _ns1__InsIotTestData *soap_alloc(void) const { return SOAP_NEW(_ns1__InsIotTestData); }
      public:
        /// Constructor with initializations
        _ns1__InsIotTestData() : MoNumber(), PartNo(), StationNumber(), Barcode(), Machine(), Hole(), TestTime(), strResult(), ErrCode(), TC1(), TC2(), TC3(), TC4(), DT1(), DT2(), DT3(), DT4(), TotalTestTime(), UserID(), Memo1(), Memo2(), Memo3(), Memo4(), Memo5(), Memo6(), Memo7(), Memo8(), Memo9(), Memo10(), soap() { }
        virtual ~_ns1__InsIotTestData() { }
        /// Friend allocator used by soap_new__ns1__InsIotTestData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsIotTestData * SOAP_FMAC2 soap_instantiate__ns1__InsIotTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:811 */
#ifndef SOAP_TYPE__ns1__InsIotTestDataResponse
#define SOAP_TYPE__ns1__InsIotTestDataResponse (232)
/* complex XSD type 'ns1:InsIotTestDataResponse': */
class SOAP_CMAC _ns1__InsIotTestDataResponse {
      public:
        /// Optional element 'ns1:InsIotTestDataResult' of XSD type 'xsd:string'
        std::string *InsIotTestDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsIotTestDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsIotTestDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsIotTestDataResponse, default initialized and not managed by a soap context
        virtual _ns1__InsIotTestDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsIotTestDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsIotTestDataResponse() : InsIotTestDataResult(), soap() { }
        virtual ~_ns1__InsIotTestDataResponse() { }
        /// Friend allocator used by soap_new__ns1__InsIotTestDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsIotTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__InsIotTestDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:814 */
#ifndef SOAP_TYPE__ns1__chkDispensing
#define SOAP_TYPE__ns1__chkDispensing (233)
/* complex XSD type 'ns1:chkDispensing': */
class SOAP_CMAC _ns1__chkDispensing {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkDispensing
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkDispensing; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkDispensing, default initialized and not managed by a soap context
        virtual _ns1__chkDispensing *soap_alloc(void) const { return SOAP_NEW(_ns1__chkDispensing); }
      public:
        /// Constructor with initializations
        _ns1__chkDispensing() : SN(), soap() { }
        virtual ~_ns1__chkDispensing() { }
        /// Friend allocator used by soap_new__ns1__chkDispensing(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkDispensing * SOAP_FMAC2 soap_instantiate__ns1__chkDispensing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:817 */
#ifndef SOAP_TYPE__ns1__chkDispensingResponse
#define SOAP_TYPE__ns1__chkDispensingResponse (234)
/* complex XSD type 'ns1:chkDispensingResponse': */
class SOAP_CMAC _ns1__chkDispensingResponse {
      public:
        /// Optional element 'ns1:chkDispensingResult' of XSD type 'xsd:string'
        std::string *chkDispensingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkDispensingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkDispensingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkDispensingResponse, default initialized and not managed by a soap context
        virtual _ns1__chkDispensingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkDispensingResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkDispensingResponse() : chkDispensingResult(), soap() { }
        virtual ~_ns1__chkDispensingResponse() { }
        /// Friend allocator used by soap_new__ns1__chkDispensingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkDispensingResponse * SOAP_FMAC2 soap_instantiate__ns1__chkDispensingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:820 */
#ifndef SOAP_TYPE__ns1__chkZJSN
#define SOAP_TYPE__ns1__chkZJSN (235)
/* complex XSD type 'ns1:chkZJSN': */
class SOAP_CMAC _ns1__chkZJSN {
      public:
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:strType' of XSD type 'xsd:string'
        std::string *strType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkZJSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkZJSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkZJSN, default initialized and not managed by a soap context
        virtual _ns1__chkZJSN *soap_alloc(void) const { return SOAP_NEW(_ns1__chkZJSN); }
      public:
        /// Constructor with initializations
        _ns1__chkZJSN() : ZJSN(), StationNumber(), strType(), soap() { }
        virtual ~_ns1__chkZJSN() { }
        /// Friend allocator used by soap_new__ns1__chkZJSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkZJSN * SOAP_FMAC2 soap_instantiate__ns1__chkZJSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:823 */
#ifndef SOAP_TYPE__ns1__chkZJSNResponse
#define SOAP_TYPE__ns1__chkZJSNResponse (236)
/* complex XSD type 'ns1:chkZJSNResponse': */
class SOAP_CMAC _ns1__chkZJSNResponse {
      public:
        /// Optional element 'ns1:chkZJSNResult' of XSD type 'xsd:string'
        std::string *chkZJSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkZJSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkZJSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkZJSNResponse, default initialized and not managed by a soap context
        virtual _ns1__chkZJSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkZJSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkZJSNResponse() : chkZJSNResult(), soap() { }
        virtual ~_ns1__chkZJSNResponse() { }
        /// Friend allocator used by soap_new__ns1__chkZJSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkZJSNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkZJSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:826 */
#ifndef SOAP_TYPE__ns1__LnkZJSN
#define SOAP_TYPE__ns1__LnkZJSN (237)
/* complex XSD type 'ns1:LnkZJSN': */
class SOAP_CMAC _ns1__LnkZJSN {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LnkZJSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LnkZJSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LnkZJSN, default initialized and not managed by a soap context
        virtual _ns1__LnkZJSN *soap_alloc(void) const { return SOAP_NEW(_ns1__LnkZJSN); }
      public:
        /// Constructor with initializations
        _ns1__LnkZJSN() : Emp(), SN(), ZJSN(), StationNumber(), soap() { }
        virtual ~_ns1__LnkZJSN() { }
        /// Friend allocator used by soap_new__ns1__LnkZJSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LnkZJSN * SOAP_FMAC2 soap_instantiate__ns1__LnkZJSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:829 */
#ifndef SOAP_TYPE__ns1__LnkZJSNResponse
#define SOAP_TYPE__ns1__LnkZJSNResponse (238)
/* complex XSD type 'ns1:LnkZJSNResponse': */
class SOAP_CMAC _ns1__LnkZJSNResponse {
      public:
        /// Optional element 'ns1:LnkZJSNResult' of XSD type 'xsd:string'
        std::string *LnkZJSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LnkZJSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LnkZJSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LnkZJSNResponse, default initialized and not managed by a soap context
        virtual _ns1__LnkZJSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LnkZJSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__LnkZJSNResponse() : LnkZJSNResult(), soap() { }
        virtual ~_ns1__LnkZJSNResponse() { }
        /// Friend allocator used by soap_new__ns1__LnkZJSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LnkZJSNResponse * SOAP_FMAC2 soap_instantiate__ns1__LnkZJSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:832 */
#ifndef SOAP_TYPE__ns1__LnkSideSN
#define SOAP_TYPE__ns1__LnkSideSN (239)
/* complex XSD type 'ns1:LnkSideSN': */
class SOAP_CMAC _ns1__LnkSideSN {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Optional element 'ns1:LnkSN' of XSD type 'xsd:string'
        std::string *LnkSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Optional element 'ns1:strType' of XSD type 'xsd:string'
        std::string *strType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LnkSideSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LnkSideSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LnkSideSN, default initialized and not managed by a soap context
        virtual _ns1__LnkSideSN *soap_alloc(void) const { return SOAP_NEW(_ns1__LnkSideSN); }
      public:
        /// Constructor with initializations
        _ns1__LnkSideSN() : Emp(), ZJSN(), LnkSN(), StationNumber(), strType(), soap() { }
        virtual ~_ns1__LnkSideSN() { }
        /// Friend allocator used by soap_new__ns1__LnkSideSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LnkSideSN * SOAP_FMAC2 soap_instantiate__ns1__LnkSideSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:835 */
#ifndef SOAP_TYPE__ns1__LnkSideSNResponse
#define SOAP_TYPE__ns1__LnkSideSNResponse (240)
/* complex XSD type 'ns1:LnkSideSNResponse': */
class SOAP_CMAC _ns1__LnkSideSNResponse {
      public:
        /// Optional element 'ns1:LnkSideSNResult' of XSD type 'xsd:string'
        std::string *LnkSideSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LnkSideSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LnkSideSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LnkSideSNResponse, default initialized and not managed by a soap context
        virtual _ns1__LnkSideSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LnkSideSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__LnkSideSNResponse() : LnkSideSNResult(), soap() { }
        virtual ~_ns1__LnkSideSNResponse() { }
        /// Friend allocator used by soap_new__ns1__LnkSideSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LnkSideSNResponse * SOAP_FMAC2 soap_instantiate__ns1__LnkSideSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:838 */
#ifndef SOAP_TYPE__ns1__chkGrillSN
#define SOAP_TYPE__ns1__chkGrillSN (241)
/* complex XSD type 'ns1:chkGrillSN': */
class SOAP_CMAC _ns1__chkGrillSN {
      public:
        /// Optional element 'ns1:GrillSN' of XSD type 'xsd:string'
        std::string *GrillSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkGrillSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkGrillSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkGrillSN, default initialized and not managed by a soap context
        virtual _ns1__chkGrillSN *soap_alloc(void) const { return SOAP_NEW(_ns1__chkGrillSN); }
      public:
        /// Constructor with initializations
        _ns1__chkGrillSN() : GrillSN(), soap() { }
        virtual ~_ns1__chkGrillSN() { }
        /// Friend allocator used by soap_new__ns1__chkGrillSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkGrillSN * SOAP_FMAC2 soap_instantiate__ns1__chkGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:841 */
#ifndef SOAP_TYPE__ns1__chkGrillSNResponse
#define SOAP_TYPE__ns1__chkGrillSNResponse (242)
/* complex XSD type 'ns1:chkGrillSNResponse': */
class SOAP_CMAC _ns1__chkGrillSNResponse {
      public:
        /// Optional element 'ns1:chkGrillSNResult' of XSD type 'xsd:string'
        std::string *chkGrillSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__chkGrillSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__chkGrillSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__chkGrillSNResponse, default initialized and not managed by a soap context
        virtual _ns1__chkGrillSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__chkGrillSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__chkGrillSNResponse() : chkGrillSNResult(), soap() { }
        virtual ~_ns1__chkGrillSNResponse() { }
        /// Friend allocator used by soap_new__ns1__chkGrillSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__chkGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkGrillSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:844 */
#ifndef SOAP_TYPE__ns1__LnkGrillSN
#define SOAP_TYPE__ns1__LnkGrillSN (243)
/* complex XSD type 'ns1:LnkGrillSN': */
class SOAP_CMAC _ns1__LnkGrillSN {
      public:
        /// Optional element 'ns1:GrillSN' of XSD type 'xsd:string'
        std::string *GrillSN;
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LnkGrillSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LnkGrillSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LnkGrillSN, default initialized and not managed by a soap context
        virtual _ns1__LnkGrillSN *soap_alloc(void) const { return SOAP_NEW(_ns1__LnkGrillSN); }
      public:
        /// Constructor with initializations
        _ns1__LnkGrillSN() : GrillSN(), ZJSN(), StationNumber(), soap() { }
        virtual ~_ns1__LnkGrillSN() { }
        /// Friend allocator used by soap_new__ns1__LnkGrillSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LnkGrillSN * SOAP_FMAC2 soap_instantiate__ns1__LnkGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:847 */
#ifndef SOAP_TYPE__ns1__LnkGrillSNResponse
#define SOAP_TYPE__ns1__LnkGrillSNResponse (244)
/* complex XSD type 'ns1:LnkGrillSNResponse': */
class SOAP_CMAC _ns1__LnkGrillSNResponse {
      public:
        /// Optional element 'ns1:LnkGrillSNResult' of XSD type 'xsd:string'
        std::string *LnkGrillSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LnkGrillSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LnkGrillSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LnkGrillSNResponse, default initialized and not managed by a soap context
        virtual _ns1__LnkGrillSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LnkGrillSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__LnkGrillSNResponse() : LnkGrillSNResult(), soap() { }
        virtual ~_ns1__LnkGrillSNResponse() { }
        /// Friend allocator used by soap_new__ns1__LnkGrillSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LnkGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__LnkGrillSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:850 */
#ifndef SOAP_TYPE__ns1__CloseGrillSN
#define SOAP_TYPE__ns1__CloseGrillSN (245)
/* complex XSD type 'ns1:CloseGrillSN': */
class SOAP_CMAC _ns1__CloseGrillSN {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:GrillSN' of XSD type 'xsd:string'
        std::string *GrillSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseGrillSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseGrillSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseGrillSN, default initialized and not managed by a soap context
        virtual _ns1__CloseGrillSN *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseGrillSN); }
      public:
        /// Constructor with initializations
        _ns1__CloseGrillSN() : Emp(), GrillSN(), StationNumber(), soap() { }
        virtual ~_ns1__CloseGrillSN() { }
        /// Friend allocator used by soap_new__ns1__CloseGrillSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseGrillSN * SOAP_FMAC2 soap_instantiate__ns1__CloseGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:853 */
#ifndef SOAP_TYPE__ns1__CloseGrillSNResponse
#define SOAP_TYPE__ns1__CloseGrillSNResponse (246)
/* complex XSD type 'ns1:CloseGrillSNResponse': */
class SOAP_CMAC _ns1__CloseGrillSNResponse {
      public:
        /// Optional element 'ns1:CloseGrillSNResult' of XSD type 'xsd:string'
        std::string *CloseGrillSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseGrillSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseGrillSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseGrillSNResponse, default initialized and not managed by a soap context
        virtual _ns1__CloseGrillSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseGrillSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__CloseGrillSNResponse() : CloseGrillSNResult(), soap() { }
        virtual ~_ns1__CloseGrillSNResponse() { }
        /// Friend allocator used by soap_new__ns1__CloseGrillSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseGrillSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:856 */
#ifndef SOAP_TYPE__ns1__InsGrillBySN
#define SOAP_TYPE__ns1__InsGrillBySN (247)
/* complex XSD type 'ns1:InsGrillBySN': */
class SOAP_CMAC _ns1__InsGrillBySN {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:GrillSN' of XSD type 'xsd:string'
        std::string *GrillSN;
        /// Optional element 'ns1:OvenSN' of XSD type 'xsd:string'
        std::string *OvenSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsGrillBySN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsGrillBySN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsGrillBySN, default initialized and not managed by a soap context
        virtual _ns1__InsGrillBySN *soap_alloc(void) const { return SOAP_NEW(_ns1__InsGrillBySN); }
      public:
        /// Constructor with initializations
        _ns1__InsGrillBySN() : Emp(), GrillSN(), OvenSN(), StationNumber(), soap() { }
        virtual ~_ns1__InsGrillBySN() { }
        /// Friend allocator used by soap_new__ns1__InsGrillBySN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsGrillBySN * SOAP_FMAC2 soap_instantiate__ns1__InsGrillBySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:859 */
#ifndef SOAP_TYPE__ns1__InsGrillBySNResponse
#define SOAP_TYPE__ns1__InsGrillBySNResponse (248)
/* complex XSD type 'ns1:InsGrillBySNResponse': */
class SOAP_CMAC _ns1__InsGrillBySNResponse {
      public:
        /// Optional element 'ns1:InsGrillBySNResult' of XSD type 'xsd:string'
        std::string *InsGrillBySNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsGrillBySNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsGrillBySNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsGrillBySNResponse, default initialized and not managed by a soap context
        virtual _ns1__InsGrillBySNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsGrillBySNResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsGrillBySNResponse() : InsGrillBySNResult(), soap() { }
        virtual ~_ns1__InsGrillBySNResponse() { }
        /// Friend allocator used by soap_new__ns1__InsGrillBySNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsGrillBySNResponse * SOAP_FMAC2 soap_instantiate__ns1__InsGrillBySNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:862 */
#ifndef SOAP_TYPE__ns1__GetGrillTime
#define SOAP_TYPE__ns1__GetGrillTime (249)
/* complex XSD type 'ns1:GetGrillTime': */
class SOAP_CMAC _ns1__GetGrillTime {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetGrillTime
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetGrillTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetGrillTime, default initialized and not managed by a soap context
        virtual _ns1__GetGrillTime *soap_alloc(void) const { return SOAP_NEW(_ns1__GetGrillTime); }
      public:
        /// Constructor with initializations
        _ns1__GetGrillTime() : soap() { }
        virtual ~_ns1__GetGrillTime() { }
        /// Friend allocator used by soap_new__ns1__GetGrillTime(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetGrillTime * SOAP_FMAC2 soap_instantiate__ns1__GetGrillTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:865 */
#ifndef SOAP_TYPE__ns1__GetGrillTimeResponse
#define SOAP_TYPE__ns1__GetGrillTimeResponse (250)
/* complex XSD type 'ns1:GetGrillTimeResponse': */
class SOAP_CMAC _ns1__GetGrillTimeResponse {
      public:
        /// Optional element 'ns1:GetGrillTimeResult' of XSD type 'xsd:string'
        std::string *GetGrillTimeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetGrillTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetGrillTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetGrillTimeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetGrillTimeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetGrillTimeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetGrillTimeResponse() : GetGrillTimeResult(), soap() { }
        virtual ~_ns1__GetGrillTimeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetGrillTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetGrillTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetGrillTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:868 */
#ifndef SOAP_TYPE__ns1__OutGrillBySN
#define SOAP_TYPE__ns1__OutGrillBySN (251)
/* complex XSD type 'ns1:OutGrillBySN': */
class SOAP_CMAC _ns1__OutGrillBySN {
      public:
        /// Optional element 'ns1:Emp' of XSD type 'xsd:string'
        std::string *Emp;
        /// Optional element 'ns1:GrillSN' of XSD type 'xsd:string'
        std::string *GrillSN;
        /// Optional element 'ns1:StationNumber' of XSD type 'xsd:string'
        std::string *StationNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutGrillBySN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OutGrillBySN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutGrillBySN, default initialized and not managed by a soap context
        virtual _ns1__OutGrillBySN *soap_alloc(void) const { return SOAP_NEW(_ns1__OutGrillBySN); }
      public:
        /// Constructor with initializations
        _ns1__OutGrillBySN() : Emp(), GrillSN(), StationNumber(), soap() { }
        virtual ~_ns1__OutGrillBySN() { }
        /// Friend allocator used by soap_new__ns1__OutGrillBySN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutGrillBySN * SOAP_FMAC2 soap_instantiate__ns1__OutGrillBySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:871 */
#ifndef SOAP_TYPE__ns1__OutGrillBySNResponse
#define SOAP_TYPE__ns1__OutGrillBySNResponse (252)
/* complex XSD type 'ns1:OutGrillBySNResponse': */
class SOAP_CMAC _ns1__OutGrillBySNResponse {
      public:
        /// Optional element 'ns1:OutGrillBySNResult' of XSD type 'xsd:string'
        std::string *OutGrillBySNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OutGrillBySNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OutGrillBySNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OutGrillBySNResponse, default initialized and not managed by a soap context
        virtual _ns1__OutGrillBySNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__OutGrillBySNResponse); }
      public:
        /// Constructor with initializations
        _ns1__OutGrillBySNResponse() : OutGrillBySNResult(), soap() { }
        virtual ~_ns1__OutGrillBySNResponse() { }
        /// Friend allocator used by soap_new__ns1__OutGrillBySNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OutGrillBySNResponse * SOAP_FMAC2 soap_instantiate__ns1__OutGrillBySNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:874 */
#ifndef SOAP_TYPE__ns1__CancelGrillSN
#define SOAP_TYPE__ns1__CancelGrillSN (253)
/* complex XSD type 'ns1:CancelGrillSN': */
class SOAP_CMAC _ns1__CancelGrillSN {
      public:
        /// Optional element 'ns1:GrillSN' of XSD type 'xsd:string'
        std::string *GrillSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelGrillSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelGrillSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelGrillSN, default initialized and not managed by a soap context
        virtual _ns1__CancelGrillSN *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelGrillSN); }
      public:
        /// Constructor with initializations
        _ns1__CancelGrillSN() : GrillSN(), soap() { }
        virtual ~_ns1__CancelGrillSN() { }
        /// Friend allocator used by soap_new__ns1__CancelGrillSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelGrillSN * SOAP_FMAC2 soap_instantiate__ns1__CancelGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:877 */
#ifndef SOAP_TYPE__ns1__CancelGrillSNResponse
#define SOAP_TYPE__ns1__CancelGrillSNResponse (254)
/* complex XSD type 'ns1:CancelGrillSNResponse': */
class SOAP_CMAC _ns1__CancelGrillSNResponse {
      public:
        /// Optional element 'ns1:CancelGrillSNResult' of XSD type 'xsd:string'
        std::string *CancelGrillSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelGrillSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelGrillSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelGrillSNResponse, default initialized and not managed by a soap context
        virtual _ns1__CancelGrillSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelGrillSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__CancelGrillSNResponse() : CancelGrillSNResult(), soap() { }
        virtual ~_ns1__CancelGrillSNResponse() { }
        /// Friend allocator used by soap_new__ns1__CancelGrillSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelGrillSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:880 */
#ifndef SOAP_TYPE__ns1__CancelLnkSN
#define SOAP_TYPE__ns1__CancelLnkSN (255)
/* complex XSD type 'ns1:CancelLnkSN': */
class SOAP_CMAC _ns1__CancelLnkSN {
      public:
        /// Optional element 'ns1:ZJSN' of XSD type 'xsd:string'
        std::string *ZJSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelLnkSN
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelLnkSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelLnkSN, default initialized and not managed by a soap context
        virtual _ns1__CancelLnkSN *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelLnkSN); }
      public:
        /// Constructor with initializations
        _ns1__CancelLnkSN() : ZJSN(), soap() { }
        virtual ~_ns1__CancelLnkSN() { }
        /// Friend allocator used by soap_new__ns1__CancelLnkSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelLnkSN * SOAP_FMAC2 soap_instantiate__ns1__CancelLnkSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:883 */
#ifndef SOAP_TYPE__ns1__CancelLnkSNResponse
#define SOAP_TYPE__ns1__CancelLnkSNResponse (256)
/* complex XSD type 'ns1:CancelLnkSNResponse': */
class SOAP_CMAC _ns1__CancelLnkSNResponse {
      public:
        /// Optional element 'ns1:CancelLnkSNResult' of XSD type 'xsd:string'
        std::string *CancelLnkSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelLnkSNResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelLnkSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelLnkSNResponse, default initialized and not managed by a soap context
        virtual _ns1__CancelLnkSNResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelLnkSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__CancelLnkSNResponse() : CancelLnkSNResult(), soap() { }
        virtual ~_ns1__CancelLnkSNResponse() { }
        /// Friend allocator used by soap_new__ns1__CancelLnkSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelLnkSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelLnkSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:886 */
#ifndef SOAP_TYPE__ns1__GetWeightSet
#define SOAP_TYPE__ns1__GetWeightSet (257)
/* complex XSD type 'ns1:GetWeightSet': */
class SOAP_CMAC _ns1__GetWeightSet {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        std::string *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWeightSet
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetWeightSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWeightSet, default initialized and not managed by a soap context
        virtual _ns1__GetWeightSet *soap_alloc(void) const { return SOAP_NEW(_ns1__GetWeightSet); }
      public:
        /// Constructor with initializations
        _ns1__GetWeightSet() : SN(), soap() { }
        virtual ~_ns1__GetWeightSet() { }
        /// Friend allocator used by soap_new__ns1__GetWeightSet(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWeightSet * SOAP_FMAC2 soap_instantiate__ns1__GetWeightSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:889 */
#ifndef SOAP_TYPE__ns1__GetWeightSetResponse
#define SOAP_TYPE__ns1__GetWeightSetResponse (258)
/* complex XSD type 'ns1:GetWeightSetResponse': */
class SOAP_CMAC _ns1__GetWeightSetResponse {
      public:
        /// Optional element 'ns1:GetWeightSetResult' of XSD type 'xsd:string'
        std::string *GetWeightSetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWeightSetResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetWeightSetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWeightSetResponse, default initialized and not managed by a soap context
        virtual _ns1__GetWeightSetResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetWeightSetResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetWeightSetResponse() : GetWeightSetResult(), soap() { }
        virtual ~_ns1__GetWeightSetResponse() { }
        /// Friend allocator used by soap_new__ns1__GetWeightSetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWeightSetResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWeightSetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:892 */
#ifndef SOAP_TYPE__ns1__GetPackToWMS
#define SOAP_TYPE__ns1__GetPackToWMS (259)
/* complex XSD type 'ns1:GetPackToWMS': */
class SOAP_CMAC _ns1__GetPackToWMS {
      public:
        /// Optional element 'ns1:CartonNo' of XSD type 'xsd:string'
        std::string *CartonNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPackToWMS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPackToWMS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPackToWMS, default initialized and not managed by a soap context
        virtual _ns1__GetPackToWMS *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPackToWMS); }
      public:
        /// Constructor with initializations
        _ns1__GetPackToWMS() : CartonNo(), soap() { }
        virtual ~_ns1__GetPackToWMS() { }
        /// Friend allocator used by soap_new__ns1__GetPackToWMS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPackToWMS * SOAP_FMAC2 soap_instantiate__ns1__GetPackToWMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:895 */
#ifndef SOAP_TYPE__ns1__GetPackToWMSResponse
#define SOAP_TYPE__ns1__GetPackToWMSResponse (260)
/* complex XSD type 'ns1:GetPackToWMSResponse': */
class SOAP_CMAC _ns1__GetPackToWMSResponse {
      public:
        /// Optional element 'ns1:GetPackToWMSResult' of XSD type 'xsd:string'
        std::string *GetPackToWMSResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPackToWMSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPackToWMSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPackToWMSResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPackToWMSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPackToWMSResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPackToWMSResponse() : GetPackToWMSResult(), soap() { }
        virtual ~_ns1__GetPackToWMSResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPackToWMSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPackToWMSResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPackToWMSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:898 */
#ifndef SOAP_TYPE__ns1__GetPallentToWMS
#define SOAP_TYPE__ns1__GetPallentToWMS (261)
/* complex XSD type 'ns1:GetPallentToWMS': */
class SOAP_CMAC _ns1__GetPallentToWMS {
      public:
        /// Optional element 'ns1:PallentNo' of XSD type 'xsd:string'
        std::string *PallentNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPallentToWMS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPallentToWMS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPallentToWMS, default initialized and not managed by a soap context
        virtual _ns1__GetPallentToWMS *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPallentToWMS); }
      public:
        /// Constructor with initializations
        _ns1__GetPallentToWMS() : PallentNo(), soap() { }
        virtual ~_ns1__GetPallentToWMS() { }
        /// Friend allocator used by soap_new__ns1__GetPallentToWMS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPallentToWMS * SOAP_FMAC2 soap_instantiate__ns1__GetPallentToWMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:7225 */
#ifndef SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult
#define SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult (313)
/* complex XSD type 'ns1:GetPallentToWMSResponse-GetPallentToWMSResult': */
class SOAP_CMAC _ns1__GetPallentToWMSResponse_GetPallentToWMSResult {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPallentToWMSResponse_GetPallentToWMSResult, default initialized and not managed by a soap context
        virtual _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult); }
      public:
        /// Constructor with initializations
        _ns1__GetPallentToWMSResponse_GetPallentToWMSResult() : __any(), __any_() { }
        virtual ~_ns1__GetPallentToWMSResponse_GetPallentToWMSResult() { }
        /// Friend allocator used by soap_new__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPallentToWMSResponse_GetPallentToWMSResult * SOAP_FMAC2 soap_instantiate__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:901 */
#ifndef SOAP_TYPE__ns1__GetPallentToWMSResponse
#define SOAP_TYPE__ns1__GetPallentToWMSResponse (262)
/* complex XSD type 'ns1:GetPallentToWMSResponse': */
class SOAP_CMAC _ns1__GetPallentToWMSResponse {
      public:
        /// Optional element 'ns1:GetPallentToWMSResult' of XSD type 'ns1:GetPallentToWMSResponse-GetPallentToWMSResult'
        _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *GetPallentToWMSResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPallentToWMSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPallentToWMSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPallentToWMSResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPallentToWMSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPallentToWMSResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPallentToWMSResponse() : GetPallentToWMSResult(), soap() { }
        virtual ~_ns1__GetPallentToWMSResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPallentToWMSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPallentToWMSResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPallentToWMSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:904 */
#ifndef SOAP_TYPE__ns1__SetPallentForWMS
#define SOAP_TYPE__ns1__SetPallentForWMS (263)
/* complex XSD type 'ns1:SetPallentForWMS': */
class SOAP_CMAC _ns1__SetPallentForWMS {
      public:
        /// Optional element 'ns1:OldPallentNo' of XSD type 'xsd:string'
        std::string *OldPallentNo;
        /// Optional element 'ns1:PallentNo' of XSD type 'xsd:string'
        std::string *PallentNo;
        /// Optional element 'ns1:CartonNo' of XSD type 'xsd:string'
        std::string *CartonNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetPallentForWMS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetPallentForWMS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetPallentForWMS, default initialized and not managed by a soap context
        virtual _ns1__SetPallentForWMS *soap_alloc(void) const { return SOAP_NEW(_ns1__SetPallentForWMS); }
      public:
        /// Constructor with initializations
        _ns1__SetPallentForWMS() : OldPallentNo(), PallentNo(), CartonNo(), soap() { }
        virtual ~_ns1__SetPallentForWMS() { }
        /// Friend allocator used by soap_new__ns1__SetPallentForWMS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetPallentForWMS * SOAP_FMAC2 soap_instantiate__ns1__SetPallentForWMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:907 */
#ifndef SOAP_TYPE__ns1__SetPallentForWMSResponse
#define SOAP_TYPE__ns1__SetPallentForWMSResponse (264)
/* complex XSD type 'ns1:SetPallentForWMSResponse': */
class SOAP_CMAC _ns1__SetPallentForWMSResponse {
      public:
        /// Optional element 'ns1:SetPallentForWMSResult' of XSD type 'xsd:string'
        std::string *SetPallentForWMSResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetPallentForWMSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetPallentForWMSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetPallentForWMSResponse, default initialized and not managed by a soap context
        virtual _ns1__SetPallentForWMSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetPallentForWMSResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetPallentForWMSResponse() : SetPallentForWMSResult(), soap() { }
        virtual ~_ns1__SetPallentForWMSResponse() { }
        /// Friend allocator used by soap_new__ns1__SetPallentForWMSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetPallentForWMSResponse * SOAP_FMAC2 soap_instantiate__ns1__SetPallentForWMSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:910 */
#ifndef SOAP_TYPE__ns1__GetPackStation
#define SOAP_TYPE__ns1__GetPackStation (265)
/* complex XSD type 'ns1:GetPackStation': */
class SOAP_CMAC _ns1__GetPackStation {
      public:
        /// Optional element 'ns1:CartonNo' of XSD type 'xsd:string'
        std::string *CartonNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPackStation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPackStation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPackStation, default initialized and not managed by a soap context
        virtual _ns1__GetPackStation *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPackStation); }
      public:
        /// Constructor with initializations
        _ns1__GetPackStation() : CartonNo(), soap() { }
        virtual ~_ns1__GetPackStation() { }
        /// Friend allocator used by soap_new__ns1__GetPackStation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPackStation * SOAP_FMAC2 soap_instantiate__ns1__GetPackStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:913 */
#ifndef SOAP_TYPE__ns1__GetPackStationResponse
#define SOAP_TYPE__ns1__GetPackStationResponse (266)
/* complex XSD type 'ns1:GetPackStationResponse': */
class SOAP_CMAC _ns1__GetPackStationResponse {
      public:
        /// Optional element 'ns1:GetPackStationResult' of XSD type 'xsd:string'
        std::string *GetPackStationResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPackStationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPackStationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPackStationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPackStationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPackStationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPackStationResponse() : GetPackStationResult(), soap() { }
        virtual ~_ns1__GetPackStationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPackStationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPackStationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPackStationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:916 */
#ifndef SOAP_TYPE__ns1__GetPackWeigth
#define SOAP_TYPE__ns1__GetPackWeigth (267)
/* complex XSD type 'ns1:GetPackWeigth': */
class SOAP_CMAC _ns1__GetPackWeigth {
      public:
        /// Optional element 'ns1:CartonNo' of XSD type 'xsd:string'
        std::string *CartonNo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPackWeigth
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPackWeigth; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPackWeigth, default initialized and not managed by a soap context
        virtual _ns1__GetPackWeigth *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPackWeigth); }
      public:
        /// Constructor with initializations
        _ns1__GetPackWeigth() : CartonNo(), soap() { }
        virtual ~_ns1__GetPackWeigth() { }
        /// Friend allocator used by soap_new__ns1__GetPackWeigth(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPackWeigth * SOAP_FMAC2 soap_instantiate__ns1__GetPackWeigth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:919 */
#ifndef SOAP_TYPE__ns1__GetPackWeigthResponse
#define SOAP_TYPE__ns1__GetPackWeigthResponse (268)
/* complex XSD type 'ns1:GetPackWeigthResponse': */
class SOAP_CMAC _ns1__GetPackWeigthResponse {
      public:
        /// Optional element 'ns1:GetPackWeigthResult' of XSD type 'xsd:string'
        std::string *GetPackWeigthResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPackWeigthResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPackWeigthResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPackWeigthResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPackWeigthResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPackWeigthResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPackWeigthResponse() : GetPackWeigthResult(), soap() { }
        virtual ~_ns1__GetPackWeigthResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPackWeigthResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPackWeigthResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPackWeigthResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:922 */
#ifndef SOAP_TYPE__ns1__GetAhsMo
#define SOAP_TYPE__ns1__GetAhsMo (269)
/* complex XSD type 'ns1:GetAhsMo': */
class SOAP_CMAC _ns1__GetAhsMo {
      public:
        /// Optional element 'ns1:MoNumber' of XSD type 'xsd:string'
        std::string *MoNumber;
        /// Optional element 'ns1:sDate' of XSD type 'xsd:string'
        std::string *sDate;
        /// Optional element 'ns1:eDate' of XSD type 'xsd:string'
        std::string *eDate;
        /// Optional element 'ns1:PrintType' of XSD type 'xsd:string'
        std::string *PrintType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAhsMo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAhsMo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAhsMo, default initialized and not managed by a soap context
        virtual _ns1__GetAhsMo *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAhsMo); }
      public:
        /// Constructor with initializations
        _ns1__GetAhsMo() : MoNumber(), sDate(), eDate(), PrintType(), soap() { }
        virtual ~_ns1__GetAhsMo() { }
        /// Friend allocator used by soap_new__ns1__GetAhsMo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAhsMo * SOAP_FMAC2 soap_instantiate__ns1__GetAhsMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:7429 */
#ifndef SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult
#define SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult (315)
/* complex XSD type 'ns1:GetAhsMoResponse-GetAhsMoResult': */
class SOAP_CMAC _ns1__GetAhsMoResponse_GetAhsMoResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAhsMoResponse_GetAhsMoResult, default initialized and not managed by a soap context
        virtual _ns1__GetAhsMoResponse_GetAhsMoResult *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAhsMoResponse_GetAhsMoResult); }
      public:
        /// Constructor with initializations
        _ns1__GetAhsMoResponse_GetAhsMoResult() : xsd__schema(), __any() { }
        virtual ~_ns1__GetAhsMoResponse_GetAhsMoResult() { }
        /// Friend allocator used by soap_new__ns1__GetAhsMoResponse_GetAhsMoResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAhsMoResponse_GetAhsMoResult * SOAP_FMAC2 soap_instantiate__ns1__GetAhsMoResponse_GetAhsMoResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:925 */
#ifndef SOAP_TYPE__ns1__GetAhsMoResponse
#define SOAP_TYPE__ns1__GetAhsMoResponse (270)
/* complex XSD type 'ns1:GetAhsMoResponse': */
class SOAP_CMAC _ns1__GetAhsMoResponse {
      public:
        /// Optional element 'ns1:GetAhsMoResult' of XSD type 'ns1:GetAhsMoResponse-GetAhsMoResult'
        _ns1__GetAhsMoResponse_GetAhsMoResult *GetAhsMoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAhsMoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAhsMoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAhsMoResponse, default initialized and not managed by a soap context
        virtual _ns1__GetAhsMoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAhsMoResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetAhsMoResponse() : GetAhsMoResult(), soap() { }
        virtual ~_ns1__GetAhsMoResponse() { }
        /// Friend allocator used by soap_new__ns1__GetAhsMoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAhsMoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAhsMoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8103 */
#ifndef SOAP_TYPE___ns1__GetAhsBarcode
#define SOAP_TYPE___ns1__GetAhsBarcode (320)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAhsBarcode {
      public:
        /** Optional element 'ns1:GetAhsBarcode' of XSD type 'ns1:GetAhsBarcode' */
        _ns1__GetAhsBarcode *ns1__GetAhsBarcode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAhsBarcode */
        int soap_type() const { return SOAP_TYPE___ns1__GetAhsBarcode; }
        /** Constructor with member initializations */
        __ns1__GetAhsBarcode() : ns1__GetAhsBarcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetAhsBarcode * SOAP_FMAC2 soap_instantiate___ns1__GetAhsBarcode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8173 */
#ifndef SOAP_TYPE___ns1__UpdAhsBarcode
#define SOAP_TYPE___ns1__UpdAhsBarcode (324)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdAhsBarcode {
      public:
        /** Optional element 'ns1:UpdAhsBarcode' of XSD type 'ns1:UpdAhsBarcode' */
        _ns1__UpdAhsBarcode *ns1__UpdAhsBarcode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdAhsBarcode */
        int soap_type() const { return SOAP_TYPE___ns1__UpdAhsBarcode; }
        /** Constructor with member initializations */
        __ns1__UpdAhsBarcode() : ns1__UpdAhsBarcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdAhsBarcode * SOAP_FMAC2 soap_instantiate___ns1__UpdAhsBarcode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8243 */
#ifndef SOAP_TYPE___ns1__ChkWeightTime
#define SOAP_TYPE___ns1__ChkWeightTime (328)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkWeightTime {
      public:
        /** Optional element 'ns1:ChkWeightTime' of XSD type 'ns1:ChkWeightTime' */
        _ns1__ChkWeightTime *ns1__ChkWeightTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkWeightTime */
        int soap_type() const { return SOAP_TYPE___ns1__ChkWeightTime; }
        /** Constructor with member initializations */
        __ns1__ChkWeightTime() : ns1__ChkWeightTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkWeightTime * SOAP_FMAC2 soap_instantiate___ns1__ChkWeightTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8313 */
#ifndef SOAP_TYPE___ns1__InsSNTest
#define SOAP_TYPE___ns1__InsSNTest (332)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsSNTest {
      public:
        /** Optional element 'ns1:InsSNTest' of XSD type 'ns1:InsSNTest' */
        _ns1__InsSNTest *ns1__InsSNTest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsSNTest */
        int soap_type() const { return SOAP_TYPE___ns1__InsSNTest; }
        /** Constructor with member initializations */
        __ns1__InsSNTest() : ns1__InsSNTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsSNTest * SOAP_FMAC2 soap_instantiate___ns1__InsSNTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8383 */
#ifndef SOAP_TYPE___ns1__SelSNTest
#define SOAP_TYPE___ns1__SelSNTest (336)
/* Wrapper: */
struct SOAP_CMAC __ns1__SelSNTest {
      public:
        /** Optional element 'ns1:SelSNTest' of XSD type 'ns1:SelSNTest' */
        _ns1__SelSNTest *ns1__SelSNTest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelSNTest */
        int soap_type() const { return SOAP_TYPE___ns1__SelSNTest; }
        /** Constructor with member initializations */
        __ns1__SelSNTest() : ns1__SelSNTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SelSNTest * SOAP_FMAC2 soap_instantiate___ns1__SelSNTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8453 */
#ifndef SOAP_TYPE___ns1__DelSNTest
#define SOAP_TYPE___ns1__DelSNTest (340)
/* Wrapper: */
struct SOAP_CMAC __ns1__DelSNTest {
      public:
        /** Optional element 'ns1:DelSNTest' of XSD type 'ns1:DelSNTest' */
        _ns1__DelSNTest *ns1__DelSNTest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DelSNTest */
        int soap_type() const { return SOAP_TYPE___ns1__DelSNTest; }
        /** Constructor with member initializations */
        __ns1__DelSNTest() : ns1__DelSNTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DelSNTest * SOAP_FMAC2 soap_instantiate___ns1__DelSNTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8523 */
#ifndef SOAP_TYPE___ns1__ChkSnLinkForApple
#define SOAP_TYPE___ns1__ChkSnLinkForApple (344)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnLinkForApple {
      public:
        /** Optional element 'ns1:ChkSnLinkForApple' of XSD type 'ns1:ChkSnLinkForApple' */
        _ns1__ChkSnLinkForApple *ns1__ChkSnLinkForApple;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnLinkForApple */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnLinkForApple; }
        /** Constructor with member initializations */
        __ns1__ChkSnLinkForApple() : ns1__ChkSnLinkForApple() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnLinkForApple * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLinkForApple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8593 */
#ifndef SOAP_TYPE___ns1__doSnLinkForApple
#define SOAP_TYPE___ns1__doSnLinkForApple (348)
/* Wrapper: */
struct SOAP_CMAC __ns1__doSnLinkForApple {
      public:
        /** Optional element 'ns1:doSnLinkForApple' of XSD type 'ns1:doSnLinkForApple' */
        _ns1__doSnLinkForApple *ns1__doSnLinkForApple;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doSnLinkForApple */
        int soap_type() const { return SOAP_TYPE___ns1__doSnLinkForApple; }
        /** Constructor with member initializations */
        __ns1__doSnLinkForApple() : ns1__doSnLinkForApple() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doSnLinkForApple * SOAP_FMAC2 soap_instantiate___ns1__doSnLinkForApple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8663 */
#ifndef SOAP_TYPE___ns1__GetObeNW
#define SOAP_TYPE___ns1__GetObeNW (352)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetObeNW {
      public:
        /** Optional element 'ns1:GetObeNW' of XSD type 'ns1:GetObeNW' */
        _ns1__GetObeNW *ns1__GetObeNW;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetObeNW */
        int soap_type() const { return SOAP_TYPE___ns1__GetObeNW; }
        /** Constructor with member initializations */
        __ns1__GetObeNW() : ns1__GetObeNW() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetObeNW * SOAP_FMAC2 soap_instantiate___ns1__GetObeNW(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8733 */
#ifndef SOAP_TYPE___ns1__GetFruitSNCheck
#define SOAP_TYPE___ns1__GetFruitSNCheck (356)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFruitSNCheck {
      public:
        /** Optional element 'ns1:GetFruitSNCheck' of XSD type 'ns1:GetFruitSNCheck' */
        _ns1__GetFruitSNCheck *ns1__GetFruitSNCheck;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFruitSNCheck */
        int soap_type() const { return SOAP_TYPE___ns1__GetFruitSNCheck; }
        /** Constructor with member initializations */
        __ns1__GetFruitSNCheck() : ns1__GetFruitSNCheck() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetFruitSNCheck * SOAP_FMAC2 soap_instantiate___ns1__GetFruitSNCheck(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8803 */
#ifndef SOAP_TYPE___ns1__GetLotLinkCount
#define SOAP_TYPE___ns1__GetLotLinkCount (360)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLotLinkCount {
      public:
        /** Optional element 'ns1:GetLotLinkCount' of XSD type 'ns1:GetLotLinkCount' */
        _ns1__GetLotLinkCount *ns1__GetLotLinkCount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLotLinkCount */
        int soap_type() const { return SOAP_TYPE___ns1__GetLotLinkCount; }
        /** Constructor with member initializations */
        __ns1__GetLotLinkCount() : ns1__GetLotLinkCount() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLotLinkCount * SOAP_FMAC2 soap_instantiate___ns1__GetLotLinkCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8873 */
#ifndef SOAP_TYPE___ns1__doLotLinkForApple
#define SOAP_TYPE___ns1__doLotLinkForApple (364)
/* Wrapper: */
struct SOAP_CMAC __ns1__doLotLinkForApple {
      public:
        /** Optional element 'ns1:doLotLinkForApple' of XSD type 'ns1:doLotLinkForApple' */
        _ns1__doLotLinkForApple *ns1__doLotLinkForApple;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doLotLinkForApple */
        int soap_type() const { return SOAP_TYPE___ns1__doLotLinkForApple; }
        /** Constructor with member initializations */
        __ns1__doLotLinkForApple() : ns1__doLotLinkForApple() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doLotLinkForApple * SOAP_FMAC2 soap_instantiate___ns1__doLotLinkForApple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:8943 */
#ifndef SOAP_TYPE___ns1__GetShippingList
#define SOAP_TYPE___ns1__GetShippingList (368)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingList {
      public:
        /** Optional element 'ns1:GetShippingList' of XSD type 'ns1:GetShippingList' */
        _ns1__GetShippingList *ns1__GetShippingList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingList */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingList; }
        /** Constructor with member initializations */
        __ns1__GetShippingList() : ns1__GetShippingList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingList * SOAP_FMAC2 soap_instantiate___ns1__GetShippingList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9013 */
#ifndef SOAP_TYPE___ns1__GetShippingBerthList
#define SOAP_TYPE___ns1__GetShippingBerthList (372)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingBerthList {
      public:
        /** Optional element 'ns1:GetShippingBerthList' of XSD type 'ns1:GetShippingBerthList' */
        _ns1__GetShippingBerthList *ns1__GetShippingBerthList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingBerthList */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingBerthList; }
        /** Constructor with member initializations */
        __ns1__GetShippingBerthList() : ns1__GetShippingBerthList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingBerthList * SOAP_FMAC2 soap_instantiate___ns1__GetShippingBerthList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9083 */
#ifndef SOAP_TYPE___ns1__UpdShipping
#define SOAP_TYPE___ns1__UpdShipping (376)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdShipping {
      public:
        /** Optional element 'ns1:UpdShipping' of XSD type 'ns1:UpdShipping' */
        _ns1__UpdShipping *ns1__UpdShipping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdShipping */
        int soap_type() const { return SOAP_TYPE___ns1__UpdShipping; }
        /** Constructor with member initializations */
        __ns1__UpdShipping() : ns1__UpdShipping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdShipping * SOAP_FMAC2 soap_instantiate___ns1__UpdShipping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9153 */
#ifndef SOAP_TYPE___ns1__GetShippingPalle
#define SOAP_TYPE___ns1__GetShippingPalle (380)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingPalle {
      public:
        /** Optional element 'ns1:GetShippingPalle' of XSD type 'ns1:GetShippingPalle' */
        _ns1__GetShippingPalle *ns1__GetShippingPalle;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingPalle */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingPalle; }
        /** Constructor with member initializations */
        __ns1__GetShippingPalle() : ns1__GetShippingPalle() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingPalle * SOAP_FMAC2 soap_instantiate___ns1__GetShippingPalle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9223 */
#ifndef SOAP_TYPE___ns1__InsShippingPalle
#define SOAP_TYPE___ns1__InsShippingPalle (384)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsShippingPalle {
      public:
        /** Optional element 'ns1:InsShippingPalle' of XSD type 'ns1:InsShippingPalle' */
        _ns1__InsShippingPalle *ns1__InsShippingPalle;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsShippingPalle */
        int soap_type() const { return SOAP_TYPE___ns1__InsShippingPalle; }
        /** Constructor with member initializations */
        __ns1__InsShippingPalle() : ns1__InsShippingPalle() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsShippingPalle * SOAP_FMAC2 soap_instantiate___ns1__InsShippingPalle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9293 */
#ifndef SOAP_TYPE___ns1__InsShippingBerth
#define SOAP_TYPE___ns1__InsShippingBerth (388)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsShippingBerth {
      public:
        /** Optional element 'ns1:InsShippingBerth' of XSD type 'ns1:InsShippingBerth' */
        _ns1__InsShippingBerth *ns1__InsShippingBerth;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsShippingBerth */
        int soap_type() const { return SOAP_TYPE___ns1__InsShippingBerth; }
        /** Constructor with member initializations */
        __ns1__InsShippingBerth() : ns1__InsShippingBerth() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsShippingBerth * SOAP_FMAC2 soap_instantiate___ns1__InsShippingBerth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9363 */
#ifndef SOAP_TYPE___ns1__GetShippingForBerth
#define SOAP_TYPE___ns1__GetShippingForBerth (392)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingForBerth {
      public:
        /** Optional element 'ns1:GetShippingForBerth' of XSD type 'ns1:GetShippingForBerth' */
        _ns1__GetShippingForBerth *ns1__GetShippingForBerth;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingForBerth */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingForBerth; }
        /** Constructor with member initializations */
        __ns1__GetShippingForBerth() : ns1__GetShippingForBerth() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingForBerth * SOAP_FMAC2 soap_instantiate___ns1__GetShippingForBerth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9433 */
#ifndef SOAP_TYPE___ns1__GetShippingWeight
#define SOAP_TYPE___ns1__GetShippingWeight (396)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingWeight {
      public:
        /** Optional element 'ns1:GetShippingWeight' of XSD type 'ns1:GetShippingWeight' */
        _ns1__GetShippingWeight *ns1__GetShippingWeight;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingWeight */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingWeight; }
        /** Constructor with member initializations */
        __ns1__GetShippingWeight() : ns1__GetShippingWeight() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingWeight * SOAP_FMAC2 soap_instantiate___ns1__GetShippingWeight(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9503 */
#ifndef SOAP_TYPE___ns1__getStationByMoForTestPad
#define SOAP_TYPE___ns1__getStationByMoForTestPad (400)
/* Wrapper: */
struct SOAP_CMAC __ns1__getStationByMoForTestPad {
      public:
        /** Optional element 'ns1:getStationByMoForTestPad' of XSD type 'ns1:getStationByMoForTestPad' */
        _ns1__getStationByMoForTestPad *ns1__getStationByMoForTestPad;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getStationByMoForTestPad */
        int soap_type() const { return SOAP_TYPE___ns1__getStationByMoForTestPad; }
        /** Constructor with member initializations */
        __ns1__getStationByMoForTestPad() : ns1__getStationByMoForTestPad() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getStationByMoForTestPad * SOAP_FMAC2 soap_instantiate___ns1__getStationByMoForTestPad(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9573 */
#ifndef SOAP_TYPE___ns1__SetFlatnessFruitRec
#define SOAP_TYPE___ns1__SetFlatnessFruitRec (404)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetFlatnessFruitRec {
      public:
        /** Optional element 'ns1:SetFlatnessFruitRec' of XSD type 'ns1:SetFlatnessFruitRec' */
        _ns1__SetFlatnessFruitRec *ns1__SetFlatnessFruitRec;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetFlatnessFruitRec */
        int soap_type() const { return SOAP_TYPE___ns1__SetFlatnessFruitRec; }
        /** Constructor with member initializations */
        __ns1__SetFlatnessFruitRec() : ns1__SetFlatnessFruitRec() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetFlatnessFruitRec * SOAP_FMAC2 soap_instantiate___ns1__SetFlatnessFruitRec(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9643 */
#ifndef SOAP_TYPE___ns1__GetSNForLink
#define SOAP_TYPE___ns1__GetSNForLink (408)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSNForLink {
      public:
        /** Optional element 'ns1:GetSNForLink' of XSD type 'ns1:GetSNForLink' */
        _ns1__GetSNForLink *ns1__GetSNForLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSNForLink */
        int soap_type() const { return SOAP_TYPE___ns1__GetSNForLink; }
        /** Constructor with member initializations */
        __ns1__GetSNForLink() : ns1__GetSNForLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetSNForLink * SOAP_FMAC2 soap_instantiate___ns1__GetSNForLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9713 */
#ifndef SOAP_TYPE___ns1__SetAutoLineRec
#define SOAP_TYPE___ns1__SetAutoLineRec (412)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetAutoLineRec {
      public:
        /** Optional element 'ns1:SetAutoLineRec' of XSD type 'ns1:SetAutoLineRec' */
        _ns1__SetAutoLineRec *ns1__SetAutoLineRec;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetAutoLineRec */
        int soap_type() const { return SOAP_TYPE___ns1__SetAutoLineRec; }
        /** Constructor with member initializations */
        __ns1__SetAutoLineRec() : ns1__SetAutoLineRec() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetAutoLineRec * SOAP_FMAC2 soap_instantiate___ns1__SetAutoLineRec(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9783 */
#ifndef SOAP_TYPE___ns1__HPSNLinkBasket
#define SOAP_TYPE___ns1__HPSNLinkBasket (416)
/* Wrapper: */
struct SOAP_CMAC __ns1__HPSNLinkBasket {
      public:
        /** Optional element 'ns1:HPSNLinkBasket' of XSD type 'ns1:HPSNLinkBasket' */
        _ns1__HPSNLinkBasket *ns1__HPSNLinkBasket;
      public:
        /** Return unique type id SOAP_TYPE___ns1__HPSNLinkBasket */
        int soap_type() const { return SOAP_TYPE___ns1__HPSNLinkBasket; }
        /** Constructor with member initializations */
        __ns1__HPSNLinkBasket() : ns1__HPSNLinkBasket() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__HPSNLinkBasket * SOAP_FMAC2 soap_instantiate___ns1__HPSNLinkBasket(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9853 */
#ifndef SOAP_TYPE___ns1__BasketLinkPunch
#define SOAP_TYPE___ns1__BasketLinkPunch (420)
/* Wrapper: */
struct SOAP_CMAC __ns1__BasketLinkPunch {
      public:
        /** Optional element 'ns1:BasketLinkPunch' of XSD type 'ns1:BasketLinkPunch' */
        _ns1__BasketLinkPunch *ns1__BasketLinkPunch;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BasketLinkPunch */
        int soap_type() const { return SOAP_TYPE___ns1__BasketLinkPunch; }
        /** Constructor with member initializations */
        __ns1__BasketLinkPunch() : ns1__BasketLinkPunch() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BasketLinkPunch * SOAP_FMAC2 soap_instantiate___ns1__BasketLinkPunch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9923 */
#ifndef SOAP_TYPE___ns1__PunchOut
#define SOAP_TYPE___ns1__PunchOut (424)
/* Wrapper: */
struct SOAP_CMAC __ns1__PunchOut {
      public:
        /** Optional element 'ns1:PunchOut' of XSD type 'ns1:PunchOut' */
        _ns1__PunchOut *ns1__PunchOut;
      public:
        /** Return unique type id SOAP_TYPE___ns1__PunchOut */
        int soap_type() const { return SOAP_TYPE___ns1__PunchOut; }
        /** Constructor with member initializations */
        __ns1__PunchOut() : ns1__PunchOut() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__PunchOut * SOAP_FMAC2 soap_instantiate___ns1__PunchOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:9993 */
#ifndef SOAP_TYPE___ns1__chkMoSNForAOI
#define SOAP_TYPE___ns1__chkMoSNForAOI (428)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkMoSNForAOI {
      public:
        /** Optional element 'ns1:chkMoSNForAOI' of XSD type 'ns1:chkMoSNForAOI' */
        _ns1__chkMoSNForAOI *ns1__chkMoSNForAOI;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkMoSNForAOI */
        int soap_type() const { return SOAP_TYPE___ns1__chkMoSNForAOI; }
        /** Constructor with member initializations */
        __ns1__chkMoSNForAOI() : ns1__chkMoSNForAOI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkMoSNForAOI * SOAP_FMAC2 soap_instantiate___ns1__chkMoSNForAOI(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10063 */
#ifndef SOAP_TYPE___ns1__InsAoiMo
#define SOAP_TYPE___ns1__InsAoiMo (432)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsAoiMo {
      public:
        /** Optional element 'ns1:InsAoiMo' of XSD type 'ns1:InsAoiMo' */
        _ns1__InsAoiMo *ns1__InsAoiMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsAoiMo */
        int soap_type() const { return SOAP_TYPE___ns1__InsAoiMo; }
        /** Constructor with member initializations */
        __ns1__InsAoiMo() : ns1__InsAoiMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsAoiMo * SOAP_FMAC2 soap_instantiate___ns1__InsAoiMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10133 */
#ifndef SOAP_TYPE___ns1__InsCLScada
#define SOAP_TYPE___ns1__InsCLScada (436)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsCLScada {
      public:
        /** Optional element 'ns1:InsCLScada' of XSD type 'ns1:InsCLScada' */
        _ns1__InsCLScada *ns1__InsCLScada;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsCLScada */
        int soap_type() const { return SOAP_TYPE___ns1__InsCLScada; }
        /** Constructor with member initializations */
        __ns1__InsCLScada() : ns1__InsCLScada() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsCLScada * SOAP_FMAC2 soap_instantiate___ns1__InsCLScada(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10203 */
#ifndef SOAP_TYPE___ns1__GetTestValueResult
#define SOAP_TYPE___ns1__GetTestValueResult (440)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTestValueResult {
      public:
        /** Optional element 'ns1:GetTestValueResult' of XSD type 'ns1:GetTestValueResult' */
        _ns1__GetTestValueResult *ns1__GetTestValueResult;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTestValueResult */
        int soap_type() const { return SOAP_TYPE___ns1__GetTestValueResult; }
        /** Constructor with member initializations */
        __ns1__GetTestValueResult() : ns1__GetTestValueResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTestValueResult * SOAP_FMAC2 soap_instantiate___ns1__GetTestValueResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10273 */
#ifndef SOAP_TYPE___ns1__GetStationNumberForSN
#define SOAP_TYPE___ns1__GetStationNumberForSN (444)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetStationNumberForSN {
      public:
        /** Optional element 'ns1:GetStationNumberForSN' of XSD type 'ns1:GetStationNumberForSN' */
        _ns1__GetStationNumberForSN *ns1__GetStationNumberForSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetStationNumberForSN */
        int soap_type() const { return SOAP_TYPE___ns1__GetStationNumberForSN; }
        /** Constructor with member initializations */
        __ns1__GetStationNumberForSN() : ns1__GetStationNumberForSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetStationNumberForSN * SOAP_FMAC2 soap_instantiate___ns1__GetStationNumberForSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10343 */
#ifndef SOAP_TYPE___ns1__InsSNTestForFruit
#define SOAP_TYPE___ns1__InsSNTestForFruit (448)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsSNTestForFruit {
      public:
        /** Optional element 'ns1:InsSNTestForFruit' of XSD type 'ns1:InsSNTestForFruit' */
        _ns1__InsSNTestForFruit *ns1__InsSNTestForFruit;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsSNTestForFruit */
        int soap_type() const { return SOAP_TYPE___ns1__InsSNTestForFruit; }
        /** Constructor with member initializations */
        __ns1__InsSNTestForFruit() : ns1__InsSNTestForFruit() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsSNTestForFruit * SOAP_FMAC2 soap_instantiate___ns1__InsSNTestForFruit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10413 */
#ifndef SOAP_TYPE___ns1__SelSNTestForFruit
#define SOAP_TYPE___ns1__SelSNTestForFruit (452)
/* Wrapper: */
struct SOAP_CMAC __ns1__SelSNTestForFruit {
      public:
        /** Optional element 'ns1:SelSNTestForFruit' of XSD type 'ns1:SelSNTestForFruit' */
        _ns1__SelSNTestForFruit *ns1__SelSNTestForFruit;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelSNTestForFruit */
        int soap_type() const { return SOAP_TYPE___ns1__SelSNTestForFruit; }
        /** Constructor with member initializations */
        __ns1__SelSNTestForFruit() : ns1__SelSNTestForFruit() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SelSNTestForFruit * SOAP_FMAC2 soap_instantiate___ns1__SelSNTestForFruit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10483 */
#ifndef SOAP_TYPE___ns1__SNLinkShelf
#define SOAP_TYPE___ns1__SNLinkShelf (456)
/* Wrapper: */
struct SOAP_CMAC __ns1__SNLinkShelf {
      public:
        /** Optional element 'ns1:SNLinkShelf' of XSD type 'ns1:SNLinkShelf' */
        _ns1__SNLinkShelf *ns1__SNLinkShelf;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SNLinkShelf */
        int soap_type() const { return SOAP_TYPE___ns1__SNLinkShelf; }
        /** Constructor with member initializations */
        __ns1__SNLinkShelf() : ns1__SNLinkShelf() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SNLinkShelf * SOAP_FMAC2 soap_instantiate___ns1__SNLinkShelf(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10553 */
#ifndef SOAP_TYPE___ns1__SelShelfLink
#define SOAP_TYPE___ns1__SelShelfLink (460)
/* Wrapper: */
struct SOAP_CMAC __ns1__SelShelfLink {
      public:
        /** Optional element 'ns1:SelShelfLink' of XSD type 'ns1:SelShelfLink' */
        _ns1__SelShelfLink *ns1__SelShelfLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelShelfLink */
        int soap_type() const { return SOAP_TYPE___ns1__SelShelfLink; }
        /** Constructor with member initializations */
        __ns1__SelShelfLink() : ns1__SelShelfLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SelShelfLink * SOAP_FMAC2 soap_instantiate___ns1__SelShelfLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10623 */
#ifndef SOAP_TYPE___ns1__UploadForHP
#define SOAP_TYPE___ns1__UploadForHP (464)
/* Wrapper: */
struct SOAP_CMAC __ns1__UploadForHP {
      public:
        /** Optional element 'ns1:UploadForHP' of XSD type 'ns1:UploadForHP' */
        _ns1__UploadForHP *ns1__UploadForHP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UploadForHP */
        int soap_type() const { return SOAP_TYPE___ns1__UploadForHP; }
        /** Constructor with member initializations */
        __ns1__UploadForHP() : ns1__UploadForHP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UploadForHP * SOAP_FMAC2 soap_instantiate___ns1__UploadForHP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10693 */
#ifndef SOAP_TYPE___ns1__GetMachineForGroup
#define SOAP_TYPE___ns1__GetMachineForGroup (468)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMachineForGroup {
      public:
        /** Optional element 'ns1:GetMachineForGroup' of XSD type 'ns1:GetMachineForGroup' */
        _ns1__GetMachineForGroup *ns1__GetMachineForGroup;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMachineForGroup */
        int soap_type() const { return SOAP_TYPE___ns1__GetMachineForGroup; }
        /** Constructor with member initializations */
        __ns1__GetMachineForGroup() : ns1__GetMachineForGroup() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMachineForGroup * SOAP_FMAC2 soap_instantiate___ns1__GetMachineForGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10763 */
#ifndef SOAP_TYPE___ns1__SetDiecastSN
#define SOAP_TYPE___ns1__SetDiecastSN (472)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDiecastSN {
      public:
        /** Optional element 'ns1:SetDiecastSN' of XSD type 'ns1:SetDiecastSN' */
        _ns1__SetDiecastSN *ns1__SetDiecastSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDiecastSN */
        int soap_type() const { return SOAP_TYPE___ns1__SetDiecastSN; }
        /** Constructor with member initializations */
        __ns1__SetDiecastSN() : ns1__SetDiecastSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetDiecastSN * SOAP_FMAC2 soap_instantiate___ns1__SetDiecastSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10833 */
#ifndef SOAP_TYPE___ns1__GetNgCode
#define SOAP_TYPE___ns1__GetNgCode (476)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetNgCode {
      public:
        /** Optional element 'ns1:GetNgCode' of XSD type 'ns1:GetNgCode' */
        _ns1__GetNgCode *ns1__GetNgCode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetNgCode */
        int soap_type() const { return SOAP_TYPE___ns1__GetNgCode; }
        /** Constructor with member initializations */
        __ns1__GetNgCode() : ns1__GetNgCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetNgCode * SOAP_FMAC2 soap_instantiate___ns1__GetNgCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10903 */
#ifndef SOAP_TYPE___ns1__getMoBase
#define SOAP_TYPE___ns1__getMoBase (480)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMoBase {
      public:
        /** Optional element 'ns1:getMoBase' of XSD type 'ns1:getMoBase' */
        _ns1__getMoBase *ns1__getMoBase;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMoBase */
        int soap_type() const { return SOAP_TYPE___ns1__getMoBase; }
        /** Constructor with member initializations */
        __ns1__getMoBase() : ns1__getMoBase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMoBase * SOAP_FMAC2 soap_instantiate___ns1__getMoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:10973 */
#ifndef SOAP_TYPE___ns1__SnLnkOutSN
#define SOAP_TYPE___ns1__SnLnkOutSN (484)
/* Wrapper: */
struct SOAP_CMAC __ns1__SnLnkOutSN {
      public:
        /** Optional element 'ns1:SnLnkOutSN' of XSD type 'ns1:SnLnkOutSN' */
        _ns1__SnLnkOutSN *ns1__SnLnkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SnLnkOutSN */
        int soap_type() const { return SOAP_TYPE___ns1__SnLnkOutSN; }
        /** Constructor with member initializations */
        __ns1__SnLnkOutSN() : ns1__SnLnkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SnLnkOutSN * SOAP_FMAC2 soap_instantiate___ns1__SnLnkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11043 */
#ifndef SOAP_TYPE___ns1__InsFruitMachineChk
#define SOAP_TYPE___ns1__InsFruitMachineChk (488)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFruitMachineChk {
      public:
        /** Optional element 'ns1:InsFruitMachineChk' of XSD type 'ns1:InsFruitMachineChk' */
        _ns1__InsFruitMachineChk *ns1__InsFruitMachineChk;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFruitMachineChk */
        int soap_type() const { return SOAP_TYPE___ns1__InsFruitMachineChk; }
        /** Constructor with member initializations */
        __ns1__InsFruitMachineChk() : ns1__InsFruitMachineChk() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFruitMachineChk * SOAP_FMAC2 soap_instantiate___ns1__InsFruitMachineChk(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11113 */
#ifndef SOAP_TYPE___ns1__GetFruitMachineChk
#define SOAP_TYPE___ns1__GetFruitMachineChk (492)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFruitMachineChk {
      public:
        /** Optional element 'ns1:GetFruitMachineChk' of XSD type 'ns1:GetFruitMachineChk' */
        _ns1__GetFruitMachineChk *ns1__GetFruitMachineChk;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFruitMachineChk */
        int soap_type() const { return SOAP_TYPE___ns1__GetFruitMachineChk; }
        /** Constructor with member initializations */
        __ns1__GetFruitMachineChk() : ns1__GetFruitMachineChk() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetFruitMachineChk * SOAP_FMAC2 soap_instantiate___ns1__GetFruitMachineChk(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11183 */
#ifndef SOAP_TYPE___ns1__InsZjList
#define SOAP_TYPE___ns1__InsZjList (496)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsZjList {
      public:
        /** Optional element 'ns1:InsZjList' of XSD type 'ns1:InsZjList' */
        _ns1__InsZjList *ns1__InsZjList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsZjList */
        int soap_type() const { return SOAP_TYPE___ns1__InsZjList; }
        /** Constructor with member initializations */
        __ns1__InsZjList() : ns1__InsZjList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsZjList * SOAP_FMAC2 soap_instantiate___ns1__InsZjList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11253 */
#ifndef SOAP_TYPE___ns1__checkTestData
#define SOAP_TYPE___ns1__checkTestData (500)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkTestData {
      public:
        /** Optional element 'ns1:checkTestData' of XSD type 'ns1:checkTestData' */
        _ns1__checkTestData *ns1__checkTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkTestData */
        int soap_type() const { return SOAP_TYPE___ns1__checkTestData; }
        /** Constructor with member initializations */
        __ns1__checkTestData() : ns1__checkTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkTestData * SOAP_FMAC2 soap_instantiate___ns1__checkTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11323 */
#ifndef SOAP_TYPE___ns1__checkEmpNo
#define SOAP_TYPE___ns1__checkEmpNo (504)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkEmpNo {
      public:
        /** Optional element 'ns1:checkEmpNo' of XSD type 'ns1:checkEmpNo' */
        _ns1__checkEmpNo *ns1__checkEmpNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkEmpNo */
        int soap_type() const { return SOAP_TYPE___ns1__checkEmpNo; }
        /** Constructor with member initializations */
        __ns1__checkEmpNo() : ns1__checkEmpNo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkEmpNo * SOAP_FMAC2 soap_instantiate___ns1__checkEmpNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11393 */
#ifndef SOAP_TYPE___ns1__checkSN_USCOREStation
#define SOAP_TYPE___ns1__checkSN_USCOREStation (508)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkSN_USCOREStation {
      public:
        /** Optional element 'ns1:checkSN_Station' of XSD type 'ns1:checkSN_Station' */
        _ns1__checkSN_USCOREStation *ns1__checkSN_USCOREStation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkSN_USCOREStation */
        int soap_type() const { return SOAP_TYPE___ns1__checkSN_USCOREStation; }
        /** Constructor with member initializations */
        __ns1__checkSN_USCOREStation() : ns1__checkSN_USCOREStation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkSN_USCOREStation * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11463 */
#ifndef SOAP_TYPE___ns1__sendTestData
#define SOAP_TYPE___ns1__sendTestData (512)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendTestData {
      public:
        /** Optional element 'ns1:sendTestData' of XSD type 'ns1:sendTestData' */
        _ns1__sendTestData *ns1__sendTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendTestData */
        int soap_type() const { return SOAP_TYPE___ns1__sendTestData; }
        /** Constructor with member initializations */
        __ns1__sendTestData() : ns1__sendTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendTestData * SOAP_FMAC2 soap_instantiate___ns1__sendTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11533 */
#ifndef SOAP_TYPE___ns1__sendTestResult
#define SOAP_TYPE___ns1__sendTestResult (516)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendTestResult {
      public:
        /** Optional element 'ns1:sendTestResult' of XSD type 'ns1:sendTestResult' */
        _ns1__sendTestResult *ns1__sendTestResult;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendTestResult */
        int soap_type() const { return SOAP_TYPE___ns1__sendTestResult; }
        /** Constructor with member initializations */
        __ns1__sendTestResult() : ns1__sendTestResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendTestResult * SOAP_FMAC2 soap_instantiate___ns1__sendTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11603 */
#ifndef SOAP_TYPE___ns1__InFruitsOrtQty
#define SOAP_TYPE___ns1__InFruitsOrtQty (520)
/* Wrapper: */
struct SOAP_CMAC __ns1__InFruitsOrtQty {
      public:
        /** Optional element 'ns1:InFruitsOrtQty' of XSD type 'ns1:InFruitsOrtQty' */
        _ns1__InFruitsOrtQty *ns1__InFruitsOrtQty;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InFruitsOrtQty */
        int soap_type() const { return SOAP_TYPE___ns1__InFruitsOrtQty; }
        /** Constructor with member initializations */
        __ns1__InFruitsOrtQty() : ns1__InFruitsOrtQty() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InFruitsOrtQty * SOAP_FMAC2 soap_instantiate___ns1__InFruitsOrtQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11673 */
#ifndef SOAP_TYPE___ns1__chkStationTime
#define SOAP_TYPE___ns1__chkStationTime (524)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkStationTime {
      public:
        /** Optional element 'ns1:chkStationTime' of XSD type 'ns1:chkStationTime' */
        _ns1__chkStationTime *ns1__chkStationTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkStationTime */
        int soap_type() const { return SOAP_TYPE___ns1__chkStationTime; }
        /** Constructor with member initializations */
        __ns1__chkStationTime() : ns1__chkStationTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkStationTime * SOAP_FMAC2 soap_instantiate___ns1__chkStationTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11743 */
#ifndef SOAP_TYPE___ns1__ImpMesAteTestData
#define SOAP_TYPE___ns1__ImpMesAteTestData (528)
/* Wrapper: */
struct SOAP_CMAC __ns1__ImpMesAteTestData {
      public:
        /** Optional element 'ns1:ImpMesAteTestData' of XSD type 'ns1:ImpMesAteTestData' */
        _ns1__ImpMesAteTestData *ns1__ImpMesAteTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ImpMesAteTestData */
        int soap_type() const { return SOAP_TYPE___ns1__ImpMesAteTestData; }
        /** Constructor with member initializations */
        __ns1__ImpMesAteTestData() : ns1__ImpMesAteTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ImpMesAteTestData * SOAP_FMAC2 soap_instantiate___ns1__ImpMesAteTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11813 */
#ifndef SOAP_TYPE___ns1__InsFlatNess
#define SOAP_TYPE___ns1__InsFlatNess (532)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFlatNess {
      public:
        /** Optional element 'ns1:InsFlatNess' of XSD type 'ns1:InsFlatNess' */
        _ns1__InsFlatNess *ns1__InsFlatNess;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFlatNess */
        int soap_type() const { return SOAP_TYPE___ns1__InsFlatNess; }
        /** Constructor with member initializations */
        __ns1__InsFlatNess() : ns1__InsFlatNess() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFlatNess * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11883 */
#ifndef SOAP_TYPE___ns1__InsFlatNessForLSD
#define SOAP_TYPE___ns1__InsFlatNessForLSD (536)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFlatNessForLSD {
      public:
        /** Optional element 'ns1:InsFlatNessForLSD' of XSD type 'ns1:InsFlatNessForLSD' */
        _ns1__InsFlatNessForLSD *ns1__InsFlatNessForLSD;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFlatNessForLSD */
        int soap_type() const { return SOAP_TYPE___ns1__InsFlatNessForLSD; }
        /** Constructor with member initializations */
        __ns1__InsFlatNessForLSD() : ns1__InsFlatNessForLSD() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFlatNessForLSD * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForLSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:11953 */
#ifndef SOAP_TYPE___ns1__InsFlatNessForCL
#define SOAP_TYPE___ns1__InsFlatNessForCL (540)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFlatNessForCL {
      public:
        /** Optional element 'ns1:InsFlatNessForCL' of XSD type 'ns1:InsFlatNessForCL' */
        _ns1__InsFlatNessForCL *ns1__InsFlatNessForCL;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFlatNessForCL */
        int soap_type() const { return SOAP_TYPE___ns1__InsFlatNessForCL; }
        /** Constructor with member initializations */
        __ns1__InsFlatNessForCL() : ns1__InsFlatNessForCL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFlatNessForCL * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForCL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12023 */
#ifndef SOAP_TYPE___ns1__InsWHDetection
#define SOAP_TYPE___ns1__InsWHDetection (544)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsWHDetection {
      public:
        /** Optional element 'ns1:InsWHDetection' of XSD type 'ns1:InsWHDetection' */
        _ns1__InsWHDetection *ns1__InsWHDetection;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsWHDetection */
        int soap_type() const { return SOAP_TYPE___ns1__InsWHDetection; }
        /** Constructor with member initializations */
        __ns1__InsWHDetection() : ns1__InsWHDetection() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsWHDetection * SOAP_FMAC2 soap_instantiate___ns1__InsWHDetection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12093 */
#ifndef SOAP_TYPE___ns1__InsThermal
#define SOAP_TYPE___ns1__InsThermal (548)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsThermal {
      public:
        /** Optional element 'ns1:InsThermal' of XSD type 'ns1:InsThermal' */
        _ns1__InsThermal *ns1__InsThermal;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsThermal */
        int soap_type() const { return SOAP_TYPE___ns1__InsThermal; }
        /** Constructor with member initializations */
        __ns1__InsThermal() : ns1__InsThermal() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsThermal * SOAP_FMAC2 soap_instantiate___ns1__InsThermal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12163 */
#ifndef SOAP_TYPE___ns1__ChkSnLink
#define SOAP_TYPE___ns1__ChkSnLink (552)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnLink {
      public:
        /** Optional element 'ns1:ChkSnLink' of XSD type 'ns1:ChkSnLink' */
        _ns1__ChkSnLink *ns1__ChkSnLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnLink */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnLink; }
        /** Constructor with member initializations */
        __ns1__ChkSnLink() : ns1__ChkSnLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnLink * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12233 */
#ifndef SOAP_TYPE___ns1__InsThermalNew
#define SOAP_TYPE___ns1__InsThermalNew (556)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsThermalNew {
      public:
        /** Optional element 'ns1:InsThermalNew' of XSD type 'ns1:InsThermalNew' */
        _ns1__InsThermalNew *ns1__InsThermalNew;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsThermalNew */
        int soap_type() const { return SOAP_TYPE___ns1__InsThermalNew; }
        /** Constructor with member initializations */
        __ns1__InsThermalNew() : ns1__InsThermalNew() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsThermalNew * SOAP_FMAC2 soap_instantiate___ns1__InsThermalNew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12303 */
#ifndef SOAP_TYPE___ns1__getInfoByMo
#define SOAP_TYPE___ns1__getInfoByMo (560)
/* Wrapper: */
struct SOAP_CMAC __ns1__getInfoByMo {
      public:
        /** Optional element 'ns1:getInfoByMo' of XSD type 'ns1:getInfoByMo' */
        _ns1__getInfoByMo *ns1__getInfoByMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getInfoByMo */
        int soap_type() const { return SOAP_TYPE___ns1__getInfoByMo; }
        /** Constructor with member initializations */
        __ns1__getInfoByMo() : ns1__getInfoByMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getInfoByMo * SOAP_FMAC2 soap_instantiate___ns1__getInfoByMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12373 */
#ifndef SOAP_TYPE___ns1__SetEnergyStat
#define SOAP_TYPE___ns1__SetEnergyStat (564)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetEnergyStat {
      public:
        /** Optional element 'ns1:SetEnergyStat' of XSD type 'ns1:SetEnergyStat' */
        _ns1__SetEnergyStat *ns1__SetEnergyStat;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetEnergyStat */
        int soap_type() const { return SOAP_TYPE___ns1__SetEnergyStat; }
        /** Constructor with member initializations */
        __ns1__SetEnergyStat() : ns1__SetEnergyStat() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetEnergyStat * SOAP_FMAC2 soap_instantiate___ns1__SetEnergyStat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12443 */
#ifndef SOAP_TYPE___ns1__chkMoStation
#define SOAP_TYPE___ns1__chkMoStation (568)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkMoStation {
      public:
        /** Optional element 'ns1:chkMoStation' of XSD type 'ns1:chkMoStation' */
        _ns1__chkMoStation *ns1__chkMoStation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkMoStation */
        int soap_type() const { return SOAP_TYPE___ns1__chkMoStation; }
        /** Constructor with member initializations */
        __ns1__chkMoStation() : ns1__chkMoStation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkMoStation * SOAP_FMAC2 soap_instantiate___ns1__chkMoStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12513 */
#ifndef SOAP_TYPE___ns1__ChkSnMo
#define SOAP_TYPE___ns1__ChkSnMo (572)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnMo {
      public:
        /** Optional element 'ns1:ChkSnMo' of XSD type 'ns1:ChkSnMo' */
        _ns1__ChkSnMo *ns1__ChkSnMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnMo */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnMo; }
        /** Constructor with member initializations */
        __ns1__ChkSnMo() : ns1__ChkSnMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnMo * SOAP_FMAC2 soap_instantiate___ns1__ChkSnMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12583 */
#ifndef SOAP_TYPE___ns1__ChkSnNextMo
#define SOAP_TYPE___ns1__ChkSnNextMo (576)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnNextMo {
      public:
        /** Optional element 'ns1:ChkSnNextMo' of XSD type 'ns1:ChkSnNextMo' */
        _ns1__ChkSnNextMo *ns1__ChkSnNextMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnNextMo */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnNextMo; }
        /** Constructor with member initializations */
        __ns1__ChkSnNextMo() : ns1__ChkSnNextMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnNextMo * SOAP_FMAC2 soap_instantiate___ns1__ChkSnNextMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12653 */
#ifndef SOAP_TYPE___ns1__checkSN_USCOREStationNumber
#define SOAP_TYPE___ns1__checkSN_USCOREStationNumber (580)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkSN_USCOREStationNumber {
      public:
        /** Optional element 'ns1:checkSN_StationNumber' of XSD type 'ns1:checkSN_StationNumber' */
        _ns1__checkSN_USCOREStationNumber *ns1__checkSN_USCOREStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkSN_USCOREStationNumber */
        int soap_type() const { return SOAP_TYPE___ns1__checkSN_USCOREStationNumber; }
        /** Constructor with member initializations */
        __ns1__checkSN_USCOREStationNumber() : ns1__checkSN_USCOREStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkSN_USCOREStationNumber * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12723 */
#ifndef SOAP_TYPE___ns1__checkEmpForStationNumber
#define SOAP_TYPE___ns1__checkEmpForStationNumber (584)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkEmpForStationNumber {
      public:
        /** Optional element 'ns1:checkEmpForStationNumber' of XSD type 'ns1:checkEmpForStationNumber' */
        _ns1__checkEmpForStationNumber *ns1__checkEmpForStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkEmpForStationNumber */
        int soap_type() const { return SOAP_TYPE___ns1__checkEmpForStationNumber; }
        /** Constructor with member initializations */
        __ns1__checkEmpForStationNumber() : ns1__checkEmpForStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkEmpForStationNumber * SOAP_FMAC2 soap_instantiate___ns1__checkEmpForStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12793 */
#ifndef SOAP_TYPE___ns1__sendDataForStationNumber
#define SOAP_TYPE___ns1__sendDataForStationNumber (588)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendDataForStationNumber {
      public:
        /** Optional element 'ns1:sendDataForStationNumber' of XSD type 'ns1:sendDataForStationNumber' */
        _ns1__sendDataForStationNumber *ns1__sendDataForStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendDataForStationNumber */
        int soap_type() const { return SOAP_TYPE___ns1__sendDataForStationNumber; }
        /** Constructor with member initializations */
        __ns1__sendDataForStationNumber() : ns1__sendDataForStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendDataForStationNumber * SOAP_FMAC2 soap_instantiate___ns1__sendDataForStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12863 */
#ifndef SOAP_TYPE___ns1__sendResultForStationNumber
#define SOAP_TYPE___ns1__sendResultForStationNumber (592)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendResultForStationNumber {
      public:
        /** Optional element 'ns1:sendResultForStationNumber' of XSD type 'ns1:sendResultForStationNumber' */
        _ns1__sendResultForStationNumber *ns1__sendResultForStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendResultForStationNumber */
        int soap_type() const { return SOAP_TYPE___ns1__sendResultForStationNumber; }
        /** Constructor with member initializations */
        __ns1__sendResultForStationNumber() : ns1__sendResultForStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendResultForStationNumber * SOAP_FMAC2 soap_instantiate___ns1__sendResultForStationNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:12933 */
#ifndef SOAP_TYPE___ns1__eMesNextMo
#define SOAP_TYPE___ns1__eMesNextMo (596)
/* Wrapper: */
struct SOAP_CMAC __ns1__eMesNextMo {
      public:
        /** Optional element 'ns1:eMesNextMo' of XSD type 'ns1:eMesNextMo' */
        _ns1__eMesNextMo *ns1__eMesNextMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__eMesNextMo */
        int soap_type() const { return SOAP_TYPE___ns1__eMesNextMo; }
        /** Constructor with member initializations */
        __ns1__eMesNextMo() : ns1__eMesNextMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__eMesNextMo * SOAP_FMAC2 soap_instantiate___ns1__eMesNextMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13003 */
#ifndef SOAP_TYPE___ns1__SnDoMapping
#define SOAP_TYPE___ns1__SnDoMapping (600)
/* Wrapper: */
struct SOAP_CMAC __ns1__SnDoMapping {
      public:
        /** Optional element 'ns1:SnDoMapping' of XSD type 'ns1:SnDoMapping' */
        _ns1__SnDoMapping *ns1__SnDoMapping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SnDoMapping */
        int soap_type() const { return SOAP_TYPE___ns1__SnDoMapping; }
        /** Constructor with member initializations */
        __ns1__SnDoMapping() : ns1__SnDoMapping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SnDoMapping * SOAP_FMAC2 soap_instantiate___ns1__SnDoMapping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13073 */
#ifndef SOAP_TYPE___ns1__getStationByMo
#define SOAP_TYPE___ns1__getStationByMo (604)
/* Wrapper: */
struct SOAP_CMAC __ns1__getStationByMo {
      public:
        /** Optional element 'ns1:getStationByMo' of XSD type 'ns1:getStationByMo' */
        _ns1__getStationByMo *ns1__getStationByMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getStationByMo */
        int soap_type() const { return SOAP_TYPE___ns1__getStationByMo; }
        /** Constructor with member initializations */
        __ns1__getStationByMo() : ns1__getStationByMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getStationByMo * SOAP_FMAC2 soap_instantiate___ns1__getStationByMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13143 */
#ifndef SOAP_TYPE___ns1__getStationTypeDesc
#define SOAP_TYPE___ns1__getStationTypeDesc (608)
/* Wrapper: */
struct SOAP_CMAC __ns1__getStationTypeDesc {
      public:
        /** Optional element 'ns1:getStationTypeDesc' of XSD type 'ns1:getStationTypeDesc' */
        _ns1__getStationTypeDesc *ns1__getStationTypeDesc;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getStationTypeDesc */
        int soap_type() const { return SOAP_TYPE___ns1__getStationTypeDesc; }
        /** Constructor with member initializations */
        __ns1__getStationTypeDesc() : ns1__getStationTypeDesc() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getStationTypeDesc * SOAP_FMAC2 soap_instantiate___ns1__getStationTypeDesc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13213 */
#ifndef SOAP_TYPE___ns1__chkSnMapping
#define SOAP_TYPE___ns1__chkSnMapping (612)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkSnMapping {
      public:
        /** Optional element 'ns1:chkSnMapping' of XSD type 'ns1:chkSnMapping' */
        _ns1__chkSnMapping *ns1__chkSnMapping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkSnMapping */
        int soap_type() const { return SOAP_TYPE___ns1__chkSnMapping; }
        /** Constructor with member initializations */
        __ns1__chkSnMapping() : ns1__chkSnMapping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkSnMapping * SOAP_FMAC2 soap_instantiate___ns1__chkSnMapping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13283 */
#ifndef SOAP_TYPE___ns1__getMoAssyList
#define SOAP_TYPE___ns1__getMoAssyList (616)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMoAssyList {
      public:
        /** Optional element 'ns1:getMoAssyList' of XSD type 'ns1:getMoAssyList' */
        _ns1__getMoAssyList *ns1__getMoAssyList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMoAssyList */
        int soap_type() const { return SOAP_TYPE___ns1__getMoAssyList; }
        /** Constructor with member initializations */
        __ns1__getMoAssyList() : ns1__getMoAssyList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMoAssyList * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13353 */
#ifndef SOAP_TYPE___ns1__getPartBomExt
#define SOAP_TYPE___ns1__getPartBomExt (620)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPartBomExt {
      public:
        /** Optional element 'ns1:getPartBomExt' of XSD type 'ns1:getPartBomExt' */
        _ns1__getPartBomExt *ns1__getPartBomExt;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPartBomExt */
        int soap_type() const { return SOAP_TYPE___ns1__getPartBomExt; }
        /** Constructor with member initializations */
        __ns1__getPartBomExt() : ns1__getPartBomExt() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPartBomExt * SOAP_FMAC2 soap_instantiate___ns1__getPartBomExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13423 */
#ifndef SOAP_TYPE___ns1__InsPartAssy
#define SOAP_TYPE___ns1__InsPartAssy (624)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsPartAssy {
      public:
        /** Optional element 'ns1:InsPartAssy' of XSD type 'ns1:InsPartAssy' */
        _ns1__InsPartAssy *ns1__InsPartAssy;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsPartAssy */
        int soap_type() const { return SOAP_TYPE___ns1__InsPartAssy; }
        /** Constructor with member initializations */
        __ns1__InsPartAssy() : ns1__InsPartAssy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsPartAssy * SOAP_FMAC2 soap_instantiate___ns1__InsPartAssy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13493 */
#ifndef SOAP_TYPE___ns1__GetLinkOutSn
#define SOAP_TYPE___ns1__GetLinkOutSn (628)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLinkOutSn {
      public:
        /** Optional element 'ns1:GetLinkOutSn' of XSD type 'ns1:GetLinkOutSn' */
        _ns1__GetLinkOutSn *ns1__GetLinkOutSn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLinkOutSn */
        int soap_type() const { return SOAP_TYPE___ns1__GetLinkOutSn; }
        /** Constructor with member initializations */
        __ns1__GetLinkOutSn() : ns1__GetLinkOutSn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLinkOutSn * SOAP_FMAC2 soap_instantiate___ns1__GetLinkOutSn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13563 */
#ifndef SOAP_TYPE___ns1__getMoAssyCount
#define SOAP_TYPE___ns1__getMoAssyCount (632)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMoAssyCount {
      public:
        /** Optional element 'ns1:getMoAssyCount' of XSD type 'ns1:getMoAssyCount' */
        _ns1__getMoAssyCount *ns1__getMoAssyCount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMoAssyCount */
        int soap_type() const { return SOAP_TYPE___ns1__getMoAssyCount; }
        /** Constructor with member initializations */
        __ns1__getMoAssyCount() : ns1__getMoAssyCount() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMoAssyCount * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13633 */
#ifndef SOAP_TYPE___ns1__getPNbySN
#define SOAP_TYPE___ns1__getPNbySN (636)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPNbySN {
      public:
        /** Optional element 'ns1:getPNbySN' of XSD type 'ns1:getPNbySN' */
        _ns1__getPNbySN *ns1__getPNbySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPNbySN */
        int soap_type() const { return SOAP_TYPE___ns1__getPNbySN; }
        /** Constructor with member initializations */
        __ns1__getPNbySN() : ns1__getPNbySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPNbySN * SOAP_FMAC2 soap_instantiate___ns1__getPNbySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13703 */
#ifndef SOAP_TYPE___ns1__chkAssySN
#define SOAP_TYPE___ns1__chkAssySN (640)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkAssySN {
      public:
        /** Optional element 'ns1:chkAssySN' of XSD type 'ns1:chkAssySN' */
        _ns1__chkAssySN *ns1__chkAssySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkAssySN */
        int soap_type() const { return SOAP_TYPE___ns1__chkAssySN; }
        /** Constructor with member initializations */
        __ns1__chkAssySN() : ns1__chkAssySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkAssySN * SOAP_FMAC2 soap_instantiate___ns1__chkAssySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13773 */
#ifndef SOAP_TYPE___ns1__doAssy
#define SOAP_TYPE___ns1__doAssy (644)
/* Wrapper: */
struct SOAP_CMAC __ns1__doAssy {
      public:
        /** Optional element 'ns1:doAssy' of XSD type 'ns1:doAssy' */
        _ns1__doAssy *ns1__doAssy;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doAssy */
        int soap_type() const { return SOAP_TYPE___ns1__doAssy; }
        /** Constructor with member initializations */
        __ns1__doAssy() : ns1__doAssy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doAssy * SOAP_FMAC2 soap_instantiate___ns1__doAssy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13843 */
#ifndef SOAP_TYPE___ns1__getPmcAssyList
#define SOAP_TYPE___ns1__getPmcAssyList (648)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPmcAssyList {
      public:
        /** Optional element 'ns1:getPmcAssyList' of XSD type 'ns1:getPmcAssyList' */
        _ns1__getPmcAssyList *ns1__getPmcAssyList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPmcAssyList */
        int soap_type() const { return SOAP_TYPE___ns1__getPmcAssyList; }
        /** Constructor with member initializations */
        __ns1__getPmcAssyList() : ns1__getPmcAssyList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPmcAssyList * SOAP_FMAC2 soap_instantiate___ns1__getPmcAssyList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13913 */
#ifndef SOAP_TYPE___ns1__getPmcPartAssyList
#define SOAP_TYPE___ns1__getPmcPartAssyList (652)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPmcPartAssyList {
      public:
        /** Optional element 'ns1:getPmcPartAssyList' of XSD type 'ns1:getPmcPartAssyList' */
        _ns1__getPmcPartAssyList *ns1__getPmcPartAssyList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPmcPartAssyList */
        int soap_type() const { return SOAP_TYPE___ns1__getPmcPartAssyList; }
        /** Constructor with member initializations */
        __ns1__getPmcPartAssyList() : ns1__getPmcPartAssyList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPmcPartAssyList * SOAP_FMAC2 soap_instantiate___ns1__getPmcPartAssyList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:13983 */
#ifndef SOAP_TYPE___ns1__GetPmcSNPart
#define SOAP_TYPE___ns1__GetPmcSNPart (656)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPmcSNPart {
      public:
        /** Optional element 'ns1:GetPmcSNPart' of XSD type 'ns1:GetPmcSNPart' */
        _ns1__GetPmcSNPart *ns1__GetPmcSNPart;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPmcSNPart */
        int soap_type() const { return SOAP_TYPE___ns1__GetPmcSNPart; }
        /** Constructor with member initializations */
        __ns1__GetPmcSNPart() : ns1__GetPmcSNPart() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPmcSNPart * SOAP_FMAC2 soap_instantiate___ns1__GetPmcSNPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14053 */
#ifndef SOAP_TYPE___ns1__doPmcSNLink
#define SOAP_TYPE___ns1__doPmcSNLink (660)
/* Wrapper: */
struct SOAP_CMAC __ns1__doPmcSNLink {
      public:
        /** Optional element 'ns1:doPmcSNLink' of XSD type 'ns1:doPmcSNLink' */
        _ns1__doPmcSNLink *ns1__doPmcSNLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doPmcSNLink */
        int soap_type() const { return SOAP_TYPE___ns1__doPmcSNLink; }
        /** Constructor with member initializations */
        __ns1__doPmcSNLink() : ns1__doPmcSNLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doPmcSNLink * SOAP_FMAC2 soap_instantiate___ns1__doPmcSNLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14123 */
#ifndef SOAP_TYPE___ns1__InsZJTestData
#define SOAP_TYPE___ns1__InsZJTestData (664)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsZJTestData {
      public:
        /** Optional element 'ns1:InsZJTestData' of XSD type 'ns1:InsZJTestData' */
        _ns1__InsZJTestData *ns1__InsZJTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsZJTestData */
        int soap_type() const { return SOAP_TYPE___ns1__InsZJTestData; }
        /** Constructor with member initializations */
        __ns1__InsZJTestData() : ns1__InsZJTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsZJTestData * SOAP_FMAC2 soap_instantiate___ns1__InsZJTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14193 */
#ifndef SOAP_TYPE___ns1__SNLinkZJ
#define SOAP_TYPE___ns1__SNLinkZJ (668)
/* Wrapper: */
struct SOAP_CMAC __ns1__SNLinkZJ {
      public:
        /** Optional element 'ns1:SNLinkZJ' of XSD type 'ns1:SNLinkZJ' */
        _ns1__SNLinkZJ *ns1__SNLinkZJ;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SNLinkZJ */
        int soap_type() const { return SOAP_TYPE___ns1__SNLinkZJ; }
        /** Constructor with member initializations */
        __ns1__SNLinkZJ() : ns1__SNLinkZJ() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SNLinkZJ * SOAP_FMAC2 soap_instantiate___ns1__SNLinkZJ(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14263 */
#ifndef SOAP_TYPE___ns1__GetLintOutQty
#define SOAP_TYPE___ns1__GetLintOutQty (672)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLintOutQty {
      public:
        /** Optional element 'ns1:GetLintOutQty' of XSD type 'ns1:GetLintOutQty' */
        _ns1__GetLintOutQty *ns1__GetLintOutQty;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLintOutQty */
        int soap_type() const { return SOAP_TYPE___ns1__GetLintOutQty; }
        /** Constructor with member initializations */
        __ns1__GetLintOutQty() : ns1__GetLintOutQty() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLintOutQty * SOAP_FMAC2 soap_instantiate___ns1__GetLintOutQty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14333 */
#ifndef SOAP_TYPE___ns1__chkOutSN
#define SOAP_TYPE___ns1__chkOutSN (676)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkOutSN {
      public:
        /** Optional element 'ns1:chkOutSN' of XSD type 'ns1:chkOutSN' */
        _ns1__chkOutSN *ns1__chkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkOutSN */
        int soap_type() const { return SOAP_TYPE___ns1__chkOutSN; }
        /** Constructor with member initializations */
        __ns1__chkOutSN() : ns1__chkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkOutSN * SOAP_FMAC2 soap_instantiate___ns1__chkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14403 */
#ifndef SOAP_TYPE___ns1__ChkLinkOutSN
#define SOAP_TYPE___ns1__ChkLinkOutSN (680)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkLinkOutSN {
      public:
        /** Optional element 'ns1:ChkLinkOutSN' of XSD type 'ns1:ChkLinkOutSN' */
        _ns1__ChkLinkOutSN *ns1__ChkLinkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkLinkOutSN */
        int soap_type() const { return SOAP_TYPE___ns1__ChkLinkOutSN; }
        /** Constructor with member initializations */
        __ns1__ChkLinkOutSN() : ns1__ChkLinkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkLinkOutSN * SOAP_FMAC2 soap_instantiate___ns1__ChkLinkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14473 */
#ifndef SOAP_TYPE___ns1__doLinkOutSN
#define SOAP_TYPE___ns1__doLinkOutSN (684)
/* Wrapper: */
struct SOAP_CMAC __ns1__doLinkOutSN {
      public:
        /** Optional element 'ns1:doLinkOutSN' of XSD type 'ns1:doLinkOutSN' */
        _ns1__doLinkOutSN *ns1__doLinkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doLinkOutSN */
        int soap_type() const { return SOAP_TYPE___ns1__doLinkOutSN; }
        /** Constructor with member initializations */
        __ns1__doLinkOutSN() : ns1__doLinkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doLinkOutSN * SOAP_FMAC2 soap_instantiate___ns1__doLinkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14543 */
#ifndef SOAP_TYPE___ns1__InsLinkSN
#define SOAP_TYPE___ns1__InsLinkSN (688)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsLinkSN {
      public:
        /** Optional element 'ns1:InsLinkSN' of XSD type 'ns1:InsLinkSN' */
        _ns1__InsLinkSN *ns1__InsLinkSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsLinkSN */
        int soap_type() const { return SOAP_TYPE___ns1__InsLinkSN; }
        /** Constructor with member initializations */
        __ns1__InsLinkSN() : ns1__InsLinkSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsLinkSN * SOAP_FMAC2 soap_instantiate___ns1__InsLinkSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14613 */
#ifndef SOAP_TYPE___ns1__GetLinkZJCount
#define SOAP_TYPE___ns1__GetLinkZJCount (692)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLinkZJCount {
      public:
        /** Optional element 'ns1:GetLinkZJCount' of XSD type 'ns1:GetLinkZJCount' */
        _ns1__GetLinkZJCount *ns1__GetLinkZJCount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLinkZJCount */
        int soap_type() const { return SOAP_TYPE___ns1__GetLinkZJCount; }
        /** Constructor with member initializations */
        __ns1__GetLinkZJCount() : ns1__GetLinkZJCount() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLinkZJCount * SOAP_FMAC2 soap_instantiate___ns1__GetLinkZJCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14683 */
#ifndef SOAP_TYPE___ns1__InsBoxNOTime
#define SOAP_TYPE___ns1__InsBoxNOTime (696)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsBoxNOTime {
      public:
        /** Optional element 'ns1:InsBoxNOTime' of XSD type 'ns1:InsBoxNOTime' */
        _ns1__InsBoxNOTime *ns1__InsBoxNOTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsBoxNOTime */
        int soap_type() const { return SOAP_TYPE___ns1__InsBoxNOTime; }
        /** Constructor with member initializations */
        __ns1__InsBoxNOTime() : ns1__InsBoxNOTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsBoxNOTime * SOAP_FMAC2 soap_instantiate___ns1__InsBoxNOTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14753 */
#ifndef SOAP_TYPE___ns1__chkBoxNo
#define SOAP_TYPE___ns1__chkBoxNo (700)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkBoxNo {
      public:
        /** Optional element 'ns1:chkBoxNo' of XSD type 'ns1:chkBoxNo' */
        _ns1__chkBoxNo *ns1__chkBoxNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkBoxNo */
        int soap_type() const { return SOAP_TYPE___ns1__chkBoxNo; }
        /** Constructor with member initializations */
        __ns1__chkBoxNo() : ns1__chkBoxNo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkBoxNo * SOAP_FMAC2 soap_instantiate___ns1__chkBoxNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14823 */
#ifndef SOAP_TYPE___ns1__InSNtoBox
#define SOAP_TYPE___ns1__InSNtoBox (704)
/* Wrapper: */
struct SOAP_CMAC __ns1__InSNtoBox {
      public:
        /** Optional element 'ns1:InSNtoBox' of XSD type 'ns1:InSNtoBox' */
        _ns1__InSNtoBox *ns1__InSNtoBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InSNtoBox */
        int soap_type() const { return SOAP_TYPE___ns1__InSNtoBox; }
        /** Constructor with member initializations */
        __ns1__InSNtoBox() : ns1__InSNtoBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InSNtoBox * SOAP_FMAC2 soap_instantiate___ns1__InSNtoBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14893 */
#ifndef SOAP_TYPE___ns1__EndSNtoBox
#define SOAP_TYPE___ns1__EndSNtoBox (708)
/* Wrapper: */
struct SOAP_CMAC __ns1__EndSNtoBox {
      public:
        /** Optional element 'ns1:EndSNtoBox' of XSD type 'ns1:EndSNtoBox' */
        _ns1__EndSNtoBox *ns1__EndSNtoBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EndSNtoBox */
        int soap_type() const { return SOAP_TYPE___ns1__EndSNtoBox; }
        /** Constructor with member initializations */
        __ns1__EndSNtoBox() : ns1__EndSNtoBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EndSNtoBox * SOAP_FMAC2 soap_instantiate___ns1__EndSNtoBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:14963 */
#ifndef SOAP_TYPE___ns1__InStationbyBox
#define SOAP_TYPE___ns1__InStationbyBox (712)
/* Wrapper: */
struct SOAP_CMAC __ns1__InStationbyBox {
      public:
        /** Optional element 'ns1:InStationbyBox' of XSD type 'ns1:InStationbyBox' */
        _ns1__InStationbyBox *ns1__InStationbyBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InStationbyBox */
        int soap_type() const { return SOAP_TYPE___ns1__InStationbyBox; }
        /** Constructor with member initializations */
        __ns1__InStationbyBox() : ns1__InStationbyBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InStationbyBox * SOAP_FMAC2 soap_instantiate___ns1__InStationbyBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15033 */
#ifndef SOAP_TYPE___ns1__OutStationbyBox
#define SOAP_TYPE___ns1__OutStationbyBox (716)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutStationbyBox {
      public:
        /** Optional element 'ns1:OutStationbyBox' of XSD type 'ns1:OutStationbyBox' */
        _ns1__OutStationbyBox *ns1__OutStationbyBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutStationbyBox */
        int soap_type() const { return SOAP_TYPE___ns1__OutStationbyBox; }
        /** Constructor with member initializations */
        __ns1__OutStationbyBox() : ns1__OutStationbyBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutStationbyBox * SOAP_FMAC2 soap_instantiate___ns1__OutStationbyBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15103 */
#ifndef SOAP_TYPE___ns1__CancelBoxLnk
#define SOAP_TYPE___ns1__CancelBoxLnk (720)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelBoxLnk {
      public:
        /** Optional element 'ns1:CancelBoxLnk' of XSD type 'ns1:CancelBoxLnk' */
        _ns1__CancelBoxLnk *ns1__CancelBoxLnk;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelBoxLnk */
        int soap_type() const { return SOAP_TYPE___ns1__CancelBoxLnk; }
        /** Constructor with member initializations */
        __ns1__CancelBoxLnk() : ns1__CancelBoxLnk() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelBoxLnk * SOAP_FMAC2 soap_instantiate___ns1__CancelBoxLnk(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15173 */
#ifndef SOAP_TYPE___ns1__InsSNStationEmp
#define SOAP_TYPE___ns1__InsSNStationEmp (724)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsSNStationEmp {
      public:
        /** Optional element 'ns1:InsSNStationEmp' of XSD type 'ns1:InsSNStationEmp' */
        _ns1__InsSNStationEmp *ns1__InsSNStationEmp;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsSNStationEmp */
        int soap_type() const { return SOAP_TYPE___ns1__InsSNStationEmp; }
        /** Constructor with member initializations */
        __ns1__InsSNStationEmp() : ns1__InsSNStationEmp() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsSNStationEmp * SOAP_FMAC2 soap_instantiate___ns1__InsSNStationEmp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15243 */
#ifndef SOAP_TYPE___ns1__InsLnkOutSN
#define SOAP_TYPE___ns1__InsLnkOutSN (728)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsLnkOutSN {
      public:
        /** Optional element 'ns1:InsLnkOutSN' of XSD type 'ns1:InsLnkOutSN' */
        _ns1__InsLnkOutSN *ns1__InsLnkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsLnkOutSN */
        int soap_type() const { return SOAP_TYPE___ns1__InsLnkOutSN; }
        /** Constructor with member initializations */
        __ns1__InsLnkOutSN() : ns1__InsLnkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsLnkOutSN * SOAP_FMAC2 soap_instantiate___ns1__InsLnkOutSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15313 */
#ifndef SOAP_TYPE___ns1__InsBoxInfo
#define SOAP_TYPE___ns1__InsBoxInfo (732)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsBoxInfo {
      public:
        /** Optional element 'ns1:InsBoxInfo' of XSD type 'ns1:InsBoxInfo' */
        _ns1__InsBoxInfo *ns1__InsBoxInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsBoxInfo */
        int soap_type() const { return SOAP_TYPE___ns1__InsBoxInfo; }
        /** Constructor with member initializations */
        __ns1__InsBoxInfo() : ns1__InsBoxInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsBoxInfo * SOAP_FMAC2 soap_instantiate___ns1__InsBoxInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15383 */
#ifndef SOAP_TYPE___ns1__UpdSnRecInfo
#define SOAP_TYPE___ns1__UpdSnRecInfo (736)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdSnRecInfo {
      public:
        /** Optional element 'ns1:UpdSnRecInfo' of XSD type 'ns1:UpdSnRecInfo' */
        _ns1__UpdSnRecInfo *ns1__UpdSnRecInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdSnRecInfo */
        int soap_type() const { return SOAP_TYPE___ns1__UpdSnRecInfo; }
        /** Constructor with member initializations */
        __ns1__UpdSnRecInfo() : ns1__UpdSnRecInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdSnRecInfo * SOAP_FMAC2 soap_instantiate___ns1__UpdSnRecInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15453 */
#ifndef SOAP_TYPE___ns1__GetMoBase
#define SOAP_TYPE___ns1__GetMoBase (740)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMoBase {
      public:
        /** Optional element 'ns1:GetMoBase' of XSD type 'ns1:GetMoBase' */
        _ns1__GetMoBase *ns1__GetMoBase;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMoBase */
        int soap_type() const { return SOAP_TYPE___ns1__GetMoBase; }
        /** Constructor with member initializations */
        __ns1__GetMoBase() : ns1__GetMoBase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMoBase * SOAP_FMAC2 soap_instantiate___ns1__GetMoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15523 */
#ifndef SOAP_TYPE___ns1__GetTestValue
#define SOAP_TYPE___ns1__GetTestValue (744)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTestValue {
      public:
        /** Optional element 'ns1:GetTestValue' of XSD type 'ns1:GetTestValue' */
        _ns1__GetTestValue *ns1__GetTestValue;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTestValue */
        int soap_type() const { return SOAP_TYPE___ns1__GetTestValue; }
        /** Constructor with member initializations */
        __ns1__GetTestValue() : ns1__GetTestValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTestValue * SOAP_FMAC2 soap_instantiate___ns1__GetTestValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15593 */
#ifndef SOAP_TYPE___ns1__GetLnkData
#define SOAP_TYPE___ns1__GetLnkData (748)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLnkData {
      public:
        /** Optional element 'ns1:GetLnkData' of XSD type 'ns1:GetLnkData' */
        _ns1__GetLnkData *ns1__GetLnkData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLnkData */
        int soap_type() const { return SOAP_TYPE___ns1__GetLnkData; }
        /** Constructor with member initializations */
        __ns1__GetLnkData() : ns1__GetLnkData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLnkData * SOAP_FMAC2 soap_instantiate___ns1__GetLnkData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15663 */
#ifndef SOAP_TYPE___ns1__InsIotMachineRec
#define SOAP_TYPE___ns1__InsIotMachineRec (752)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsIotMachineRec {
      public:
        /** Optional element 'ns1:InsIotMachineRec' of XSD type 'ns1:InsIotMachineRec' */
        _ns1__InsIotMachineRec *ns1__InsIotMachineRec;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsIotMachineRec */
        int soap_type() const { return SOAP_TYPE___ns1__InsIotMachineRec; }
        /** Constructor with member initializations */
        __ns1__InsIotMachineRec() : ns1__InsIotMachineRec() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsIotMachineRec * SOAP_FMAC2 soap_instantiate___ns1__InsIotMachineRec(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15733 */
#ifndef SOAP_TYPE___ns1__InsIotTestData
#define SOAP_TYPE___ns1__InsIotTestData (756)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsIotTestData {
      public:
        /** Optional element 'ns1:InsIotTestData' of XSD type 'ns1:InsIotTestData' */
        _ns1__InsIotTestData *ns1__InsIotTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsIotTestData */
        int soap_type() const { return SOAP_TYPE___ns1__InsIotTestData; }
        /** Constructor with member initializations */
        __ns1__InsIotTestData() : ns1__InsIotTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsIotTestData * SOAP_FMAC2 soap_instantiate___ns1__InsIotTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15803 */
#ifndef SOAP_TYPE___ns1__chkDispensing
#define SOAP_TYPE___ns1__chkDispensing (760)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkDispensing {
      public:
        /** Optional element 'ns1:chkDispensing' of XSD type 'ns1:chkDispensing' */
        _ns1__chkDispensing *ns1__chkDispensing;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkDispensing */
        int soap_type() const { return SOAP_TYPE___ns1__chkDispensing; }
        /** Constructor with member initializations */
        __ns1__chkDispensing() : ns1__chkDispensing() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkDispensing * SOAP_FMAC2 soap_instantiate___ns1__chkDispensing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15873 */
#ifndef SOAP_TYPE___ns1__chkZJSN
#define SOAP_TYPE___ns1__chkZJSN (764)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkZJSN {
      public:
        /** Optional element 'ns1:chkZJSN' of XSD type 'ns1:chkZJSN' */
        _ns1__chkZJSN *ns1__chkZJSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkZJSN */
        int soap_type() const { return SOAP_TYPE___ns1__chkZJSN; }
        /** Constructor with member initializations */
        __ns1__chkZJSN() : ns1__chkZJSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkZJSN * SOAP_FMAC2 soap_instantiate___ns1__chkZJSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:15943 */
#ifndef SOAP_TYPE___ns1__LnkZJSN
#define SOAP_TYPE___ns1__LnkZJSN (768)
/* Wrapper: */
struct SOAP_CMAC __ns1__LnkZJSN {
      public:
        /** Optional element 'ns1:LnkZJSN' of XSD type 'ns1:LnkZJSN' */
        _ns1__LnkZJSN *ns1__LnkZJSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LnkZJSN */
        int soap_type() const { return SOAP_TYPE___ns1__LnkZJSN; }
        /** Constructor with member initializations */
        __ns1__LnkZJSN() : ns1__LnkZJSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LnkZJSN * SOAP_FMAC2 soap_instantiate___ns1__LnkZJSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16013 */
#ifndef SOAP_TYPE___ns1__LnkSideSN
#define SOAP_TYPE___ns1__LnkSideSN (772)
/* Wrapper: */
struct SOAP_CMAC __ns1__LnkSideSN {
      public:
        /** Optional element 'ns1:LnkSideSN' of XSD type 'ns1:LnkSideSN' */
        _ns1__LnkSideSN *ns1__LnkSideSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LnkSideSN */
        int soap_type() const { return SOAP_TYPE___ns1__LnkSideSN; }
        /** Constructor with member initializations */
        __ns1__LnkSideSN() : ns1__LnkSideSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LnkSideSN * SOAP_FMAC2 soap_instantiate___ns1__LnkSideSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16083 */
#ifndef SOAP_TYPE___ns1__chkGrillSN
#define SOAP_TYPE___ns1__chkGrillSN (776)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkGrillSN {
      public:
        /** Optional element 'ns1:chkGrillSN' of XSD type 'ns1:chkGrillSN' */
        _ns1__chkGrillSN *ns1__chkGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkGrillSN */
        int soap_type() const { return SOAP_TYPE___ns1__chkGrillSN; }
        /** Constructor with member initializations */
        __ns1__chkGrillSN() : ns1__chkGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkGrillSN * SOAP_FMAC2 soap_instantiate___ns1__chkGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16153 */
#ifndef SOAP_TYPE___ns1__LnkGrillSN
#define SOAP_TYPE___ns1__LnkGrillSN (780)
/* Wrapper: */
struct SOAP_CMAC __ns1__LnkGrillSN {
      public:
        /** Optional element 'ns1:LnkGrillSN' of XSD type 'ns1:LnkGrillSN' */
        _ns1__LnkGrillSN *ns1__LnkGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LnkGrillSN */
        int soap_type() const { return SOAP_TYPE___ns1__LnkGrillSN; }
        /** Constructor with member initializations */
        __ns1__LnkGrillSN() : ns1__LnkGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LnkGrillSN * SOAP_FMAC2 soap_instantiate___ns1__LnkGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16223 */
#ifndef SOAP_TYPE___ns1__CloseGrillSN
#define SOAP_TYPE___ns1__CloseGrillSN (784)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseGrillSN {
      public:
        /** Optional element 'ns1:CloseGrillSN' of XSD type 'ns1:CloseGrillSN' */
        _ns1__CloseGrillSN *ns1__CloseGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseGrillSN */
        int soap_type() const { return SOAP_TYPE___ns1__CloseGrillSN; }
        /** Constructor with member initializations */
        __ns1__CloseGrillSN() : ns1__CloseGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CloseGrillSN * SOAP_FMAC2 soap_instantiate___ns1__CloseGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16293 */
#ifndef SOAP_TYPE___ns1__InsGrillBySN
#define SOAP_TYPE___ns1__InsGrillBySN (788)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsGrillBySN {
      public:
        /** Optional element 'ns1:InsGrillBySN' of XSD type 'ns1:InsGrillBySN' */
        _ns1__InsGrillBySN *ns1__InsGrillBySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsGrillBySN */
        int soap_type() const { return SOAP_TYPE___ns1__InsGrillBySN; }
        /** Constructor with member initializations */
        __ns1__InsGrillBySN() : ns1__InsGrillBySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsGrillBySN * SOAP_FMAC2 soap_instantiate___ns1__InsGrillBySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16363 */
#ifndef SOAP_TYPE___ns1__GetGrillTime
#define SOAP_TYPE___ns1__GetGrillTime (792)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetGrillTime {
      public:
        /** Optional element 'ns1:GetGrillTime' of XSD type 'ns1:GetGrillTime' */
        _ns1__GetGrillTime *ns1__GetGrillTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetGrillTime */
        int soap_type() const { return SOAP_TYPE___ns1__GetGrillTime; }
        /** Constructor with member initializations */
        __ns1__GetGrillTime() : ns1__GetGrillTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetGrillTime * SOAP_FMAC2 soap_instantiate___ns1__GetGrillTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16433 */
#ifndef SOAP_TYPE___ns1__OutGrillBySN
#define SOAP_TYPE___ns1__OutGrillBySN (796)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutGrillBySN {
      public:
        /** Optional element 'ns1:OutGrillBySN' of XSD type 'ns1:OutGrillBySN' */
        _ns1__OutGrillBySN *ns1__OutGrillBySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutGrillBySN */
        int soap_type() const { return SOAP_TYPE___ns1__OutGrillBySN; }
        /** Constructor with member initializations */
        __ns1__OutGrillBySN() : ns1__OutGrillBySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutGrillBySN * SOAP_FMAC2 soap_instantiate___ns1__OutGrillBySN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16503 */
#ifndef SOAP_TYPE___ns1__CancelGrillSN
#define SOAP_TYPE___ns1__CancelGrillSN (800)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelGrillSN {
      public:
        /** Optional element 'ns1:CancelGrillSN' of XSD type 'ns1:CancelGrillSN' */
        _ns1__CancelGrillSN *ns1__CancelGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelGrillSN */
        int soap_type() const { return SOAP_TYPE___ns1__CancelGrillSN; }
        /** Constructor with member initializations */
        __ns1__CancelGrillSN() : ns1__CancelGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelGrillSN * SOAP_FMAC2 soap_instantiate___ns1__CancelGrillSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16573 */
#ifndef SOAP_TYPE___ns1__CancelLnkSN
#define SOAP_TYPE___ns1__CancelLnkSN (804)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelLnkSN {
      public:
        /** Optional element 'ns1:CancelLnkSN' of XSD type 'ns1:CancelLnkSN' */
        _ns1__CancelLnkSN *ns1__CancelLnkSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelLnkSN */
        int soap_type() const { return SOAP_TYPE___ns1__CancelLnkSN; }
        /** Constructor with member initializations */
        __ns1__CancelLnkSN() : ns1__CancelLnkSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelLnkSN * SOAP_FMAC2 soap_instantiate___ns1__CancelLnkSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16643 */
#ifndef SOAP_TYPE___ns1__GetWeightSet
#define SOAP_TYPE___ns1__GetWeightSet (808)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetWeightSet {
      public:
        /** Optional element 'ns1:GetWeightSet' of XSD type 'ns1:GetWeightSet' */
        _ns1__GetWeightSet *ns1__GetWeightSet;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetWeightSet */
        int soap_type() const { return SOAP_TYPE___ns1__GetWeightSet; }
        /** Constructor with member initializations */
        __ns1__GetWeightSet() : ns1__GetWeightSet() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetWeightSet * SOAP_FMAC2 soap_instantiate___ns1__GetWeightSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16713 */
#ifndef SOAP_TYPE___ns1__GetPackToWMS
#define SOAP_TYPE___ns1__GetPackToWMS (812)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPackToWMS {
      public:
        /** Optional element 'ns1:GetPackToWMS' of XSD type 'ns1:GetPackToWMS' */
        _ns1__GetPackToWMS *ns1__GetPackToWMS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPackToWMS */
        int soap_type() const { return SOAP_TYPE___ns1__GetPackToWMS; }
        /** Constructor with member initializations */
        __ns1__GetPackToWMS() : ns1__GetPackToWMS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPackToWMS * SOAP_FMAC2 soap_instantiate___ns1__GetPackToWMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16783 */
#ifndef SOAP_TYPE___ns1__GetPallentToWMS
#define SOAP_TYPE___ns1__GetPallentToWMS (816)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPallentToWMS {
      public:
        /** Optional element 'ns1:GetPallentToWMS' of XSD type 'ns1:GetPallentToWMS' */
        _ns1__GetPallentToWMS *ns1__GetPallentToWMS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPallentToWMS */
        int soap_type() const { return SOAP_TYPE___ns1__GetPallentToWMS; }
        /** Constructor with member initializations */
        __ns1__GetPallentToWMS() : ns1__GetPallentToWMS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPallentToWMS * SOAP_FMAC2 soap_instantiate___ns1__GetPallentToWMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16853 */
#ifndef SOAP_TYPE___ns1__SetPallentForWMS
#define SOAP_TYPE___ns1__SetPallentForWMS (820)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetPallentForWMS {
      public:
        /** Optional element 'ns1:SetPallentForWMS' of XSD type 'ns1:SetPallentForWMS' */
        _ns1__SetPallentForWMS *ns1__SetPallentForWMS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetPallentForWMS */
        int soap_type() const { return SOAP_TYPE___ns1__SetPallentForWMS; }
        /** Constructor with member initializations */
        __ns1__SetPallentForWMS() : ns1__SetPallentForWMS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetPallentForWMS * SOAP_FMAC2 soap_instantiate___ns1__SetPallentForWMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16923 */
#ifndef SOAP_TYPE___ns1__GetPackStation
#define SOAP_TYPE___ns1__GetPackStation (824)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPackStation {
      public:
        /** Optional element 'ns1:GetPackStation' of XSD type 'ns1:GetPackStation' */
        _ns1__GetPackStation *ns1__GetPackStation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPackStation */
        int soap_type() const { return SOAP_TYPE___ns1__GetPackStation; }
        /** Constructor with member initializations */
        __ns1__GetPackStation() : ns1__GetPackStation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPackStation * SOAP_FMAC2 soap_instantiate___ns1__GetPackStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:16993 */
#ifndef SOAP_TYPE___ns1__GetPackWeigth
#define SOAP_TYPE___ns1__GetPackWeigth (828)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPackWeigth {
      public:
        /** Optional element 'ns1:GetPackWeigth' of XSD type 'ns1:GetPackWeigth' */
        _ns1__GetPackWeigth *ns1__GetPackWeigth;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPackWeigth */
        int soap_type() const { return SOAP_TYPE___ns1__GetPackWeigth; }
        /** Constructor with member initializations */
        __ns1__GetPackWeigth() : ns1__GetPackWeigth() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPackWeigth * SOAP_FMAC2 soap_instantiate___ns1__GetPackWeigth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17063 */
#ifndef SOAP_TYPE___ns1__GetAhsMo
#define SOAP_TYPE___ns1__GetAhsMo (832)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAhsMo {
      public:
        /** Optional element 'ns1:GetAhsMo' of XSD type 'ns1:GetAhsMo' */
        _ns1__GetAhsMo *ns1__GetAhsMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAhsMo */
        int soap_type() const { return SOAP_TYPE___ns1__GetAhsMo; }
        /** Constructor with member initializations */
        __ns1__GetAhsMo() : ns1__GetAhsMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetAhsMo * SOAP_FMAC2 soap_instantiate___ns1__GetAhsMo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17133 */
#ifndef SOAP_TYPE___ns1__GetAhsBarcode_
#define SOAP_TYPE___ns1__GetAhsBarcode_ (834)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAhsBarcode_ {
      public:
        /** Optional element 'ns1:GetAhsBarcode' of XSD type 'ns1:GetAhsBarcode' */
        _ns1__GetAhsBarcode *ns1__GetAhsBarcode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAhsBarcode_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetAhsBarcode_; }
        /** Constructor with member initializations */
        __ns1__GetAhsBarcode_() : ns1__GetAhsBarcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetAhsBarcode_ * SOAP_FMAC2 soap_instantiate___ns1__GetAhsBarcode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17203 */
#ifndef SOAP_TYPE___ns1__UpdAhsBarcode_
#define SOAP_TYPE___ns1__UpdAhsBarcode_ (836)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdAhsBarcode_ {
      public:
        /** Optional element 'ns1:UpdAhsBarcode' of XSD type 'ns1:UpdAhsBarcode' */
        _ns1__UpdAhsBarcode *ns1__UpdAhsBarcode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdAhsBarcode_ */
        int soap_type() const { return SOAP_TYPE___ns1__UpdAhsBarcode_; }
        /** Constructor with member initializations */
        __ns1__UpdAhsBarcode_() : ns1__UpdAhsBarcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdAhsBarcode_ * SOAP_FMAC2 soap_instantiate___ns1__UpdAhsBarcode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17273 */
#ifndef SOAP_TYPE___ns1__ChkWeightTime_
#define SOAP_TYPE___ns1__ChkWeightTime_ (838)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkWeightTime_ {
      public:
        /** Optional element 'ns1:ChkWeightTime' of XSD type 'ns1:ChkWeightTime' */
        _ns1__ChkWeightTime *ns1__ChkWeightTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkWeightTime_ */
        int soap_type() const { return SOAP_TYPE___ns1__ChkWeightTime_; }
        /** Constructor with member initializations */
        __ns1__ChkWeightTime_() : ns1__ChkWeightTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkWeightTime_ * SOAP_FMAC2 soap_instantiate___ns1__ChkWeightTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17343 */
#ifndef SOAP_TYPE___ns1__InsSNTest_
#define SOAP_TYPE___ns1__InsSNTest_ (840)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsSNTest_ {
      public:
        /** Optional element 'ns1:InsSNTest' of XSD type 'ns1:InsSNTest' */
        _ns1__InsSNTest *ns1__InsSNTest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsSNTest_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsSNTest_; }
        /** Constructor with member initializations */
        __ns1__InsSNTest_() : ns1__InsSNTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsSNTest_ * SOAP_FMAC2 soap_instantiate___ns1__InsSNTest_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17413 */
#ifndef SOAP_TYPE___ns1__SelSNTest_
#define SOAP_TYPE___ns1__SelSNTest_ (842)
/* Wrapper: */
struct SOAP_CMAC __ns1__SelSNTest_ {
      public:
        /** Optional element 'ns1:SelSNTest' of XSD type 'ns1:SelSNTest' */
        _ns1__SelSNTest *ns1__SelSNTest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelSNTest_ */
        int soap_type() const { return SOAP_TYPE___ns1__SelSNTest_; }
        /** Constructor with member initializations */
        __ns1__SelSNTest_() : ns1__SelSNTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SelSNTest_ * SOAP_FMAC2 soap_instantiate___ns1__SelSNTest_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17483 */
#ifndef SOAP_TYPE___ns1__DelSNTest_
#define SOAP_TYPE___ns1__DelSNTest_ (844)
/* Wrapper: */
struct SOAP_CMAC __ns1__DelSNTest_ {
      public:
        /** Optional element 'ns1:DelSNTest' of XSD type 'ns1:DelSNTest' */
        _ns1__DelSNTest *ns1__DelSNTest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DelSNTest_ */
        int soap_type() const { return SOAP_TYPE___ns1__DelSNTest_; }
        /** Constructor with member initializations */
        __ns1__DelSNTest_() : ns1__DelSNTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DelSNTest_ * SOAP_FMAC2 soap_instantiate___ns1__DelSNTest_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17553 */
#ifndef SOAP_TYPE___ns1__ChkSnLinkForApple_
#define SOAP_TYPE___ns1__ChkSnLinkForApple_ (846)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnLinkForApple_ {
      public:
        /** Optional element 'ns1:ChkSnLinkForApple' of XSD type 'ns1:ChkSnLinkForApple' */
        _ns1__ChkSnLinkForApple *ns1__ChkSnLinkForApple;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnLinkForApple_ */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnLinkForApple_; }
        /** Constructor with member initializations */
        __ns1__ChkSnLinkForApple_() : ns1__ChkSnLinkForApple() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnLinkForApple_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLinkForApple_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17623 */
#ifndef SOAP_TYPE___ns1__doSnLinkForApple_
#define SOAP_TYPE___ns1__doSnLinkForApple_ (848)
/* Wrapper: */
struct SOAP_CMAC __ns1__doSnLinkForApple_ {
      public:
        /** Optional element 'ns1:doSnLinkForApple' of XSD type 'ns1:doSnLinkForApple' */
        _ns1__doSnLinkForApple *ns1__doSnLinkForApple;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doSnLinkForApple_ */
        int soap_type() const { return SOAP_TYPE___ns1__doSnLinkForApple_; }
        /** Constructor with member initializations */
        __ns1__doSnLinkForApple_() : ns1__doSnLinkForApple() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doSnLinkForApple_ * SOAP_FMAC2 soap_instantiate___ns1__doSnLinkForApple_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17693 */
#ifndef SOAP_TYPE___ns1__GetObeNW_
#define SOAP_TYPE___ns1__GetObeNW_ (850)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetObeNW_ {
      public:
        /** Optional element 'ns1:GetObeNW' of XSD type 'ns1:GetObeNW' */
        _ns1__GetObeNW *ns1__GetObeNW;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetObeNW_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetObeNW_; }
        /** Constructor with member initializations */
        __ns1__GetObeNW_() : ns1__GetObeNW() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetObeNW_ * SOAP_FMAC2 soap_instantiate___ns1__GetObeNW_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17763 */
#ifndef SOAP_TYPE___ns1__GetFruitSNCheck_
#define SOAP_TYPE___ns1__GetFruitSNCheck_ (852)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFruitSNCheck_ {
      public:
        /** Optional element 'ns1:GetFruitSNCheck' of XSD type 'ns1:GetFruitSNCheck' */
        _ns1__GetFruitSNCheck *ns1__GetFruitSNCheck;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFruitSNCheck_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetFruitSNCheck_; }
        /** Constructor with member initializations */
        __ns1__GetFruitSNCheck_() : ns1__GetFruitSNCheck() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetFruitSNCheck_ * SOAP_FMAC2 soap_instantiate___ns1__GetFruitSNCheck_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17833 */
#ifndef SOAP_TYPE___ns1__GetLotLinkCount_
#define SOAP_TYPE___ns1__GetLotLinkCount_ (854)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLotLinkCount_ {
      public:
        /** Optional element 'ns1:GetLotLinkCount' of XSD type 'ns1:GetLotLinkCount' */
        _ns1__GetLotLinkCount *ns1__GetLotLinkCount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLotLinkCount_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetLotLinkCount_; }
        /** Constructor with member initializations */
        __ns1__GetLotLinkCount_() : ns1__GetLotLinkCount() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLotLinkCount_ * SOAP_FMAC2 soap_instantiate___ns1__GetLotLinkCount_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17903 */
#ifndef SOAP_TYPE___ns1__doLotLinkForApple_
#define SOAP_TYPE___ns1__doLotLinkForApple_ (856)
/* Wrapper: */
struct SOAP_CMAC __ns1__doLotLinkForApple_ {
      public:
        /** Optional element 'ns1:doLotLinkForApple' of XSD type 'ns1:doLotLinkForApple' */
        _ns1__doLotLinkForApple *ns1__doLotLinkForApple;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doLotLinkForApple_ */
        int soap_type() const { return SOAP_TYPE___ns1__doLotLinkForApple_; }
        /** Constructor with member initializations */
        __ns1__doLotLinkForApple_() : ns1__doLotLinkForApple() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doLotLinkForApple_ * SOAP_FMAC2 soap_instantiate___ns1__doLotLinkForApple_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:17973 */
#ifndef SOAP_TYPE___ns1__GetShippingList_
#define SOAP_TYPE___ns1__GetShippingList_ (858)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingList_ {
      public:
        /** Optional element 'ns1:GetShippingList' of XSD type 'ns1:GetShippingList' */
        _ns1__GetShippingList *ns1__GetShippingList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingList_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingList_; }
        /** Constructor with member initializations */
        __ns1__GetShippingList_() : ns1__GetShippingList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingList_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18043 */
#ifndef SOAP_TYPE___ns1__GetShippingBerthList_
#define SOAP_TYPE___ns1__GetShippingBerthList_ (860)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingBerthList_ {
      public:
        /** Optional element 'ns1:GetShippingBerthList' of XSD type 'ns1:GetShippingBerthList' */
        _ns1__GetShippingBerthList *ns1__GetShippingBerthList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingBerthList_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingBerthList_; }
        /** Constructor with member initializations */
        __ns1__GetShippingBerthList_() : ns1__GetShippingBerthList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingBerthList_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingBerthList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18113 */
#ifndef SOAP_TYPE___ns1__UpdShipping_
#define SOAP_TYPE___ns1__UpdShipping_ (862)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdShipping_ {
      public:
        /** Optional element 'ns1:UpdShipping' of XSD type 'ns1:UpdShipping' */
        _ns1__UpdShipping *ns1__UpdShipping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdShipping_ */
        int soap_type() const { return SOAP_TYPE___ns1__UpdShipping_; }
        /** Constructor with member initializations */
        __ns1__UpdShipping_() : ns1__UpdShipping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdShipping_ * SOAP_FMAC2 soap_instantiate___ns1__UpdShipping_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18183 */
#ifndef SOAP_TYPE___ns1__GetShippingPalle_
#define SOAP_TYPE___ns1__GetShippingPalle_ (864)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingPalle_ {
      public:
        /** Optional element 'ns1:GetShippingPalle' of XSD type 'ns1:GetShippingPalle' */
        _ns1__GetShippingPalle *ns1__GetShippingPalle;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingPalle_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingPalle_; }
        /** Constructor with member initializations */
        __ns1__GetShippingPalle_() : ns1__GetShippingPalle() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingPalle_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingPalle_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18253 */
#ifndef SOAP_TYPE___ns1__InsShippingPalle_
#define SOAP_TYPE___ns1__InsShippingPalle_ (866)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsShippingPalle_ {
      public:
        /** Optional element 'ns1:InsShippingPalle' of XSD type 'ns1:InsShippingPalle' */
        _ns1__InsShippingPalle *ns1__InsShippingPalle;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsShippingPalle_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsShippingPalle_; }
        /** Constructor with member initializations */
        __ns1__InsShippingPalle_() : ns1__InsShippingPalle() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsShippingPalle_ * SOAP_FMAC2 soap_instantiate___ns1__InsShippingPalle_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18323 */
#ifndef SOAP_TYPE___ns1__InsShippingBerth_
#define SOAP_TYPE___ns1__InsShippingBerth_ (868)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsShippingBerth_ {
      public:
        /** Optional element 'ns1:InsShippingBerth' of XSD type 'ns1:InsShippingBerth' */
        _ns1__InsShippingBerth *ns1__InsShippingBerth;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsShippingBerth_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsShippingBerth_; }
        /** Constructor with member initializations */
        __ns1__InsShippingBerth_() : ns1__InsShippingBerth() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsShippingBerth_ * SOAP_FMAC2 soap_instantiate___ns1__InsShippingBerth_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18393 */
#ifndef SOAP_TYPE___ns1__GetShippingForBerth_
#define SOAP_TYPE___ns1__GetShippingForBerth_ (870)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingForBerth_ {
      public:
        /** Optional element 'ns1:GetShippingForBerth' of XSD type 'ns1:GetShippingForBerth' */
        _ns1__GetShippingForBerth *ns1__GetShippingForBerth;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingForBerth_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingForBerth_; }
        /** Constructor with member initializations */
        __ns1__GetShippingForBerth_() : ns1__GetShippingForBerth() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingForBerth_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingForBerth_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18463 */
#ifndef SOAP_TYPE___ns1__GetShippingWeight_
#define SOAP_TYPE___ns1__GetShippingWeight_ (872)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShippingWeight_ {
      public:
        /** Optional element 'ns1:GetShippingWeight' of XSD type 'ns1:GetShippingWeight' */
        _ns1__GetShippingWeight *ns1__GetShippingWeight;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShippingWeight_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetShippingWeight_; }
        /** Constructor with member initializations */
        __ns1__GetShippingWeight_() : ns1__GetShippingWeight() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShippingWeight_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingWeight_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18533 */
#ifndef SOAP_TYPE___ns1__getStationByMoForTestPad_
#define SOAP_TYPE___ns1__getStationByMoForTestPad_ (874)
/* Wrapper: */
struct SOAP_CMAC __ns1__getStationByMoForTestPad_ {
      public:
        /** Optional element 'ns1:getStationByMoForTestPad' of XSD type 'ns1:getStationByMoForTestPad' */
        _ns1__getStationByMoForTestPad *ns1__getStationByMoForTestPad;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getStationByMoForTestPad_ */
        int soap_type() const { return SOAP_TYPE___ns1__getStationByMoForTestPad_; }
        /** Constructor with member initializations */
        __ns1__getStationByMoForTestPad_() : ns1__getStationByMoForTestPad() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getStationByMoForTestPad_ * SOAP_FMAC2 soap_instantiate___ns1__getStationByMoForTestPad_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18603 */
#ifndef SOAP_TYPE___ns1__SetFlatnessFruitRec_
#define SOAP_TYPE___ns1__SetFlatnessFruitRec_ (876)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetFlatnessFruitRec_ {
      public:
        /** Optional element 'ns1:SetFlatnessFruitRec' of XSD type 'ns1:SetFlatnessFruitRec' */
        _ns1__SetFlatnessFruitRec *ns1__SetFlatnessFruitRec;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetFlatnessFruitRec_ */
        int soap_type() const { return SOAP_TYPE___ns1__SetFlatnessFruitRec_; }
        /** Constructor with member initializations */
        __ns1__SetFlatnessFruitRec_() : ns1__SetFlatnessFruitRec() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetFlatnessFruitRec_ * SOAP_FMAC2 soap_instantiate___ns1__SetFlatnessFruitRec_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18673 */
#ifndef SOAP_TYPE___ns1__GetSNForLink_
#define SOAP_TYPE___ns1__GetSNForLink_ (878)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSNForLink_ {
      public:
        /** Optional element 'ns1:GetSNForLink' of XSD type 'ns1:GetSNForLink' */
        _ns1__GetSNForLink *ns1__GetSNForLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSNForLink_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetSNForLink_; }
        /** Constructor with member initializations */
        __ns1__GetSNForLink_() : ns1__GetSNForLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetSNForLink_ * SOAP_FMAC2 soap_instantiate___ns1__GetSNForLink_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18743 */
#ifndef SOAP_TYPE___ns1__SetAutoLineRec_
#define SOAP_TYPE___ns1__SetAutoLineRec_ (880)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetAutoLineRec_ {
      public:
        /** Optional element 'ns1:SetAutoLineRec' of XSD type 'ns1:SetAutoLineRec' */
        _ns1__SetAutoLineRec *ns1__SetAutoLineRec;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetAutoLineRec_ */
        int soap_type() const { return SOAP_TYPE___ns1__SetAutoLineRec_; }
        /** Constructor with member initializations */
        __ns1__SetAutoLineRec_() : ns1__SetAutoLineRec() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetAutoLineRec_ * SOAP_FMAC2 soap_instantiate___ns1__SetAutoLineRec_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18813 */
#ifndef SOAP_TYPE___ns1__HPSNLinkBasket_
#define SOAP_TYPE___ns1__HPSNLinkBasket_ (882)
/* Wrapper: */
struct SOAP_CMAC __ns1__HPSNLinkBasket_ {
      public:
        /** Optional element 'ns1:HPSNLinkBasket' of XSD type 'ns1:HPSNLinkBasket' */
        _ns1__HPSNLinkBasket *ns1__HPSNLinkBasket;
      public:
        /** Return unique type id SOAP_TYPE___ns1__HPSNLinkBasket_ */
        int soap_type() const { return SOAP_TYPE___ns1__HPSNLinkBasket_; }
        /** Constructor with member initializations */
        __ns1__HPSNLinkBasket_() : ns1__HPSNLinkBasket() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__HPSNLinkBasket_ * SOAP_FMAC2 soap_instantiate___ns1__HPSNLinkBasket_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18883 */
#ifndef SOAP_TYPE___ns1__BasketLinkPunch_
#define SOAP_TYPE___ns1__BasketLinkPunch_ (884)
/* Wrapper: */
struct SOAP_CMAC __ns1__BasketLinkPunch_ {
      public:
        /** Optional element 'ns1:BasketLinkPunch' of XSD type 'ns1:BasketLinkPunch' */
        _ns1__BasketLinkPunch *ns1__BasketLinkPunch;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BasketLinkPunch_ */
        int soap_type() const { return SOAP_TYPE___ns1__BasketLinkPunch_; }
        /** Constructor with member initializations */
        __ns1__BasketLinkPunch_() : ns1__BasketLinkPunch() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BasketLinkPunch_ * SOAP_FMAC2 soap_instantiate___ns1__BasketLinkPunch_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:18953 */
#ifndef SOAP_TYPE___ns1__PunchOut_
#define SOAP_TYPE___ns1__PunchOut_ (886)
/* Wrapper: */
struct SOAP_CMAC __ns1__PunchOut_ {
      public:
        /** Optional element 'ns1:PunchOut' of XSD type 'ns1:PunchOut' */
        _ns1__PunchOut *ns1__PunchOut;
      public:
        /** Return unique type id SOAP_TYPE___ns1__PunchOut_ */
        int soap_type() const { return SOAP_TYPE___ns1__PunchOut_; }
        /** Constructor with member initializations */
        __ns1__PunchOut_() : ns1__PunchOut() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__PunchOut_ * SOAP_FMAC2 soap_instantiate___ns1__PunchOut_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19023 */
#ifndef SOAP_TYPE___ns1__chkMoSNForAOI_
#define SOAP_TYPE___ns1__chkMoSNForAOI_ (888)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkMoSNForAOI_ {
      public:
        /** Optional element 'ns1:chkMoSNForAOI' of XSD type 'ns1:chkMoSNForAOI' */
        _ns1__chkMoSNForAOI *ns1__chkMoSNForAOI;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkMoSNForAOI_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkMoSNForAOI_; }
        /** Constructor with member initializations */
        __ns1__chkMoSNForAOI_() : ns1__chkMoSNForAOI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkMoSNForAOI_ * SOAP_FMAC2 soap_instantiate___ns1__chkMoSNForAOI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19093 */
#ifndef SOAP_TYPE___ns1__InsAoiMo_
#define SOAP_TYPE___ns1__InsAoiMo_ (890)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsAoiMo_ {
      public:
        /** Optional element 'ns1:InsAoiMo' of XSD type 'ns1:InsAoiMo' */
        _ns1__InsAoiMo *ns1__InsAoiMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsAoiMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsAoiMo_; }
        /** Constructor with member initializations */
        __ns1__InsAoiMo_() : ns1__InsAoiMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsAoiMo_ * SOAP_FMAC2 soap_instantiate___ns1__InsAoiMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19163 */
#ifndef SOAP_TYPE___ns1__InsCLScada_
#define SOAP_TYPE___ns1__InsCLScada_ (892)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsCLScada_ {
      public:
        /** Optional element 'ns1:InsCLScada' of XSD type 'ns1:InsCLScada' */
        _ns1__InsCLScada *ns1__InsCLScada;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsCLScada_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsCLScada_; }
        /** Constructor with member initializations */
        __ns1__InsCLScada_() : ns1__InsCLScada() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsCLScada_ * SOAP_FMAC2 soap_instantiate___ns1__InsCLScada_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19233 */
#ifndef SOAP_TYPE___ns1__GetTestValueResult_
#define SOAP_TYPE___ns1__GetTestValueResult_ (894)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTestValueResult_ {
      public:
        /** Optional element 'ns1:GetTestValueResult' of XSD type 'ns1:GetTestValueResult' */
        _ns1__GetTestValueResult *ns1__GetTestValueResult;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTestValueResult_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetTestValueResult_; }
        /** Constructor with member initializations */
        __ns1__GetTestValueResult_() : ns1__GetTestValueResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTestValueResult_ * SOAP_FMAC2 soap_instantiate___ns1__GetTestValueResult_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19303 */
#ifndef SOAP_TYPE___ns1__GetStationNumberForSN_
#define SOAP_TYPE___ns1__GetStationNumberForSN_ (896)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetStationNumberForSN_ {
      public:
        /** Optional element 'ns1:GetStationNumberForSN' of XSD type 'ns1:GetStationNumberForSN' */
        _ns1__GetStationNumberForSN *ns1__GetStationNumberForSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetStationNumberForSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetStationNumberForSN_; }
        /** Constructor with member initializations */
        __ns1__GetStationNumberForSN_() : ns1__GetStationNumberForSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetStationNumberForSN_ * SOAP_FMAC2 soap_instantiate___ns1__GetStationNumberForSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19373 */
#ifndef SOAP_TYPE___ns1__InsSNTestForFruit_
#define SOAP_TYPE___ns1__InsSNTestForFruit_ (898)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsSNTestForFruit_ {
      public:
        /** Optional element 'ns1:InsSNTestForFruit' of XSD type 'ns1:InsSNTestForFruit' */
        _ns1__InsSNTestForFruit *ns1__InsSNTestForFruit;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsSNTestForFruit_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsSNTestForFruit_; }
        /** Constructor with member initializations */
        __ns1__InsSNTestForFruit_() : ns1__InsSNTestForFruit() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsSNTestForFruit_ * SOAP_FMAC2 soap_instantiate___ns1__InsSNTestForFruit_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19443 */
#ifndef SOAP_TYPE___ns1__SelSNTestForFruit_
#define SOAP_TYPE___ns1__SelSNTestForFruit_ (900)
/* Wrapper: */
struct SOAP_CMAC __ns1__SelSNTestForFruit_ {
      public:
        /** Optional element 'ns1:SelSNTestForFruit' of XSD type 'ns1:SelSNTestForFruit' */
        _ns1__SelSNTestForFruit *ns1__SelSNTestForFruit;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelSNTestForFruit_ */
        int soap_type() const { return SOAP_TYPE___ns1__SelSNTestForFruit_; }
        /** Constructor with member initializations */
        __ns1__SelSNTestForFruit_() : ns1__SelSNTestForFruit() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SelSNTestForFruit_ * SOAP_FMAC2 soap_instantiate___ns1__SelSNTestForFruit_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19513 */
#ifndef SOAP_TYPE___ns1__SNLinkShelf_
#define SOAP_TYPE___ns1__SNLinkShelf_ (902)
/* Wrapper: */
struct SOAP_CMAC __ns1__SNLinkShelf_ {
      public:
        /** Optional element 'ns1:SNLinkShelf' of XSD type 'ns1:SNLinkShelf' */
        _ns1__SNLinkShelf *ns1__SNLinkShelf;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SNLinkShelf_ */
        int soap_type() const { return SOAP_TYPE___ns1__SNLinkShelf_; }
        /** Constructor with member initializations */
        __ns1__SNLinkShelf_() : ns1__SNLinkShelf() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SNLinkShelf_ * SOAP_FMAC2 soap_instantiate___ns1__SNLinkShelf_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19583 */
#ifndef SOAP_TYPE___ns1__SelShelfLink_
#define SOAP_TYPE___ns1__SelShelfLink_ (904)
/* Wrapper: */
struct SOAP_CMAC __ns1__SelShelfLink_ {
      public:
        /** Optional element 'ns1:SelShelfLink' of XSD type 'ns1:SelShelfLink' */
        _ns1__SelShelfLink *ns1__SelShelfLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelShelfLink_ */
        int soap_type() const { return SOAP_TYPE___ns1__SelShelfLink_; }
        /** Constructor with member initializations */
        __ns1__SelShelfLink_() : ns1__SelShelfLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SelShelfLink_ * SOAP_FMAC2 soap_instantiate___ns1__SelShelfLink_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19653 */
#ifndef SOAP_TYPE___ns1__UploadForHP_
#define SOAP_TYPE___ns1__UploadForHP_ (906)
/* Wrapper: */
struct SOAP_CMAC __ns1__UploadForHP_ {
      public:
        /** Optional element 'ns1:UploadForHP' of XSD type 'ns1:UploadForHP' */
        _ns1__UploadForHP *ns1__UploadForHP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UploadForHP_ */
        int soap_type() const { return SOAP_TYPE___ns1__UploadForHP_; }
        /** Constructor with member initializations */
        __ns1__UploadForHP_() : ns1__UploadForHP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UploadForHP_ * SOAP_FMAC2 soap_instantiate___ns1__UploadForHP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19723 */
#ifndef SOAP_TYPE___ns1__GetMachineForGroup_
#define SOAP_TYPE___ns1__GetMachineForGroup_ (908)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMachineForGroup_ {
      public:
        /** Optional element 'ns1:GetMachineForGroup' of XSD type 'ns1:GetMachineForGroup' */
        _ns1__GetMachineForGroup *ns1__GetMachineForGroup;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMachineForGroup_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetMachineForGroup_; }
        /** Constructor with member initializations */
        __ns1__GetMachineForGroup_() : ns1__GetMachineForGroup() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMachineForGroup_ * SOAP_FMAC2 soap_instantiate___ns1__GetMachineForGroup_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19793 */
#ifndef SOAP_TYPE___ns1__SetDiecastSN_
#define SOAP_TYPE___ns1__SetDiecastSN_ (910)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDiecastSN_ {
      public:
        /** Optional element 'ns1:SetDiecastSN' of XSD type 'ns1:SetDiecastSN' */
        _ns1__SetDiecastSN *ns1__SetDiecastSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDiecastSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__SetDiecastSN_; }
        /** Constructor with member initializations */
        __ns1__SetDiecastSN_() : ns1__SetDiecastSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetDiecastSN_ * SOAP_FMAC2 soap_instantiate___ns1__SetDiecastSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19863 */
#ifndef SOAP_TYPE___ns1__GetNgCode_
#define SOAP_TYPE___ns1__GetNgCode_ (912)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetNgCode_ {
      public:
        /** Optional element 'ns1:GetNgCode' of XSD type 'ns1:GetNgCode' */
        _ns1__GetNgCode *ns1__GetNgCode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetNgCode_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetNgCode_; }
        /** Constructor with member initializations */
        __ns1__GetNgCode_() : ns1__GetNgCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetNgCode_ * SOAP_FMAC2 soap_instantiate___ns1__GetNgCode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:19933 */
#ifndef SOAP_TYPE___ns1__getMoBase_
#define SOAP_TYPE___ns1__getMoBase_ (914)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMoBase_ {
      public:
        /** Optional element 'ns1:getMoBase' of XSD type 'ns1:getMoBase' */
        _ns1__getMoBase *ns1__getMoBase;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMoBase_ */
        int soap_type() const { return SOAP_TYPE___ns1__getMoBase_; }
        /** Constructor with member initializations */
        __ns1__getMoBase_() : ns1__getMoBase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMoBase_ * SOAP_FMAC2 soap_instantiate___ns1__getMoBase_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20003 */
#ifndef SOAP_TYPE___ns1__SnLnkOutSN_
#define SOAP_TYPE___ns1__SnLnkOutSN_ (916)
/* Wrapper: */
struct SOAP_CMAC __ns1__SnLnkOutSN_ {
      public:
        /** Optional element 'ns1:SnLnkOutSN' of XSD type 'ns1:SnLnkOutSN' */
        _ns1__SnLnkOutSN *ns1__SnLnkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SnLnkOutSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__SnLnkOutSN_; }
        /** Constructor with member initializations */
        __ns1__SnLnkOutSN_() : ns1__SnLnkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SnLnkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__SnLnkOutSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20073 */
#ifndef SOAP_TYPE___ns1__InsFruitMachineChk_
#define SOAP_TYPE___ns1__InsFruitMachineChk_ (918)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFruitMachineChk_ {
      public:
        /** Optional element 'ns1:InsFruitMachineChk' of XSD type 'ns1:InsFruitMachineChk' */
        _ns1__InsFruitMachineChk *ns1__InsFruitMachineChk;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFruitMachineChk_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsFruitMachineChk_; }
        /** Constructor with member initializations */
        __ns1__InsFruitMachineChk_() : ns1__InsFruitMachineChk() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFruitMachineChk_ * SOAP_FMAC2 soap_instantiate___ns1__InsFruitMachineChk_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20143 */
#ifndef SOAP_TYPE___ns1__GetFruitMachineChk_
#define SOAP_TYPE___ns1__GetFruitMachineChk_ (920)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFruitMachineChk_ {
      public:
        /** Optional element 'ns1:GetFruitMachineChk' of XSD type 'ns1:GetFruitMachineChk' */
        _ns1__GetFruitMachineChk *ns1__GetFruitMachineChk;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFruitMachineChk_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetFruitMachineChk_; }
        /** Constructor with member initializations */
        __ns1__GetFruitMachineChk_() : ns1__GetFruitMachineChk() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetFruitMachineChk_ * SOAP_FMAC2 soap_instantiate___ns1__GetFruitMachineChk_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20213 */
#ifndef SOAP_TYPE___ns1__InsZjList_
#define SOAP_TYPE___ns1__InsZjList_ (922)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsZjList_ {
      public:
        /** Optional element 'ns1:InsZjList' of XSD type 'ns1:InsZjList' */
        _ns1__InsZjList *ns1__InsZjList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsZjList_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsZjList_; }
        /** Constructor with member initializations */
        __ns1__InsZjList_() : ns1__InsZjList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsZjList_ * SOAP_FMAC2 soap_instantiate___ns1__InsZjList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20283 */
#ifndef SOAP_TYPE___ns1__checkTestData_
#define SOAP_TYPE___ns1__checkTestData_ (924)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkTestData_ {
      public:
        /** Optional element 'ns1:checkTestData' of XSD type 'ns1:checkTestData' */
        _ns1__checkTestData *ns1__checkTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkTestData_ */
        int soap_type() const { return SOAP_TYPE___ns1__checkTestData_; }
        /** Constructor with member initializations */
        __ns1__checkTestData_() : ns1__checkTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkTestData_ * SOAP_FMAC2 soap_instantiate___ns1__checkTestData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20353 */
#ifndef SOAP_TYPE___ns1__checkEmpNo_
#define SOAP_TYPE___ns1__checkEmpNo_ (926)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkEmpNo_ {
      public:
        /** Optional element 'ns1:checkEmpNo' of XSD type 'ns1:checkEmpNo' */
        _ns1__checkEmpNo *ns1__checkEmpNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkEmpNo_ */
        int soap_type() const { return SOAP_TYPE___ns1__checkEmpNo_; }
        /** Constructor with member initializations */
        __ns1__checkEmpNo_() : ns1__checkEmpNo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkEmpNo_ * SOAP_FMAC2 soap_instantiate___ns1__checkEmpNo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20423 */
#ifndef SOAP_TYPE___ns1__checkSN_USCOREStation_
#define SOAP_TYPE___ns1__checkSN_USCOREStation_ (928)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkSN_USCOREStation_ {
      public:
        /** Optional element 'ns1:checkSN_Station' of XSD type 'ns1:checkSN_Station' */
        _ns1__checkSN_USCOREStation *ns1__checkSN_USCOREStation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkSN_USCOREStation_ */
        int soap_type() const { return SOAP_TYPE___ns1__checkSN_USCOREStation_; }
        /** Constructor with member initializations */
        __ns1__checkSN_USCOREStation_() : ns1__checkSN_USCOREStation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkSN_USCOREStation_ * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20493 */
#ifndef SOAP_TYPE___ns1__sendTestData_
#define SOAP_TYPE___ns1__sendTestData_ (930)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendTestData_ {
      public:
        /** Optional element 'ns1:sendTestData' of XSD type 'ns1:sendTestData' */
        _ns1__sendTestData *ns1__sendTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendTestData_ */
        int soap_type() const { return SOAP_TYPE___ns1__sendTestData_; }
        /** Constructor with member initializations */
        __ns1__sendTestData_() : ns1__sendTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendTestData_ * SOAP_FMAC2 soap_instantiate___ns1__sendTestData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20563 */
#ifndef SOAP_TYPE___ns1__sendTestResult_
#define SOAP_TYPE___ns1__sendTestResult_ (932)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendTestResult_ {
      public:
        /** Optional element 'ns1:sendTestResult' of XSD type 'ns1:sendTestResult' */
        _ns1__sendTestResult *ns1__sendTestResult;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendTestResult_ */
        int soap_type() const { return SOAP_TYPE___ns1__sendTestResult_; }
        /** Constructor with member initializations */
        __ns1__sendTestResult_() : ns1__sendTestResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendTestResult_ * SOAP_FMAC2 soap_instantiate___ns1__sendTestResult_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20633 */
#ifndef SOAP_TYPE___ns1__InFruitsOrtQty_
#define SOAP_TYPE___ns1__InFruitsOrtQty_ (934)
/* Wrapper: */
struct SOAP_CMAC __ns1__InFruitsOrtQty_ {
      public:
        /** Optional element 'ns1:InFruitsOrtQty' of XSD type 'ns1:InFruitsOrtQty' */
        _ns1__InFruitsOrtQty *ns1__InFruitsOrtQty;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InFruitsOrtQty_ */
        int soap_type() const { return SOAP_TYPE___ns1__InFruitsOrtQty_; }
        /** Constructor with member initializations */
        __ns1__InFruitsOrtQty_() : ns1__InFruitsOrtQty() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InFruitsOrtQty_ * SOAP_FMAC2 soap_instantiate___ns1__InFruitsOrtQty_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20703 */
#ifndef SOAP_TYPE___ns1__chkStationTime_
#define SOAP_TYPE___ns1__chkStationTime_ (936)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkStationTime_ {
      public:
        /** Optional element 'ns1:chkStationTime' of XSD type 'ns1:chkStationTime' */
        _ns1__chkStationTime *ns1__chkStationTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkStationTime_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkStationTime_; }
        /** Constructor with member initializations */
        __ns1__chkStationTime_() : ns1__chkStationTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkStationTime_ * SOAP_FMAC2 soap_instantiate___ns1__chkStationTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20773 */
#ifndef SOAP_TYPE___ns1__ImpMesAteTestData_
#define SOAP_TYPE___ns1__ImpMesAteTestData_ (938)
/* Wrapper: */
struct SOAP_CMAC __ns1__ImpMesAteTestData_ {
      public:
        /** Optional element 'ns1:ImpMesAteTestData' of XSD type 'ns1:ImpMesAteTestData' */
        _ns1__ImpMesAteTestData *ns1__ImpMesAteTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ImpMesAteTestData_ */
        int soap_type() const { return SOAP_TYPE___ns1__ImpMesAteTestData_; }
        /** Constructor with member initializations */
        __ns1__ImpMesAteTestData_() : ns1__ImpMesAteTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ImpMesAteTestData_ * SOAP_FMAC2 soap_instantiate___ns1__ImpMesAteTestData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20843 */
#ifndef SOAP_TYPE___ns1__InsFlatNess_
#define SOAP_TYPE___ns1__InsFlatNess_ (940)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFlatNess_ {
      public:
        /** Optional element 'ns1:InsFlatNess' of XSD type 'ns1:InsFlatNess' */
        _ns1__InsFlatNess *ns1__InsFlatNess;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFlatNess_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsFlatNess_; }
        /** Constructor with member initializations */
        __ns1__InsFlatNess_() : ns1__InsFlatNess() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFlatNess_ * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNess_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20913 */
#ifndef SOAP_TYPE___ns1__InsFlatNessForLSD_
#define SOAP_TYPE___ns1__InsFlatNessForLSD_ (942)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFlatNessForLSD_ {
      public:
        /** Optional element 'ns1:InsFlatNessForLSD' of XSD type 'ns1:InsFlatNessForLSD' */
        _ns1__InsFlatNessForLSD *ns1__InsFlatNessForLSD;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFlatNessForLSD_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsFlatNessForLSD_; }
        /** Constructor with member initializations */
        __ns1__InsFlatNessForLSD_() : ns1__InsFlatNessForLSD() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFlatNessForLSD_ * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForLSD_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:20983 */
#ifndef SOAP_TYPE___ns1__InsFlatNessForCL_
#define SOAP_TYPE___ns1__InsFlatNessForCL_ (944)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsFlatNessForCL_ {
      public:
        /** Optional element 'ns1:InsFlatNessForCL' of XSD type 'ns1:InsFlatNessForCL' */
        _ns1__InsFlatNessForCL *ns1__InsFlatNessForCL;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsFlatNessForCL_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsFlatNessForCL_; }
        /** Constructor with member initializations */
        __ns1__InsFlatNessForCL_() : ns1__InsFlatNessForCL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsFlatNessForCL_ * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForCL_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21053 */
#ifndef SOAP_TYPE___ns1__InsWHDetection_
#define SOAP_TYPE___ns1__InsWHDetection_ (946)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsWHDetection_ {
      public:
        /** Optional element 'ns1:InsWHDetection' of XSD type 'ns1:InsWHDetection' */
        _ns1__InsWHDetection *ns1__InsWHDetection;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsWHDetection_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsWHDetection_; }
        /** Constructor with member initializations */
        __ns1__InsWHDetection_() : ns1__InsWHDetection() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsWHDetection_ * SOAP_FMAC2 soap_instantiate___ns1__InsWHDetection_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21123 */
#ifndef SOAP_TYPE___ns1__InsThermal_
#define SOAP_TYPE___ns1__InsThermal_ (948)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsThermal_ {
      public:
        /** Optional element 'ns1:InsThermal' of XSD type 'ns1:InsThermal' */
        _ns1__InsThermal *ns1__InsThermal;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsThermal_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsThermal_; }
        /** Constructor with member initializations */
        __ns1__InsThermal_() : ns1__InsThermal() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsThermal_ * SOAP_FMAC2 soap_instantiate___ns1__InsThermal_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21193 */
#ifndef SOAP_TYPE___ns1__ChkSnLink_
#define SOAP_TYPE___ns1__ChkSnLink_ (950)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnLink_ {
      public:
        /** Optional element 'ns1:ChkSnLink' of XSD type 'ns1:ChkSnLink' */
        _ns1__ChkSnLink *ns1__ChkSnLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnLink_ */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnLink_; }
        /** Constructor with member initializations */
        __ns1__ChkSnLink_() : ns1__ChkSnLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnLink_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLink_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21263 */
#ifndef SOAP_TYPE___ns1__InsThermalNew_
#define SOAP_TYPE___ns1__InsThermalNew_ (952)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsThermalNew_ {
      public:
        /** Optional element 'ns1:InsThermalNew' of XSD type 'ns1:InsThermalNew' */
        _ns1__InsThermalNew *ns1__InsThermalNew;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsThermalNew_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsThermalNew_; }
        /** Constructor with member initializations */
        __ns1__InsThermalNew_() : ns1__InsThermalNew() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsThermalNew_ * SOAP_FMAC2 soap_instantiate___ns1__InsThermalNew_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21333 */
#ifndef SOAP_TYPE___ns1__getInfoByMo_
#define SOAP_TYPE___ns1__getInfoByMo_ (954)
/* Wrapper: */
struct SOAP_CMAC __ns1__getInfoByMo_ {
      public:
        /** Optional element 'ns1:getInfoByMo' of XSD type 'ns1:getInfoByMo' */
        _ns1__getInfoByMo *ns1__getInfoByMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getInfoByMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__getInfoByMo_; }
        /** Constructor with member initializations */
        __ns1__getInfoByMo_() : ns1__getInfoByMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getInfoByMo_ * SOAP_FMAC2 soap_instantiate___ns1__getInfoByMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21403 */
#ifndef SOAP_TYPE___ns1__SetEnergyStat_
#define SOAP_TYPE___ns1__SetEnergyStat_ (956)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetEnergyStat_ {
      public:
        /** Optional element 'ns1:SetEnergyStat' of XSD type 'ns1:SetEnergyStat' */
        _ns1__SetEnergyStat *ns1__SetEnergyStat;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetEnergyStat_ */
        int soap_type() const { return SOAP_TYPE___ns1__SetEnergyStat_; }
        /** Constructor with member initializations */
        __ns1__SetEnergyStat_() : ns1__SetEnergyStat() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetEnergyStat_ * SOAP_FMAC2 soap_instantiate___ns1__SetEnergyStat_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21473 */
#ifndef SOAP_TYPE___ns1__chkMoStation_
#define SOAP_TYPE___ns1__chkMoStation_ (958)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkMoStation_ {
      public:
        /** Optional element 'ns1:chkMoStation' of XSD type 'ns1:chkMoStation' */
        _ns1__chkMoStation *ns1__chkMoStation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkMoStation_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkMoStation_; }
        /** Constructor with member initializations */
        __ns1__chkMoStation_() : ns1__chkMoStation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkMoStation_ * SOAP_FMAC2 soap_instantiate___ns1__chkMoStation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21543 */
#ifndef SOAP_TYPE___ns1__ChkSnMo_
#define SOAP_TYPE___ns1__ChkSnMo_ (960)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnMo_ {
      public:
        /** Optional element 'ns1:ChkSnMo' of XSD type 'ns1:ChkSnMo' */
        _ns1__ChkSnMo *ns1__ChkSnMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnMo_; }
        /** Constructor with member initializations */
        __ns1__ChkSnMo_() : ns1__ChkSnMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnMo_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21613 */
#ifndef SOAP_TYPE___ns1__ChkSnNextMo_
#define SOAP_TYPE___ns1__ChkSnNextMo_ (962)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkSnNextMo_ {
      public:
        /** Optional element 'ns1:ChkSnNextMo' of XSD type 'ns1:ChkSnNextMo' */
        _ns1__ChkSnNextMo *ns1__ChkSnNextMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkSnNextMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__ChkSnNextMo_; }
        /** Constructor with member initializations */
        __ns1__ChkSnNextMo_() : ns1__ChkSnNextMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkSnNextMo_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnNextMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21683 */
#ifndef SOAP_TYPE___ns1__checkSN_USCOREStationNumber_
#define SOAP_TYPE___ns1__checkSN_USCOREStationNumber_ (964)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkSN_USCOREStationNumber_ {
      public:
        /** Optional element 'ns1:checkSN_StationNumber' of XSD type 'ns1:checkSN_StationNumber' */
        _ns1__checkSN_USCOREStationNumber *ns1__checkSN_USCOREStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkSN_USCOREStationNumber_ */
        int soap_type() const { return SOAP_TYPE___ns1__checkSN_USCOREStationNumber_; }
        /** Constructor with member initializations */
        __ns1__checkSN_USCOREStationNumber_() : ns1__checkSN_USCOREStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkSN_USCOREStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStationNumber_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21753 */
#ifndef SOAP_TYPE___ns1__checkEmpForStationNumber_
#define SOAP_TYPE___ns1__checkEmpForStationNumber_ (966)
/* Wrapper: */
struct SOAP_CMAC __ns1__checkEmpForStationNumber_ {
      public:
        /** Optional element 'ns1:checkEmpForStationNumber' of XSD type 'ns1:checkEmpForStationNumber' */
        _ns1__checkEmpForStationNumber *ns1__checkEmpForStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkEmpForStationNumber_ */
        int soap_type() const { return SOAP_TYPE___ns1__checkEmpForStationNumber_; }
        /** Constructor with member initializations */
        __ns1__checkEmpForStationNumber_() : ns1__checkEmpForStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__checkEmpForStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__checkEmpForStationNumber_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21823 */
#ifndef SOAP_TYPE___ns1__sendDataForStationNumber_
#define SOAP_TYPE___ns1__sendDataForStationNumber_ (968)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendDataForStationNumber_ {
      public:
        /** Optional element 'ns1:sendDataForStationNumber' of XSD type 'ns1:sendDataForStationNumber' */
        _ns1__sendDataForStationNumber *ns1__sendDataForStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendDataForStationNumber_ */
        int soap_type() const { return SOAP_TYPE___ns1__sendDataForStationNumber_; }
        /** Constructor with member initializations */
        __ns1__sendDataForStationNumber_() : ns1__sendDataForStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendDataForStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__sendDataForStationNumber_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21893 */
#ifndef SOAP_TYPE___ns1__sendResultForStationNumber_
#define SOAP_TYPE___ns1__sendResultForStationNumber_ (970)
/* Wrapper: */
struct SOAP_CMAC __ns1__sendResultForStationNumber_ {
      public:
        /** Optional element 'ns1:sendResultForStationNumber' of XSD type 'ns1:sendResultForStationNumber' */
        _ns1__sendResultForStationNumber *ns1__sendResultForStationNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__sendResultForStationNumber_ */
        int soap_type() const { return SOAP_TYPE___ns1__sendResultForStationNumber_; }
        /** Constructor with member initializations */
        __ns1__sendResultForStationNumber_() : ns1__sendResultForStationNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__sendResultForStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__sendResultForStationNumber_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:21963 */
#ifndef SOAP_TYPE___ns1__eMesNextMo_
#define SOAP_TYPE___ns1__eMesNextMo_ (972)
/* Wrapper: */
struct SOAP_CMAC __ns1__eMesNextMo_ {
      public:
        /** Optional element 'ns1:eMesNextMo' of XSD type 'ns1:eMesNextMo' */
        _ns1__eMesNextMo *ns1__eMesNextMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__eMesNextMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__eMesNextMo_; }
        /** Constructor with member initializations */
        __ns1__eMesNextMo_() : ns1__eMesNextMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__eMesNextMo_ * SOAP_FMAC2 soap_instantiate___ns1__eMesNextMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22033 */
#ifndef SOAP_TYPE___ns1__SnDoMapping_
#define SOAP_TYPE___ns1__SnDoMapping_ (974)
/* Wrapper: */
struct SOAP_CMAC __ns1__SnDoMapping_ {
      public:
        /** Optional element 'ns1:SnDoMapping' of XSD type 'ns1:SnDoMapping' */
        _ns1__SnDoMapping *ns1__SnDoMapping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SnDoMapping_ */
        int soap_type() const { return SOAP_TYPE___ns1__SnDoMapping_; }
        /** Constructor with member initializations */
        __ns1__SnDoMapping_() : ns1__SnDoMapping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SnDoMapping_ * SOAP_FMAC2 soap_instantiate___ns1__SnDoMapping_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22103 */
#ifndef SOAP_TYPE___ns1__getStationByMo_
#define SOAP_TYPE___ns1__getStationByMo_ (976)
/* Wrapper: */
struct SOAP_CMAC __ns1__getStationByMo_ {
      public:
        /** Optional element 'ns1:getStationByMo' of XSD type 'ns1:getStationByMo' */
        _ns1__getStationByMo *ns1__getStationByMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getStationByMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__getStationByMo_; }
        /** Constructor with member initializations */
        __ns1__getStationByMo_() : ns1__getStationByMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getStationByMo_ * SOAP_FMAC2 soap_instantiate___ns1__getStationByMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22173 */
#ifndef SOAP_TYPE___ns1__getStationTypeDesc_
#define SOAP_TYPE___ns1__getStationTypeDesc_ (978)
/* Wrapper: */
struct SOAP_CMAC __ns1__getStationTypeDesc_ {
      public:
        /** Optional element 'ns1:getStationTypeDesc' of XSD type 'ns1:getStationTypeDesc' */
        _ns1__getStationTypeDesc *ns1__getStationTypeDesc;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getStationTypeDesc_ */
        int soap_type() const { return SOAP_TYPE___ns1__getStationTypeDesc_; }
        /** Constructor with member initializations */
        __ns1__getStationTypeDesc_() : ns1__getStationTypeDesc() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getStationTypeDesc_ * SOAP_FMAC2 soap_instantiate___ns1__getStationTypeDesc_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22243 */
#ifndef SOAP_TYPE___ns1__chkSnMapping_
#define SOAP_TYPE___ns1__chkSnMapping_ (980)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkSnMapping_ {
      public:
        /** Optional element 'ns1:chkSnMapping' of XSD type 'ns1:chkSnMapping' */
        _ns1__chkSnMapping *ns1__chkSnMapping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkSnMapping_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkSnMapping_; }
        /** Constructor with member initializations */
        __ns1__chkSnMapping_() : ns1__chkSnMapping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkSnMapping_ * SOAP_FMAC2 soap_instantiate___ns1__chkSnMapping_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22313 */
#ifndef SOAP_TYPE___ns1__getMoAssyList_
#define SOAP_TYPE___ns1__getMoAssyList_ (982)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMoAssyList_ {
      public:
        /** Optional element 'ns1:getMoAssyList' of XSD type 'ns1:getMoAssyList' */
        _ns1__getMoAssyList *ns1__getMoAssyList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMoAssyList_ */
        int soap_type() const { return SOAP_TYPE___ns1__getMoAssyList_; }
        /** Constructor with member initializations */
        __ns1__getMoAssyList_() : ns1__getMoAssyList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMoAssyList_ * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22383 */
#ifndef SOAP_TYPE___ns1__getPartBomExt_
#define SOAP_TYPE___ns1__getPartBomExt_ (984)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPartBomExt_ {
      public:
        /** Optional element 'ns1:getPartBomExt' of XSD type 'ns1:getPartBomExt' */
        _ns1__getPartBomExt *ns1__getPartBomExt;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPartBomExt_ */
        int soap_type() const { return SOAP_TYPE___ns1__getPartBomExt_; }
        /** Constructor with member initializations */
        __ns1__getPartBomExt_() : ns1__getPartBomExt() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPartBomExt_ * SOAP_FMAC2 soap_instantiate___ns1__getPartBomExt_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22453 */
#ifndef SOAP_TYPE___ns1__InsPartAssy_
#define SOAP_TYPE___ns1__InsPartAssy_ (986)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsPartAssy_ {
      public:
        /** Optional element 'ns1:InsPartAssy' of XSD type 'ns1:InsPartAssy' */
        _ns1__InsPartAssy *ns1__InsPartAssy;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsPartAssy_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsPartAssy_; }
        /** Constructor with member initializations */
        __ns1__InsPartAssy_() : ns1__InsPartAssy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsPartAssy_ * SOAP_FMAC2 soap_instantiate___ns1__InsPartAssy_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22523 */
#ifndef SOAP_TYPE___ns1__GetLinkOutSn_
#define SOAP_TYPE___ns1__GetLinkOutSn_ (988)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLinkOutSn_ {
      public:
        /** Optional element 'ns1:GetLinkOutSn' of XSD type 'ns1:GetLinkOutSn' */
        _ns1__GetLinkOutSn *ns1__GetLinkOutSn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLinkOutSn_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetLinkOutSn_; }
        /** Constructor with member initializations */
        __ns1__GetLinkOutSn_() : ns1__GetLinkOutSn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLinkOutSn_ * SOAP_FMAC2 soap_instantiate___ns1__GetLinkOutSn_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22593 */
#ifndef SOAP_TYPE___ns1__getMoAssyCount_
#define SOAP_TYPE___ns1__getMoAssyCount_ (990)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMoAssyCount_ {
      public:
        /** Optional element 'ns1:getMoAssyCount' of XSD type 'ns1:getMoAssyCount' */
        _ns1__getMoAssyCount *ns1__getMoAssyCount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMoAssyCount_ */
        int soap_type() const { return SOAP_TYPE___ns1__getMoAssyCount_; }
        /** Constructor with member initializations */
        __ns1__getMoAssyCount_() : ns1__getMoAssyCount() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMoAssyCount_ * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyCount_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22663 */
#ifndef SOAP_TYPE___ns1__getPNbySN_
#define SOAP_TYPE___ns1__getPNbySN_ (992)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPNbySN_ {
      public:
        /** Optional element 'ns1:getPNbySN' of XSD type 'ns1:getPNbySN' */
        _ns1__getPNbySN *ns1__getPNbySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPNbySN_ */
        int soap_type() const { return SOAP_TYPE___ns1__getPNbySN_; }
        /** Constructor with member initializations */
        __ns1__getPNbySN_() : ns1__getPNbySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPNbySN_ * SOAP_FMAC2 soap_instantiate___ns1__getPNbySN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22733 */
#ifndef SOAP_TYPE___ns1__chkAssySN_
#define SOAP_TYPE___ns1__chkAssySN_ (994)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkAssySN_ {
      public:
        /** Optional element 'ns1:chkAssySN' of XSD type 'ns1:chkAssySN' */
        _ns1__chkAssySN *ns1__chkAssySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkAssySN_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkAssySN_; }
        /** Constructor with member initializations */
        __ns1__chkAssySN_() : ns1__chkAssySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkAssySN_ * SOAP_FMAC2 soap_instantiate___ns1__chkAssySN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22803 */
#ifndef SOAP_TYPE___ns1__doAssy_
#define SOAP_TYPE___ns1__doAssy_ (996)
/* Wrapper: */
struct SOAP_CMAC __ns1__doAssy_ {
      public:
        /** Optional element 'ns1:doAssy' of XSD type 'ns1:doAssy' */
        _ns1__doAssy *ns1__doAssy;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doAssy_ */
        int soap_type() const { return SOAP_TYPE___ns1__doAssy_; }
        /** Constructor with member initializations */
        __ns1__doAssy_() : ns1__doAssy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doAssy_ * SOAP_FMAC2 soap_instantiate___ns1__doAssy_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22873 */
#ifndef SOAP_TYPE___ns1__getPmcAssyList_
#define SOAP_TYPE___ns1__getPmcAssyList_ (998)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPmcAssyList_ {
      public:
        /** Optional element 'ns1:getPmcAssyList' of XSD type 'ns1:getPmcAssyList' */
        _ns1__getPmcAssyList *ns1__getPmcAssyList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPmcAssyList_ */
        int soap_type() const { return SOAP_TYPE___ns1__getPmcAssyList_; }
        /** Constructor with member initializations */
        __ns1__getPmcAssyList_() : ns1__getPmcAssyList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPmcAssyList_ * SOAP_FMAC2 soap_instantiate___ns1__getPmcAssyList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:22943 */
#ifndef SOAP_TYPE___ns1__getPmcPartAssyList_
#define SOAP_TYPE___ns1__getPmcPartAssyList_ (1000)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPmcPartAssyList_ {
      public:
        /** Optional element 'ns1:getPmcPartAssyList' of XSD type 'ns1:getPmcPartAssyList' */
        _ns1__getPmcPartAssyList *ns1__getPmcPartAssyList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPmcPartAssyList_ */
        int soap_type() const { return SOAP_TYPE___ns1__getPmcPartAssyList_; }
        /** Constructor with member initializations */
        __ns1__getPmcPartAssyList_() : ns1__getPmcPartAssyList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPmcPartAssyList_ * SOAP_FMAC2 soap_instantiate___ns1__getPmcPartAssyList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23013 */
#ifndef SOAP_TYPE___ns1__GetPmcSNPart_
#define SOAP_TYPE___ns1__GetPmcSNPart_ (1002)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPmcSNPart_ {
      public:
        /** Optional element 'ns1:GetPmcSNPart' of XSD type 'ns1:GetPmcSNPart' */
        _ns1__GetPmcSNPart *ns1__GetPmcSNPart;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPmcSNPart_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetPmcSNPart_; }
        /** Constructor with member initializations */
        __ns1__GetPmcSNPart_() : ns1__GetPmcSNPart() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPmcSNPart_ * SOAP_FMAC2 soap_instantiate___ns1__GetPmcSNPart_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23083 */
#ifndef SOAP_TYPE___ns1__doPmcSNLink_
#define SOAP_TYPE___ns1__doPmcSNLink_ (1004)
/* Wrapper: */
struct SOAP_CMAC __ns1__doPmcSNLink_ {
      public:
        /** Optional element 'ns1:doPmcSNLink' of XSD type 'ns1:doPmcSNLink' */
        _ns1__doPmcSNLink *ns1__doPmcSNLink;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doPmcSNLink_ */
        int soap_type() const { return SOAP_TYPE___ns1__doPmcSNLink_; }
        /** Constructor with member initializations */
        __ns1__doPmcSNLink_() : ns1__doPmcSNLink() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doPmcSNLink_ * SOAP_FMAC2 soap_instantiate___ns1__doPmcSNLink_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23153 */
#ifndef SOAP_TYPE___ns1__InsZJTestData_
#define SOAP_TYPE___ns1__InsZJTestData_ (1006)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsZJTestData_ {
      public:
        /** Optional element 'ns1:InsZJTestData' of XSD type 'ns1:InsZJTestData' */
        _ns1__InsZJTestData *ns1__InsZJTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsZJTestData_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsZJTestData_; }
        /** Constructor with member initializations */
        __ns1__InsZJTestData_() : ns1__InsZJTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsZJTestData_ * SOAP_FMAC2 soap_instantiate___ns1__InsZJTestData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23223 */
#ifndef SOAP_TYPE___ns1__SNLinkZJ_
#define SOAP_TYPE___ns1__SNLinkZJ_ (1008)
/* Wrapper: */
struct SOAP_CMAC __ns1__SNLinkZJ_ {
      public:
        /** Optional element 'ns1:SNLinkZJ' of XSD type 'ns1:SNLinkZJ' */
        _ns1__SNLinkZJ *ns1__SNLinkZJ;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SNLinkZJ_ */
        int soap_type() const { return SOAP_TYPE___ns1__SNLinkZJ_; }
        /** Constructor with member initializations */
        __ns1__SNLinkZJ_() : ns1__SNLinkZJ() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SNLinkZJ_ * SOAP_FMAC2 soap_instantiate___ns1__SNLinkZJ_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23293 */
#ifndef SOAP_TYPE___ns1__GetLintOutQty_
#define SOAP_TYPE___ns1__GetLintOutQty_ (1010)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLintOutQty_ {
      public:
        /** Optional element 'ns1:GetLintOutQty' of XSD type 'ns1:GetLintOutQty' */
        _ns1__GetLintOutQty *ns1__GetLintOutQty;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLintOutQty_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetLintOutQty_; }
        /** Constructor with member initializations */
        __ns1__GetLintOutQty_() : ns1__GetLintOutQty() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLintOutQty_ * SOAP_FMAC2 soap_instantiate___ns1__GetLintOutQty_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23363 */
#ifndef SOAP_TYPE___ns1__chkOutSN_
#define SOAP_TYPE___ns1__chkOutSN_ (1012)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkOutSN_ {
      public:
        /** Optional element 'ns1:chkOutSN' of XSD type 'ns1:chkOutSN' */
        _ns1__chkOutSN *ns1__chkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkOutSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkOutSN_; }
        /** Constructor with member initializations */
        __ns1__chkOutSN_() : ns1__chkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__chkOutSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23433 */
#ifndef SOAP_TYPE___ns1__ChkLinkOutSN_
#define SOAP_TYPE___ns1__ChkLinkOutSN_ (1014)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChkLinkOutSN_ {
      public:
        /** Optional element 'ns1:ChkLinkOutSN' of XSD type 'ns1:ChkLinkOutSN' */
        _ns1__ChkLinkOutSN *ns1__ChkLinkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChkLinkOutSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__ChkLinkOutSN_; }
        /** Constructor with member initializations */
        __ns1__ChkLinkOutSN_() : ns1__ChkLinkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChkLinkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__ChkLinkOutSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23503 */
#ifndef SOAP_TYPE___ns1__doLinkOutSN_
#define SOAP_TYPE___ns1__doLinkOutSN_ (1016)
/* Wrapper: */
struct SOAP_CMAC __ns1__doLinkOutSN_ {
      public:
        /** Optional element 'ns1:doLinkOutSN' of XSD type 'ns1:doLinkOutSN' */
        _ns1__doLinkOutSN *ns1__doLinkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doLinkOutSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__doLinkOutSN_; }
        /** Constructor with member initializations */
        __ns1__doLinkOutSN_() : ns1__doLinkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doLinkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__doLinkOutSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23573 */
#ifndef SOAP_TYPE___ns1__InsLinkSN_
#define SOAP_TYPE___ns1__InsLinkSN_ (1018)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsLinkSN_ {
      public:
        /** Optional element 'ns1:InsLinkSN' of XSD type 'ns1:InsLinkSN' */
        _ns1__InsLinkSN *ns1__InsLinkSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsLinkSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsLinkSN_; }
        /** Constructor with member initializations */
        __ns1__InsLinkSN_() : ns1__InsLinkSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsLinkSN_ * SOAP_FMAC2 soap_instantiate___ns1__InsLinkSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23643 */
#ifndef SOAP_TYPE___ns1__GetLinkZJCount_
#define SOAP_TYPE___ns1__GetLinkZJCount_ (1020)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLinkZJCount_ {
      public:
        /** Optional element 'ns1:GetLinkZJCount' of XSD type 'ns1:GetLinkZJCount' */
        _ns1__GetLinkZJCount *ns1__GetLinkZJCount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLinkZJCount_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetLinkZJCount_; }
        /** Constructor with member initializations */
        __ns1__GetLinkZJCount_() : ns1__GetLinkZJCount() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLinkZJCount_ * SOAP_FMAC2 soap_instantiate___ns1__GetLinkZJCount_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23713 */
#ifndef SOAP_TYPE___ns1__InsBoxNOTime_
#define SOAP_TYPE___ns1__InsBoxNOTime_ (1022)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsBoxNOTime_ {
      public:
        /** Optional element 'ns1:InsBoxNOTime' of XSD type 'ns1:InsBoxNOTime' */
        _ns1__InsBoxNOTime *ns1__InsBoxNOTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsBoxNOTime_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsBoxNOTime_; }
        /** Constructor with member initializations */
        __ns1__InsBoxNOTime_() : ns1__InsBoxNOTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsBoxNOTime_ * SOAP_FMAC2 soap_instantiate___ns1__InsBoxNOTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23783 */
#ifndef SOAP_TYPE___ns1__chkBoxNo_
#define SOAP_TYPE___ns1__chkBoxNo_ (1024)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkBoxNo_ {
      public:
        /** Optional element 'ns1:chkBoxNo' of XSD type 'ns1:chkBoxNo' */
        _ns1__chkBoxNo *ns1__chkBoxNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkBoxNo_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkBoxNo_; }
        /** Constructor with member initializations */
        __ns1__chkBoxNo_() : ns1__chkBoxNo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkBoxNo_ * SOAP_FMAC2 soap_instantiate___ns1__chkBoxNo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23853 */
#ifndef SOAP_TYPE___ns1__InSNtoBox_
#define SOAP_TYPE___ns1__InSNtoBox_ (1026)
/* Wrapper: */
struct SOAP_CMAC __ns1__InSNtoBox_ {
      public:
        /** Optional element 'ns1:InSNtoBox' of XSD type 'ns1:InSNtoBox' */
        _ns1__InSNtoBox *ns1__InSNtoBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InSNtoBox_ */
        int soap_type() const { return SOAP_TYPE___ns1__InSNtoBox_; }
        /** Constructor with member initializations */
        __ns1__InSNtoBox_() : ns1__InSNtoBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InSNtoBox_ * SOAP_FMAC2 soap_instantiate___ns1__InSNtoBox_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23923 */
#ifndef SOAP_TYPE___ns1__EndSNtoBox_
#define SOAP_TYPE___ns1__EndSNtoBox_ (1028)
/* Wrapper: */
struct SOAP_CMAC __ns1__EndSNtoBox_ {
      public:
        /** Optional element 'ns1:EndSNtoBox' of XSD type 'ns1:EndSNtoBox' */
        _ns1__EndSNtoBox *ns1__EndSNtoBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EndSNtoBox_ */
        int soap_type() const { return SOAP_TYPE___ns1__EndSNtoBox_; }
        /** Constructor with member initializations */
        __ns1__EndSNtoBox_() : ns1__EndSNtoBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EndSNtoBox_ * SOAP_FMAC2 soap_instantiate___ns1__EndSNtoBox_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:23993 */
#ifndef SOAP_TYPE___ns1__InStationbyBox_
#define SOAP_TYPE___ns1__InStationbyBox_ (1030)
/* Wrapper: */
struct SOAP_CMAC __ns1__InStationbyBox_ {
      public:
        /** Optional element 'ns1:InStationbyBox' of XSD type 'ns1:InStationbyBox' */
        _ns1__InStationbyBox *ns1__InStationbyBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InStationbyBox_ */
        int soap_type() const { return SOAP_TYPE___ns1__InStationbyBox_; }
        /** Constructor with member initializations */
        __ns1__InStationbyBox_() : ns1__InStationbyBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InStationbyBox_ * SOAP_FMAC2 soap_instantiate___ns1__InStationbyBox_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24063 */
#ifndef SOAP_TYPE___ns1__OutStationbyBox_
#define SOAP_TYPE___ns1__OutStationbyBox_ (1032)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutStationbyBox_ {
      public:
        /** Optional element 'ns1:OutStationbyBox' of XSD type 'ns1:OutStationbyBox' */
        _ns1__OutStationbyBox *ns1__OutStationbyBox;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutStationbyBox_ */
        int soap_type() const { return SOAP_TYPE___ns1__OutStationbyBox_; }
        /** Constructor with member initializations */
        __ns1__OutStationbyBox_() : ns1__OutStationbyBox() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutStationbyBox_ * SOAP_FMAC2 soap_instantiate___ns1__OutStationbyBox_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24133 */
#ifndef SOAP_TYPE___ns1__CancelBoxLnk_
#define SOAP_TYPE___ns1__CancelBoxLnk_ (1034)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelBoxLnk_ {
      public:
        /** Optional element 'ns1:CancelBoxLnk' of XSD type 'ns1:CancelBoxLnk' */
        _ns1__CancelBoxLnk *ns1__CancelBoxLnk;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelBoxLnk_ */
        int soap_type() const { return SOAP_TYPE___ns1__CancelBoxLnk_; }
        /** Constructor with member initializations */
        __ns1__CancelBoxLnk_() : ns1__CancelBoxLnk() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelBoxLnk_ * SOAP_FMAC2 soap_instantiate___ns1__CancelBoxLnk_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24203 */
#ifndef SOAP_TYPE___ns1__InsSNStationEmp_
#define SOAP_TYPE___ns1__InsSNStationEmp_ (1036)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsSNStationEmp_ {
      public:
        /** Optional element 'ns1:InsSNStationEmp' of XSD type 'ns1:InsSNStationEmp' */
        _ns1__InsSNStationEmp *ns1__InsSNStationEmp;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsSNStationEmp_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsSNStationEmp_; }
        /** Constructor with member initializations */
        __ns1__InsSNStationEmp_() : ns1__InsSNStationEmp() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsSNStationEmp_ * SOAP_FMAC2 soap_instantiate___ns1__InsSNStationEmp_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24273 */
#ifndef SOAP_TYPE___ns1__InsLnkOutSN_
#define SOAP_TYPE___ns1__InsLnkOutSN_ (1038)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsLnkOutSN_ {
      public:
        /** Optional element 'ns1:InsLnkOutSN' of XSD type 'ns1:InsLnkOutSN' */
        _ns1__InsLnkOutSN *ns1__InsLnkOutSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsLnkOutSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsLnkOutSN_; }
        /** Constructor with member initializations */
        __ns1__InsLnkOutSN_() : ns1__InsLnkOutSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsLnkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__InsLnkOutSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24343 */
#ifndef SOAP_TYPE___ns1__InsBoxInfo_
#define SOAP_TYPE___ns1__InsBoxInfo_ (1040)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsBoxInfo_ {
      public:
        /** Optional element 'ns1:InsBoxInfo' of XSD type 'ns1:InsBoxInfo' */
        _ns1__InsBoxInfo *ns1__InsBoxInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsBoxInfo_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsBoxInfo_; }
        /** Constructor with member initializations */
        __ns1__InsBoxInfo_() : ns1__InsBoxInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsBoxInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InsBoxInfo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24413 */
#ifndef SOAP_TYPE___ns1__UpdSnRecInfo_
#define SOAP_TYPE___ns1__UpdSnRecInfo_ (1042)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdSnRecInfo_ {
      public:
        /** Optional element 'ns1:UpdSnRecInfo' of XSD type 'ns1:UpdSnRecInfo' */
        _ns1__UpdSnRecInfo *ns1__UpdSnRecInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdSnRecInfo_ */
        int soap_type() const { return SOAP_TYPE___ns1__UpdSnRecInfo_; }
        /** Constructor with member initializations */
        __ns1__UpdSnRecInfo_() : ns1__UpdSnRecInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdSnRecInfo_ * SOAP_FMAC2 soap_instantiate___ns1__UpdSnRecInfo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24483 */
#ifndef SOAP_TYPE___ns1__GetMoBase_
#define SOAP_TYPE___ns1__GetMoBase_ (1044)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMoBase_ {
      public:
        /** Optional element 'ns1:GetMoBase' of XSD type 'ns1:GetMoBase' */
        _ns1__GetMoBase *ns1__GetMoBase;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMoBase_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetMoBase_; }
        /** Constructor with member initializations */
        __ns1__GetMoBase_() : ns1__GetMoBase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMoBase_ * SOAP_FMAC2 soap_instantiate___ns1__GetMoBase_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24553 */
#ifndef SOAP_TYPE___ns1__GetTestValue_
#define SOAP_TYPE___ns1__GetTestValue_ (1046)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTestValue_ {
      public:
        /** Optional element 'ns1:GetTestValue' of XSD type 'ns1:GetTestValue' */
        _ns1__GetTestValue *ns1__GetTestValue;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTestValue_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetTestValue_; }
        /** Constructor with member initializations */
        __ns1__GetTestValue_() : ns1__GetTestValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTestValue_ * SOAP_FMAC2 soap_instantiate___ns1__GetTestValue_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24623 */
#ifndef SOAP_TYPE___ns1__GetLnkData_
#define SOAP_TYPE___ns1__GetLnkData_ (1048)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetLnkData_ {
      public:
        /** Optional element 'ns1:GetLnkData' of XSD type 'ns1:GetLnkData' */
        _ns1__GetLnkData *ns1__GetLnkData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetLnkData_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetLnkData_; }
        /** Constructor with member initializations */
        __ns1__GetLnkData_() : ns1__GetLnkData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetLnkData_ * SOAP_FMAC2 soap_instantiate___ns1__GetLnkData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24693 */
#ifndef SOAP_TYPE___ns1__InsIotMachineRec_
#define SOAP_TYPE___ns1__InsIotMachineRec_ (1050)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsIotMachineRec_ {
      public:
        /** Optional element 'ns1:InsIotMachineRec' of XSD type 'ns1:InsIotMachineRec' */
        _ns1__InsIotMachineRec *ns1__InsIotMachineRec;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsIotMachineRec_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsIotMachineRec_; }
        /** Constructor with member initializations */
        __ns1__InsIotMachineRec_() : ns1__InsIotMachineRec() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsIotMachineRec_ * SOAP_FMAC2 soap_instantiate___ns1__InsIotMachineRec_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24763 */
#ifndef SOAP_TYPE___ns1__InsIotTestData_
#define SOAP_TYPE___ns1__InsIotTestData_ (1052)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsIotTestData_ {
      public:
        /** Optional element 'ns1:InsIotTestData' of XSD type 'ns1:InsIotTestData' */
        _ns1__InsIotTestData *ns1__InsIotTestData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsIotTestData_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsIotTestData_; }
        /** Constructor with member initializations */
        __ns1__InsIotTestData_() : ns1__InsIotTestData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsIotTestData_ * SOAP_FMAC2 soap_instantiate___ns1__InsIotTestData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24833 */
#ifndef SOAP_TYPE___ns1__chkDispensing_
#define SOAP_TYPE___ns1__chkDispensing_ (1054)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkDispensing_ {
      public:
        /** Optional element 'ns1:chkDispensing' of XSD type 'ns1:chkDispensing' */
        _ns1__chkDispensing *ns1__chkDispensing;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkDispensing_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkDispensing_; }
        /** Constructor with member initializations */
        __ns1__chkDispensing_() : ns1__chkDispensing() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkDispensing_ * SOAP_FMAC2 soap_instantiate___ns1__chkDispensing_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24903 */
#ifndef SOAP_TYPE___ns1__chkZJSN_
#define SOAP_TYPE___ns1__chkZJSN_ (1056)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkZJSN_ {
      public:
        /** Optional element 'ns1:chkZJSN' of XSD type 'ns1:chkZJSN' */
        _ns1__chkZJSN *ns1__chkZJSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkZJSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkZJSN_; }
        /** Constructor with member initializations */
        __ns1__chkZJSN_() : ns1__chkZJSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkZJSN_ * SOAP_FMAC2 soap_instantiate___ns1__chkZJSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:24973 */
#ifndef SOAP_TYPE___ns1__LnkZJSN_
#define SOAP_TYPE___ns1__LnkZJSN_ (1058)
/* Wrapper: */
struct SOAP_CMAC __ns1__LnkZJSN_ {
      public:
        /** Optional element 'ns1:LnkZJSN' of XSD type 'ns1:LnkZJSN' */
        _ns1__LnkZJSN *ns1__LnkZJSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LnkZJSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__LnkZJSN_; }
        /** Constructor with member initializations */
        __ns1__LnkZJSN_() : ns1__LnkZJSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LnkZJSN_ * SOAP_FMAC2 soap_instantiate___ns1__LnkZJSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25043 */
#ifndef SOAP_TYPE___ns1__LnkSideSN_
#define SOAP_TYPE___ns1__LnkSideSN_ (1060)
/* Wrapper: */
struct SOAP_CMAC __ns1__LnkSideSN_ {
      public:
        /** Optional element 'ns1:LnkSideSN' of XSD type 'ns1:LnkSideSN' */
        _ns1__LnkSideSN *ns1__LnkSideSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LnkSideSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__LnkSideSN_; }
        /** Constructor with member initializations */
        __ns1__LnkSideSN_() : ns1__LnkSideSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LnkSideSN_ * SOAP_FMAC2 soap_instantiate___ns1__LnkSideSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25113 */
#ifndef SOAP_TYPE___ns1__chkGrillSN_
#define SOAP_TYPE___ns1__chkGrillSN_ (1062)
/* Wrapper: */
struct SOAP_CMAC __ns1__chkGrillSN_ {
      public:
        /** Optional element 'ns1:chkGrillSN' of XSD type 'ns1:chkGrillSN' */
        _ns1__chkGrillSN *ns1__chkGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__chkGrillSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__chkGrillSN_; }
        /** Constructor with member initializations */
        __ns1__chkGrillSN_() : ns1__chkGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__chkGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__chkGrillSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25183 */
#ifndef SOAP_TYPE___ns1__LnkGrillSN_
#define SOAP_TYPE___ns1__LnkGrillSN_ (1064)
/* Wrapper: */
struct SOAP_CMAC __ns1__LnkGrillSN_ {
      public:
        /** Optional element 'ns1:LnkGrillSN' of XSD type 'ns1:LnkGrillSN' */
        _ns1__LnkGrillSN *ns1__LnkGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LnkGrillSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__LnkGrillSN_; }
        /** Constructor with member initializations */
        __ns1__LnkGrillSN_() : ns1__LnkGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LnkGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__LnkGrillSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25253 */
#ifndef SOAP_TYPE___ns1__CloseGrillSN_
#define SOAP_TYPE___ns1__CloseGrillSN_ (1066)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseGrillSN_ {
      public:
        /** Optional element 'ns1:CloseGrillSN' of XSD type 'ns1:CloseGrillSN' */
        _ns1__CloseGrillSN *ns1__CloseGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseGrillSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__CloseGrillSN_; }
        /** Constructor with member initializations */
        __ns1__CloseGrillSN_() : ns1__CloseGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CloseGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__CloseGrillSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25323 */
#ifndef SOAP_TYPE___ns1__InsGrillBySN_
#define SOAP_TYPE___ns1__InsGrillBySN_ (1068)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsGrillBySN_ {
      public:
        /** Optional element 'ns1:InsGrillBySN' of XSD type 'ns1:InsGrillBySN' */
        _ns1__InsGrillBySN *ns1__InsGrillBySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsGrillBySN_ */
        int soap_type() const { return SOAP_TYPE___ns1__InsGrillBySN_; }
        /** Constructor with member initializations */
        __ns1__InsGrillBySN_() : ns1__InsGrillBySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsGrillBySN_ * SOAP_FMAC2 soap_instantiate___ns1__InsGrillBySN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25393 */
#ifndef SOAP_TYPE___ns1__GetGrillTime_
#define SOAP_TYPE___ns1__GetGrillTime_ (1070)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetGrillTime_ {
      public:
        /** Optional element 'ns1:GetGrillTime' of XSD type 'ns1:GetGrillTime' */
        _ns1__GetGrillTime *ns1__GetGrillTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetGrillTime_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetGrillTime_; }
        /** Constructor with member initializations */
        __ns1__GetGrillTime_() : ns1__GetGrillTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetGrillTime_ * SOAP_FMAC2 soap_instantiate___ns1__GetGrillTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25463 */
#ifndef SOAP_TYPE___ns1__OutGrillBySN_
#define SOAP_TYPE___ns1__OutGrillBySN_ (1072)
/* Wrapper: */
struct SOAP_CMAC __ns1__OutGrillBySN_ {
      public:
        /** Optional element 'ns1:OutGrillBySN' of XSD type 'ns1:OutGrillBySN' */
        _ns1__OutGrillBySN *ns1__OutGrillBySN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OutGrillBySN_ */
        int soap_type() const { return SOAP_TYPE___ns1__OutGrillBySN_; }
        /** Constructor with member initializations */
        __ns1__OutGrillBySN_() : ns1__OutGrillBySN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__OutGrillBySN_ * SOAP_FMAC2 soap_instantiate___ns1__OutGrillBySN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25533 */
#ifndef SOAP_TYPE___ns1__CancelGrillSN_
#define SOAP_TYPE___ns1__CancelGrillSN_ (1074)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelGrillSN_ {
      public:
        /** Optional element 'ns1:CancelGrillSN' of XSD type 'ns1:CancelGrillSN' */
        _ns1__CancelGrillSN *ns1__CancelGrillSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelGrillSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__CancelGrillSN_; }
        /** Constructor with member initializations */
        __ns1__CancelGrillSN_() : ns1__CancelGrillSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__CancelGrillSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25603 */
#ifndef SOAP_TYPE___ns1__CancelLnkSN_
#define SOAP_TYPE___ns1__CancelLnkSN_ (1076)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelLnkSN_ {
      public:
        /** Optional element 'ns1:CancelLnkSN' of XSD type 'ns1:CancelLnkSN' */
        _ns1__CancelLnkSN *ns1__CancelLnkSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelLnkSN_ */
        int soap_type() const { return SOAP_TYPE___ns1__CancelLnkSN_; }
        /** Constructor with member initializations */
        __ns1__CancelLnkSN_() : ns1__CancelLnkSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelLnkSN_ * SOAP_FMAC2 soap_instantiate___ns1__CancelLnkSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25673 */
#ifndef SOAP_TYPE___ns1__GetWeightSet_
#define SOAP_TYPE___ns1__GetWeightSet_ (1078)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetWeightSet_ {
      public:
        /** Optional element 'ns1:GetWeightSet' of XSD type 'ns1:GetWeightSet' */
        _ns1__GetWeightSet *ns1__GetWeightSet;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetWeightSet_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetWeightSet_; }
        /** Constructor with member initializations */
        __ns1__GetWeightSet_() : ns1__GetWeightSet() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetWeightSet_ * SOAP_FMAC2 soap_instantiate___ns1__GetWeightSet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25743 */
#ifndef SOAP_TYPE___ns1__GetPackToWMS_
#define SOAP_TYPE___ns1__GetPackToWMS_ (1080)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPackToWMS_ {
      public:
        /** Optional element 'ns1:GetPackToWMS' of XSD type 'ns1:GetPackToWMS' */
        _ns1__GetPackToWMS *ns1__GetPackToWMS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPackToWMS_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetPackToWMS_; }
        /** Constructor with member initializations */
        __ns1__GetPackToWMS_() : ns1__GetPackToWMS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPackToWMS_ * SOAP_FMAC2 soap_instantiate___ns1__GetPackToWMS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25813 */
#ifndef SOAP_TYPE___ns1__GetPallentToWMS_
#define SOAP_TYPE___ns1__GetPallentToWMS_ (1082)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPallentToWMS_ {
      public:
        /** Optional element 'ns1:GetPallentToWMS' of XSD type 'ns1:GetPallentToWMS' */
        _ns1__GetPallentToWMS *ns1__GetPallentToWMS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPallentToWMS_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetPallentToWMS_; }
        /** Constructor with member initializations */
        __ns1__GetPallentToWMS_() : ns1__GetPallentToWMS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPallentToWMS_ * SOAP_FMAC2 soap_instantiate___ns1__GetPallentToWMS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25883 */
#ifndef SOAP_TYPE___ns1__SetPallentForWMS_
#define SOAP_TYPE___ns1__SetPallentForWMS_ (1084)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetPallentForWMS_ {
      public:
        /** Optional element 'ns1:SetPallentForWMS' of XSD type 'ns1:SetPallentForWMS' */
        _ns1__SetPallentForWMS *ns1__SetPallentForWMS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetPallentForWMS_ */
        int soap_type() const { return SOAP_TYPE___ns1__SetPallentForWMS_; }
        /** Constructor with member initializations */
        __ns1__SetPallentForWMS_() : ns1__SetPallentForWMS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetPallentForWMS_ * SOAP_FMAC2 soap_instantiate___ns1__SetPallentForWMS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:25953 */
#ifndef SOAP_TYPE___ns1__GetPackStation_
#define SOAP_TYPE___ns1__GetPackStation_ (1086)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPackStation_ {
      public:
        /** Optional element 'ns1:GetPackStation' of XSD type 'ns1:GetPackStation' */
        _ns1__GetPackStation *ns1__GetPackStation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPackStation_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetPackStation_; }
        /** Constructor with member initializations */
        __ns1__GetPackStation_() : ns1__GetPackStation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPackStation_ * SOAP_FMAC2 soap_instantiate___ns1__GetPackStation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:26023 */
#ifndef SOAP_TYPE___ns1__GetPackWeigth_
#define SOAP_TYPE___ns1__GetPackWeigth_ (1088)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPackWeigth_ {
      public:
        /** Optional element 'ns1:GetPackWeigth' of XSD type 'ns1:GetPackWeigth' */
        _ns1__GetPackWeigth *ns1__GetPackWeigth;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPackWeigth_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetPackWeigth_; }
        /** Constructor with member initializations */
        __ns1__GetPackWeigth_() : ns1__GetPackWeigth() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPackWeigth_ * SOAP_FMAC2 soap_instantiate___ns1__GetPackWeigth_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:26093 */
#ifndef SOAP_TYPE___ns1__GetAhsMo_
#define SOAP_TYPE___ns1__GetAhsMo_ (1090)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAhsMo_ {
      public:
        /** Optional element 'ns1:GetAhsMo' of XSD type 'ns1:GetAhsMo' */
        _ns1__GetAhsMo *ns1__GetAhsMo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAhsMo_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetAhsMo_; }
        /** Constructor with member initializations */
        __ns1__GetAhsMo_() : ns1__GetAhsMo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetAhsMo_ * SOAP_FMAC2 soap_instantiate___ns1__GetAhsMo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:30024 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1091)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:30024 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1092)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:30024 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1094)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:30024 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1097)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:30024 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1098)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* WebService.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* WebService.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* WebService.h:140 */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (11)
typedef _XML _xsd__schema;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* _ns1__GetAhsMoResponse_GetAhsMoResult has binding name '_ns1__GetAhsMoResponse_GetAhsMoResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult
#define SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult (315)
#endif

/* _ns1__GetPallentToWMSResponse_GetPallentToWMSResult has binding name '_ns1__GetPallentToWMSResponse_GetPallentToWMSResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult
#define SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult (313)
#endif

/* _ns1__doLinkOutSN_assyDt has binding name '_ns1__doLinkOutSN_assyDt' for type '' */
#ifndef SOAP_TYPE__ns1__doLinkOutSN_assyDt
#define SOAP_TYPE__ns1__doLinkOutSN_assyDt (311)
#endif

/* _ns1__doPmcSNLink_assyDt has binding name '_ns1__doPmcSNLink_assyDt' for type '' */
#ifndef SOAP_TYPE__ns1__doPmcSNLink_assyDt
#define SOAP_TYPE__ns1__doPmcSNLink_assyDt (309)
#endif

/* _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult has binding name '_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult' for type '' */
#ifndef SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult
#define SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult (307)
#endif

/* _ns1__getPmcAssyListResponse_getPmcAssyListResult has binding name '_ns1__getPmcAssyListResponse_getPmcAssyListResult' for type '' */
#ifndef SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult
#define SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult (305)
#endif

/* _ns1__doAssy_assyDt has binding name '_ns1__doAssy_assyDt' for type '' */
#ifndef SOAP_TYPE__ns1__doAssy_assyDt
#define SOAP_TYPE__ns1__doAssy_assyDt (303)
#endif

/* _ns1__GetLinkOutSnResponse_GetLinkOutSnResult has binding name '_ns1__GetLinkOutSnResponse_GetLinkOutSnResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult
#define SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult (301)
#endif

/* _ns1__getPartBomExtResponse_getPartBomExtResult has binding name '_ns1__getPartBomExtResponse_getPartBomExtResult' for type '' */
#ifndef SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult
#define SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult (299)
#endif

/* _ns1__getMoAssyListResponse_getMoAssyListResult has binding name '_ns1__getMoAssyListResponse_getMoAssyListResult' for type '' */
#ifndef SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult
#define SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult (297)
#endif

/* _ns1__getInfoByMoResponse_getInfoByMoResult has binding name '_ns1__getInfoByMoResponse_getInfoByMoResult' for type '' */
#ifndef SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult
#define SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult (295)
#endif

/* _ns1__GetMachineForGroupResponse_GetMachineForGroupResult has binding name '_ns1__GetMachineForGroupResponse_GetMachineForGroupResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult
#define SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult (292)
#endif

/* _ns1__SetFlatnessFruitRec_dt has binding name '_ns1__SetFlatnessFruitRec_dt' for type '' */
#ifndef SOAP_TYPE__ns1__SetFlatnessFruitRec_dt
#define SOAP_TYPE__ns1__SetFlatnessFruitRec_dt (290)
#endif

/* _ns1__GetShippingWeightResponse_GetShippingWeightResult has binding name '_ns1__GetShippingWeightResponse_GetShippingWeightResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult
#define SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult (288)
#endif

/* _ns1__GetShippingForBerthResponse_GetShippingForBerthResult has binding name '_ns1__GetShippingForBerthResponse_GetShippingForBerthResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult
#define SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult (286)
#endif

/* _ns1__GetShippingBerthListResponse_GetShippingBerthListResult has binding name '_ns1__GetShippingBerthListResponse_GetShippingBerthListResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult
#define SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult (284)
#endif

/* _ns1__GetShippingListResponse_GetShippingListResult has binding name '_ns1__GetShippingListResponse_GetShippingListResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult
#define SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult (282)
#endif

/* _ns1__doLotLinkForApple_assyDt has binding name '_ns1__doLotLinkForApple_assyDt' for type '' */
#ifndef SOAP_TYPE__ns1__doLotLinkForApple_assyDt
#define SOAP_TYPE__ns1__doLotLinkForApple_assyDt (280)
#endif

/* _ns1__doSnLinkForApple_assyDt has binding name '_ns1__doSnLinkForApple_assyDt' for type '' */
#ifndef SOAP_TYPE__ns1__doSnLinkForApple_assyDt
#define SOAP_TYPE__ns1__doSnLinkForApple_assyDt (277)
#endif

/* _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult has binding name '_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult
#define SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult (275)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (271)
#endif

/* _ns1__GetAhsMoResponse has binding name '_ns1__GetAhsMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetAhsMoResponse
#define SOAP_TYPE__ns1__GetAhsMoResponse (270)
#endif

/* _ns1__GetAhsMo has binding name '_ns1__GetAhsMo' for type '' */
#ifndef SOAP_TYPE__ns1__GetAhsMo
#define SOAP_TYPE__ns1__GetAhsMo (269)
#endif

/* _ns1__GetPackWeigthResponse has binding name '_ns1__GetPackWeigthResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPackWeigthResponse
#define SOAP_TYPE__ns1__GetPackWeigthResponse (268)
#endif

/* _ns1__GetPackWeigth has binding name '_ns1__GetPackWeigth' for type '' */
#ifndef SOAP_TYPE__ns1__GetPackWeigth
#define SOAP_TYPE__ns1__GetPackWeigth (267)
#endif

/* _ns1__GetPackStationResponse has binding name '_ns1__GetPackStationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPackStationResponse
#define SOAP_TYPE__ns1__GetPackStationResponse (266)
#endif

/* _ns1__GetPackStation has binding name '_ns1__GetPackStation' for type '' */
#ifndef SOAP_TYPE__ns1__GetPackStation
#define SOAP_TYPE__ns1__GetPackStation (265)
#endif

/* _ns1__SetPallentForWMSResponse has binding name '_ns1__SetPallentForWMSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetPallentForWMSResponse
#define SOAP_TYPE__ns1__SetPallentForWMSResponse (264)
#endif

/* _ns1__SetPallentForWMS has binding name '_ns1__SetPallentForWMS' for type '' */
#ifndef SOAP_TYPE__ns1__SetPallentForWMS
#define SOAP_TYPE__ns1__SetPallentForWMS (263)
#endif

/* _ns1__GetPallentToWMSResponse has binding name '_ns1__GetPallentToWMSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPallentToWMSResponse
#define SOAP_TYPE__ns1__GetPallentToWMSResponse (262)
#endif

/* _ns1__GetPallentToWMS has binding name '_ns1__GetPallentToWMS' for type '' */
#ifndef SOAP_TYPE__ns1__GetPallentToWMS
#define SOAP_TYPE__ns1__GetPallentToWMS (261)
#endif

/* _ns1__GetPackToWMSResponse has binding name '_ns1__GetPackToWMSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPackToWMSResponse
#define SOAP_TYPE__ns1__GetPackToWMSResponse (260)
#endif

/* _ns1__GetPackToWMS has binding name '_ns1__GetPackToWMS' for type '' */
#ifndef SOAP_TYPE__ns1__GetPackToWMS
#define SOAP_TYPE__ns1__GetPackToWMS (259)
#endif

/* _ns1__GetWeightSetResponse has binding name '_ns1__GetWeightSetResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetWeightSetResponse
#define SOAP_TYPE__ns1__GetWeightSetResponse (258)
#endif

/* _ns1__GetWeightSet has binding name '_ns1__GetWeightSet' for type '' */
#ifndef SOAP_TYPE__ns1__GetWeightSet
#define SOAP_TYPE__ns1__GetWeightSet (257)
#endif

/* _ns1__CancelLnkSNResponse has binding name '_ns1__CancelLnkSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CancelLnkSNResponse
#define SOAP_TYPE__ns1__CancelLnkSNResponse (256)
#endif

/* _ns1__CancelLnkSN has binding name '_ns1__CancelLnkSN' for type '' */
#ifndef SOAP_TYPE__ns1__CancelLnkSN
#define SOAP_TYPE__ns1__CancelLnkSN (255)
#endif

/* _ns1__CancelGrillSNResponse has binding name '_ns1__CancelGrillSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CancelGrillSNResponse
#define SOAP_TYPE__ns1__CancelGrillSNResponse (254)
#endif

/* _ns1__CancelGrillSN has binding name '_ns1__CancelGrillSN' for type '' */
#ifndef SOAP_TYPE__ns1__CancelGrillSN
#define SOAP_TYPE__ns1__CancelGrillSN (253)
#endif

/* _ns1__OutGrillBySNResponse has binding name '_ns1__OutGrillBySNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OutGrillBySNResponse
#define SOAP_TYPE__ns1__OutGrillBySNResponse (252)
#endif

/* _ns1__OutGrillBySN has binding name '_ns1__OutGrillBySN' for type '' */
#ifndef SOAP_TYPE__ns1__OutGrillBySN
#define SOAP_TYPE__ns1__OutGrillBySN (251)
#endif

/* _ns1__GetGrillTimeResponse has binding name '_ns1__GetGrillTimeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetGrillTimeResponse
#define SOAP_TYPE__ns1__GetGrillTimeResponse (250)
#endif

/* _ns1__GetGrillTime has binding name '_ns1__GetGrillTime' for type '' */
#ifndef SOAP_TYPE__ns1__GetGrillTime
#define SOAP_TYPE__ns1__GetGrillTime (249)
#endif

/* _ns1__InsGrillBySNResponse has binding name '_ns1__InsGrillBySNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsGrillBySNResponse
#define SOAP_TYPE__ns1__InsGrillBySNResponse (248)
#endif

/* _ns1__InsGrillBySN has binding name '_ns1__InsGrillBySN' for type '' */
#ifndef SOAP_TYPE__ns1__InsGrillBySN
#define SOAP_TYPE__ns1__InsGrillBySN (247)
#endif

/* _ns1__CloseGrillSNResponse has binding name '_ns1__CloseGrillSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CloseGrillSNResponse
#define SOAP_TYPE__ns1__CloseGrillSNResponse (246)
#endif

/* _ns1__CloseGrillSN has binding name '_ns1__CloseGrillSN' for type '' */
#ifndef SOAP_TYPE__ns1__CloseGrillSN
#define SOAP_TYPE__ns1__CloseGrillSN (245)
#endif

/* _ns1__LnkGrillSNResponse has binding name '_ns1__LnkGrillSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LnkGrillSNResponse
#define SOAP_TYPE__ns1__LnkGrillSNResponse (244)
#endif

/* _ns1__LnkGrillSN has binding name '_ns1__LnkGrillSN' for type '' */
#ifndef SOAP_TYPE__ns1__LnkGrillSN
#define SOAP_TYPE__ns1__LnkGrillSN (243)
#endif

/* _ns1__chkGrillSNResponse has binding name '_ns1__chkGrillSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkGrillSNResponse
#define SOAP_TYPE__ns1__chkGrillSNResponse (242)
#endif

/* _ns1__chkGrillSN has binding name '_ns1__chkGrillSN' for type '' */
#ifndef SOAP_TYPE__ns1__chkGrillSN
#define SOAP_TYPE__ns1__chkGrillSN (241)
#endif

/* _ns1__LnkSideSNResponse has binding name '_ns1__LnkSideSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LnkSideSNResponse
#define SOAP_TYPE__ns1__LnkSideSNResponse (240)
#endif

/* _ns1__LnkSideSN has binding name '_ns1__LnkSideSN' for type '' */
#ifndef SOAP_TYPE__ns1__LnkSideSN
#define SOAP_TYPE__ns1__LnkSideSN (239)
#endif

/* _ns1__LnkZJSNResponse has binding name '_ns1__LnkZJSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LnkZJSNResponse
#define SOAP_TYPE__ns1__LnkZJSNResponse (238)
#endif

/* _ns1__LnkZJSN has binding name '_ns1__LnkZJSN' for type '' */
#ifndef SOAP_TYPE__ns1__LnkZJSN
#define SOAP_TYPE__ns1__LnkZJSN (237)
#endif

/* _ns1__chkZJSNResponse has binding name '_ns1__chkZJSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkZJSNResponse
#define SOAP_TYPE__ns1__chkZJSNResponse (236)
#endif

/* _ns1__chkZJSN has binding name '_ns1__chkZJSN' for type '' */
#ifndef SOAP_TYPE__ns1__chkZJSN
#define SOAP_TYPE__ns1__chkZJSN (235)
#endif

/* _ns1__chkDispensingResponse has binding name '_ns1__chkDispensingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkDispensingResponse
#define SOAP_TYPE__ns1__chkDispensingResponse (234)
#endif

/* _ns1__chkDispensing has binding name '_ns1__chkDispensing' for type '' */
#ifndef SOAP_TYPE__ns1__chkDispensing
#define SOAP_TYPE__ns1__chkDispensing (233)
#endif

/* _ns1__InsIotTestDataResponse has binding name '_ns1__InsIotTestDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsIotTestDataResponse
#define SOAP_TYPE__ns1__InsIotTestDataResponse (232)
#endif

/* _ns1__InsIotTestData has binding name '_ns1__InsIotTestData' for type '' */
#ifndef SOAP_TYPE__ns1__InsIotTestData
#define SOAP_TYPE__ns1__InsIotTestData (231)
#endif

/* _ns1__InsIotMachineRecResponse has binding name '_ns1__InsIotMachineRecResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsIotMachineRecResponse
#define SOAP_TYPE__ns1__InsIotMachineRecResponse (230)
#endif

/* _ns1__InsIotMachineRec has binding name '_ns1__InsIotMachineRec' for type '' */
#ifndef SOAP_TYPE__ns1__InsIotMachineRec
#define SOAP_TYPE__ns1__InsIotMachineRec (229)
#endif

/* _ns1__GetLnkDataResponse has binding name '_ns1__GetLnkDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetLnkDataResponse
#define SOAP_TYPE__ns1__GetLnkDataResponse (228)
#endif

/* _ns1__GetLnkData has binding name '_ns1__GetLnkData' for type '' */
#ifndef SOAP_TYPE__ns1__GetLnkData
#define SOAP_TYPE__ns1__GetLnkData (227)
#endif

/* _ns1__GetTestValueResponse has binding name '_ns1__GetTestValueResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetTestValueResponse
#define SOAP_TYPE__ns1__GetTestValueResponse (226)
#endif

/* _ns1__GetTestValue has binding name '_ns1__GetTestValue' for type '' */
#ifndef SOAP_TYPE__ns1__GetTestValue
#define SOAP_TYPE__ns1__GetTestValue (225)
#endif

/* _ns1__GetMoBaseResponse has binding name '_ns1__GetMoBaseResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetMoBaseResponse
#define SOAP_TYPE__ns1__GetMoBaseResponse (224)
#endif

/* _ns1__GetMoBase has binding name '_ns1__GetMoBase' for type '' */
#ifndef SOAP_TYPE__ns1__GetMoBase
#define SOAP_TYPE__ns1__GetMoBase (223)
#endif

/* _ns1__UpdSnRecInfoResponse has binding name '_ns1__UpdSnRecInfoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpdSnRecInfoResponse
#define SOAP_TYPE__ns1__UpdSnRecInfoResponse (222)
#endif

/* _ns1__UpdSnRecInfo has binding name '_ns1__UpdSnRecInfo' for type '' */
#ifndef SOAP_TYPE__ns1__UpdSnRecInfo
#define SOAP_TYPE__ns1__UpdSnRecInfo (221)
#endif

/* _ns1__InsBoxInfoResponse has binding name '_ns1__InsBoxInfoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsBoxInfoResponse
#define SOAP_TYPE__ns1__InsBoxInfoResponse (220)
#endif

/* _ns1__InsBoxInfo has binding name '_ns1__InsBoxInfo' for type '' */
#ifndef SOAP_TYPE__ns1__InsBoxInfo
#define SOAP_TYPE__ns1__InsBoxInfo (219)
#endif

/* _ns1__InsLnkOutSNResponse has binding name '_ns1__InsLnkOutSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsLnkOutSNResponse
#define SOAP_TYPE__ns1__InsLnkOutSNResponse (218)
#endif

/* _ns1__InsLnkOutSN has binding name '_ns1__InsLnkOutSN' for type '' */
#ifndef SOAP_TYPE__ns1__InsLnkOutSN
#define SOAP_TYPE__ns1__InsLnkOutSN (217)
#endif

/* _ns1__InsSNStationEmpResponse has binding name '_ns1__InsSNStationEmpResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsSNStationEmpResponse
#define SOAP_TYPE__ns1__InsSNStationEmpResponse (216)
#endif

/* _ns1__InsSNStationEmp has binding name '_ns1__InsSNStationEmp' for type '' */
#ifndef SOAP_TYPE__ns1__InsSNStationEmp
#define SOAP_TYPE__ns1__InsSNStationEmp (215)
#endif

/* _ns1__CancelBoxLnkResponse has binding name '_ns1__CancelBoxLnkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CancelBoxLnkResponse
#define SOAP_TYPE__ns1__CancelBoxLnkResponse (214)
#endif

/* _ns1__CancelBoxLnk has binding name '_ns1__CancelBoxLnk' for type '' */
#ifndef SOAP_TYPE__ns1__CancelBoxLnk
#define SOAP_TYPE__ns1__CancelBoxLnk (213)
#endif

/* _ns1__OutStationbyBoxResponse has binding name '_ns1__OutStationbyBoxResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OutStationbyBoxResponse
#define SOAP_TYPE__ns1__OutStationbyBoxResponse (212)
#endif

/* _ns1__OutStationbyBox has binding name '_ns1__OutStationbyBox' for type '' */
#ifndef SOAP_TYPE__ns1__OutStationbyBox
#define SOAP_TYPE__ns1__OutStationbyBox (211)
#endif

/* _ns1__InStationbyBoxResponse has binding name '_ns1__InStationbyBoxResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InStationbyBoxResponse
#define SOAP_TYPE__ns1__InStationbyBoxResponse (210)
#endif

/* _ns1__InStationbyBox has binding name '_ns1__InStationbyBox' for type '' */
#ifndef SOAP_TYPE__ns1__InStationbyBox
#define SOAP_TYPE__ns1__InStationbyBox (209)
#endif

/* _ns1__EndSNtoBoxResponse has binding name '_ns1__EndSNtoBoxResponse' for type '' */
#ifndef SOAP_TYPE__ns1__EndSNtoBoxResponse
#define SOAP_TYPE__ns1__EndSNtoBoxResponse (208)
#endif

/* _ns1__EndSNtoBox has binding name '_ns1__EndSNtoBox' for type '' */
#ifndef SOAP_TYPE__ns1__EndSNtoBox
#define SOAP_TYPE__ns1__EndSNtoBox (207)
#endif

/* _ns1__InSNtoBoxResponse has binding name '_ns1__InSNtoBoxResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InSNtoBoxResponse
#define SOAP_TYPE__ns1__InSNtoBoxResponse (206)
#endif

/* _ns1__InSNtoBox has binding name '_ns1__InSNtoBox' for type '' */
#ifndef SOAP_TYPE__ns1__InSNtoBox
#define SOAP_TYPE__ns1__InSNtoBox (205)
#endif

/* _ns1__chkBoxNoResponse has binding name '_ns1__chkBoxNoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkBoxNoResponse
#define SOAP_TYPE__ns1__chkBoxNoResponse (204)
#endif

/* _ns1__chkBoxNo has binding name '_ns1__chkBoxNo' for type '' */
#ifndef SOAP_TYPE__ns1__chkBoxNo
#define SOAP_TYPE__ns1__chkBoxNo (203)
#endif

/* _ns1__InsBoxNOTimeResponse has binding name '_ns1__InsBoxNOTimeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsBoxNOTimeResponse
#define SOAP_TYPE__ns1__InsBoxNOTimeResponse (202)
#endif

/* _ns1__InsBoxNOTime has binding name '_ns1__InsBoxNOTime' for type '' */
#ifndef SOAP_TYPE__ns1__InsBoxNOTime
#define SOAP_TYPE__ns1__InsBoxNOTime (201)
#endif

/* _ns1__GetLinkZJCountResponse has binding name '_ns1__GetLinkZJCountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetLinkZJCountResponse
#define SOAP_TYPE__ns1__GetLinkZJCountResponse (200)
#endif

/* _ns1__GetLinkZJCount has binding name '_ns1__GetLinkZJCount' for type '' */
#ifndef SOAP_TYPE__ns1__GetLinkZJCount
#define SOAP_TYPE__ns1__GetLinkZJCount (199)
#endif

/* _ns1__InsLinkSNResponse has binding name '_ns1__InsLinkSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsLinkSNResponse
#define SOAP_TYPE__ns1__InsLinkSNResponse (198)
#endif

/* _ns1__InsLinkSN has binding name '_ns1__InsLinkSN' for type '' */
#ifndef SOAP_TYPE__ns1__InsLinkSN
#define SOAP_TYPE__ns1__InsLinkSN (197)
#endif

/* _ns1__doLinkOutSNResponse has binding name '_ns1__doLinkOutSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__doLinkOutSNResponse
#define SOAP_TYPE__ns1__doLinkOutSNResponse (196)
#endif

/* _ns1__doLinkOutSN has binding name '_ns1__doLinkOutSN' for type '' */
#ifndef SOAP_TYPE__ns1__doLinkOutSN
#define SOAP_TYPE__ns1__doLinkOutSN (195)
#endif

/* _ns1__ChkLinkOutSNResponse has binding name '_ns1__ChkLinkOutSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChkLinkOutSNResponse
#define SOAP_TYPE__ns1__ChkLinkOutSNResponse (194)
#endif

/* _ns1__ChkLinkOutSN has binding name '_ns1__ChkLinkOutSN' for type '' */
#ifndef SOAP_TYPE__ns1__ChkLinkOutSN
#define SOAP_TYPE__ns1__ChkLinkOutSN (193)
#endif

/* _ns1__chkOutSNResponse has binding name '_ns1__chkOutSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkOutSNResponse
#define SOAP_TYPE__ns1__chkOutSNResponse (192)
#endif

/* _ns1__chkOutSN has binding name '_ns1__chkOutSN' for type '' */
#ifndef SOAP_TYPE__ns1__chkOutSN
#define SOAP_TYPE__ns1__chkOutSN (191)
#endif

/* _ns1__GetLintOutQtyResponse has binding name '_ns1__GetLintOutQtyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetLintOutQtyResponse
#define SOAP_TYPE__ns1__GetLintOutQtyResponse (190)
#endif

/* _ns1__GetLintOutQty has binding name '_ns1__GetLintOutQty' for type '' */
#ifndef SOAP_TYPE__ns1__GetLintOutQty
#define SOAP_TYPE__ns1__GetLintOutQty (189)
#endif

/* _ns1__SNLinkZJResponse has binding name '_ns1__SNLinkZJResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SNLinkZJResponse
#define SOAP_TYPE__ns1__SNLinkZJResponse (188)
#endif

/* _ns1__SNLinkZJ has binding name '_ns1__SNLinkZJ' for type '' */
#ifndef SOAP_TYPE__ns1__SNLinkZJ
#define SOAP_TYPE__ns1__SNLinkZJ (187)
#endif

/* _ns1__InsZJTestDataResponse has binding name '_ns1__InsZJTestDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsZJTestDataResponse
#define SOAP_TYPE__ns1__InsZJTestDataResponse (186)
#endif

/* _ns1__InsZJTestData has binding name '_ns1__InsZJTestData' for type '' */
#ifndef SOAP_TYPE__ns1__InsZJTestData
#define SOAP_TYPE__ns1__InsZJTestData (185)
#endif

/* _ns1__doPmcSNLinkResponse has binding name '_ns1__doPmcSNLinkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__doPmcSNLinkResponse
#define SOAP_TYPE__ns1__doPmcSNLinkResponse (184)
#endif

/* _ns1__doPmcSNLink has binding name '_ns1__doPmcSNLink' for type '' */
#ifndef SOAP_TYPE__ns1__doPmcSNLink
#define SOAP_TYPE__ns1__doPmcSNLink (183)
#endif

/* _ns1__GetPmcSNPartResponse has binding name '_ns1__GetPmcSNPartResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPmcSNPartResponse
#define SOAP_TYPE__ns1__GetPmcSNPartResponse (182)
#endif

/* _ns1__GetPmcSNPart has binding name '_ns1__GetPmcSNPart' for type '' */
#ifndef SOAP_TYPE__ns1__GetPmcSNPart
#define SOAP_TYPE__ns1__GetPmcSNPart (181)
#endif

/* _ns1__getPmcPartAssyListResponse has binding name '_ns1__getPmcPartAssyListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getPmcPartAssyListResponse
#define SOAP_TYPE__ns1__getPmcPartAssyListResponse (180)
#endif

/* _ns1__getPmcPartAssyList has binding name '_ns1__getPmcPartAssyList' for type '' */
#ifndef SOAP_TYPE__ns1__getPmcPartAssyList
#define SOAP_TYPE__ns1__getPmcPartAssyList (179)
#endif

/* _ns1__getPmcAssyListResponse has binding name '_ns1__getPmcAssyListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getPmcAssyListResponse
#define SOAP_TYPE__ns1__getPmcAssyListResponse (178)
#endif

/* _ns1__getPmcAssyList has binding name '_ns1__getPmcAssyList' for type '' */
#ifndef SOAP_TYPE__ns1__getPmcAssyList
#define SOAP_TYPE__ns1__getPmcAssyList (177)
#endif

/* _ns1__doAssyResponse has binding name '_ns1__doAssyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__doAssyResponse
#define SOAP_TYPE__ns1__doAssyResponse (176)
#endif

/* _ns1__doAssy has binding name '_ns1__doAssy' for type '' */
#ifndef SOAP_TYPE__ns1__doAssy
#define SOAP_TYPE__ns1__doAssy (175)
#endif

/* _ns1__chkAssySNResponse has binding name '_ns1__chkAssySNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkAssySNResponse
#define SOAP_TYPE__ns1__chkAssySNResponse (174)
#endif

/* _ns1__chkAssySN has binding name '_ns1__chkAssySN' for type '' */
#ifndef SOAP_TYPE__ns1__chkAssySN
#define SOAP_TYPE__ns1__chkAssySN (173)
#endif

/* _ns1__getPNbySNResponse has binding name '_ns1__getPNbySNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getPNbySNResponse
#define SOAP_TYPE__ns1__getPNbySNResponse (172)
#endif

/* _ns1__getPNbySN has binding name '_ns1__getPNbySN' for type '' */
#ifndef SOAP_TYPE__ns1__getPNbySN
#define SOAP_TYPE__ns1__getPNbySN (171)
#endif

/* _ns1__getMoAssyCountResponse has binding name '_ns1__getMoAssyCountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getMoAssyCountResponse
#define SOAP_TYPE__ns1__getMoAssyCountResponse (170)
#endif

/* _ns1__getMoAssyCount has binding name '_ns1__getMoAssyCount' for type '' */
#ifndef SOAP_TYPE__ns1__getMoAssyCount
#define SOAP_TYPE__ns1__getMoAssyCount (169)
#endif

/* _ns1__GetLinkOutSnResponse has binding name '_ns1__GetLinkOutSnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetLinkOutSnResponse
#define SOAP_TYPE__ns1__GetLinkOutSnResponse (168)
#endif

/* _ns1__GetLinkOutSn has binding name '_ns1__GetLinkOutSn' for type '' */
#ifndef SOAP_TYPE__ns1__GetLinkOutSn
#define SOAP_TYPE__ns1__GetLinkOutSn (167)
#endif

/* _ns1__InsPartAssyResponse has binding name '_ns1__InsPartAssyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsPartAssyResponse
#define SOAP_TYPE__ns1__InsPartAssyResponse (166)
#endif

/* _ns1__InsPartAssy has binding name '_ns1__InsPartAssy' for type '' */
#ifndef SOAP_TYPE__ns1__InsPartAssy
#define SOAP_TYPE__ns1__InsPartAssy (165)
#endif

/* _ns1__getPartBomExtResponse has binding name '_ns1__getPartBomExtResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getPartBomExtResponse
#define SOAP_TYPE__ns1__getPartBomExtResponse (164)
#endif

/* _ns1__getPartBomExt has binding name '_ns1__getPartBomExt' for type '' */
#ifndef SOAP_TYPE__ns1__getPartBomExt
#define SOAP_TYPE__ns1__getPartBomExt (163)
#endif

/* _ns1__getMoAssyListResponse has binding name '_ns1__getMoAssyListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getMoAssyListResponse
#define SOAP_TYPE__ns1__getMoAssyListResponse (162)
#endif

/* _ns1__getMoAssyList has binding name '_ns1__getMoAssyList' for type '' */
#ifndef SOAP_TYPE__ns1__getMoAssyList
#define SOAP_TYPE__ns1__getMoAssyList (161)
#endif

/* _ns1__chkSnMappingResponse has binding name '_ns1__chkSnMappingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkSnMappingResponse
#define SOAP_TYPE__ns1__chkSnMappingResponse (160)
#endif

/* _ns1__chkSnMapping has binding name '_ns1__chkSnMapping' for type '' */
#ifndef SOAP_TYPE__ns1__chkSnMapping
#define SOAP_TYPE__ns1__chkSnMapping (159)
#endif

/* _ns1__getStationTypeDescResponse has binding name '_ns1__getStationTypeDescResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getStationTypeDescResponse
#define SOAP_TYPE__ns1__getStationTypeDescResponse (158)
#endif

/* _ns1__getStationTypeDesc has binding name '_ns1__getStationTypeDesc' for type '' */
#ifndef SOAP_TYPE__ns1__getStationTypeDesc
#define SOAP_TYPE__ns1__getStationTypeDesc (157)
#endif

/* _ns1__getStationByMoResponse has binding name '_ns1__getStationByMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getStationByMoResponse
#define SOAP_TYPE__ns1__getStationByMoResponse (156)
#endif

/* _ns1__getStationByMo has binding name '_ns1__getStationByMo' for type '' */
#ifndef SOAP_TYPE__ns1__getStationByMo
#define SOAP_TYPE__ns1__getStationByMo (155)
#endif

/* _ns1__SnDoMappingResponse has binding name '_ns1__SnDoMappingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SnDoMappingResponse
#define SOAP_TYPE__ns1__SnDoMappingResponse (154)
#endif

/* _ns1__SnDoMapping has binding name '_ns1__SnDoMapping' for type '' */
#ifndef SOAP_TYPE__ns1__SnDoMapping
#define SOAP_TYPE__ns1__SnDoMapping (153)
#endif

/* _ns1__eMesNextMoResponse has binding name '_ns1__eMesNextMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__eMesNextMoResponse
#define SOAP_TYPE__ns1__eMesNextMoResponse (152)
#endif

/* _ns1__eMesNextMo has binding name '_ns1__eMesNextMo' for type '' */
#ifndef SOAP_TYPE__ns1__eMesNextMo
#define SOAP_TYPE__ns1__eMesNextMo (151)
#endif

/* _ns1__sendResultForStationNumberResponse has binding name '_ns1__sendResultForStationNumberResponse' for type '' */
#ifndef SOAP_TYPE__ns1__sendResultForStationNumberResponse
#define SOAP_TYPE__ns1__sendResultForStationNumberResponse (150)
#endif

/* _ns1__sendResultForStationNumber has binding name '_ns1__sendResultForStationNumber' for type '' */
#ifndef SOAP_TYPE__ns1__sendResultForStationNumber
#define SOAP_TYPE__ns1__sendResultForStationNumber (149)
#endif

/* _ns1__sendDataForStationNumberResponse has binding name '_ns1__sendDataForStationNumberResponse' for type '' */
#ifndef SOAP_TYPE__ns1__sendDataForStationNumberResponse
#define SOAP_TYPE__ns1__sendDataForStationNumberResponse (148)
#endif

/* _ns1__sendDataForStationNumber has binding name '_ns1__sendDataForStationNumber' for type '' */
#ifndef SOAP_TYPE__ns1__sendDataForStationNumber
#define SOAP_TYPE__ns1__sendDataForStationNumber (147)
#endif

/* _ns1__checkEmpForStationNumberResponse has binding name '_ns1__checkEmpForStationNumberResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkEmpForStationNumberResponse
#define SOAP_TYPE__ns1__checkEmpForStationNumberResponse (146)
#endif

/* _ns1__checkEmpForStationNumber has binding name '_ns1__checkEmpForStationNumber' for type '' */
#ifndef SOAP_TYPE__ns1__checkEmpForStationNumber
#define SOAP_TYPE__ns1__checkEmpForStationNumber (145)
#endif

/* _ns1__checkSN_USCOREStationNumberResponse has binding name '_ns1__checkSN_USCOREStationNumberResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse
#define SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse (144)
#endif

/* _ns1__checkSN_USCOREStationNumber has binding name '_ns1__checkSN_USCOREStationNumber' for type '' */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStationNumber
#define SOAP_TYPE__ns1__checkSN_USCOREStationNumber (143)
#endif

/* _ns1__ChkSnNextMoResponse has binding name '_ns1__ChkSnNextMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnNextMoResponse
#define SOAP_TYPE__ns1__ChkSnNextMoResponse (142)
#endif

/* _ns1__ChkSnNextMo has binding name '_ns1__ChkSnNextMo' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnNextMo
#define SOAP_TYPE__ns1__ChkSnNextMo (141)
#endif

/* _ns1__ChkSnMoResponse has binding name '_ns1__ChkSnMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnMoResponse
#define SOAP_TYPE__ns1__ChkSnMoResponse (140)
#endif

/* _ns1__ChkSnMo has binding name '_ns1__ChkSnMo' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnMo
#define SOAP_TYPE__ns1__ChkSnMo (139)
#endif

/* _ns1__chkMoStationResponse has binding name '_ns1__chkMoStationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkMoStationResponse
#define SOAP_TYPE__ns1__chkMoStationResponse (138)
#endif

/* _ns1__chkMoStation has binding name '_ns1__chkMoStation' for type '' */
#ifndef SOAP_TYPE__ns1__chkMoStation
#define SOAP_TYPE__ns1__chkMoStation (137)
#endif

/* _ns1__SetEnergyStatResponse has binding name '_ns1__SetEnergyStatResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetEnergyStatResponse
#define SOAP_TYPE__ns1__SetEnergyStatResponse (136)
#endif

/* _ns1__SetEnergyStat has binding name '_ns1__SetEnergyStat' for type '' */
#ifndef SOAP_TYPE__ns1__SetEnergyStat
#define SOAP_TYPE__ns1__SetEnergyStat (135)
#endif

/* _ns1__getInfoByMoResponse has binding name '_ns1__getInfoByMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getInfoByMoResponse
#define SOAP_TYPE__ns1__getInfoByMoResponse (134)
#endif

/* _ns1__getInfoByMo has binding name '_ns1__getInfoByMo' for type '' */
#ifndef SOAP_TYPE__ns1__getInfoByMo
#define SOAP_TYPE__ns1__getInfoByMo (133)
#endif

/* _ns1__InsThermalNewResponse has binding name '_ns1__InsThermalNewResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsThermalNewResponse
#define SOAP_TYPE__ns1__InsThermalNewResponse (132)
#endif

/* _ns1__InsThermalNew has binding name '_ns1__InsThermalNew' for type '' */
#ifndef SOAP_TYPE__ns1__InsThermalNew
#define SOAP_TYPE__ns1__InsThermalNew (131)
#endif

/* _ns1__ChkSnLinkResponse has binding name '_ns1__ChkSnLinkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnLinkResponse
#define SOAP_TYPE__ns1__ChkSnLinkResponse (130)
#endif

/* _ns1__ChkSnLink has binding name '_ns1__ChkSnLink' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnLink
#define SOAP_TYPE__ns1__ChkSnLink (129)
#endif

/* _ns1__InsThermalResponse has binding name '_ns1__InsThermalResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsThermalResponse
#define SOAP_TYPE__ns1__InsThermalResponse (128)
#endif

/* _ns1__InsThermal has binding name '_ns1__InsThermal' for type '' */
#ifndef SOAP_TYPE__ns1__InsThermal
#define SOAP_TYPE__ns1__InsThermal (127)
#endif

/* _ns1__InsWHDetectionResponse has binding name '_ns1__InsWHDetectionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsWHDetectionResponse
#define SOAP_TYPE__ns1__InsWHDetectionResponse (126)
#endif

/* _ns1__InsWHDetection has binding name '_ns1__InsWHDetection' for type '' */
#ifndef SOAP_TYPE__ns1__InsWHDetection
#define SOAP_TYPE__ns1__InsWHDetection (125)
#endif

/* _ns1__InsFlatNessForCLResponse has binding name '_ns1__InsFlatNessForCLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsFlatNessForCLResponse
#define SOAP_TYPE__ns1__InsFlatNessForCLResponse (124)
#endif

/* _ns1__InsFlatNessForCL has binding name '_ns1__InsFlatNessForCL' for type '' */
#ifndef SOAP_TYPE__ns1__InsFlatNessForCL
#define SOAP_TYPE__ns1__InsFlatNessForCL (123)
#endif

/* _ns1__InsFlatNessForLSDResponse has binding name '_ns1__InsFlatNessForLSDResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsFlatNessForLSDResponse
#define SOAP_TYPE__ns1__InsFlatNessForLSDResponse (122)
#endif

/* _ns1__InsFlatNessForLSD has binding name '_ns1__InsFlatNessForLSD' for type '' */
#ifndef SOAP_TYPE__ns1__InsFlatNessForLSD
#define SOAP_TYPE__ns1__InsFlatNessForLSD (121)
#endif

/* _ns1__InsFlatNessResponse has binding name '_ns1__InsFlatNessResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsFlatNessResponse
#define SOAP_TYPE__ns1__InsFlatNessResponse (120)
#endif

/* _ns1__InsFlatNess has binding name '_ns1__InsFlatNess' for type '' */
#ifndef SOAP_TYPE__ns1__InsFlatNess
#define SOAP_TYPE__ns1__InsFlatNess (119)
#endif

/* _ns1__ImpMesAteTestDataResponse has binding name '_ns1__ImpMesAteTestDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ImpMesAteTestDataResponse
#define SOAP_TYPE__ns1__ImpMesAteTestDataResponse (118)
#endif

/* _ns1__ImpMesAteTestData has binding name '_ns1__ImpMesAteTestData' for type '' */
#ifndef SOAP_TYPE__ns1__ImpMesAteTestData
#define SOAP_TYPE__ns1__ImpMesAteTestData (117)
#endif

/* _ns1__chkStationTimeResponse has binding name '_ns1__chkStationTimeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkStationTimeResponse
#define SOAP_TYPE__ns1__chkStationTimeResponse (116)
#endif

/* _ns1__chkStationTime has binding name '_ns1__chkStationTime' for type '' */
#ifndef SOAP_TYPE__ns1__chkStationTime
#define SOAP_TYPE__ns1__chkStationTime (115)
#endif

/* _ns1__InFruitsOrtQtyResponse has binding name '_ns1__InFruitsOrtQtyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InFruitsOrtQtyResponse
#define SOAP_TYPE__ns1__InFruitsOrtQtyResponse (114)
#endif

/* _ns1__InFruitsOrtQty has binding name '_ns1__InFruitsOrtQty' for type '' */
#ifndef SOAP_TYPE__ns1__InFruitsOrtQty
#define SOAP_TYPE__ns1__InFruitsOrtQty (113)
#endif

/* _ns1__sendTestResultResponse has binding name '_ns1__sendTestResultResponse' for type '' */
#ifndef SOAP_TYPE__ns1__sendTestResultResponse
#define SOAP_TYPE__ns1__sendTestResultResponse (112)
#endif

/* _ns1__sendTestResult has binding name '_ns1__sendTestResult' for type '' */
#ifndef SOAP_TYPE__ns1__sendTestResult
#define SOAP_TYPE__ns1__sendTestResult (111)
#endif

/* _ns1__sendTestDataResponse has binding name '_ns1__sendTestDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__sendTestDataResponse
#define SOAP_TYPE__ns1__sendTestDataResponse (110)
#endif

/* _ns1__sendTestData has binding name '_ns1__sendTestData' for type '' */
#ifndef SOAP_TYPE__ns1__sendTestData
#define SOAP_TYPE__ns1__sendTestData (109)
#endif

/* _ns1__checkSN_USCOREStationResponse has binding name '_ns1__checkSN_USCOREStationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStationResponse
#define SOAP_TYPE__ns1__checkSN_USCOREStationResponse (108)
#endif

/* _ns1__checkSN_USCOREStation has binding name '_ns1__checkSN_USCOREStation' for type '' */
#ifndef SOAP_TYPE__ns1__checkSN_USCOREStation
#define SOAP_TYPE__ns1__checkSN_USCOREStation (107)
#endif

/* _ns1__checkEmpNoResponse has binding name '_ns1__checkEmpNoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkEmpNoResponse
#define SOAP_TYPE__ns1__checkEmpNoResponse (106)
#endif

/* _ns1__checkEmpNo has binding name '_ns1__checkEmpNo' for type '' */
#ifndef SOAP_TYPE__ns1__checkEmpNo
#define SOAP_TYPE__ns1__checkEmpNo (105)
#endif

/* _ns1__checkTestDataResponse has binding name '_ns1__checkTestDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkTestDataResponse
#define SOAP_TYPE__ns1__checkTestDataResponse (104)
#endif

/* _ns1__checkTestData has binding name '_ns1__checkTestData' for type '' */
#ifndef SOAP_TYPE__ns1__checkTestData
#define SOAP_TYPE__ns1__checkTestData (103)
#endif

/* _ns1__InsZjListResponse has binding name '_ns1__InsZjListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsZjListResponse
#define SOAP_TYPE__ns1__InsZjListResponse (102)
#endif

/* _ns1__InsZjList has binding name '_ns1__InsZjList' for type '' */
#ifndef SOAP_TYPE__ns1__InsZjList
#define SOAP_TYPE__ns1__InsZjList (101)
#endif

/* _ns1__GetFruitMachineChkResponse has binding name '_ns1__GetFruitMachineChkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetFruitMachineChkResponse
#define SOAP_TYPE__ns1__GetFruitMachineChkResponse (100)
#endif

/* _ns1__GetFruitMachineChk has binding name '_ns1__GetFruitMachineChk' for type '' */
#ifndef SOAP_TYPE__ns1__GetFruitMachineChk
#define SOAP_TYPE__ns1__GetFruitMachineChk (99)
#endif

/* _ns1__InsFruitMachineChkResponse has binding name '_ns1__InsFruitMachineChkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsFruitMachineChkResponse
#define SOAP_TYPE__ns1__InsFruitMachineChkResponse (98)
#endif

/* _ns1__InsFruitMachineChk has binding name '_ns1__InsFruitMachineChk' for type '' */
#ifndef SOAP_TYPE__ns1__InsFruitMachineChk
#define SOAP_TYPE__ns1__InsFruitMachineChk (97)
#endif

/* _ns1__SnLnkOutSNResponse has binding name '_ns1__SnLnkOutSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SnLnkOutSNResponse
#define SOAP_TYPE__ns1__SnLnkOutSNResponse (96)
#endif

/* _ns1__SnLnkOutSN has binding name '_ns1__SnLnkOutSN' for type '' */
#ifndef SOAP_TYPE__ns1__SnLnkOutSN
#define SOAP_TYPE__ns1__SnLnkOutSN (95)
#endif

/* _ns1__getMoBaseResponse has binding name '_ns1__getMoBaseResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getMoBaseResponse
#define SOAP_TYPE__ns1__getMoBaseResponse (94)
#endif

/* _ns1__getMoBase has binding name '_ns1__getMoBase' for type '' */
#ifndef SOAP_TYPE__ns1__getMoBase
#define SOAP_TYPE__ns1__getMoBase (93)
#endif

/* _ns1__GetNgCodeResponse has binding name '_ns1__GetNgCodeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetNgCodeResponse
#define SOAP_TYPE__ns1__GetNgCodeResponse (92)
#endif

/* _ns1__GetNgCode has binding name '_ns1__GetNgCode' for type '' */
#ifndef SOAP_TYPE__ns1__GetNgCode
#define SOAP_TYPE__ns1__GetNgCode (91)
#endif

/* _ns1__SetDiecastSNResponse has binding name '_ns1__SetDiecastSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDiecastSNResponse
#define SOAP_TYPE__ns1__SetDiecastSNResponse (90)
#endif

/* _ns1__SetDiecastSN has binding name '_ns1__SetDiecastSN' for type '' */
#ifndef SOAP_TYPE__ns1__SetDiecastSN
#define SOAP_TYPE__ns1__SetDiecastSN (89)
#endif

/* _ns1__GetMachineForGroupResponse has binding name '_ns1__GetMachineForGroupResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetMachineForGroupResponse
#define SOAP_TYPE__ns1__GetMachineForGroupResponse (88)
#endif

/* _ns1__GetMachineForGroup has binding name '_ns1__GetMachineForGroup' for type '' */
#ifndef SOAP_TYPE__ns1__GetMachineForGroup
#define SOAP_TYPE__ns1__GetMachineForGroup (87)
#endif

/* _ns1__UploadForHPResponse has binding name '_ns1__UploadForHPResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UploadForHPResponse
#define SOAP_TYPE__ns1__UploadForHPResponse (86)
#endif

/* _ns1__UploadForHP has binding name '_ns1__UploadForHP' for type '' */
#ifndef SOAP_TYPE__ns1__UploadForHP
#define SOAP_TYPE__ns1__UploadForHP (85)
#endif

/* _ns1__SelShelfLinkResponse has binding name '_ns1__SelShelfLinkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SelShelfLinkResponse
#define SOAP_TYPE__ns1__SelShelfLinkResponse (84)
#endif

/* _ns1__SelShelfLink has binding name '_ns1__SelShelfLink' for type '' */
#ifndef SOAP_TYPE__ns1__SelShelfLink
#define SOAP_TYPE__ns1__SelShelfLink (83)
#endif

/* _ns1__SNLinkShelfResponse has binding name '_ns1__SNLinkShelfResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SNLinkShelfResponse
#define SOAP_TYPE__ns1__SNLinkShelfResponse (82)
#endif

/* _ns1__SNLinkShelf has binding name '_ns1__SNLinkShelf' for type '' */
#ifndef SOAP_TYPE__ns1__SNLinkShelf
#define SOAP_TYPE__ns1__SNLinkShelf (81)
#endif

/* _ns1__SelSNTestForFruitResponse has binding name '_ns1__SelSNTestForFruitResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SelSNTestForFruitResponse
#define SOAP_TYPE__ns1__SelSNTestForFruitResponse (80)
#endif

/* _ns1__SelSNTestForFruit has binding name '_ns1__SelSNTestForFruit' for type '' */
#ifndef SOAP_TYPE__ns1__SelSNTestForFruit
#define SOAP_TYPE__ns1__SelSNTestForFruit (79)
#endif

/* _ns1__InsSNTestForFruitResponse has binding name '_ns1__InsSNTestForFruitResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsSNTestForFruitResponse
#define SOAP_TYPE__ns1__InsSNTestForFruitResponse (78)
#endif

/* _ns1__InsSNTestForFruit has binding name '_ns1__InsSNTestForFruit' for type '' */
#ifndef SOAP_TYPE__ns1__InsSNTestForFruit
#define SOAP_TYPE__ns1__InsSNTestForFruit (77)
#endif

/* _ns1__GetStationNumberForSNResponse has binding name '_ns1__GetStationNumberForSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetStationNumberForSNResponse
#define SOAP_TYPE__ns1__GetStationNumberForSNResponse (76)
#endif

/* _ns1__GetStationNumberForSN has binding name '_ns1__GetStationNumberForSN' for type '' */
#ifndef SOAP_TYPE__ns1__GetStationNumberForSN
#define SOAP_TYPE__ns1__GetStationNumberForSN (75)
#endif

/* _ns1__GetTestValueResultResponse has binding name '_ns1__GetTestValueResultResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetTestValueResultResponse
#define SOAP_TYPE__ns1__GetTestValueResultResponse (74)
#endif

/* _ns1__GetTestValueResult has binding name '_ns1__GetTestValueResult' for type '' */
#ifndef SOAP_TYPE__ns1__GetTestValueResult
#define SOAP_TYPE__ns1__GetTestValueResult (73)
#endif

/* _ns1__InsCLScadaResponse has binding name '_ns1__InsCLScadaResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsCLScadaResponse
#define SOAP_TYPE__ns1__InsCLScadaResponse (72)
#endif

/* _ns1__InsCLScada has binding name '_ns1__InsCLScada' for type '' */
#ifndef SOAP_TYPE__ns1__InsCLScada
#define SOAP_TYPE__ns1__InsCLScada (71)
#endif

/* _ns1__InsAoiMoResponse has binding name '_ns1__InsAoiMoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsAoiMoResponse
#define SOAP_TYPE__ns1__InsAoiMoResponse (70)
#endif

/* _ns1__InsAoiMo has binding name '_ns1__InsAoiMo' for type '' */
#ifndef SOAP_TYPE__ns1__InsAoiMo
#define SOAP_TYPE__ns1__InsAoiMo (69)
#endif

/* _ns1__chkMoSNForAOIResponse has binding name '_ns1__chkMoSNForAOIResponse' for type '' */
#ifndef SOAP_TYPE__ns1__chkMoSNForAOIResponse
#define SOAP_TYPE__ns1__chkMoSNForAOIResponse (68)
#endif

/* _ns1__chkMoSNForAOI has binding name '_ns1__chkMoSNForAOI' for type '' */
#ifndef SOAP_TYPE__ns1__chkMoSNForAOI
#define SOAP_TYPE__ns1__chkMoSNForAOI (67)
#endif

/* _ns1__PunchOutResponse has binding name '_ns1__PunchOutResponse' for type '' */
#ifndef SOAP_TYPE__ns1__PunchOutResponse
#define SOAP_TYPE__ns1__PunchOutResponse (66)
#endif

/* _ns1__PunchOut has binding name '_ns1__PunchOut' for type '' */
#ifndef SOAP_TYPE__ns1__PunchOut
#define SOAP_TYPE__ns1__PunchOut (65)
#endif

/* _ns1__BasketLinkPunchResponse has binding name '_ns1__BasketLinkPunchResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BasketLinkPunchResponse
#define SOAP_TYPE__ns1__BasketLinkPunchResponse (64)
#endif

/* _ns1__BasketLinkPunch has binding name '_ns1__BasketLinkPunch' for type '' */
#ifndef SOAP_TYPE__ns1__BasketLinkPunch
#define SOAP_TYPE__ns1__BasketLinkPunch (63)
#endif

/* _ns1__HPSNLinkBasketResponse has binding name '_ns1__HPSNLinkBasketResponse' for type '' */
#ifndef SOAP_TYPE__ns1__HPSNLinkBasketResponse
#define SOAP_TYPE__ns1__HPSNLinkBasketResponse (62)
#endif

/* _ns1__HPSNLinkBasket has binding name '_ns1__HPSNLinkBasket' for type '' */
#ifndef SOAP_TYPE__ns1__HPSNLinkBasket
#define SOAP_TYPE__ns1__HPSNLinkBasket (61)
#endif

/* _ns1__SetAutoLineRecResponse has binding name '_ns1__SetAutoLineRecResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetAutoLineRecResponse
#define SOAP_TYPE__ns1__SetAutoLineRecResponse (60)
#endif

/* _ns1__SetAutoLineRec has binding name '_ns1__SetAutoLineRec' for type '' */
#ifndef SOAP_TYPE__ns1__SetAutoLineRec
#define SOAP_TYPE__ns1__SetAutoLineRec (59)
#endif

/* _ns1__GetSNForLinkResponse has binding name '_ns1__GetSNForLinkResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSNForLinkResponse
#define SOAP_TYPE__ns1__GetSNForLinkResponse (58)
#endif

/* _ns1__GetSNForLink has binding name '_ns1__GetSNForLink' for type '' */
#ifndef SOAP_TYPE__ns1__GetSNForLink
#define SOAP_TYPE__ns1__GetSNForLink (57)
#endif

/* _ns1__SetFlatnessFruitRecResponse has binding name '_ns1__SetFlatnessFruitRecResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetFlatnessFruitRecResponse
#define SOAP_TYPE__ns1__SetFlatnessFruitRecResponse (56)
#endif

/* _ns1__SetFlatnessFruitRec has binding name '_ns1__SetFlatnessFruitRec' for type '' */
#ifndef SOAP_TYPE__ns1__SetFlatnessFruitRec
#define SOAP_TYPE__ns1__SetFlatnessFruitRec (55)
#endif

/* _ns1__getStationByMoForTestPadResponse has binding name '_ns1__getStationByMoForTestPadResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getStationByMoForTestPadResponse
#define SOAP_TYPE__ns1__getStationByMoForTestPadResponse (54)
#endif

/* _ns1__getStationByMoForTestPad has binding name '_ns1__getStationByMoForTestPad' for type '' */
#ifndef SOAP_TYPE__ns1__getStationByMoForTestPad
#define SOAP_TYPE__ns1__getStationByMoForTestPad (53)
#endif

/* _ns1__GetShippingWeightResponse has binding name '_ns1__GetShippingWeightResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingWeightResponse
#define SOAP_TYPE__ns1__GetShippingWeightResponse (52)
#endif

/* _ns1__GetShippingWeight has binding name '_ns1__GetShippingWeight' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingWeight
#define SOAP_TYPE__ns1__GetShippingWeight (51)
#endif

/* _ns1__GetShippingForBerthResponse has binding name '_ns1__GetShippingForBerthResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingForBerthResponse
#define SOAP_TYPE__ns1__GetShippingForBerthResponse (50)
#endif

/* _ns1__GetShippingForBerth has binding name '_ns1__GetShippingForBerth' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingForBerth
#define SOAP_TYPE__ns1__GetShippingForBerth (49)
#endif

/* _ns1__InsShippingBerthResponse has binding name '_ns1__InsShippingBerthResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsShippingBerthResponse
#define SOAP_TYPE__ns1__InsShippingBerthResponse (48)
#endif

/* _ns1__InsShippingBerth has binding name '_ns1__InsShippingBerth' for type '' */
#ifndef SOAP_TYPE__ns1__InsShippingBerth
#define SOAP_TYPE__ns1__InsShippingBerth (47)
#endif

/* _ns1__InsShippingPalleResponse has binding name '_ns1__InsShippingPalleResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsShippingPalleResponse
#define SOAP_TYPE__ns1__InsShippingPalleResponse (46)
#endif

/* _ns1__InsShippingPalle has binding name '_ns1__InsShippingPalle' for type '' */
#ifndef SOAP_TYPE__ns1__InsShippingPalle
#define SOAP_TYPE__ns1__InsShippingPalle (45)
#endif

/* _ns1__GetShippingPalleResponse has binding name '_ns1__GetShippingPalleResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingPalleResponse
#define SOAP_TYPE__ns1__GetShippingPalleResponse (44)
#endif

/* _ns1__GetShippingPalle has binding name '_ns1__GetShippingPalle' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingPalle
#define SOAP_TYPE__ns1__GetShippingPalle (43)
#endif

/* _ns1__UpdShippingResponse has binding name '_ns1__UpdShippingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpdShippingResponse
#define SOAP_TYPE__ns1__UpdShippingResponse (42)
#endif

/* _ns1__UpdShipping has binding name '_ns1__UpdShipping' for type '' */
#ifndef SOAP_TYPE__ns1__UpdShipping
#define SOAP_TYPE__ns1__UpdShipping (41)
#endif

/* _ns1__GetShippingBerthListResponse has binding name '_ns1__GetShippingBerthListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingBerthListResponse
#define SOAP_TYPE__ns1__GetShippingBerthListResponse (40)
#endif

/* _ns1__GetShippingBerthList has binding name '_ns1__GetShippingBerthList' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingBerthList
#define SOAP_TYPE__ns1__GetShippingBerthList (39)
#endif

/* _ns1__GetShippingListResponse has binding name '_ns1__GetShippingListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingListResponse
#define SOAP_TYPE__ns1__GetShippingListResponse (38)
#endif

/* _ns1__GetShippingList has binding name '_ns1__GetShippingList' for type '' */
#ifndef SOAP_TYPE__ns1__GetShippingList
#define SOAP_TYPE__ns1__GetShippingList (37)
#endif

/* _ns1__doLotLinkForAppleResponse has binding name '_ns1__doLotLinkForAppleResponse' for type '' */
#ifndef SOAP_TYPE__ns1__doLotLinkForAppleResponse
#define SOAP_TYPE__ns1__doLotLinkForAppleResponse (36)
#endif

/* _ns1__doLotLinkForApple has binding name '_ns1__doLotLinkForApple' for type '' */
#ifndef SOAP_TYPE__ns1__doLotLinkForApple
#define SOAP_TYPE__ns1__doLotLinkForApple (35)
#endif

/* _ns1__GetLotLinkCountResponse has binding name '_ns1__GetLotLinkCountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetLotLinkCountResponse
#define SOAP_TYPE__ns1__GetLotLinkCountResponse (34)
#endif

/* _ns1__GetLotLinkCount has binding name '_ns1__GetLotLinkCount' for type '' */
#ifndef SOAP_TYPE__ns1__GetLotLinkCount
#define SOAP_TYPE__ns1__GetLotLinkCount (33)
#endif

/* _ns1__GetFruitSNCheckResponse has binding name '_ns1__GetFruitSNCheckResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetFruitSNCheckResponse
#define SOAP_TYPE__ns1__GetFruitSNCheckResponse (32)
#endif

/* _ns1__GetFruitSNCheck has binding name '_ns1__GetFruitSNCheck' for type '' */
#ifndef SOAP_TYPE__ns1__GetFruitSNCheck
#define SOAP_TYPE__ns1__GetFruitSNCheck (31)
#endif

/* _ns1__GetObeNWResponse has binding name '_ns1__GetObeNWResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetObeNWResponse
#define SOAP_TYPE__ns1__GetObeNWResponse (30)
#endif

/* _ns1__GetObeNW has binding name '_ns1__GetObeNW' for type '' */
#ifndef SOAP_TYPE__ns1__GetObeNW
#define SOAP_TYPE__ns1__GetObeNW (29)
#endif

/* _ns1__doSnLinkForAppleResponse has binding name '_ns1__doSnLinkForAppleResponse' for type '' */
#ifndef SOAP_TYPE__ns1__doSnLinkForAppleResponse
#define SOAP_TYPE__ns1__doSnLinkForAppleResponse (28)
#endif

/* _ns1__doSnLinkForApple has binding name '_ns1__doSnLinkForApple' for type '' */
#ifndef SOAP_TYPE__ns1__doSnLinkForApple
#define SOAP_TYPE__ns1__doSnLinkForApple (27)
#endif

/* _ns1__ChkSnLinkForAppleResponse has binding name '_ns1__ChkSnLinkForAppleResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnLinkForAppleResponse
#define SOAP_TYPE__ns1__ChkSnLinkForAppleResponse (26)
#endif

/* _ns1__ChkSnLinkForApple has binding name '_ns1__ChkSnLinkForApple' for type '' */
#ifndef SOAP_TYPE__ns1__ChkSnLinkForApple
#define SOAP_TYPE__ns1__ChkSnLinkForApple (25)
#endif

/* _ns1__DelSNTestResponse has binding name '_ns1__DelSNTestResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DelSNTestResponse
#define SOAP_TYPE__ns1__DelSNTestResponse (24)
#endif

/* _ns1__DelSNTest has binding name '_ns1__DelSNTest' for type '' */
#ifndef SOAP_TYPE__ns1__DelSNTest
#define SOAP_TYPE__ns1__DelSNTest (23)
#endif

/* _ns1__SelSNTestResponse has binding name '_ns1__SelSNTestResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SelSNTestResponse
#define SOAP_TYPE__ns1__SelSNTestResponse (22)
#endif

/* _ns1__SelSNTest has binding name '_ns1__SelSNTest' for type '' */
#ifndef SOAP_TYPE__ns1__SelSNTest
#define SOAP_TYPE__ns1__SelSNTest (21)
#endif

/* _ns1__InsSNTestResponse has binding name '_ns1__InsSNTestResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsSNTestResponse
#define SOAP_TYPE__ns1__InsSNTestResponse (20)
#endif

/* _ns1__InsSNTest has binding name '_ns1__InsSNTest' for type '' */
#ifndef SOAP_TYPE__ns1__InsSNTest
#define SOAP_TYPE__ns1__InsSNTest (19)
#endif

/* _ns1__ChkWeightTimeResponse has binding name '_ns1__ChkWeightTimeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChkWeightTimeResponse
#define SOAP_TYPE__ns1__ChkWeightTimeResponse (18)
#endif

/* _ns1__ChkWeightTime has binding name '_ns1__ChkWeightTime' for type '' */
#ifndef SOAP_TYPE__ns1__ChkWeightTime
#define SOAP_TYPE__ns1__ChkWeightTime (17)
#endif

/* _ns1__UpdAhsBarcodeResponse has binding name '_ns1__UpdAhsBarcodeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpdAhsBarcodeResponse
#define SOAP_TYPE__ns1__UpdAhsBarcodeResponse (16)
#endif

/* _ns1__UpdAhsBarcode has binding name '_ns1__UpdAhsBarcode' for type '' */
#ifndef SOAP_TYPE__ns1__UpdAhsBarcode
#define SOAP_TYPE__ns1__UpdAhsBarcode (15)
#endif

/* _ns1__GetAhsBarcodeResponse has binding name '_ns1__GetAhsBarcodeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetAhsBarcodeResponse
#define SOAP_TYPE__ns1__GetAhsBarcodeResponse (14)
#endif

/* _ns1__GetAhsBarcode has binding name '_ns1__GetAhsBarcode' for type '' */
#ifndef SOAP_TYPE__ns1__GetAhsBarcode
#define SOAP_TYPE__ns1__GetAhsBarcode (13)
#endif

/* ns1__ArrayOfString has binding name 'ns1__ArrayOfString' for type 'ns1:ArrayOfString' */
#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (12)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1098)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1097)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1094)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1092)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1091)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (1100)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (1099)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (1093)
#endif

/* _ns1__GetAhsMo * has binding name 'PointerTo_ns1__GetAhsMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAhsMo
#define SOAP_TYPE_PointerTo_ns1__GetAhsMo (829)
#endif

/* _ns1__GetPackWeigth * has binding name 'PointerTo_ns1__GetPackWeigth' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPackWeigth
#define SOAP_TYPE_PointerTo_ns1__GetPackWeigth (825)
#endif

/* _ns1__GetPackStation * has binding name 'PointerTo_ns1__GetPackStation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPackStation
#define SOAP_TYPE_PointerTo_ns1__GetPackStation (821)
#endif

/* _ns1__SetPallentForWMS * has binding name 'PointerTo_ns1__SetPallentForWMS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetPallentForWMS
#define SOAP_TYPE_PointerTo_ns1__SetPallentForWMS (817)
#endif

/* _ns1__GetPallentToWMS * has binding name 'PointerTo_ns1__GetPallentToWMS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPallentToWMS
#define SOAP_TYPE_PointerTo_ns1__GetPallentToWMS (813)
#endif

/* _ns1__GetPackToWMS * has binding name 'PointerTo_ns1__GetPackToWMS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPackToWMS
#define SOAP_TYPE_PointerTo_ns1__GetPackToWMS (809)
#endif

/* _ns1__GetWeightSet * has binding name 'PointerTo_ns1__GetWeightSet' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetWeightSet
#define SOAP_TYPE_PointerTo_ns1__GetWeightSet (805)
#endif

/* _ns1__CancelLnkSN * has binding name 'PointerTo_ns1__CancelLnkSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CancelLnkSN
#define SOAP_TYPE_PointerTo_ns1__CancelLnkSN (801)
#endif

/* _ns1__CancelGrillSN * has binding name 'PointerTo_ns1__CancelGrillSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CancelGrillSN
#define SOAP_TYPE_PointerTo_ns1__CancelGrillSN (797)
#endif

/* _ns1__OutGrillBySN * has binding name 'PointerTo_ns1__OutGrillBySN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OutGrillBySN
#define SOAP_TYPE_PointerTo_ns1__OutGrillBySN (793)
#endif

/* _ns1__GetGrillTime * has binding name 'PointerTo_ns1__GetGrillTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetGrillTime
#define SOAP_TYPE_PointerTo_ns1__GetGrillTime (789)
#endif

/* _ns1__InsGrillBySN * has binding name 'PointerTo_ns1__InsGrillBySN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsGrillBySN
#define SOAP_TYPE_PointerTo_ns1__InsGrillBySN (785)
#endif

/* _ns1__CloseGrillSN * has binding name 'PointerTo_ns1__CloseGrillSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CloseGrillSN
#define SOAP_TYPE_PointerTo_ns1__CloseGrillSN (781)
#endif

/* _ns1__LnkGrillSN * has binding name 'PointerTo_ns1__LnkGrillSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LnkGrillSN
#define SOAP_TYPE_PointerTo_ns1__LnkGrillSN (777)
#endif

/* _ns1__chkGrillSN * has binding name 'PointerTo_ns1__chkGrillSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkGrillSN
#define SOAP_TYPE_PointerTo_ns1__chkGrillSN (773)
#endif

/* _ns1__LnkSideSN * has binding name 'PointerTo_ns1__LnkSideSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LnkSideSN
#define SOAP_TYPE_PointerTo_ns1__LnkSideSN (769)
#endif

/* _ns1__LnkZJSN * has binding name 'PointerTo_ns1__LnkZJSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LnkZJSN
#define SOAP_TYPE_PointerTo_ns1__LnkZJSN (765)
#endif

/* _ns1__chkZJSN * has binding name 'PointerTo_ns1__chkZJSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkZJSN
#define SOAP_TYPE_PointerTo_ns1__chkZJSN (761)
#endif

/* _ns1__chkDispensing * has binding name 'PointerTo_ns1__chkDispensing' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkDispensing
#define SOAP_TYPE_PointerTo_ns1__chkDispensing (757)
#endif

/* _ns1__InsIotTestData * has binding name 'PointerTo_ns1__InsIotTestData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsIotTestData
#define SOAP_TYPE_PointerTo_ns1__InsIotTestData (753)
#endif

/* _ns1__InsIotMachineRec * has binding name 'PointerTo_ns1__InsIotMachineRec' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsIotMachineRec
#define SOAP_TYPE_PointerTo_ns1__InsIotMachineRec (749)
#endif

/* _ns1__GetLnkData * has binding name 'PointerTo_ns1__GetLnkData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLnkData
#define SOAP_TYPE_PointerTo_ns1__GetLnkData (745)
#endif

/* _ns1__GetTestValue * has binding name 'PointerTo_ns1__GetTestValue' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetTestValue
#define SOAP_TYPE_PointerTo_ns1__GetTestValue (741)
#endif

/* _ns1__GetMoBase * has binding name 'PointerTo_ns1__GetMoBase' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetMoBase
#define SOAP_TYPE_PointerTo_ns1__GetMoBase (737)
#endif

/* _ns1__UpdSnRecInfo * has binding name 'PointerTo_ns1__UpdSnRecInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdSnRecInfo
#define SOAP_TYPE_PointerTo_ns1__UpdSnRecInfo (733)
#endif

/* _ns1__InsBoxInfo * has binding name 'PointerTo_ns1__InsBoxInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsBoxInfo
#define SOAP_TYPE_PointerTo_ns1__InsBoxInfo (729)
#endif

/* _ns1__InsLnkOutSN * has binding name 'PointerTo_ns1__InsLnkOutSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsLnkOutSN
#define SOAP_TYPE_PointerTo_ns1__InsLnkOutSN (725)
#endif

/* _ns1__InsSNStationEmp * has binding name 'PointerTo_ns1__InsSNStationEmp' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsSNStationEmp
#define SOAP_TYPE_PointerTo_ns1__InsSNStationEmp (721)
#endif

/* _ns1__CancelBoxLnk * has binding name 'PointerTo_ns1__CancelBoxLnk' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CancelBoxLnk
#define SOAP_TYPE_PointerTo_ns1__CancelBoxLnk (717)
#endif

/* _ns1__OutStationbyBox * has binding name 'PointerTo_ns1__OutStationbyBox' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OutStationbyBox
#define SOAP_TYPE_PointerTo_ns1__OutStationbyBox (713)
#endif

/* _ns1__InStationbyBox * has binding name 'PointerTo_ns1__InStationbyBox' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InStationbyBox
#define SOAP_TYPE_PointerTo_ns1__InStationbyBox (709)
#endif

/* _ns1__EndSNtoBox * has binding name 'PointerTo_ns1__EndSNtoBox' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EndSNtoBox
#define SOAP_TYPE_PointerTo_ns1__EndSNtoBox (705)
#endif

/* _ns1__InSNtoBox * has binding name 'PointerTo_ns1__InSNtoBox' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InSNtoBox
#define SOAP_TYPE_PointerTo_ns1__InSNtoBox (701)
#endif

/* _ns1__chkBoxNo * has binding name 'PointerTo_ns1__chkBoxNo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkBoxNo
#define SOAP_TYPE_PointerTo_ns1__chkBoxNo (697)
#endif

/* _ns1__InsBoxNOTime * has binding name 'PointerTo_ns1__InsBoxNOTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsBoxNOTime
#define SOAP_TYPE_PointerTo_ns1__InsBoxNOTime (693)
#endif

/* _ns1__GetLinkZJCount * has binding name 'PointerTo_ns1__GetLinkZJCount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLinkZJCount
#define SOAP_TYPE_PointerTo_ns1__GetLinkZJCount (689)
#endif

/* _ns1__InsLinkSN * has binding name 'PointerTo_ns1__InsLinkSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsLinkSN
#define SOAP_TYPE_PointerTo_ns1__InsLinkSN (685)
#endif

/* _ns1__doLinkOutSN * has binding name 'PointerTo_ns1__doLinkOutSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doLinkOutSN
#define SOAP_TYPE_PointerTo_ns1__doLinkOutSN (681)
#endif

/* _ns1__ChkLinkOutSN * has binding name 'PointerTo_ns1__ChkLinkOutSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChkLinkOutSN
#define SOAP_TYPE_PointerTo_ns1__ChkLinkOutSN (677)
#endif

/* _ns1__chkOutSN * has binding name 'PointerTo_ns1__chkOutSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkOutSN
#define SOAP_TYPE_PointerTo_ns1__chkOutSN (673)
#endif

/* _ns1__GetLintOutQty * has binding name 'PointerTo_ns1__GetLintOutQty' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLintOutQty
#define SOAP_TYPE_PointerTo_ns1__GetLintOutQty (669)
#endif

/* _ns1__SNLinkZJ * has binding name 'PointerTo_ns1__SNLinkZJ' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SNLinkZJ
#define SOAP_TYPE_PointerTo_ns1__SNLinkZJ (665)
#endif

/* _ns1__InsZJTestData * has binding name 'PointerTo_ns1__InsZJTestData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsZJTestData
#define SOAP_TYPE_PointerTo_ns1__InsZJTestData (661)
#endif

/* _ns1__doPmcSNLink * has binding name 'PointerTo_ns1__doPmcSNLink' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doPmcSNLink
#define SOAP_TYPE_PointerTo_ns1__doPmcSNLink (657)
#endif

/* _ns1__GetPmcSNPart * has binding name 'PointerTo_ns1__GetPmcSNPart' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPmcSNPart
#define SOAP_TYPE_PointerTo_ns1__GetPmcSNPart (653)
#endif

/* _ns1__getPmcPartAssyList * has binding name 'PointerTo_ns1__getPmcPartAssyList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPmcPartAssyList
#define SOAP_TYPE_PointerTo_ns1__getPmcPartAssyList (649)
#endif

/* _ns1__getPmcAssyList * has binding name 'PointerTo_ns1__getPmcAssyList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPmcAssyList
#define SOAP_TYPE_PointerTo_ns1__getPmcAssyList (645)
#endif

/* _ns1__doAssy * has binding name 'PointerTo_ns1__doAssy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doAssy
#define SOAP_TYPE_PointerTo_ns1__doAssy (641)
#endif

/* _ns1__chkAssySN * has binding name 'PointerTo_ns1__chkAssySN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkAssySN
#define SOAP_TYPE_PointerTo_ns1__chkAssySN (637)
#endif

/* _ns1__getPNbySN * has binding name 'PointerTo_ns1__getPNbySN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPNbySN
#define SOAP_TYPE_PointerTo_ns1__getPNbySN (633)
#endif

/* _ns1__getMoAssyCount * has binding name 'PointerTo_ns1__getMoAssyCount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getMoAssyCount
#define SOAP_TYPE_PointerTo_ns1__getMoAssyCount (629)
#endif

/* _ns1__GetLinkOutSn * has binding name 'PointerTo_ns1__GetLinkOutSn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLinkOutSn
#define SOAP_TYPE_PointerTo_ns1__GetLinkOutSn (625)
#endif

/* _ns1__InsPartAssy * has binding name 'PointerTo_ns1__InsPartAssy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsPartAssy
#define SOAP_TYPE_PointerTo_ns1__InsPartAssy (621)
#endif

/* _ns1__getPartBomExt * has binding name 'PointerTo_ns1__getPartBomExt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPartBomExt
#define SOAP_TYPE_PointerTo_ns1__getPartBomExt (617)
#endif

/* _ns1__getMoAssyList * has binding name 'PointerTo_ns1__getMoAssyList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getMoAssyList
#define SOAP_TYPE_PointerTo_ns1__getMoAssyList (613)
#endif

/* _ns1__chkSnMapping * has binding name 'PointerTo_ns1__chkSnMapping' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkSnMapping
#define SOAP_TYPE_PointerTo_ns1__chkSnMapping (609)
#endif

/* _ns1__getStationTypeDesc * has binding name 'PointerTo_ns1__getStationTypeDesc' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getStationTypeDesc
#define SOAP_TYPE_PointerTo_ns1__getStationTypeDesc (605)
#endif

/* _ns1__getStationByMo * has binding name 'PointerTo_ns1__getStationByMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getStationByMo
#define SOAP_TYPE_PointerTo_ns1__getStationByMo (601)
#endif

/* _ns1__SnDoMapping * has binding name 'PointerTo_ns1__SnDoMapping' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SnDoMapping
#define SOAP_TYPE_PointerTo_ns1__SnDoMapping (597)
#endif

/* _ns1__eMesNextMo * has binding name 'PointerTo_ns1__eMesNextMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__eMesNextMo
#define SOAP_TYPE_PointerTo_ns1__eMesNextMo (593)
#endif

/* _ns1__sendResultForStationNumber * has binding name 'PointerTo_ns1__sendResultForStationNumber' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__sendResultForStationNumber
#define SOAP_TYPE_PointerTo_ns1__sendResultForStationNumber (589)
#endif

/* _ns1__sendDataForStationNumber * has binding name 'PointerTo_ns1__sendDataForStationNumber' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__sendDataForStationNumber
#define SOAP_TYPE_PointerTo_ns1__sendDataForStationNumber (585)
#endif

/* _ns1__checkEmpForStationNumber * has binding name 'PointerTo_ns1__checkEmpForStationNumber' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkEmpForStationNumber
#define SOAP_TYPE_PointerTo_ns1__checkEmpForStationNumber (581)
#endif

/* _ns1__checkSN_USCOREStationNumber * has binding name 'PointerTo_ns1__checkSN_USCOREStationNumber' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStationNumber
#define SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStationNumber (577)
#endif

/* _ns1__ChkSnNextMo * has binding name 'PointerTo_ns1__ChkSnNextMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChkSnNextMo
#define SOAP_TYPE_PointerTo_ns1__ChkSnNextMo (573)
#endif

/* _ns1__ChkSnMo * has binding name 'PointerTo_ns1__ChkSnMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChkSnMo
#define SOAP_TYPE_PointerTo_ns1__ChkSnMo (569)
#endif

/* _ns1__chkMoStation * has binding name 'PointerTo_ns1__chkMoStation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkMoStation
#define SOAP_TYPE_PointerTo_ns1__chkMoStation (565)
#endif

/* _ns1__SetEnergyStat * has binding name 'PointerTo_ns1__SetEnergyStat' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetEnergyStat
#define SOAP_TYPE_PointerTo_ns1__SetEnergyStat (561)
#endif

/* _ns1__getInfoByMo * has binding name 'PointerTo_ns1__getInfoByMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getInfoByMo
#define SOAP_TYPE_PointerTo_ns1__getInfoByMo (557)
#endif

/* _ns1__InsThermalNew * has binding name 'PointerTo_ns1__InsThermalNew' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsThermalNew
#define SOAP_TYPE_PointerTo_ns1__InsThermalNew (553)
#endif

/* _ns1__ChkSnLink * has binding name 'PointerTo_ns1__ChkSnLink' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChkSnLink
#define SOAP_TYPE_PointerTo_ns1__ChkSnLink (549)
#endif

/* _ns1__InsThermal * has binding name 'PointerTo_ns1__InsThermal' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsThermal
#define SOAP_TYPE_PointerTo_ns1__InsThermal (545)
#endif

/* _ns1__InsWHDetection * has binding name 'PointerTo_ns1__InsWHDetection' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsWHDetection
#define SOAP_TYPE_PointerTo_ns1__InsWHDetection (541)
#endif

/* _ns1__InsFlatNessForCL * has binding name 'PointerTo_ns1__InsFlatNessForCL' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsFlatNessForCL
#define SOAP_TYPE_PointerTo_ns1__InsFlatNessForCL (537)
#endif

/* _ns1__InsFlatNessForLSD * has binding name 'PointerTo_ns1__InsFlatNessForLSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsFlatNessForLSD
#define SOAP_TYPE_PointerTo_ns1__InsFlatNessForLSD (533)
#endif

/* _ns1__InsFlatNess * has binding name 'PointerTo_ns1__InsFlatNess' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsFlatNess
#define SOAP_TYPE_PointerTo_ns1__InsFlatNess (529)
#endif

/* _ns1__ImpMesAteTestData * has binding name 'PointerTo_ns1__ImpMesAteTestData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ImpMesAteTestData
#define SOAP_TYPE_PointerTo_ns1__ImpMesAteTestData (525)
#endif

/* _ns1__chkStationTime * has binding name 'PointerTo_ns1__chkStationTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkStationTime
#define SOAP_TYPE_PointerTo_ns1__chkStationTime (521)
#endif

/* _ns1__InFruitsOrtQty * has binding name 'PointerTo_ns1__InFruitsOrtQty' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InFruitsOrtQty
#define SOAP_TYPE_PointerTo_ns1__InFruitsOrtQty (517)
#endif

/* _ns1__sendTestResult * has binding name 'PointerTo_ns1__sendTestResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__sendTestResult
#define SOAP_TYPE_PointerTo_ns1__sendTestResult (513)
#endif

/* _ns1__sendTestData * has binding name 'PointerTo_ns1__sendTestData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__sendTestData
#define SOAP_TYPE_PointerTo_ns1__sendTestData (509)
#endif

/* _ns1__checkSN_USCOREStation * has binding name 'PointerTo_ns1__checkSN_USCOREStation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStation
#define SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStation (505)
#endif

/* _ns1__checkEmpNo * has binding name 'PointerTo_ns1__checkEmpNo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkEmpNo
#define SOAP_TYPE_PointerTo_ns1__checkEmpNo (501)
#endif

/* _ns1__checkTestData * has binding name 'PointerTo_ns1__checkTestData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkTestData
#define SOAP_TYPE_PointerTo_ns1__checkTestData (497)
#endif

/* _ns1__InsZjList * has binding name 'PointerTo_ns1__InsZjList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsZjList
#define SOAP_TYPE_PointerTo_ns1__InsZjList (493)
#endif

/* _ns1__GetFruitMachineChk * has binding name 'PointerTo_ns1__GetFruitMachineChk' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetFruitMachineChk
#define SOAP_TYPE_PointerTo_ns1__GetFruitMachineChk (489)
#endif

/* _ns1__InsFruitMachineChk * has binding name 'PointerTo_ns1__InsFruitMachineChk' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsFruitMachineChk
#define SOAP_TYPE_PointerTo_ns1__InsFruitMachineChk (485)
#endif

/* _ns1__SnLnkOutSN * has binding name 'PointerTo_ns1__SnLnkOutSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SnLnkOutSN
#define SOAP_TYPE_PointerTo_ns1__SnLnkOutSN (481)
#endif

/* _ns1__getMoBase * has binding name 'PointerTo_ns1__getMoBase' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getMoBase
#define SOAP_TYPE_PointerTo_ns1__getMoBase (477)
#endif

/* _ns1__GetNgCode * has binding name 'PointerTo_ns1__GetNgCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetNgCode
#define SOAP_TYPE_PointerTo_ns1__GetNgCode (473)
#endif

/* _ns1__SetDiecastSN * has binding name 'PointerTo_ns1__SetDiecastSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDiecastSN
#define SOAP_TYPE_PointerTo_ns1__SetDiecastSN (469)
#endif

/* _ns1__GetMachineForGroup * has binding name 'PointerTo_ns1__GetMachineForGroup' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetMachineForGroup
#define SOAP_TYPE_PointerTo_ns1__GetMachineForGroup (465)
#endif

/* _ns1__UploadForHP * has binding name 'PointerTo_ns1__UploadForHP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UploadForHP
#define SOAP_TYPE_PointerTo_ns1__UploadForHP (461)
#endif

/* _ns1__SelShelfLink * has binding name 'PointerTo_ns1__SelShelfLink' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SelShelfLink
#define SOAP_TYPE_PointerTo_ns1__SelShelfLink (457)
#endif

/* _ns1__SNLinkShelf * has binding name 'PointerTo_ns1__SNLinkShelf' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SNLinkShelf
#define SOAP_TYPE_PointerTo_ns1__SNLinkShelf (453)
#endif

/* _ns1__SelSNTestForFruit * has binding name 'PointerTo_ns1__SelSNTestForFruit' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SelSNTestForFruit
#define SOAP_TYPE_PointerTo_ns1__SelSNTestForFruit (449)
#endif

/* _ns1__InsSNTestForFruit * has binding name 'PointerTo_ns1__InsSNTestForFruit' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsSNTestForFruit
#define SOAP_TYPE_PointerTo_ns1__InsSNTestForFruit (445)
#endif

/* _ns1__GetStationNumberForSN * has binding name 'PointerTo_ns1__GetStationNumberForSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetStationNumberForSN
#define SOAP_TYPE_PointerTo_ns1__GetStationNumberForSN (441)
#endif

/* _ns1__GetTestValueResult * has binding name 'PointerTo_ns1__GetTestValueResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetTestValueResult
#define SOAP_TYPE_PointerTo_ns1__GetTestValueResult (437)
#endif

/* _ns1__InsCLScada * has binding name 'PointerTo_ns1__InsCLScada' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsCLScada
#define SOAP_TYPE_PointerTo_ns1__InsCLScada (433)
#endif

/* _ns1__InsAoiMo * has binding name 'PointerTo_ns1__InsAoiMo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsAoiMo
#define SOAP_TYPE_PointerTo_ns1__InsAoiMo (429)
#endif

/* _ns1__chkMoSNForAOI * has binding name 'PointerTo_ns1__chkMoSNForAOI' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__chkMoSNForAOI
#define SOAP_TYPE_PointerTo_ns1__chkMoSNForAOI (425)
#endif

/* _ns1__PunchOut * has binding name 'PointerTo_ns1__PunchOut' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PunchOut
#define SOAP_TYPE_PointerTo_ns1__PunchOut (421)
#endif

/* _ns1__BasketLinkPunch * has binding name 'PointerTo_ns1__BasketLinkPunch' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BasketLinkPunch
#define SOAP_TYPE_PointerTo_ns1__BasketLinkPunch (417)
#endif

/* _ns1__HPSNLinkBasket * has binding name 'PointerTo_ns1__HPSNLinkBasket' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__HPSNLinkBasket
#define SOAP_TYPE_PointerTo_ns1__HPSNLinkBasket (413)
#endif

/* _ns1__SetAutoLineRec * has binding name 'PointerTo_ns1__SetAutoLineRec' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetAutoLineRec
#define SOAP_TYPE_PointerTo_ns1__SetAutoLineRec (409)
#endif

/* _ns1__GetSNForLink * has binding name 'PointerTo_ns1__GetSNForLink' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSNForLink
#define SOAP_TYPE_PointerTo_ns1__GetSNForLink (405)
#endif

/* _ns1__SetFlatnessFruitRec * has binding name 'PointerTo_ns1__SetFlatnessFruitRec' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec
#define SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec (401)
#endif

/* _ns1__getStationByMoForTestPad * has binding name 'PointerTo_ns1__getStationByMoForTestPad' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getStationByMoForTestPad
#define SOAP_TYPE_PointerTo_ns1__getStationByMoForTestPad (397)
#endif

/* _ns1__GetShippingWeight * has binding name 'PointerTo_ns1__GetShippingWeight' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingWeight
#define SOAP_TYPE_PointerTo_ns1__GetShippingWeight (393)
#endif

/* _ns1__GetShippingForBerth * has binding name 'PointerTo_ns1__GetShippingForBerth' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingForBerth
#define SOAP_TYPE_PointerTo_ns1__GetShippingForBerth (389)
#endif

/* _ns1__InsShippingBerth * has binding name 'PointerTo_ns1__InsShippingBerth' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsShippingBerth
#define SOAP_TYPE_PointerTo_ns1__InsShippingBerth (385)
#endif

/* _ns1__InsShippingPalle * has binding name 'PointerTo_ns1__InsShippingPalle' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsShippingPalle
#define SOAP_TYPE_PointerTo_ns1__InsShippingPalle (381)
#endif

/* _ns1__GetShippingPalle * has binding name 'PointerTo_ns1__GetShippingPalle' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingPalle
#define SOAP_TYPE_PointerTo_ns1__GetShippingPalle (377)
#endif

/* _ns1__UpdShipping * has binding name 'PointerTo_ns1__UpdShipping' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdShipping
#define SOAP_TYPE_PointerTo_ns1__UpdShipping (373)
#endif

/* _ns1__GetShippingBerthList * has binding name 'PointerTo_ns1__GetShippingBerthList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingBerthList
#define SOAP_TYPE_PointerTo_ns1__GetShippingBerthList (369)
#endif

/* _ns1__GetShippingList * has binding name 'PointerTo_ns1__GetShippingList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingList
#define SOAP_TYPE_PointerTo_ns1__GetShippingList (365)
#endif

/* _ns1__doLotLinkForApple * has binding name 'PointerTo_ns1__doLotLinkForApple' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doLotLinkForApple
#define SOAP_TYPE_PointerTo_ns1__doLotLinkForApple (361)
#endif

/* _ns1__GetLotLinkCount * has binding name 'PointerTo_ns1__GetLotLinkCount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLotLinkCount
#define SOAP_TYPE_PointerTo_ns1__GetLotLinkCount (357)
#endif

/* _ns1__GetFruitSNCheck * has binding name 'PointerTo_ns1__GetFruitSNCheck' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetFruitSNCheck
#define SOAP_TYPE_PointerTo_ns1__GetFruitSNCheck (353)
#endif

/* _ns1__GetObeNW * has binding name 'PointerTo_ns1__GetObeNW' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetObeNW
#define SOAP_TYPE_PointerTo_ns1__GetObeNW (349)
#endif

/* _ns1__doSnLinkForApple * has binding name 'PointerTo_ns1__doSnLinkForApple' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doSnLinkForApple
#define SOAP_TYPE_PointerTo_ns1__doSnLinkForApple (345)
#endif

/* _ns1__ChkSnLinkForApple * has binding name 'PointerTo_ns1__ChkSnLinkForApple' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChkSnLinkForApple
#define SOAP_TYPE_PointerTo_ns1__ChkSnLinkForApple (341)
#endif

/* _ns1__DelSNTest * has binding name 'PointerTo_ns1__DelSNTest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DelSNTest
#define SOAP_TYPE_PointerTo_ns1__DelSNTest (337)
#endif

/* _ns1__SelSNTest * has binding name 'PointerTo_ns1__SelSNTest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SelSNTest
#define SOAP_TYPE_PointerTo_ns1__SelSNTest (333)
#endif

/* _ns1__InsSNTest * has binding name 'PointerTo_ns1__InsSNTest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsSNTest
#define SOAP_TYPE_PointerTo_ns1__InsSNTest (329)
#endif

/* _ns1__ChkWeightTime * has binding name 'PointerTo_ns1__ChkWeightTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChkWeightTime
#define SOAP_TYPE_PointerTo_ns1__ChkWeightTime (325)
#endif

/* _ns1__UpdAhsBarcode * has binding name 'PointerTo_ns1__UpdAhsBarcode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdAhsBarcode
#define SOAP_TYPE_PointerTo_ns1__UpdAhsBarcode (321)
#endif

/* _ns1__GetAhsBarcode * has binding name 'PointerTo_ns1__GetAhsBarcode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAhsBarcode
#define SOAP_TYPE_PointerTo_ns1__GetAhsBarcode (317)
#endif

/* _ns1__GetAhsMoResponse_GetAhsMoResult * has binding name 'PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult
#define SOAP_TYPE_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult (316)
#endif

/* _ns1__GetPallentToWMSResponse_GetPallentToWMSResult * has binding name 'PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult
#define SOAP_TYPE_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult (314)
#endif

/* _ns1__doLinkOutSN_assyDt * has binding name 'PointerTo_ns1__doLinkOutSN_assyDt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doLinkOutSN_assyDt
#define SOAP_TYPE_PointerTo_ns1__doLinkOutSN_assyDt (312)
#endif

/* _ns1__doPmcSNLink_assyDt * has binding name 'PointerTo_ns1__doPmcSNLink_assyDt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doPmcSNLink_assyDt
#define SOAP_TYPE_PointerTo_ns1__doPmcSNLink_assyDt (310)
#endif

/* _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult * has binding name 'PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult
#define SOAP_TYPE_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult (308)
#endif

/* _ns1__getPmcAssyListResponse_getPmcAssyListResult * has binding name 'PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult
#define SOAP_TYPE_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult (306)
#endif

/* _ns1__doAssy_assyDt * has binding name 'PointerTo_ns1__doAssy_assyDt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doAssy_assyDt
#define SOAP_TYPE_PointerTo_ns1__doAssy_assyDt (304)
#endif

/* _ns1__GetLinkOutSnResponse_GetLinkOutSnResult * has binding name 'PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult
#define SOAP_TYPE_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult (302)
#endif

/* _ns1__getPartBomExtResponse_getPartBomExtResult * has binding name 'PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult
#define SOAP_TYPE_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult (300)
#endif

/* _ns1__getMoAssyListResponse_getMoAssyListResult * has binding name 'PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult
#define SOAP_TYPE_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult (298)
#endif

/* _ns1__getInfoByMoResponse_getInfoByMoResult * has binding name 'PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult
#define SOAP_TYPE_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult (296)
#endif

/* ns1__ArrayOfString * has binding name 'PointerTons1__ArrayOfString' for type 'ns1:ArrayOfString' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfString
#define SOAP_TYPE_PointerTons1__ArrayOfString (294)
#endif

/* _ns1__GetMachineForGroupResponse_GetMachineForGroupResult * has binding name 'PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult
#define SOAP_TYPE_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult (293)
#endif

/* _ns1__SetFlatnessFruitRec_dt * has binding name 'PointerTo_ns1__SetFlatnessFruitRec_dt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec_dt
#define SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec_dt (291)
#endif

/* _ns1__GetShippingWeightResponse_GetShippingWeightResult * has binding name 'PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult
#define SOAP_TYPE_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult (289)
#endif

/* _ns1__GetShippingForBerthResponse_GetShippingForBerthResult * has binding name 'PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult
#define SOAP_TYPE_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult (287)
#endif

/* _ns1__GetShippingBerthListResponse_GetShippingBerthListResult * has binding name 'PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult
#define SOAP_TYPE_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult (285)
#endif

/* _ns1__GetShippingListResponse_GetShippingListResult * has binding name 'PointerTo_ns1__GetShippingListResponse_GetShippingListResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShippingListResponse_GetShippingListResult
#define SOAP_TYPE_PointerTo_ns1__GetShippingListResponse_GetShippingListResult (283)
#endif

/* _ns1__doLotLinkForApple_assyDt * has binding name 'PointerTo_ns1__doLotLinkForApple_assyDt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doLotLinkForApple_assyDt
#define SOAP_TYPE_PointerTo_ns1__doLotLinkForApple_assyDt (281)
#endif

/* _ns1__doSnLinkForApple_assyDt * has binding name 'PointerTo_ns1__doSnLinkForApple_assyDt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__doSnLinkForApple_assyDt
#define SOAP_TYPE_PointerTo_ns1__doSnLinkForApple_assyDt (279)
#endif

/* _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult * has binding name 'PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult
#define SOAP_TYPE_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult (276)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (274)
#endif

/* _xsd__schema has binding name '_xsd__schema' for type '' */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (11)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (278)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (272)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetAhsBarcode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetAhsBarcode *ns1__GetAhsBarcode, _ns1__GetAhsBarcodeResponse &ns1__GetAhsBarcodeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UpdAhsBarcode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdAhsBarcode *ns1__UpdAhsBarcode, _ns1__UpdAhsBarcodeResponse &ns1__UpdAhsBarcodeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkWeightTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkWeightTime *ns1__ChkWeightTime, _ns1__ChkWeightTimeResponse &ns1__ChkWeightTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsSNTest(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsSNTest *ns1__InsSNTest, _ns1__InsSNTestResponse &ns1__InsSNTestResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SelSNTest(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SelSNTest *ns1__SelSNTest, _ns1__SelSNTestResponse &ns1__SelSNTestResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DelSNTest(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DelSNTest *ns1__DelSNTest, _ns1__DelSNTestResponse &ns1__DelSNTestResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnLinkForApple(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnLinkForApple *ns1__ChkSnLinkForApple, _ns1__ChkSnLinkForAppleResponse &ns1__ChkSnLinkForAppleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doSnLinkForApple(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doSnLinkForApple *ns1__doSnLinkForApple, _ns1__doSnLinkForAppleResponse &ns1__doSnLinkForAppleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetObeNW(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetObeNW *ns1__GetObeNW, _ns1__GetObeNWResponse &ns1__GetObeNWResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFruitSNCheck(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFruitSNCheck *ns1__GetFruitSNCheck, _ns1__GetFruitSNCheckResponse &ns1__GetFruitSNCheckResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLotLinkCount(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLotLinkCount *ns1__GetLotLinkCount, _ns1__GetLotLinkCountResponse &ns1__GetLotLinkCountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doLotLinkForApple(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doLotLinkForApple *ns1__doLotLinkForApple, _ns1__doLotLinkForAppleResponse &ns1__doLotLinkForAppleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingList *ns1__GetShippingList, _ns1__GetShippingListResponse &ns1__GetShippingListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingBerthList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingBerthList *ns1__GetShippingBerthList, _ns1__GetShippingBerthListResponse &ns1__GetShippingBerthListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UpdShipping(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdShipping *ns1__UpdShipping, _ns1__UpdShippingResponse &ns1__UpdShippingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingPalle(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingPalle *ns1__GetShippingPalle, _ns1__GetShippingPalleResponse &ns1__GetShippingPalleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsShippingPalle(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsShippingPalle *ns1__InsShippingPalle, _ns1__InsShippingPalleResponse &ns1__InsShippingPalleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsShippingBerth(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsShippingBerth *ns1__InsShippingBerth, _ns1__InsShippingBerthResponse &ns1__InsShippingBerthResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingForBerth(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingForBerth *ns1__GetShippingForBerth, _ns1__GetShippingForBerthResponse &ns1__GetShippingForBerthResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingWeight(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingWeight *ns1__GetShippingWeight, _ns1__GetShippingWeightResponse &ns1__GetShippingWeightResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getStationByMoForTestPad(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getStationByMoForTestPad *ns1__getStationByMoForTestPad, _ns1__getStationByMoForTestPadResponse &ns1__getStationByMoForTestPadResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetFlatnessFruitRec(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetFlatnessFruitRec *ns1__SetFlatnessFruitRec, _ns1__SetFlatnessFruitRecResponse &ns1__SetFlatnessFruitRecResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSNForLink(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSNForLink *ns1__GetSNForLink, _ns1__GetSNForLinkResponse &ns1__GetSNForLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetAutoLineRec(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetAutoLineRec *ns1__SetAutoLineRec, _ns1__SetAutoLineRecResponse &ns1__SetAutoLineRecResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__HPSNLinkBasket(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__HPSNLinkBasket *ns1__HPSNLinkBasket, _ns1__HPSNLinkBasketResponse &ns1__HPSNLinkBasketResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__BasketLinkPunch(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__BasketLinkPunch *ns1__BasketLinkPunch, _ns1__BasketLinkPunchResponse &ns1__BasketLinkPunchResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__PunchOut(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__PunchOut *ns1__PunchOut, _ns1__PunchOutResponse &ns1__PunchOutResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkMoSNForAOI(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkMoSNForAOI *ns1__chkMoSNForAOI, _ns1__chkMoSNForAOIResponse &ns1__chkMoSNForAOIResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsAoiMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsAoiMo *ns1__InsAoiMo, _ns1__InsAoiMoResponse &ns1__InsAoiMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsCLScada(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsCLScada *ns1__InsCLScada, _ns1__InsCLScadaResponse &ns1__InsCLScadaResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTestValueResult(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTestValueResult *ns1__GetTestValueResult, _ns1__GetTestValueResultResponse &ns1__GetTestValueResultResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetStationNumberForSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetStationNumberForSN *ns1__GetStationNumberForSN, _ns1__GetStationNumberForSNResponse &ns1__GetStationNumberForSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsSNTestForFruit(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsSNTestForFruit *ns1__InsSNTestForFruit, _ns1__InsSNTestForFruitResponse &ns1__InsSNTestForFruitResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SelSNTestForFruit(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SelSNTestForFruit *ns1__SelSNTestForFruit, _ns1__SelSNTestForFruitResponse &ns1__SelSNTestForFruitResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SNLinkShelf(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SNLinkShelf *ns1__SNLinkShelf, _ns1__SNLinkShelfResponse &ns1__SNLinkShelfResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SelShelfLink(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SelShelfLink *ns1__SelShelfLink, _ns1__SelShelfLinkResponse &ns1__SelShelfLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UploadForHP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UploadForHP *ns1__UploadForHP, _ns1__UploadForHPResponse &ns1__UploadForHPResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetMachineForGroup(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetMachineForGroup *ns1__GetMachineForGroup, _ns1__GetMachineForGroupResponse &ns1__GetMachineForGroupResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetDiecastSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetDiecastSN *ns1__SetDiecastSN, _ns1__SetDiecastSNResponse &ns1__SetDiecastSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetNgCode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetNgCode *ns1__GetNgCode, _ns1__GetNgCodeResponse &ns1__GetNgCodeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMoBase(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMoBase *ns1__getMoBase, _ns1__getMoBaseResponse &ns1__getMoBaseResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SnLnkOutSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SnLnkOutSN *ns1__SnLnkOutSN, _ns1__SnLnkOutSNResponse &ns1__SnLnkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFruitMachineChk(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFruitMachineChk *ns1__InsFruitMachineChk, _ns1__InsFruitMachineChkResponse &ns1__InsFruitMachineChkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFruitMachineChk(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFruitMachineChk *ns1__GetFruitMachineChk, _ns1__GetFruitMachineChkResponse &ns1__GetFruitMachineChkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsZjList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsZjList *ns1__InsZjList, _ns1__InsZjListResponse &ns1__InsZjListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkTestData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkTestData *ns1__checkTestData, _ns1__checkTestDataResponse &ns1__checkTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkEmpNo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkEmpNo *ns1__checkEmpNo, _ns1__checkEmpNoResponse &ns1__checkEmpNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkSN_USCOREStation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkSN_USCOREStation *ns1__checkSN_USCOREStation, _ns1__checkSN_USCOREStationResponse &ns1__checkSN_USCOREStationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendTestData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendTestData *ns1__sendTestData, _ns1__sendTestDataResponse &ns1__sendTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendTestResult(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendTestResult *ns1__sendTestResult, _ns1__sendTestResultResponse &ns1__sendTestResultResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InFruitsOrtQty(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InFruitsOrtQty *ns1__InFruitsOrtQty, _ns1__InFruitsOrtQtyResponse &ns1__InFruitsOrtQtyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkStationTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkStationTime *ns1__chkStationTime, _ns1__chkStationTimeResponse &ns1__chkStationTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ImpMesAteTestData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ImpMesAteTestData *ns1__ImpMesAteTestData, _ns1__ImpMesAteTestDataResponse &ns1__ImpMesAteTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFlatNess(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFlatNess *ns1__InsFlatNess, _ns1__InsFlatNessResponse &ns1__InsFlatNessResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFlatNessForLSD(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFlatNessForLSD *ns1__InsFlatNessForLSD, _ns1__InsFlatNessForLSDResponse &ns1__InsFlatNessForLSDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFlatNessForCL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFlatNessForCL *ns1__InsFlatNessForCL, _ns1__InsFlatNessForCLResponse &ns1__InsFlatNessForCLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsWHDetection(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsWHDetection *ns1__InsWHDetection, _ns1__InsWHDetectionResponse &ns1__InsWHDetectionResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsThermal(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsThermal *ns1__InsThermal, _ns1__InsThermalResponse &ns1__InsThermalResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnLink(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnLink *ns1__ChkSnLink, _ns1__ChkSnLinkResponse &ns1__ChkSnLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsThermalNew(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsThermalNew *ns1__InsThermalNew, _ns1__InsThermalNewResponse &ns1__InsThermalNewResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getInfoByMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getInfoByMo *ns1__getInfoByMo, _ns1__getInfoByMoResponse &ns1__getInfoByMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetEnergyStat(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetEnergyStat *ns1__SetEnergyStat, _ns1__SetEnergyStatResponse &ns1__SetEnergyStatResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkMoStation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkMoStation *ns1__chkMoStation, _ns1__chkMoStationResponse &ns1__chkMoStationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnMo *ns1__ChkSnMo, _ns1__ChkSnMoResponse &ns1__ChkSnMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnNextMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnNextMo *ns1__ChkSnNextMo, _ns1__ChkSnNextMoResponse &ns1__ChkSnNextMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkSN_USCOREStationNumber *ns1__checkSN_USCOREStationNumber, _ns1__checkSN_USCOREStationNumberResponse &ns1__checkSN_USCOREStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkEmpForStationNumber(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkEmpForStationNumber *ns1__checkEmpForStationNumber, _ns1__checkEmpForStationNumberResponse &ns1__checkEmpForStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendDataForStationNumber(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendDataForStationNumber *ns1__sendDataForStationNumber, _ns1__sendDataForStationNumberResponse &ns1__sendDataForStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendResultForStationNumber(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendResultForStationNumber *ns1__sendResultForStationNumber, _ns1__sendResultForStationNumberResponse &ns1__sendResultForStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__eMesNextMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__eMesNextMo *ns1__eMesNextMo, _ns1__eMesNextMoResponse &ns1__eMesNextMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SnDoMapping(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SnDoMapping *ns1__SnDoMapping, _ns1__SnDoMappingResponse &ns1__SnDoMappingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getStationByMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getStationByMo *ns1__getStationByMo, _ns1__getStationByMoResponse &ns1__getStationByMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getStationTypeDesc(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getStationTypeDesc *ns1__getStationTypeDesc, _ns1__getStationTypeDescResponse &ns1__getStationTypeDescResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkSnMapping(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkSnMapping *ns1__chkSnMapping, _ns1__chkSnMappingResponse &ns1__chkSnMappingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMoAssyList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMoAssyList *ns1__getMoAssyList, _ns1__getMoAssyListResponse &ns1__getMoAssyListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPartBomExt(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPartBomExt *ns1__getPartBomExt, _ns1__getPartBomExtResponse &ns1__getPartBomExtResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsPartAssy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsPartAssy *ns1__InsPartAssy, _ns1__InsPartAssyResponse &ns1__InsPartAssyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLinkOutSn(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLinkOutSn *ns1__GetLinkOutSn, _ns1__GetLinkOutSnResponse &ns1__GetLinkOutSnResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMoAssyCount(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMoAssyCount *ns1__getMoAssyCount, _ns1__getMoAssyCountResponse &ns1__getMoAssyCountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPNbySN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPNbySN *ns1__getPNbySN, _ns1__getPNbySNResponse &ns1__getPNbySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkAssySN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkAssySN *ns1__chkAssySN, _ns1__chkAssySNResponse &ns1__chkAssySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doAssy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doAssy *ns1__doAssy, _ns1__doAssyResponse &ns1__doAssyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPmcAssyList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPmcAssyList *ns1__getPmcAssyList, _ns1__getPmcAssyListResponse &ns1__getPmcAssyListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPmcPartAssyList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPmcPartAssyList *ns1__getPmcPartAssyList, _ns1__getPmcPartAssyListResponse &ns1__getPmcPartAssyListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPmcSNPart(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPmcSNPart *ns1__GetPmcSNPart, _ns1__GetPmcSNPartResponse &ns1__GetPmcSNPartResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doPmcSNLink(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doPmcSNLink *ns1__doPmcSNLink, _ns1__doPmcSNLinkResponse &ns1__doPmcSNLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsZJTestData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsZJTestData *ns1__InsZJTestData, _ns1__InsZJTestDataResponse &ns1__InsZJTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SNLinkZJ(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SNLinkZJ *ns1__SNLinkZJ, _ns1__SNLinkZJResponse &ns1__SNLinkZJResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLintOutQty(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLintOutQty *ns1__GetLintOutQty, _ns1__GetLintOutQtyResponse &ns1__GetLintOutQtyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkOutSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkOutSN *ns1__chkOutSN, _ns1__chkOutSNResponse &ns1__chkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkLinkOutSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkLinkOutSN *ns1__ChkLinkOutSN, _ns1__ChkLinkOutSNResponse &ns1__ChkLinkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doLinkOutSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doLinkOutSN *ns1__doLinkOutSN, _ns1__doLinkOutSNResponse &ns1__doLinkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsLinkSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsLinkSN *ns1__InsLinkSN, _ns1__InsLinkSNResponse &ns1__InsLinkSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLinkZJCount(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLinkZJCount *ns1__GetLinkZJCount, _ns1__GetLinkZJCountResponse &ns1__GetLinkZJCountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsBoxNOTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsBoxNOTime *ns1__InsBoxNOTime, _ns1__InsBoxNOTimeResponse &ns1__InsBoxNOTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkBoxNo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkBoxNo *ns1__chkBoxNo, _ns1__chkBoxNoResponse &ns1__chkBoxNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InSNtoBox(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InSNtoBox *ns1__InSNtoBox, _ns1__InSNtoBoxResponse &ns1__InSNtoBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__EndSNtoBox(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__EndSNtoBox *ns1__EndSNtoBox, _ns1__EndSNtoBoxResponse &ns1__EndSNtoBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InStationbyBox(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InStationbyBox *ns1__InStationbyBox, _ns1__InStationbyBoxResponse &ns1__InStationbyBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__OutStationbyBox(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__OutStationbyBox *ns1__OutStationbyBox, _ns1__OutStationbyBoxResponse &ns1__OutStationbyBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CancelBoxLnk(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelBoxLnk *ns1__CancelBoxLnk, _ns1__CancelBoxLnkResponse &ns1__CancelBoxLnkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsSNStationEmp(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsSNStationEmp *ns1__InsSNStationEmp, _ns1__InsSNStationEmpResponse &ns1__InsSNStationEmpResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsLnkOutSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsLnkOutSN *ns1__InsLnkOutSN, _ns1__InsLnkOutSNResponse &ns1__InsLnkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsBoxInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsBoxInfo *ns1__InsBoxInfo, _ns1__InsBoxInfoResponse &ns1__InsBoxInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UpdSnRecInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdSnRecInfo *ns1__UpdSnRecInfo, _ns1__UpdSnRecInfoResponse &ns1__UpdSnRecInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetMoBase(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetMoBase *ns1__GetMoBase, _ns1__GetMoBaseResponse &ns1__GetMoBaseResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTestValue(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTestValue *ns1__GetTestValue, _ns1__GetTestValueResponse &ns1__GetTestValueResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLnkData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLnkData *ns1__GetLnkData, _ns1__GetLnkDataResponse &ns1__GetLnkDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsIotMachineRec(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsIotMachineRec *ns1__InsIotMachineRec, _ns1__InsIotMachineRecResponse &ns1__InsIotMachineRecResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsIotTestData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsIotTestData *ns1__InsIotTestData, _ns1__InsIotTestDataResponse &ns1__InsIotTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkDispensing(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkDispensing *ns1__chkDispensing, _ns1__chkDispensingResponse &ns1__chkDispensingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkZJSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkZJSN *ns1__chkZJSN, _ns1__chkZJSNResponse &ns1__chkZJSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LnkZJSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LnkZJSN *ns1__LnkZJSN, _ns1__LnkZJSNResponse &ns1__LnkZJSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LnkSideSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LnkSideSN *ns1__LnkSideSN, _ns1__LnkSideSNResponse &ns1__LnkSideSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkGrillSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkGrillSN *ns1__chkGrillSN, _ns1__chkGrillSNResponse &ns1__chkGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LnkGrillSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LnkGrillSN *ns1__LnkGrillSN, _ns1__LnkGrillSNResponse &ns1__LnkGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CloseGrillSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CloseGrillSN *ns1__CloseGrillSN, _ns1__CloseGrillSNResponse &ns1__CloseGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsGrillBySN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsGrillBySN *ns1__InsGrillBySN, _ns1__InsGrillBySNResponse &ns1__InsGrillBySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetGrillTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetGrillTime *ns1__GetGrillTime, _ns1__GetGrillTimeResponse &ns1__GetGrillTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__OutGrillBySN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__OutGrillBySN *ns1__OutGrillBySN, _ns1__OutGrillBySNResponse &ns1__OutGrillBySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CancelGrillSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelGrillSN *ns1__CancelGrillSN, _ns1__CancelGrillSNResponse &ns1__CancelGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CancelLnkSN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelLnkSN *ns1__CancelLnkSN, _ns1__CancelLnkSNResponse &ns1__CancelLnkSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetWeightSet(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetWeightSet *ns1__GetWeightSet, _ns1__GetWeightSetResponse &ns1__GetWeightSetResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPackToWMS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPackToWMS *ns1__GetPackToWMS, _ns1__GetPackToWMSResponse &ns1__GetPackToWMSResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPallentToWMS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPallentToWMS *ns1__GetPallentToWMS, _ns1__GetPallentToWMSResponse &ns1__GetPallentToWMSResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetPallentForWMS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetPallentForWMS *ns1__SetPallentForWMS, _ns1__SetPallentForWMSResponse &ns1__SetPallentForWMSResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPackStation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPackStation *ns1__GetPackStation, _ns1__GetPackStationResponse &ns1__GetPackStationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPackWeigth(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPackWeigth *ns1__GetPackWeigth, _ns1__GetPackWeigthResponse &ns1__GetPackWeigthResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetAhsMo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetAhsMo *ns1__GetAhsMo, _ns1__GetAhsMoResponse &ns1__GetAhsMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetAhsBarcode_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetAhsBarcode *ns1__GetAhsBarcode, _ns1__GetAhsBarcodeResponse &ns1__GetAhsBarcodeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UpdAhsBarcode_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdAhsBarcode *ns1__UpdAhsBarcode, _ns1__UpdAhsBarcodeResponse &ns1__UpdAhsBarcodeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkWeightTime_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkWeightTime *ns1__ChkWeightTime, _ns1__ChkWeightTimeResponse &ns1__ChkWeightTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsSNTest_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsSNTest *ns1__InsSNTest, _ns1__InsSNTestResponse &ns1__InsSNTestResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SelSNTest_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SelSNTest *ns1__SelSNTest, _ns1__SelSNTestResponse &ns1__SelSNTestResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DelSNTest_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DelSNTest *ns1__DelSNTest, _ns1__DelSNTestResponse &ns1__DelSNTestResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnLinkForApple_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnLinkForApple *ns1__ChkSnLinkForApple, _ns1__ChkSnLinkForAppleResponse &ns1__ChkSnLinkForAppleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doSnLinkForApple_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doSnLinkForApple *ns1__doSnLinkForApple, _ns1__doSnLinkForAppleResponse &ns1__doSnLinkForAppleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetObeNW_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetObeNW *ns1__GetObeNW, _ns1__GetObeNWResponse &ns1__GetObeNWResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFruitSNCheck_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFruitSNCheck *ns1__GetFruitSNCheck, _ns1__GetFruitSNCheckResponse &ns1__GetFruitSNCheckResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLotLinkCount_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLotLinkCount *ns1__GetLotLinkCount, _ns1__GetLotLinkCountResponse &ns1__GetLotLinkCountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doLotLinkForApple_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doLotLinkForApple *ns1__doLotLinkForApple, _ns1__doLotLinkForAppleResponse &ns1__doLotLinkForAppleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingList_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingList *ns1__GetShippingList, _ns1__GetShippingListResponse &ns1__GetShippingListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingBerthList_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingBerthList *ns1__GetShippingBerthList, _ns1__GetShippingBerthListResponse &ns1__GetShippingBerthListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UpdShipping_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdShipping *ns1__UpdShipping, _ns1__UpdShippingResponse &ns1__UpdShippingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingPalle_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingPalle *ns1__GetShippingPalle, _ns1__GetShippingPalleResponse &ns1__GetShippingPalleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsShippingPalle_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsShippingPalle *ns1__InsShippingPalle, _ns1__InsShippingPalleResponse &ns1__InsShippingPalleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsShippingBerth_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsShippingBerth *ns1__InsShippingBerth, _ns1__InsShippingBerthResponse &ns1__InsShippingBerthResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingForBerth_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingForBerth *ns1__GetShippingForBerth, _ns1__GetShippingForBerthResponse &ns1__GetShippingForBerthResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetShippingWeight_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetShippingWeight *ns1__GetShippingWeight, _ns1__GetShippingWeightResponse &ns1__GetShippingWeightResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getStationByMoForTestPad_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getStationByMoForTestPad *ns1__getStationByMoForTestPad, _ns1__getStationByMoForTestPadResponse &ns1__getStationByMoForTestPadResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetFlatnessFruitRec_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetFlatnessFruitRec *ns1__SetFlatnessFruitRec, _ns1__SetFlatnessFruitRecResponse &ns1__SetFlatnessFruitRecResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSNForLink_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSNForLink *ns1__GetSNForLink, _ns1__GetSNForLinkResponse &ns1__GetSNForLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetAutoLineRec_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetAutoLineRec *ns1__SetAutoLineRec, _ns1__SetAutoLineRecResponse &ns1__SetAutoLineRecResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__HPSNLinkBasket_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__HPSNLinkBasket *ns1__HPSNLinkBasket, _ns1__HPSNLinkBasketResponse &ns1__HPSNLinkBasketResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__BasketLinkPunch_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__BasketLinkPunch *ns1__BasketLinkPunch, _ns1__BasketLinkPunchResponse &ns1__BasketLinkPunchResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__PunchOut_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__PunchOut *ns1__PunchOut, _ns1__PunchOutResponse &ns1__PunchOutResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkMoSNForAOI_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkMoSNForAOI *ns1__chkMoSNForAOI, _ns1__chkMoSNForAOIResponse &ns1__chkMoSNForAOIResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsAoiMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsAoiMo *ns1__InsAoiMo, _ns1__InsAoiMoResponse &ns1__InsAoiMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsCLScada_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsCLScada *ns1__InsCLScada, _ns1__InsCLScadaResponse &ns1__InsCLScadaResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTestValueResult_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTestValueResult *ns1__GetTestValueResult, _ns1__GetTestValueResultResponse &ns1__GetTestValueResultResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetStationNumberForSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetStationNumberForSN *ns1__GetStationNumberForSN, _ns1__GetStationNumberForSNResponse &ns1__GetStationNumberForSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsSNTestForFruit_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsSNTestForFruit *ns1__InsSNTestForFruit, _ns1__InsSNTestForFruitResponse &ns1__InsSNTestForFruitResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SelSNTestForFruit_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SelSNTestForFruit *ns1__SelSNTestForFruit, _ns1__SelSNTestForFruitResponse &ns1__SelSNTestForFruitResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SNLinkShelf_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SNLinkShelf *ns1__SNLinkShelf, _ns1__SNLinkShelfResponse &ns1__SNLinkShelfResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SelShelfLink_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SelShelfLink *ns1__SelShelfLink, _ns1__SelShelfLinkResponse &ns1__SelShelfLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UploadForHP_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UploadForHP *ns1__UploadForHP, _ns1__UploadForHPResponse &ns1__UploadForHPResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetMachineForGroup_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetMachineForGroup *ns1__GetMachineForGroup, _ns1__GetMachineForGroupResponse &ns1__GetMachineForGroupResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetDiecastSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetDiecastSN *ns1__SetDiecastSN, _ns1__SetDiecastSNResponse &ns1__SetDiecastSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetNgCode_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetNgCode *ns1__GetNgCode, _ns1__GetNgCodeResponse &ns1__GetNgCodeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMoBase_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMoBase *ns1__getMoBase, _ns1__getMoBaseResponse &ns1__getMoBaseResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SnLnkOutSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SnLnkOutSN *ns1__SnLnkOutSN, _ns1__SnLnkOutSNResponse &ns1__SnLnkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFruitMachineChk_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFruitMachineChk *ns1__InsFruitMachineChk, _ns1__InsFruitMachineChkResponse &ns1__InsFruitMachineChkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFruitMachineChk_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFruitMachineChk *ns1__GetFruitMachineChk, _ns1__GetFruitMachineChkResponse &ns1__GetFruitMachineChkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsZjList_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsZjList *ns1__InsZjList, _ns1__InsZjListResponse &ns1__InsZjListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkTestData_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkTestData *ns1__checkTestData, _ns1__checkTestDataResponse &ns1__checkTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkEmpNo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkEmpNo *ns1__checkEmpNo, _ns1__checkEmpNoResponse &ns1__checkEmpNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkSN_USCOREStation_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkSN_USCOREStation *ns1__checkSN_USCOREStation, _ns1__checkSN_USCOREStationResponse &ns1__checkSN_USCOREStationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendTestData_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendTestData *ns1__sendTestData, _ns1__sendTestDataResponse &ns1__sendTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendTestResult_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendTestResult *ns1__sendTestResult, _ns1__sendTestResultResponse &ns1__sendTestResultResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InFruitsOrtQty_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InFruitsOrtQty *ns1__InFruitsOrtQty, _ns1__InFruitsOrtQtyResponse &ns1__InFruitsOrtQtyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkStationTime_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkStationTime *ns1__chkStationTime, _ns1__chkStationTimeResponse &ns1__chkStationTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ImpMesAteTestData_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ImpMesAteTestData *ns1__ImpMesAteTestData, _ns1__ImpMesAteTestDataResponse &ns1__ImpMesAteTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFlatNess_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFlatNess *ns1__InsFlatNess, _ns1__InsFlatNessResponse &ns1__InsFlatNessResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFlatNessForLSD_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFlatNessForLSD *ns1__InsFlatNessForLSD, _ns1__InsFlatNessForLSDResponse &ns1__InsFlatNessForLSDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsFlatNessForCL_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsFlatNessForCL *ns1__InsFlatNessForCL, _ns1__InsFlatNessForCLResponse &ns1__InsFlatNessForCLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsWHDetection_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsWHDetection *ns1__InsWHDetection, _ns1__InsWHDetectionResponse &ns1__InsWHDetectionResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsThermal_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsThermal *ns1__InsThermal, _ns1__InsThermalResponse &ns1__InsThermalResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnLink_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnLink *ns1__ChkSnLink, _ns1__ChkSnLinkResponse &ns1__ChkSnLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsThermalNew_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsThermalNew *ns1__InsThermalNew, _ns1__InsThermalNewResponse &ns1__InsThermalNewResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getInfoByMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getInfoByMo *ns1__getInfoByMo, _ns1__getInfoByMoResponse &ns1__getInfoByMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetEnergyStat_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetEnergyStat *ns1__SetEnergyStat, _ns1__SetEnergyStatResponse &ns1__SetEnergyStatResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkMoStation_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkMoStation *ns1__chkMoStation, _ns1__chkMoStationResponse &ns1__chkMoStationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnMo *ns1__ChkSnMo, _ns1__ChkSnMoResponse &ns1__ChkSnMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkSnNextMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkSnNextMo *ns1__ChkSnNextMo, _ns1__ChkSnNextMoResponse &ns1__ChkSnNextMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkSN_USCOREStationNumber_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkSN_USCOREStationNumber *ns1__checkSN_USCOREStationNumber, _ns1__checkSN_USCOREStationNumberResponse &ns1__checkSN_USCOREStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkEmpForStationNumber_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkEmpForStationNumber *ns1__checkEmpForStationNumber, _ns1__checkEmpForStationNumberResponse &ns1__checkEmpForStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendDataForStationNumber_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendDataForStationNumber *ns1__sendDataForStationNumber, _ns1__sendDataForStationNumberResponse &ns1__sendDataForStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendResultForStationNumber_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__sendResultForStationNumber *ns1__sendResultForStationNumber, _ns1__sendResultForStationNumberResponse &ns1__sendResultForStationNumberResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__eMesNextMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__eMesNextMo *ns1__eMesNextMo, _ns1__eMesNextMoResponse &ns1__eMesNextMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SnDoMapping_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SnDoMapping *ns1__SnDoMapping, _ns1__SnDoMappingResponse &ns1__SnDoMappingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getStationByMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getStationByMo *ns1__getStationByMo, _ns1__getStationByMoResponse &ns1__getStationByMoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getStationTypeDesc_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getStationTypeDesc *ns1__getStationTypeDesc, _ns1__getStationTypeDescResponse &ns1__getStationTypeDescResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkSnMapping_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkSnMapping *ns1__chkSnMapping, _ns1__chkSnMappingResponse &ns1__chkSnMappingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMoAssyList_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMoAssyList *ns1__getMoAssyList, _ns1__getMoAssyListResponse &ns1__getMoAssyListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPartBomExt_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPartBomExt *ns1__getPartBomExt, _ns1__getPartBomExtResponse &ns1__getPartBomExtResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsPartAssy_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsPartAssy *ns1__InsPartAssy, _ns1__InsPartAssyResponse &ns1__InsPartAssyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLinkOutSn_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLinkOutSn *ns1__GetLinkOutSn, _ns1__GetLinkOutSnResponse &ns1__GetLinkOutSnResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMoAssyCount_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMoAssyCount *ns1__getMoAssyCount, _ns1__getMoAssyCountResponse &ns1__getMoAssyCountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPNbySN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPNbySN *ns1__getPNbySN, _ns1__getPNbySNResponse &ns1__getPNbySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkAssySN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkAssySN *ns1__chkAssySN, _ns1__chkAssySNResponse &ns1__chkAssySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doAssy_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doAssy *ns1__doAssy, _ns1__doAssyResponse &ns1__doAssyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPmcAssyList_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPmcAssyList *ns1__getPmcAssyList, _ns1__getPmcAssyListResponse &ns1__getPmcAssyListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPmcPartAssyList_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getPmcPartAssyList *ns1__getPmcPartAssyList, _ns1__getPmcPartAssyListResponse &ns1__getPmcPartAssyListResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPmcSNPart_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPmcSNPart *ns1__GetPmcSNPart, _ns1__GetPmcSNPartResponse &ns1__GetPmcSNPartResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doPmcSNLink_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doPmcSNLink *ns1__doPmcSNLink, _ns1__doPmcSNLinkResponse &ns1__doPmcSNLinkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsZJTestData_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsZJTestData *ns1__InsZJTestData, _ns1__InsZJTestDataResponse &ns1__InsZJTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SNLinkZJ_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SNLinkZJ *ns1__SNLinkZJ, _ns1__SNLinkZJResponse &ns1__SNLinkZJResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLintOutQty_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLintOutQty *ns1__GetLintOutQty, _ns1__GetLintOutQtyResponse &ns1__GetLintOutQtyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkOutSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkOutSN *ns1__chkOutSN, _ns1__chkOutSNResponse &ns1__chkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ChkLinkOutSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ChkLinkOutSN *ns1__ChkLinkOutSN, _ns1__ChkLinkOutSNResponse &ns1__ChkLinkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doLinkOutSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__doLinkOutSN *ns1__doLinkOutSN, _ns1__doLinkOutSNResponse &ns1__doLinkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsLinkSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsLinkSN *ns1__InsLinkSN, _ns1__InsLinkSNResponse &ns1__InsLinkSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLinkZJCount_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLinkZJCount *ns1__GetLinkZJCount, _ns1__GetLinkZJCountResponse &ns1__GetLinkZJCountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsBoxNOTime_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsBoxNOTime *ns1__InsBoxNOTime, _ns1__InsBoxNOTimeResponse &ns1__InsBoxNOTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkBoxNo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkBoxNo *ns1__chkBoxNo, _ns1__chkBoxNoResponse &ns1__chkBoxNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InSNtoBox_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InSNtoBox *ns1__InSNtoBox, _ns1__InSNtoBoxResponse &ns1__InSNtoBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__EndSNtoBox_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__EndSNtoBox *ns1__EndSNtoBox, _ns1__EndSNtoBoxResponse &ns1__EndSNtoBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InStationbyBox_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InStationbyBox *ns1__InStationbyBox, _ns1__InStationbyBoxResponse &ns1__InStationbyBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__OutStationbyBox_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__OutStationbyBox *ns1__OutStationbyBox, _ns1__OutStationbyBoxResponse &ns1__OutStationbyBoxResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CancelBoxLnk_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelBoxLnk *ns1__CancelBoxLnk, _ns1__CancelBoxLnkResponse &ns1__CancelBoxLnkResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsSNStationEmp_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsSNStationEmp *ns1__InsSNStationEmp, _ns1__InsSNStationEmpResponse &ns1__InsSNStationEmpResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsLnkOutSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsLnkOutSN *ns1__InsLnkOutSN, _ns1__InsLnkOutSNResponse &ns1__InsLnkOutSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsBoxInfo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsBoxInfo *ns1__InsBoxInfo, _ns1__InsBoxInfoResponse &ns1__InsBoxInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UpdSnRecInfo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdSnRecInfo *ns1__UpdSnRecInfo, _ns1__UpdSnRecInfoResponse &ns1__UpdSnRecInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetMoBase_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetMoBase *ns1__GetMoBase, _ns1__GetMoBaseResponse &ns1__GetMoBaseResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTestValue_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTestValue *ns1__GetTestValue, _ns1__GetTestValueResponse &ns1__GetTestValueResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetLnkData_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLnkData *ns1__GetLnkData, _ns1__GetLnkDataResponse &ns1__GetLnkDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsIotMachineRec_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsIotMachineRec *ns1__InsIotMachineRec, _ns1__InsIotMachineRecResponse &ns1__InsIotMachineRecResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsIotTestData_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsIotTestData *ns1__InsIotTestData, _ns1__InsIotTestDataResponse &ns1__InsIotTestDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkDispensing_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkDispensing *ns1__chkDispensing, _ns1__chkDispensingResponse &ns1__chkDispensingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkZJSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkZJSN *ns1__chkZJSN, _ns1__chkZJSNResponse &ns1__chkZJSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LnkZJSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LnkZJSN *ns1__LnkZJSN, _ns1__LnkZJSNResponse &ns1__LnkZJSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LnkSideSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LnkSideSN *ns1__LnkSideSN, _ns1__LnkSideSNResponse &ns1__LnkSideSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__chkGrillSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__chkGrillSN *ns1__chkGrillSN, _ns1__chkGrillSNResponse &ns1__chkGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LnkGrillSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LnkGrillSN *ns1__LnkGrillSN, _ns1__LnkGrillSNResponse &ns1__LnkGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CloseGrillSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CloseGrillSN *ns1__CloseGrillSN, _ns1__CloseGrillSNResponse &ns1__CloseGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsGrillBySN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsGrillBySN *ns1__InsGrillBySN, _ns1__InsGrillBySNResponse &ns1__InsGrillBySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetGrillTime_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetGrillTime *ns1__GetGrillTime, _ns1__GetGrillTimeResponse &ns1__GetGrillTimeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__OutGrillBySN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__OutGrillBySN *ns1__OutGrillBySN, _ns1__OutGrillBySNResponse &ns1__OutGrillBySNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CancelGrillSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelGrillSN *ns1__CancelGrillSN, _ns1__CancelGrillSNResponse &ns1__CancelGrillSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CancelLnkSN_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelLnkSN *ns1__CancelLnkSN, _ns1__CancelLnkSNResponse &ns1__CancelLnkSNResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetWeightSet_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetWeightSet *ns1__GetWeightSet, _ns1__GetWeightSetResponse &ns1__GetWeightSetResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPackToWMS_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPackToWMS *ns1__GetPackToWMS, _ns1__GetPackToWMSResponse &ns1__GetPackToWMSResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPallentToWMS_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPallentToWMS *ns1__GetPallentToWMS, _ns1__GetPallentToWMSResponse &ns1__GetPallentToWMSResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetPallentForWMS_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetPallentForWMS *ns1__SetPallentForWMS, _ns1__SetPallentForWMSResponse &ns1__SetPallentForWMSResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPackStation_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPackStation *ns1__GetPackStation, _ns1__GetPackStationResponse &ns1__GetPackStationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPackWeigth_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPackWeigth *ns1__GetPackWeigth, _ns1__GetPackWeigthResponse &ns1__GetPackWeigthResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetAhsMo_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetAhsMo *ns1__GetAhsMo, _ns1__GetAhsMoResponse &ns1__GetAhsMoResponse);

#endif

/* End of soapStub.h */

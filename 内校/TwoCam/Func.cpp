///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 17.12
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;


#ifndef NO_EXPORT_MAIN
// Main procedure 
bool IsImageOK(CHWin& HW,int nID,bool bLogNG,vector<CPos>& psOut)
{

  // Local iconic variables
  HObject  ho_Image, ho_Rectangle, ho_ImagePart;
  HObject  ho_Region, ho_RegionFillUp, ho_Open, ho_Cir, ho_ImageReduced;
  HObject  ho_Region2, ho_RegionOpening, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RC, ho_ImageSub, ho_Region3;
  HObject  ho_RegionOpening1, ho_Contours, ho_PtCon, ho_C1;
  HObject  ho_C2, ho_ObjectsConcat, ho_UnionContours;

  // Local control variables
  HTuple  hv_Row, hv_Column, hv_Phi, hv_WNum, hv_Radius;
  HTuple  hv_CNum, hv_SNum, hv_S, hv_Y, hv_X, hv_DistanceMin;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Angle;
  HTuple  hv_n, hv_d, hv_Xs, hv_Ys, hv_I, hv_Number;

  //draw_ellipse (200000, Row, Column, Phi, Radius1, Radius2)

  //ReadImage(&ho_Image, "D:/111.jpg");
  GenRectangle1(&ho_Rectangle, 166, 227, 658, 830);
  ReduceDomain(HW.hoImage, ho_Rectangle, &ho_ImagePart);
  Threshold(ho_ImagePart, &ho_Region, 150, 255);
  FillUp(ho_Region, &ho_RegionFillUp);
  //if (HDevWindowStack::IsOpen())
  //  SetDraw(HDevWindowStack::GetActive(),"margin");

  OpeningCircle(ho_RegionFillUp, &ho_Open, 55);
  CountObj(ho_Open, &hv_WNum);
  if (0 != (hv_WNum!=1))
  {
    return false;
  }
  SmallestCircle(ho_Open, &hv_Row, &hv_Column, &hv_Radius);
  DispCircle(HW.WndID, hv_Row, hv_Column, hv_Radius);
  GenCircle(&ho_Cir, hv_Row, hv_Column, hv_Radius);
  ReduceDomain(ho_Image, ho_Cir, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region2, 0, 120);
  OpeningRectangle1(ho_Region2, &ho_RegionOpening, 9, 3);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_CNum);
  if (0 != (hv_CNum<1))
  {
    return false;
  }
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 3550, 99999);
  CountObj(ho_SelectedRegions, &hv_SNum);
  if (0 != (hv_SNum!=1))
  {
    return false;
  }
  AreaCenter(ho_SelectedRegions, &hv_S, &hv_Y, &hv_X);
  AngleLx(hv_Row, hv_Column, hv_Y, hv_X, &hv_Phi);
  GenRectangle2(&ho_RC, hv_Y, hv_X, hv_Phi, 60, 25);
  ReduceDomain(ho_Image, ho_RC, &ho_ImageSub);
  Threshold(ho_ImageSub, &ho_Region3, 0, 55);
  OpeningRectangle1(ho_Region3, &ho_RegionOpening1, 11, 11);
  GenContourRegionXld(ho_RegionOpening1, &ho_Contours, "border");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  GenContourPolygonXld(&ho_PtCon, hv_Row, hv_Column);
  DistanceCcMinPoints(ho_PtCon, ho_Contours, "fast_point_to_segment", &hv_DistanceMin, 
      &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  DispLine(200000, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
  AngleLx(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Angle);
  double fVal = hv_Angle.D() * 180 / PI;
  return true;

  hv_n = 30;
  hv_d = 6.28/hv_n;
  hv_Xs = HTuple();
  hv_Ys = HTuple();
  for (hv_I=0; hv_I<=11; hv_I+=1)
  {
    hv_X = 100*(((-hv_I)*hv_d).TupleCos());
    hv_Y = 100*(((-hv_I)*hv_d).TupleSin());
    DispCross(200000, 320+hv_Y, 320+hv_X, 6, 0);
    hv_Xs[hv_I] = hv_X+400;
    hv_Ys[hv_I] = hv_Y+400;
  }
  GenContourPolygonXld(&ho_C1, hv_Ys, hv_Xs);
  hv_Xs = HTuple();
  hv_Ys = HTuple();
  {
  HTuple end_val58 = hv_n-1;
  HTuple step_val58 = 1;
  for (hv_I=11; hv_I.Continue(end_val58, step_val58); hv_I += step_val58)
  {
    hv_X = 100*(((-hv_I)*hv_d).TupleCos());
    hv_Y = 100*(((-hv_I)*hv_d).TupleSin());
    DispCross(200000, 320+hv_Y, 320+hv_X, 6, 0);
    hv_Xs[hv_I-11] = hv_X+400;
    hv_Ys[hv_I-11] = hv_Y+400;
  }
  }
  hv_Xs[hv_n-11] = (100*(HTuple(0).TupleCos()))+400;
  hv_Ys[hv_n-11] = (100*(HTuple(0).TupleSin()))+400;
  GenContourPolygonXld(&ho_C2, hv_Ys, hv_Xs);
  ConcatObj(ho_C1, ho_C2, &ho_ObjectsConcat);
  UnionAdjacentContoursXld(ho_ObjectsConcat, &ho_UnionContours, 10, 1, "attr_keep");
  // stop(...); only in hdevelop
  GenRegionContourXld(ho_UnionContours, &ho_Region, "filled");
  CountObj(ho_Region, &hv_Number);


}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
    XInitThreads();
#endif

    // Default settings used in HDevelop (can be omitted) 
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif



#include "stdafx.h"
/* soapC.cpp
   Generated by gSOAP 2.8.51 for WebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.51 2022-08-16 12:46:22 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTo_ns1__GetAhsMo:
		return soap_in_PointerTo_ns1__GetAhsMo(soap, NULL, NULL, "ns1:GetAhsMo");
	case SOAP_TYPE_PointerTo_ns1__GetPackWeigth:
		return soap_in_PointerTo_ns1__GetPackWeigth(soap, NULL, NULL, "ns1:GetPackWeigth");
	case SOAP_TYPE_PointerTo_ns1__GetPackStation:
		return soap_in_PointerTo_ns1__GetPackStation(soap, NULL, NULL, "ns1:GetPackStation");
	case SOAP_TYPE_PointerTo_ns1__SetPallentForWMS:
		return soap_in_PointerTo_ns1__SetPallentForWMS(soap, NULL, NULL, "ns1:SetPallentForWMS");
	case SOAP_TYPE_PointerTo_ns1__GetPallentToWMS:
		return soap_in_PointerTo_ns1__GetPallentToWMS(soap, NULL, NULL, "ns1:GetPallentToWMS");
	case SOAP_TYPE_PointerTo_ns1__GetPackToWMS:
		return soap_in_PointerTo_ns1__GetPackToWMS(soap, NULL, NULL, "ns1:GetPackToWMS");
	case SOAP_TYPE_PointerTo_ns1__GetWeightSet:
		return soap_in_PointerTo_ns1__GetWeightSet(soap, NULL, NULL, "ns1:GetWeightSet");
	case SOAP_TYPE_PointerTo_ns1__CancelLnkSN:
		return soap_in_PointerTo_ns1__CancelLnkSN(soap, NULL, NULL, "ns1:CancelLnkSN");
	case SOAP_TYPE_PointerTo_ns1__CancelGrillSN:
		return soap_in_PointerTo_ns1__CancelGrillSN(soap, NULL, NULL, "ns1:CancelGrillSN");
	case SOAP_TYPE_PointerTo_ns1__OutGrillBySN:
		return soap_in_PointerTo_ns1__OutGrillBySN(soap, NULL, NULL, "ns1:OutGrillBySN");
	case SOAP_TYPE_PointerTo_ns1__GetGrillTime:
		return soap_in_PointerTo_ns1__GetGrillTime(soap, NULL, NULL, "ns1:GetGrillTime");
	case SOAP_TYPE_PointerTo_ns1__InsGrillBySN:
		return soap_in_PointerTo_ns1__InsGrillBySN(soap, NULL, NULL, "ns1:InsGrillBySN");
	case SOAP_TYPE_PointerTo_ns1__CloseGrillSN:
		return soap_in_PointerTo_ns1__CloseGrillSN(soap, NULL, NULL, "ns1:CloseGrillSN");
	case SOAP_TYPE_PointerTo_ns1__LnkGrillSN:
		return soap_in_PointerTo_ns1__LnkGrillSN(soap, NULL, NULL, "ns1:LnkGrillSN");
	case SOAP_TYPE_PointerTo_ns1__chkGrillSN:
		return soap_in_PointerTo_ns1__chkGrillSN(soap, NULL, NULL, "ns1:chkGrillSN");
	case SOAP_TYPE_PointerTo_ns1__LnkSideSN:
		return soap_in_PointerTo_ns1__LnkSideSN(soap, NULL, NULL, "ns1:LnkSideSN");
	case SOAP_TYPE_PointerTo_ns1__LnkZJSN:
		return soap_in_PointerTo_ns1__LnkZJSN(soap, NULL, NULL, "ns1:LnkZJSN");
	case SOAP_TYPE_PointerTo_ns1__chkZJSN:
		return soap_in_PointerTo_ns1__chkZJSN(soap, NULL, NULL, "ns1:chkZJSN");
	case SOAP_TYPE_PointerTo_ns1__chkDispensing:
		return soap_in_PointerTo_ns1__chkDispensing(soap, NULL, NULL, "ns1:chkDispensing");
	case SOAP_TYPE_PointerTo_ns1__InsIotTestData:
		return soap_in_PointerTo_ns1__InsIotTestData(soap, NULL, NULL, "ns1:InsIotTestData");
	case SOAP_TYPE_PointerTo_ns1__InsIotMachineRec:
		return soap_in_PointerTo_ns1__InsIotMachineRec(soap, NULL, NULL, "ns1:InsIotMachineRec");
	case SOAP_TYPE_PointerTo_ns1__GetLnkData:
		return soap_in_PointerTo_ns1__GetLnkData(soap, NULL, NULL, "ns1:GetLnkData");
	case SOAP_TYPE_PointerTo_ns1__GetTestValue:
		return soap_in_PointerTo_ns1__GetTestValue(soap, NULL, NULL, "ns1:GetTestValue");
	case SOAP_TYPE_PointerTo_ns1__GetMoBase:
		return soap_in_PointerTo_ns1__GetMoBase(soap, NULL, NULL, "ns1:GetMoBase");
	case SOAP_TYPE_PointerTo_ns1__UpdSnRecInfo:
		return soap_in_PointerTo_ns1__UpdSnRecInfo(soap, NULL, NULL, "ns1:UpdSnRecInfo");
	case SOAP_TYPE_PointerTo_ns1__InsBoxInfo:
		return soap_in_PointerTo_ns1__InsBoxInfo(soap, NULL, NULL, "ns1:InsBoxInfo");
	case SOAP_TYPE_PointerTo_ns1__InsLnkOutSN:
		return soap_in_PointerTo_ns1__InsLnkOutSN(soap, NULL, NULL, "ns1:InsLnkOutSN");
	case SOAP_TYPE_PointerTo_ns1__InsSNStationEmp:
		return soap_in_PointerTo_ns1__InsSNStationEmp(soap, NULL, NULL, "ns1:InsSNStationEmp");
	case SOAP_TYPE_PointerTo_ns1__CancelBoxLnk:
		return soap_in_PointerTo_ns1__CancelBoxLnk(soap, NULL, NULL, "ns1:CancelBoxLnk");
	case SOAP_TYPE_PointerTo_ns1__OutStationbyBox:
		return soap_in_PointerTo_ns1__OutStationbyBox(soap, NULL, NULL, "ns1:OutStationbyBox");
	case SOAP_TYPE_PointerTo_ns1__InStationbyBox:
		return soap_in_PointerTo_ns1__InStationbyBox(soap, NULL, NULL, "ns1:InStationbyBox");
	case SOAP_TYPE_PointerTo_ns1__EndSNtoBox:
		return soap_in_PointerTo_ns1__EndSNtoBox(soap, NULL, NULL, "ns1:EndSNtoBox");
	case SOAP_TYPE_PointerTo_ns1__InSNtoBox:
		return soap_in_PointerTo_ns1__InSNtoBox(soap, NULL, NULL, "ns1:InSNtoBox");
	case SOAP_TYPE_PointerTo_ns1__chkBoxNo:
		return soap_in_PointerTo_ns1__chkBoxNo(soap, NULL, NULL, "ns1:chkBoxNo");
	case SOAP_TYPE_PointerTo_ns1__InsBoxNOTime:
		return soap_in_PointerTo_ns1__InsBoxNOTime(soap, NULL, NULL, "ns1:InsBoxNOTime");
	case SOAP_TYPE_PointerTo_ns1__GetLinkZJCount:
		return soap_in_PointerTo_ns1__GetLinkZJCount(soap, NULL, NULL, "ns1:GetLinkZJCount");
	case SOAP_TYPE_PointerTo_ns1__InsLinkSN:
		return soap_in_PointerTo_ns1__InsLinkSN(soap, NULL, NULL, "ns1:InsLinkSN");
	case SOAP_TYPE_PointerTo_ns1__doLinkOutSN:
		return soap_in_PointerTo_ns1__doLinkOutSN(soap, NULL, NULL, "ns1:doLinkOutSN");
	case SOAP_TYPE_PointerTo_ns1__ChkLinkOutSN:
		return soap_in_PointerTo_ns1__ChkLinkOutSN(soap, NULL, NULL, "ns1:ChkLinkOutSN");
	case SOAP_TYPE_PointerTo_ns1__chkOutSN:
		return soap_in_PointerTo_ns1__chkOutSN(soap, NULL, NULL, "ns1:chkOutSN");
	case SOAP_TYPE_PointerTo_ns1__GetLintOutQty:
		return soap_in_PointerTo_ns1__GetLintOutQty(soap, NULL, NULL, "ns1:GetLintOutQty");
	case SOAP_TYPE_PointerTo_ns1__SNLinkZJ:
		return soap_in_PointerTo_ns1__SNLinkZJ(soap, NULL, NULL, "ns1:SNLinkZJ");
	case SOAP_TYPE_PointerTo_ns1__InsZJTestData:
		return soap_in_PointerTo_ns1__InsZJTestData(soap, NULL, NULL, "ns1:InsZJTestData");
	case SOAP_TYPE_PointerTo_ns1__doPmcSNLink:
		return soap_in_PointerTo_ns1__doPmcSNLink(soap, NULL, NULL, "ns1:doPmcSNLink");
	case SOAP_TYPE_PointerTo_ns1__GetPmcSNPart:
		return soap_in_PointerTo_ns1__GetPmcSNPart(soap, NULL, NULL, "ns1:GetPmcSNPart");
	case SOAP_TYPE_PointerTo_ns1__getPmcPartAssyList:
		return soap_in_PointerTo_ns1__getPmcPartAssyList(soap, NULL, NULL, "ns1:getPmcPartAssyList");
	case SOAP_TYPE_PointerTo_ns1__getPmcAssyList:
		return soap_in_PointerTo_ns1__getPmcAssyList(soap, NULL, NULL, "ns1:getPmcAssyList");
	case SOAP_TYPE_PointerTo_ns1__doAssy:
		return soap_in_PointerTo_ns1__doAssy(soap, NULL, NULL, "ns1:doAssy");
	case SOAP_TYPE_PointerTo_ns1__chkAssySN:
		return soap_in_PointerTo_ns1__chkAssySN(soap, NULL, NULL, "ns1:chkAssySN");
	case SOAP_TYPE_PointerTo_ns1__getPNbySN:
		return soap_in_PointerTo_ns1__getPNbySN(soap, NULL, NULL, "ns1:getPNbySN");
	case SOAP_TYPE_PointerTo_ns1__getMoAssyCount:
		return soap_in_PointerTo_ns1__getMoAssyCount(soap, NULL, NULL, "ns1:getMoAssyCount");
	case SOAP_TYPE_PointerTo_ns1__GetLinkOutSn:
		return soap_in_PointerTo_ns1__GetLinkOutSn(soap, NULL, NULL, "ns1:GetLinkOutSn");
	case SOAP_TYPE_PointerTo_ns1__InsPartAssy:
		return soap_in_PointerTo_ns1__InsPartAssy(soap, NULL, NULL, "ns1:InsPartAssy");
	case SOAP_TYPE_PointerTo_ns1__getPartBomExt:
		return soap_in_PointerTo_ns1__getPartBomExt(soap, NULL, NULL, "ns1:getPartBomExt");
	case SOAP_TYPE_PointerTo_ns1__getMoAssyList:
		return soap_in_PointerTo_ns1__getMoAssyList(soap, NULL, NULL, "ns1:getMoAssyList");
	case SOAP_TYPE_PointerTo_ns1__chkSnMapping:
		return soap_in_PointerTo_ns1__chkSnMapping(soap, NULL, NULL, "ns1:chkSnMapping");
	case SOAP_TYPE_PointerTo_ns1__getStationTypeDesc:
		return soap_in_PointerTo_ns1__getStationTypeDesc(soap, NULL, NULL, "ns1:getStationTypeDesc");
	case SOAP_TYPE_PointerTo_ns1__getStationByMo:
		return soap_in_PointerTo_ns1__getStationByMo(soap, NULL, NULL, "ns1:getStationByMo");
	case SOAP_TYPE_PointerTo_ns1__SnDoMapping:
		return soap_in_PointerTo_ns1__SnDoMapping(soap, NULL, NULL, "ns1:SnDoMapping");
	case SOAP_TYPE_PointerTo_ns1__eMesNextMo:
		return soap_in_PointerTo_ns1__eMesNextMo(soap, NULL, NULL, "ns1:eMesNextMo");
	case SOAP_TYPE_PointerTo_ns1__sendResultForStationNumber:
		return soap_in_PointerTo_ns1__sendResultForStationNumber(soap, NULL, NULL, "ns1:sendResultForStationNumber");
	case SOAP_TYPE_PointerTo_ns1__sendDataForStationNumber:
		return soap_in_PointerTo_ns1__sendDataForStationNumber(soap, NULL, NULL, "ns1:sendDataForStationNumber");
	case SOAP_TYPE_PointerTo_ns1__checkEmpForStationNumber:
		return soap_in_PointerTo_ns1__checkEmpForStationNumber(soap, NULL, NULL, "ns1:checkEmpForStationNumber");
	case SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStationNumber:
		return soap_in_PointerTo_ns1__checkSN_USCOREStationNumber(soap, NULL, NULL, "ns1:checkSN_StationNumber");
	case SOAP_TYPE_PointerTo_ns1__ChkSnNextMo:
		return soap_in_PointerTo_ns1__ChkSnNextMo(soap, NULL, NULL, "ns1:ChkSnNextMo");
	case SOAP_TYPE_PointerTo_ns1__ChkSnMo:
		return soap_in_PointerTo_ns1__ChkSnMo(soap, NULL, NULL, "ns1:ChkSnMo");
	case SOAP_TYPE_PointerTo_ns1__chkMoStation:
		return soap_in_PointerTo_ns1__chkMoStation(soap, NULL, NULL, "ns1:chkMoStation");
	case SOAP_TYPE_PointerTo_ns1__SetEnergyStat:
		return soap_in_PointerTo_ns1__SetEnergyStat(soap, NULL, NULL, "ns1:SetEnergyStat");
	case SOAP_TYPE_PointerTo_ns1__getInfoByMo:
		return soap_in_PointerTo_ns1__getInfoByMo(soap, NULL, NULL, "ns1:getInfoByMo");
	case SOAP_TYPE_PointerTo_ns1__InsThermalNew:
		return soap_in_PointerTo_ns1__InsThermalNew(soap, NULL, NULL, "ns1:InsThermalNew");
	case SOAP_TYPE_PointerTo_ns1__ChkSnLink:
		return soap_in_PointerTo_ns1__ChkSnLink(soap, NULL, NULL, "ns1:ChkSnLink");
	case SOAP_TYPE_PointerTo_ns1__InsThermal:
		return soap_in_PointerTo_ns1__InsThermal(soap, NULL, NULL, "ns1:InsThermal");
	case SOAP_TYPE_PointerTo_ns1__InsWHDetection:
		return soap_in_PointerTo_ns1__InsWHDetection(soap, NULL, NULL, "ns1:InsWHDetection");
	case SOAP_TYPE_PointerTo_ns1__InsFlatNessForCL:
		return soap_in_PointerTo_ns1__InsFlatNessForCL(soap, NULL, NULL, "ns1:InsFlatNessForCL");
	case SOAP_TYPE_PointerTo_ns1__InsFlatNessForLSD:
		return soap_in_PointerTo_ns1__InsFlatNessForLSD(soap, NULL, NULL, "ns1:InsFlatNessForLSD");
	case SOAP_TYPE_PointerTo_ns1__InsFlatNess:
		return soap_in_PointerTo_ns1__InsFlatNess(soap, NULL, NULL, "ns1:InsFlatNess");
	case SOAP_TYPE_PointerTo_ns1__ImpMesAteTestData:
		return soap_in_PointerTo_ns1__ImpMesAteTestData(soap, NULL, NULL, "ns1:ImpMesAteTestData");
	case SOAP_TYPE_PointerTo_ns1__chkStationTime:
		return soap_in_PointerTo_ns1__chkStationTime(soap, NULL, NULL, "ns1:chkStationTime");
	case SOAP_TYPE_PointerTo_ns1__InFruitsOrtQty:
		return soap_in_PointerTo_ns1__InFruitsOrtQty(soap, NULL, NULL, "ns1:InFruitsOrtQty");
	case SOAP_TYPE_PointerTo_ns1__sendTestResult:
		return soap_in_PointerTo_ns1__sendTestResult(soap, NULL, NULL, "ns1:sendTestResult");
	case SOAP_TYPE_PointerTo_ns1__sendTestData:
		return soap_in_PointerTo_ns1__sendTestData(soap, NULL, NULL, "ns1:sendTestData");
	case SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStation:
		return soap_in_PointerTo_ns1__checkSN_USCOREStation(soap, NULL, NULL, "ns1:checkSN_Station");
	case SOAP_TYPE_PointerTo_ns1__checkEmpNo:
		return soap_in_PointerTo_ns1__checkEmpNo(soap, NULL, NULL, "ns1:checkEmpNo");
	case SOAP_TYPE_PointerTo_ns1__checkTestData:
		return soap_in_PointerTo_ns1__checkTestData(soap, NULL, NULL, "ns1:checkTestData");
	case SOAP_TYPE_PointerTo_ns1__InsZjList:
		return soap_in_PointerTo_ns1__InsZjList(soap, NULL, NULL, "ns1:InsZjList");
	case SOAP_TYPE_PointerTo_ns1__GetFruitMachineChk:
		return soap_in_PointerTo_ns1__GetFruitMachineChk(soap, NULL, NULL, "ns1:GetFruitMachineChk");
	case SOAP_TYPE_PointerTo_ns1__InsFruitMachineChk:
		return soap_in_PointerTo_ns1__InsFruitMachineChk(soap, NULL, NULL, "ns1:InsFruitMachineChk");
	case SOAP_TYPE_PointerTo_ns1__SnLnkOutSN:
		return soap_in_PointerTo_ns1__SnLnkOutSN(soap, NULL, NULL, "ns1:SnLnkOutSN");
	case SOAP_TYPE_PointerTo_ns1__getMoBase:
		return soap_in_PointerTo_ns1__getMoBase(soap, NULL, NULL, "ns1:getMoBase");
	case SOAP_TYPE_PointerTo_ns1__GetNgCode:
		return soap_in_PointerTo_ns1__GetNgCode(soap, NULL, NULL, "ns1:GetNgCode");
	case SOAP_TYPE_PointerTo_ns1__SetDiecastSN:
		return soap_in_PointerTo_ns1__SetDiecastSN(soap, NULL, NULL, "ns1:SetDiecastSN");
	case SOAP_TYPE_PointerTo_ns1__GetMachineForGroup:
		return soap_in_PointerTo_ns1__GetMachineForGroup(soap, NULL, NULL, "ns1:GetMachineForGroup");
	case SOAP_TYPE_PointerTo_ns1__UploadForHP:
		return soap_in_PointerTo_ns1__UploadForHP(soap, NULL, NULL, "ns1:UploadForHP");
	case SOAP_TYPE_PointerTo_ns1__SelShelfLink:
		return soap_in_PointerTo_ns1__SelShelfLink(soap, NULL, NULL, "ns1:SelShelfLink");
	case SOAP_TYPE_PointerTo_ns1__SNLinkShelf:
		return soap_in_PointerTo_ns1__SNLinkShelf(soap, NULL, NULL, "ns1:SNLinkShelf");
	case SOAP_TYPE_PointerTo_ns1__SelSNTestForFruit:
		return soap_in_PointerTo_ns1__SelSNTestForFruit(soap, NULL, NULL, "ns1:SelSNTestForFruit");
	case SOAP_TYPE_PointerTo_ns1__InsSNTestForFruit:
		return soap_in_PointerTo_ns1__InsSNTestForFruit(soap, NULL, NULL, "ns1:InsSNTestForFruit");
	case SOAP_TYPE_PointerTo_ns1__GetStationNumberForSN:
		return soap_in_PointerTo_ns1__GetStationNumberForSN(soap, NULL, NULL, "ns1:GetStationNumberForSN");
	case SOAP_TYPE_PointerTo_ns1__GetTestValueResult:
		return soap_in_PointerTo_ns1__GetTestValueResult(soap, NULL, NULL, "ns1:GetTestValueResult");
	case SOAP_TYPE_PointerTo_ns1__InsCLScada:
		return soap_in_PointerTo_ns1__InsCLScada(soap, NULL, NULL, "ns1:InsCLScada");
	case SOAP_TYPE_PointerTo_ns1__InsAoiMo:
		return soap_in_PointerTo_ns1__InsAoiMo(soap, NULL, NULL, "ns1:InsAoiMo");
	case SOAP_TYPE_PointerTo_ns1__chkMoSNForAOI:
		return soap_in_PointerTo_ns1__chkMoSNForAOI(soap, NULL, NULL, "ns1:chkMoSNForAOI");
	case SOAP_TYPE_PointerTo_ns1__PunchOut:
		return soap_in_PointerTo_ns1__PunchOut(soap, NULL, NULL, "ns1:PunchOut");
	case SOAP_TYPE_PointerTo_ns1__BasketLinkPunch:
		return soap_in_PointerTo_ns1__BasketLinkPunch(soap, NULL, NULL, "ns1:BasketLinkPunch");
	case SOAP_TYPE_PointerTo_ns1__HPSNLinkBasket:
		return soap_in_PointerTo_ns1__HPSNLinkBasket(soap, NULL, NULL, "ns1:HPSNLinkBasket");
	case SOAP_TYPE_PointerTo_ns1__SetAutoLineRec:
		return soap_in_PointerTo_ns1__SetAutoLineRec(soap, NULL, NULL, "ns1:SetAutoLineRec");
	case SOAP_TYPE_PointerTo_ns1__GetSNForLink:
		return soap_in_PointerTo_ns1__GetSNForLink(soap, NULL, NULL, "ns1:GetSNForLink");
	case SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec:
		return soap_in_PointerTo_ns1__SetFlatnessFruitRec(soap, NULL, NULL, "ns1:SetFlatnessFruitRec");
	case SOAP_TYPE_PointerTo_ns1__getStationByMoForTestPad:
		return soap_in_PointerTo_ns1__getStationByMoForTestPad(soap, NULL, NULL, "ns1:getStationByMoForTestPad");
	case SOAP_TYPE_PointerTo_ns1__GetShippingWeight:
		return soap_in_PointerTo_ns1__GetShippingWeight(soap, NULL, NULL, "ns1:GetShippingWeight");
	case SOAP_TYPE_PointerTo_ns1__GetShippingForBerth:
		return soap_in_PointerTo_ns1__GetShippingForBerth(soap, NULL, NULL, "ns1:GetShippingForBerth");
	case SOAP_TYPE_PointerTo_ns1__InsShippingBerth:
		return soap_in_PointerTo_ns1__InsShippingBerth(soap, NULL, NULL, "ns1:InsShippingBerth");
	case SOAP_TYPE_PointerTo_ns1__InsShippingPalle:
		return soap_in_PointerTo_ns1__InsShippingPalle(soap, NULL, NULL, "ns1:InsShippingPalle");
	case SOAP_TYPE_PointerTo_ns1__GetShippingPalle:
		return soap_in_PointerTo_ns1__GetShippingPalle(soap, NULL, NULL, "ns1:GetShippingPalle");
	case SOAP_TYPE_PointerTo_ns1__UpdShipping:
		return soap_in_PointerTo_ns1__UpdShipping(soap, NULL, NULL, "ns1:UpdShipping");
	case SOAP_TYPE_PointerTo_ns1__GetShippingBerthList:
		return soap_in_PointerTo_ns1__GetShippingBerthList(soap, NULL, NULL, "ns1:GetShippingBerthList");
	case SOAP_TYPE_PointerTo_ns1__GetShippingList:
		return soap_in_PointerTo_ns1__GetShippingList(soap, NULL, NULL, "ns1:GetShippingList");
	case SOAP_TYPE_PointerTo_ns1__doLotLinkForApple:
		return soap_in_PointerTo_ns1__doLotLinkForApple(soap, NULL, NULL, "ns1:doLotLinkForApple");
	case SOAP_TYPE_PointerTo_ns1__GetLotLinkCount:
		return soap_in_PointerTo_ns1__GetLotLinkCount(soap, NULL, NULL, "ns1:GetLotLinkCount");
	case SOAP_TYPE_PointerTo_ns1__GetFruitSNCheck:
		return soap_in_PointerTo_ns1__GetFruitSNCheck(soap, NULL, NULL, "ns1:GetFruitSNCheck");
	case SOAP_TYPE_PointerTo_ns1__GetObeNW:
		return soap_in_PointerTo_ns1__GetObeNW(soap, NULL, NULL, "ns1:GetObeNW");
	case SOAP_TYPE_PointerTo_ns1__doSnLinkForApple:
		return soap_in_PointerTo_ns1__doSnLinkForApple(soap, NULL, NULL, "ns1:doSnLinkForApple");
	case SOAP_TYPE_PointerTo_ns1__ChkSnLinkForApple:
		return soap_in_PointerTo_ns1__ChkSnLinkForApple(soap, NULL, NULL, "ns1:ChkSnLinkForApple");
	case SOAP_TYPE_PointerTo_ns1__DelSNTest:
		return soap_in_PointerTo_ns1__DelSNTest(soap, NULL, NULL, "ns1:DelSNTest");
	case SOAP_TYPE_PointerTo_ns1__SelSNTest:
		return soap_in_PointerTo_ns1__SelSNTest(soap, NULL, NULL, "ns1:SelSNTest");
	case SOAP_TYPE_PointerTo_ns1__InsSNTest:
		return soap_in_PointerTo_ns1__InsSNTest(soap, NULL, NULL, "ns1:InsSNTest");
	case SOAP_TYPE_PointerTo_ns1__ChkWeightTime:
		return soap_in_PointerTo_ns1__ChkWeightTime(soap, NULL, NULL, "ns1:ChkWeightTime");
	case SOAP_TYPE_PointerTo_ns1__UpdAhsBarcode:
		return soap_in_PointerTo_ns1__UpdAhsBarcode(soap, NULL, NULL, "ns1:UpdAhsBarcode");
	case SOAP_TYPE_PointerTo_ns1__GetAhsBarcode:
		return soap_in_PointerTo_ns1__GetAhsBarcode(soap, NULL, NULL, "ns1:GetAhsBarcode");
	case SOAP_TYPE_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult:
		return soap_in_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, NULL, NULL, "ns1:GetAhsMoResponse-GetAhsMoResult");
	case SOAP_TYPE_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		return soap_in_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, NULL, NULL, "ns1:GetPallentToWMSResponse-GetPallentToWMSResult");
	case SOAP_TYPE_PointerTo_ns1__doLinkOutSN_assyDt:
		return soap_in_PointerTo_ns1__doLinkOutSN_assyDt(soap, NULL, NULL, "ns1:doLinkOutSN-assyDt");
	case SOAP_TYPE_PointerTo_ns1__doPmcSNLink_assyDt:
		return soap_in_PointerTo_ns1__doPmcSNLink_assyDt(soap, NULL, NULL, "ns1:doPmcSNLink-assyDt");
	case SOAP_TYPE_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		return soap_in_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, NULL, NULL, "ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult");
	case SOAP_TYPE_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult:
		return soap_in_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, NULL, NULL, "ns1:getPmcAssyListResponse-getPmcAssyListResult");
	case SOAP_TYPE_PointerTo_ns1__doAssy_assyDt:
		return soap_in_PointerTo_ns1__doAssy_assyDt(soap, NULL, NULL, "ns1:doAssy-assyDt");
	case SOAP_TYPE_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		return soap_in_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, NULL, NULL, "ns1:GetLinkOutSnResponse-GetLinkOutSnResult");
	case SOAP_TYPE_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult:
		return soap_in_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, NULL, NULL, "ns1:getPartBomExtResponse-getPartBomExtResult");
	case SOAP_TYPE_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult:
		return soap_in_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, NULL, NULL, "ns1:getMoAssyListResponse-getMoAssyListResult");
	case SOAP_TYPE_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult:
		return soap_in_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, NULL, NULL, "ns1:getInfoByMoResponse-getInfoByMoResult");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		return soap_in_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, NULL, NULL, "ns1:GetMachineForGroupResponse-GetMachineForGroupResult");
	case SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec_dt:
		return soap_in_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, NULL, NULL, "ns1:SetFlatnessFruitRec-dt");
	case SOAP_TYPE_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult:
		return soap_in_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, NULL, NULL, "ns1:GetShippingWeightResponse-GetShippingWeightResult");
	case SOAP_TYPE_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		return soap_in_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, NULL, NULL, "ns1:GetShippingForBerthResponse-GetShippingForBerthResult");
	case SOAP_TYPE_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		return soap_in_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, NULL, NULL, "ns1:GetShippingBerthListResponse-GetShippingBerthListResult");
	case SOAP_TYPE_PointerTo_ns1__GetShippingListResponse_GetShippingListResult:
		return soap_in_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, NULL, NULL, "ns1:GetShippingListResponse-GetShippingListResult");
	case SOAP_TYPE_PointerTo_ns1__doLotLinkForApple_assyDt:
		return soap_in_PointerTo_ns1__doLotLinkForApple_assyDt(soap, NULL, NULL, "ns1:doLotLinkForApple-assyDt");
	case SOAP_TYPE_PointerTo_ns1__doSnLinkForApple_assyDt:
		return soap_in_PointerTo_ns1__doSnLinkForApple_assyDt(soap, NULL, NULL, "ns1:doSnLinkForApple-assyDt");
	case SOAP_TYPE_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		return soap_in_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, NULL, NULL, "ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetAhsMoResponse-GetAhsMoResult"))
		{	*type = SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult;
			return soap_in__ns1__GetAhsMoResponse_GetAhsMoResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPallentToWMSResponse-GetPallentToWMSResult"))
		{	*type = SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult;
			return soap_in__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doLinkOutSN-assyDt"))
		{	*type = SOAP_TYPE__ns1__doLinkOutSN_assyDt;
			return soap_in__ns1__doLinkOutSN_assyDt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doPmcSNLink-assyDt"))
		{	*type = SOAP_TYPE__ns1__doPmcSNLink_assyDt;
			return soap_in__ns1__doPmcSNLink_assyDt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult"))
		{	*type = SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult;
			return soap_in__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPmcAssyListResponse-getPmcAssyListResult"))
		{	*type = SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult;
			return soap_in__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doAssy-assyDt"))
		{	*type = SOAP_TYPE__ns1__doAssy_assyDt;
			return soap_in__ns1__doAssy_assyDt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkOutSnResponse-GetLinkOutSnResult"))
		{	*type = SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult;
			return soap_in__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPartBomExtResponse-getPartBomExtResult"))
		{	*type = SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult;
			return soap_in__ns1__getPartBomExtResponse_getPartBomExtResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoAssyListResponse-getMoAssyListResult"))
		{	*type = SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult;
			return soap_in__ns1__getMoAssyListResponse_getMoAssyListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInfoByMoResponse-getInfoByMoResult"))
		{	*type = SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult;
			return soap_in__ns1__getInfoByMoResponse_getInfoByMoResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMachineForGroupResponse-GetMachineForGroupResult"))
		{	*type = SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult;
			return soap_in__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetFlatnessFruitRec-dt"))
		{	*type = SOAP_TYPE__ns1__SetFlatnessFruitRec_dt;
			return soap_in__ns1__SetFlatnessFruitRec_dt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingWeightResponse-GetShippingWeightResult"))
		{	*type = SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult;
			return soap_in__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingForBerthResponse-GetShippingForBerthResult"))
		{	*type = SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult;
			return soap_in__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingBerthListResponse-GetShippingBerthListResult"))
		{	*type = SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult;
			return soap_in__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingListResponse-GetShippingListResult"))
		{	*type = SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult;
			return soap_in__ns1__GetShippingListResponse_GetShippingListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doLotLinkForApple-assyDt"))
		{	*type = SOAP_TYPE__ns1__doLotLinkForApple_assyDt;
			return soap_in__ns1__doLotLinkForApple_assyDt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doSnLinkForApple-assyDt"))
		{	*type = SOAP_TYPE__ns1__doSnLinkForApple_assyDt;
			return soap_in__ns1__doSnLinkForApple_assyDt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult"))
		{	*type = SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult;
			return soap_in__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAhsMoResponse"))
		{	*type = SOAP_TYPE__ns1__GetAhsMoResponse;
			return soap_in__ns1__GetAhsMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAhsMo"))
		{	*type = SOAP_TYPE__ns1__GetAhsMo;
			return soap_in__ns1__GetAhsMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPackWeigthResponse"))
		{	*type = SOAP_TYPE__ns1__GetPackWeigthResponse;
			return soap_in__ns1__GetPackWeigthResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPackWeigth"))
		{	*type = SOAP_TYPE__ns1__GetPackWeigth;
			return soap_in__ns1__GetPackWeigth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPackStationResponse"))
		{	*type = SOAP_TYPE__ns1__GetPackStationResponse;
			return soap_in__ns1__GetPackStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPackStation"))
		{	*type = SOAP_TYPE__ns1__GetPackStation;
			return soap_in__ns1__GetPackStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPallentForWMSResponse"))
		{	*type = SOAP_TYPE__ns1__SetPallentForWMSResponse;
			return soap_in__ns1__SetPallentForWMSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPallentForWMS"))
		{	*type = SOAP_TYPE__ns1__SetPallentForWMS;
			return soap_in__ns1__SetPallentForWMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPallentToWMSResponse"))
		{	*type = SOAP_TYPE__ns1__GetPallentToWMSResponse;
			return soap_in__ns1__GetPallentToWMSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPallentToWMS"))
		{	*type = SOAP_TYPE__ns1__GetPallentToWMS;
			return soap_in__ns1__GetPallentToWMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPackToWMSResponse"))
		{	*type = SOAP_TYPE__ns1__GetPackToWMSResponse;
			return soap_in__ns1__GetPackToWMSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPackToWMS"))
		{	*type = SOAP_TYPE__ns1__GetPackToWMS;
			return soap_in__ns1__GetPackToWMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWeightSetResponse"))
		{	*type = SOAP_TYPE__ns1__GetWeightSetResponse;
			return soap_in__ns1__GetWeightSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWeightSet"))
		{	*type = SOAP_TYPE__ns1__GetWeightSet;
			return soap_in__ns1__GetWeightSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelLnkSNResponse"))
		{	*type = SOAP_TYPE__ns1__CancelLnkSNResponse;
			return soap_in__ns1__CancelLnkSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelLnkSN"))
		{	*type = SOAP_TYPE__ns1__CancelLnkSN;
			return soap_in__ns1__CancelLnkSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelGrillSNResponse"))
		{	*type = SOAP_TYPE__ns1__CancelGrillSNResponse;
			return soap_in__ns1__CancelGrillSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelGrillSN"))
		{	*type = SOAP_TYPE__ns1__CancelGrillSN;
			return soap_in__ns1__CancelGrillSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutGrillBySNResponse"))
		{	*type = SOAP_TYPE__ns1__OutGrillBySNResponse;
			return soap_in__ns1__OutGrillBySNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutGrillBySN"))
		{	*type = SOAP_TYPE__ns1__OutGrillBySN;
			return soap_in__ns1__OutGrillBySN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGrillTimeResponse"))
		{	*type = SOAP_TYPE__ns1__GetGrillTimeResponse;
			return soap_in__ns1__GetGrillTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGrillTime"))
		{	*type = SOAP_TYPE__ns1__GetGrillTime;
			return soap_in__ns1__GetGrillTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsGrillBySNResponse"))
		{	*type = SOAP_TYPE__ns1__InsGrillBySNResponse;
			return soap_in__ns1__InsGrillBySNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsGrillBySN"))
		{	*type = SOAP_TYPE__ns1__InsGrillBySN;
			return soap_in__ns1__InsGrillBySN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseGrillSNResponse"))
		{	*type = SOAP_TYPE__ns1__CloseGrillSNResponse;
			return soap_in__ns1__CloseGrillSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseGrillSN"))
		{	*type = SOAP_TYPE__ns1__CloseGrillSN;
			return soap_in__ns1__CloseGrillSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LnkGrillSNResponse"))
		{	*type = SOAP_TYPE__ns1__LnkGrillSNResponse;
			return soap_in__ns1__LnkGrillSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LnkGrillSN"))
		{	*type = SOAP_TYPE__ns1__LnkGrillSN;
			return soap_in__ns1__LnkGrillSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkGrillSNResponse"))
		{	*type = SOAP_TYPE__ns1__chkGrillSNResponse;
			return soap_in__ns1__chkGrillSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkGrillSN"))
		{	*type = SOAP_TYPE__ns1__chkGrillSN;
			return soap_in__ns1__chkGrillSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LnkSideSNResponse"))
		{	*type = SOAP_TYPE__ns1__LnkSideSNResponse;
			return soap_in__ns1__LnkSideSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LnkSideSN"))
		{	*type = SOAP_TYPE__ns1__LnkSideSN;
			return soap_in__ns1__LnkSideSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LnkZJSNResponse"))
		{	*type = SOAP_TYPE__ns1__LnkZJSNResponse;
			return soap_in__ns1__LnkZJSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LnkZJSN"))
		{	*type = SOAP_TYPE__ns1__LnkZJSN;
			return soap_in__ns1__LnkZJSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkZJSNResponse"))
		{	*type = SOAP_TYPE__ns1__chkZJSNResponse;
			return soap_in__ns1__chkZJSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkZJSN"))
		{	*type = SOAP_TYPE__ns1__chkZJSN;
			return soap_in__ns1__chkZJSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkDispensingResponse"))
		{	*type = SOAP_TYPE__ns1__chkDispensingResponse;
			return soap_in__ns1__chkDispensingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkDispensing"))
		{	*type = SOAP_TYPE__ns1__chkDispensing;
			return soap_in__ns1__chkDispensing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsIotTestDataResponse"))
		{	*type = SOAP_TYPE__ns1__InsIotTestDataResponse;
			return soap_in__ns1__InsIotTestDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsIotTestData"))
		{	*type = SOAP_TYPE__ns1__InsIotTestData;
			return soap_in__ns1__InsIotTestData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsIotMachineRecResponse"))
		{	*type = SOAP_TYPE__ns1__InsIotMachineRecResponse;
			return soap_in__ns1__InsIotMachineRecResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsIotMachineRec"))
		{	*type = SOAP_TYPE__ns1__InsIotMachineRec;
			return soap_in__ns1__InsIotMachineRec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLnkDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetLnkDataResponse;
			return soap_in__ns1__GetLnkDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLnkData"))
		{	*type = SOAP_TYPE__ns1__GetLnkData;
			return soap_in__ns1__GetLnkData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTestValueResponse"))
		{	*type = SOAP_TYPE__ns1__GetTestValueResponse;
			return soap_in__ns1__GetTestValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTestValue"))
		{	*type = SOAP_TYPE__ns1__GetTestValue;
			return soap_in__ns1__GetTestValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMoBaseResponse"))
		{	*type = SOAP_TYPE__ns1__GetMoBaseResponse;
			return soap_in__ns1__GetMoBaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMoBase"))
		{	*type = SOAP_TYPE__ns1__GetMoBase;
			return soap_in__ns1__GetMoBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdSnRecInfoResponse"))
		{	*type = SOAP_TYPE__ns1__UpdSnRecInfoResponse;
			return soap_in__ns1__UpdSnRecInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdSnRecInfo"))
		{	*type = SOAP_TYPE__ns1__UpdSnRecInfo;
			return soap_in__ns1__UpdSnRecInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsBoxInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InsBoxInfoResponse;
			return soap_in__ns1__InsBoxInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsBoxInfo"))
		{	*type = SOAP_TYPE__ns1__InsBoxInfo;
			return soap_in__ns1__InsBoxInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsLnkOutSNResponse"))
		{	*type = SOAP_TYPE__ns1__InsLnkOutSNResponse;
			return soap_in__ns1__InsLnkOutSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsLnkOutSN"))
		{	*type = SOAP_TYPE__ns1__InsLnkOutSN;
			return soap_in__ns1__InsLnkOutSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsSNStationEmpResponse"))
		{	*type = SOAP_TYPE__ns1__InsSNStationEmpResponse;
			return soap_in__ns1__InsSNStationEmpResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsSNStationEmp"))
		{	*type = SOAP_TYPE__ns1__InsSNStationEmp;
			return soap_in__ns1__InsSNStationEmp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelBoxLnkResponse"))
		{	*type = SOAP_TYPE__ns1__CancelBoxLnkResponse;
			return soap_in__ns1__CancelBoxLnkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelBoxLnk"))
		{	*type = SOAP_TYPE__ns1__CancelBoxLnk;
			return soap_in__ns1__CancelBoxLnk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutStationbyBoxResponse"))
		{	*type = SOAP_TYPE__ns1__OutStationbyBoxResponse;
			return soap_in__ns1__OutStationbyBoxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OutStationbyBox"))
		{	*type = SOAP_TYPE__ns1__OutStationbyBox;
			return soap_in__ns1__OutStationbyBox(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InStationbyBoxResponse"))
		{	*type = SOAP_TYPE__ns1__InStationbyBoxResponse;
			return soap_in__ns1__InStationbyBoxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InStationbyBox"))
		{	*type = SOAP_TYPE__ns1__InStationbyBox;
			return soap_in__ns1__InStationbyBox(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndSNtoBoxResponse"))
		{	*type = SOAP_TYPE__ns1__EndSNtoBoxResponse;
			return soap_in__ns1__EndSNtoBoxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndSNtoBox"))
		{	*type = SOAP_TYPE__ns1__EndSNtoBox;
			return soap_in__ns1__EndSNtoBox(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InSNtoBoxResponse"))
		{	*type = SOAP_TYPE__ns1__InSNtoBoxResponse;
			return soap_in__ns1__InSNtoBoxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InSNtoBox"))
		{	*type = SOAP_TYPE__ns1__InSNtoBox;
			return soap_in__ns1__InSNtoBox(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkBoxNoResponse"))
		{	*type = SOAP_TYPE__ns1__chkBoxNoResponse;
			return soap_in__ns1__chkBoxNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkBoxNo"))
		{	*type = SOAP_TYPE__ns1__chkBoxNo;
			return soap_in__ns1__chkBoxNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsBoxNOTimeResponse"))
		{	*type = SOAP_TYPE__ns1__InsBoxNOTimeResponse;
			return soap_in__ns1__InsBoxNOTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsBoxNOTime"))
		{	*type = SOAP_TYPE__ns1__InsBoxNOTime;
			return soap_in__ns1__InsBoxNOTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkZJCountResponse"))
		{	*type = SOAP_TYPE__ns1__GetLinkZJCountResponse;
			return soap_in__ns1__GetLinkZJCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkZJCount"))
		{	*type = SOAP_TYPE__ns1__GetLinkZJCount;
			return soap_in__ns1__GetLinkZJCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsLinkSNResponse"))
		{	*type = SOAP_TYPE__ns1__InsLinkSNResponse;
			return soap_in__ns1__InsLinkSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsLinkSN"))
		{	*type = SOAP_TYPE__ns1__InsLinkSN;
			return soap_in__ns1__InsLinkSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doLinkOutSNResponse"))
		{	*type = SOAP_TYPE__ns1__doLinkOutSNResponse;
			return soap_in__ns1__doLinkOutSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doLinkOutSN"))
		{	*type = SOAP_TYPE__ns1__doLinkOutSN;
			return soap_in__ns1__doLinkOutSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkLinkOutSNResponse"))
		{	*type = SOAP_TYPE__ns1__ChkLinkOutSNResponse;
			return soap_in__ns1__ChkLinkOutSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkLinkOutSN"))
		{	*type = SOAP_TYPE__ns1__ChkLinkOutSN;
			return soap_in__ns1__ChkLinkOutSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkOutSNResponse"))
		{	*type = SOAP_TYPE__ns1__chkOutSNResponse;
			return soap_in__ns1__chkOutSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkOutSN"))
		{	*type = SOAP_TYPE__ns1__chkOutSN;
			return soap_in__ns1__chkOutSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLintOutQtyResponse"))
		{	*type = SOAP_TYPE__ns1__GetLintOutQtyResponse;
			return soap_in__ns1__GetLintOutQtyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLintOutQty"))
		{	*type = SOAP_TYPE__ns1__GetLintOutQty;
			return soap_in__ns1__GetLintOutQty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SNLinkZJResponse"))
		{	*type = SOAP_TYPE__ns1__SNLinkZJResponse;
			return soap_in__ns1__SNLinkZJResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SNLinkZJ"))
		{	*type = SOAP_TYPE__ns1__SNLinkZJ;
			return soap_in__ns1__SNLinkZJ(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsZJTestDataResponse"))
		{	*type = SOAP_TYPE__ns1__InsZJTestDataResponse;
			return soap_in__ns1__InsZJTestDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsZJTestData"))
		{	*type = SOAP_TYPE__ns1__InsZJTestData;
			return soap_in__ns1__InsZJTestData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doPmcSNLinkResponse"))
		{	*type = SOAP_TYPE__ns1__doPmcSNLinkResponse;
			return soap_in__ns1__doPmcSNLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doPmcSNLink"))
		{	*type = SOAP_TYPE__ns1__doPmcSNLink;
			return soap_in__ns1__doPmcSNLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPmcSNPartResponse"))
		{	*type = SOAP_TYPE__ns1__GetPmcSNPartResponse;
			return soap_in__ns1__GetPmcSNPartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPmcSNPart"))
		{	*type = SOAP_TYPE__ns1__GetPmcSNPart;
			return soap_in__ns1__GetPmcSNPart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPmcPartAssyListResponse"))
		{	*type = SOAP_TYPE__ns1__getPmcPartAssyListResponse;
			return soap_in__ns1__getPmcPartAssyListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPmcPartAssyList"))
		{	*type = SOAP_TYPE__ns1__getPmcPartAssyList;
			return soap_in__ns1__getPmcPartAssyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPmcAssyListResponse"))
		{	*type = SOAP_TYPE__ns1__getPmcAssyListResponse;
			return soap_in__ns1__getPmcAssyListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPmcAssyList"))
		{	*type = SOAP_TYPE__ns1__getPmcAssyList;
			return soap_in__ns1__getPmcAssyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doAssyResponse"))
		{	*type = SOAP_TYPE__ns1__doAssyResponse;
			return soap_in__ns1__doAssyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doAssy"))
		{	*type = SOAP_TYPE__ns1__doAssy;
			return soap_in__ns1__doAssy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkAssySNResponse"))
		{	*type = SOAP_TYPE__ns1__chkAssySNResponse;
			return soap_in__ns1__chkAssySNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkAssySN"))
		{	*type = SOAP_TYPE__ns1__chkAssySN;
			return soap_in__ns1__chkAssySN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPNbySNResponse"))
		{	*type = SOAP_TYPE__ns1__getPNbySNResponse;
			return soap_in__ns1__getPNbySNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPNbySN"))
		{	*type = SOAP_TYPE__ns1__getPNbySN;
			return soap_in__ns1__getPNbySN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoAssyCountResponse"))
		{	*type = SOAP_TYPE__ns1__getMoAssyCountResponse;
			return soap_in__ns1__getMoAssyCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoAssyCount"))
		{	*type = SOAP_TYPE__ns1__getMoAssyCount;
			return soap_in__ns1__getMoAssyCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkOutSnResponse"))
		{	*type = SOAP_TYPE__ns1__GetLinkOutSnResponse;
			return soap_in__ns1__GetLinkOutSnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkOutSn"))
		{	*type = SOAP_TYPE__ns1__GetLinkOutSn;
			return soap_in__ns1__GetLinkOutSn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsPartAssyResponse"))
		{	*type = SOAP_TYPE__ns1__InsPartAssyResponse;
			return soap_in__ns1__InsPartAssyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsPartAssy"))
		{	*type = SOAP_TYPE__ns1__InsPartAssy;
			return soap_in__ns1__InsPartAssy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPartBomExtResponse"))
		{	*type = SOAP_TYPE__ns1__getPartBomExtResponse;
			return soap_in__ns1__getPartBomExtResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPartBomExt"))
		{	*type = SOAP_TYPE__ns1__getPartBomExt;
			return soap_in__ns1__getPartBomExt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoAssyListResponse"))
		{	*type = SOAP_TYPE__ns1__getMoAssyListResponse;
			return soap_in__ns1__getMoAssyListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoAssyList"))
		{	*type = SOAP_TYPE__ns1__getMoAssyList;
			return soap_in__ns1__getMoAssyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkSnMappingResponse"))
		{	*type = SOAP_TYPE__ns1__chkSnMappingResponse;
			return soap_in__ns1__chkSnMappingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkSnMapping"))
		{	*type = SOAP_TYPE__ns1__chkSnMapping;
			return soap_in__ns1__chkSnMapping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStationTypeDescResponse"))
		{	*type = SOAP_TYPE__ns1__getStationTypeDescResponse;
			return soap_in__ns1__getStationTypeDescResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStationTypeDesc"))
		{	*type = SOAP_TYPE__ns1__getStationTypeDesc;
			return soap_in__ns1__getStationTypeDesc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStationByMoResponse"))
		{	*type = SOAP_TYPE__ns1__getStationByMoResponse;
			return soap_in__ns1__getStationByMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStationByMo"))
		{	*type = SOAP_TYPE__ns1__getStationByMo;
			return soap_in__ns1__getStationByMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnDoMappingResponse"))
		{	*type = SOAP_TYPE__ns1__SnDoMappingResponse;
			return soap_in__ns1__SnDoMappingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnDoMapping"))
		{	*type = SOAP_TYPE__ns1__SnDoMapping;
			return soap_in__ns1__SnDoMapping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:eMesNextMoResponse"))
		{	*type = SOAP_TYPE__ns1__eMesNextMoResponse;
			return soap_in__ns1__eMesNextMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:eMesNextMo"))
		{	*type = SOAP_TYPE__ns1__eMesNextMo;
			return soap_in__ns1__eMesNextMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendResultForStationNumberResponse"))
		{	*type = SOAP_TYPE__ns1__sendResultForStationNumberResponse;
			return soap_in__ns1__sendResultForStationNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendResultForStationNumber"))
		{	*type = SOAP_TYPE__ns1__sendResultForStationNumber;
			return soap_in__ns1__sendResultForStationNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendDataForStationNumberResponse"))
		{	*type = SOAP_TYPE__ns1__sendDataForStationNumberResponse;
			return soap_in__ns1__sendDataForStationNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendDataForStationNumber"))
		{	*type = SOAP_TYPE__ns1__sendDataForStationNumber;
			return soap_in__ns1__sendDataForStationNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkEmpForStationNumberResponse"))
		{	*type = SOAP_TYPE__ns1__checkEmpForStationNumberResponse;
			return soap_in__ns1__checkEmpForStationNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkEmpForStationNumber"))
		{	*type = SOAP_TYPE__ns1__checkEmpForStationNumber;
			return soap_in__ns1__checkEmpForStationNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSN_StationNumberResponse"))
		{	*type = SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse;
			return soap_in__ns1__checkSN_USCOREStationNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSN_StationNumber"))
		{	*type = SOAP_TYPE__ns1__checkSN_USCOREStationNumber;
			return soap_in__ns1__checkSN_USCOREStationNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnNextMoResponse"))
		{	*type = SOAP_TYPE__ns1__ChkSnNextMoResponse;
			return soap_in__ns1__ChkSnNextMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnNextMo"))
		{	*type = SOAP_TYPE__ns1__ChkSnNextMo;
			return soap_in__ns1__ChkSnNextMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnMoResponse"))
		{	*type = SOAP_TYPE__ns1__ChkSnMoResponse;
			return soap_in__ns1__ChkSnMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnMo"))
		{	*type = SOAP_TYPE__ns1__ChkSnMo;
			return soap_in__ns1__ChkSnMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkMoStationResponse"))
		{	*type = SOAP_TYPE__ns1__chkMoStationResponse;
			return soap_in__ns1__chkMoStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkMoStation"))
		{	*type = SOAP_TYPE__ns1__chkMoStation;
			return soap_in__ns1__chkMoStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetEnergyStatResponse"))
		{	*type = SOAP_TYPE__ns1__SetEnergyStatResponse;
			return soap_in__ns1__SetEnergyStatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetEnergyStat"))
		{	*type = SOAP_TYPE__ns1__SetEnergyStat;
			return soap_in__ns1__SetEnergyStat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInfoByMoResponse"))
		{	*type = SOAP_TYPE__ns1__getInfoByMoResponse;
			return soap_in__ns1__getInfoByMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInfoByMo"))
		{	*type = SOAP_TYPE__ns1__getInfoByMo;
			return soap_in__ns1__getInfoByMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsThermalNewResponse"))
		{	*type = SOAP_TYPE__ns1__InsThermalNewResponse;
			return soap_in__ns1__InsThermalNewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsThermalNew"))
		{	*type = SOAP_TYPE__ns1__InsThermalNew;
			return soap_in__ns1__InsThermalNew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnLinkResponse"))
		{	*type = SOAP_TYPE__ns1__ChkSnLinkResponse;
			return soap_in__ns1__ChkSnLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnLink"))
		{	*type = SOAP_TYPE__ns1__ChkSnLink;
			return soap_in__ns1__ChkSnLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsThermalResponse"))
		{	*type = SOAP_TYPE__ns1__InsThermalResponse;
			return soap_in__ns1__InsThermalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsThermal"))
		{	*type = SOAP_TYPE__ns1__InsThermal;
			return soap_in__ns1__InsThermal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsWHDetectionResponse"))
		{	*type = SOAP_TYPE__ns1__InsWHDetectionResponse;
			return soap_in__ns1__InsWHDetectionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsWHDetection"))
		{	*type = SOAP_TYPE__ns1__InsWHDetection;
			return soap_in__ns1__InsWHDetection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFlatNessForCLResponse"))
		{	*type = SOAP_TYPE__ns1__InsFlatNessForCLResponse;
			return soap_in__ns1__InsFlatNessForCLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFlatNessForCL"))
		{	*type = SOAP_TYPE__ns1__InsFlatNessForCL;
			return soap_in__ns1__InsFlatNessForCL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFlatNessForLSDResponse"))
		{	*type = SOAP_TYPE__ns1__InsFlatNessForLSDResponse;
			return soap_in__ns1__InsFlatNessForLSDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFlatNessForLSD"))
		{	*type = SOAP_TYPE__ns1__InsFlatNessForLSD;
			return soap_in__ns1__InsFlatNessForLSD(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFlatNessResponse"))
		{	*type = SOAP_TYPE__ns1__InsFlatNessResponse;
			return soap_in__ns1__InsFlatNessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFlatNess"))
		{	*type = SOAP_TYPE__ns1__InsFlatNess;
			return soap_in__ns1__InsFlatNess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ImpMesAteTestDataResponse"))
		{	*type = SOAP_TYPE__ns1__ImpMesAteTestDataResponse;
			return soap_in__ns1__ImpMesAteTestDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ImpMesAteTestData"))
		{	*type = SOAP_TYPE__ns1__ImpMesAteTestData;
			return soap_in__ns1__ImpMesAteTestData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkStationTimeResponse"))
		{	*type = SOAP_TYPE__ns1__chkStationTimeResponse;
			return soap_in__ns1__chkStationTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkStationTime"))
		{	*type = SOAP_TYPE__ns1__chkStationTime;
			return soap_in__ns1__chkStationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InFruitsOrtQtyResponse"))
		{	*type = SOAP_TYPE__ns1__InFruitsOrtQtyResponse;
			return soap_in__ns1__InFruitsOrtQtyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InFruitsOrtQty"))
		{	*type = SOAP_TYPE__ns1__InFruitsOrtQty;
			return soap_in__ns1__InFruitsOrtQty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendTestResultResponse"))
		{	*type = SOAP_TYPE__ns1__sendTestResultResponse;
			return soap_in__ns1__sendTestResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendTestResult"))
		{	*type = SOAP_TYPE__ns1__sendTestResult;
			return soap_in__ns1__sendTestResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendTestDataResponse"))
		{	*type = SOAP_TYPE__ns1__sendTestDataResponse;
			return soap_in__ns1__sendTestDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendTestData"))
		{	*type = SOAP_TYPE__ns1__sendTestData;
			return soap_in__ns1__sendTestData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSN_StationResponse"))
		{	*type = SOAP_TYPE__ns1__checkSN_USCOREStationResponse;
			return soap_in__ns1__checkSN_USCOREStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSN_Station"))
		{	*type = SOAP_TYPE__ns1__checkSN_USCOREStation;
			return soap_in__ns1__checkSN_USCOREStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkEmpNoResponse"))
		{	*type = SOAP_TYPE__ns1__checkEmpNoResponse;
			return soap_in__ns1__checkEmpNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkEmpNo"))
		{	*type = SOAP_TYPE__ns1__checkEmpNo;
			return soap_in__ns1__checkEmpNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkTestDataResponse"))
		{	*type = SOAP_TYPE__ns1__checkTestDataResponse;
			return soap_in__ns1__checkTestDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkTestData"))
		{	*type = SOAP_TYPE__ns1__checkTestData;
			return soap_in__ns1__checkTestData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsZjListResponse"))
		{	*type = SOAP_TYPE__ns1__InsZjListResponse;
			return soap_in__ns1__InsZjListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsZjList"))
		{	*type = SOAP_TYPE__ns1__InsZjList;
			return soap_in__ns1__InsZjList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFruitMachineChkResponse"))
		{	*type = SOAP_TYPE__ns1__GetFruitMachineChkResponse;
			return soap_in__ns1__GetFruitMachineChkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFruitMachineChk"))
		{	*type = SOAP_TYPE__ns1__GetFruitMachineChk;
			return soap_in__ns1__GetFruitMachineChk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFruitMachineChkResponse"))
		{	*type = SOAP_TYPE__ns1__InsFruitMachineChkResponse;
			return soap_in__ns1__InsFruitMachineChkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsFruitMachineChk"))
		{	*type = SOAP_TYPE__ns1__InsFruitMachineChk;
			return soap_in__ns1__InsFruitMachineChk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnLnkOutSNResponse"))
		{	*type = SOAP_TYPE__ns1__SnLnkOutSNResponse;
			return soap_in__ns1__SnLnkOutSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnLnkOutSN"))
		{	*type = SOAP_TYPE__ns1__SnLnkOutSN;
			return soap_in__ns1__SnLnkOutSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoBaseResponse"))
		{	*type = SOAP_TYPE__ns1__getMoBaseResponse;
			return soap_in__ns1__getMoBaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMoBase"))
		{	*type = SOAP_TYPE__ns1__getMoBase;
			return soap_in__ns1__getMoBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNgCodeResponse"))
		{	*type = SOAP_TYPE__ns1__GetNgCodeResponse;
			return soap_in__ns1__GetNgCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNgCode"))
		{	*type = SOAP_TYPE__ns1__GetNgCode;
			return soap_in__ns1__GetNgCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDiecastSNResponse"))
		{	*type = SOAP_TYPE__ns1__SetDiecastSNResponse;
			return soap_in__ns1__SetDiecastSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDiecastSN"))
		{	*type = SOAP_TYPE__ns1__SetDiecastSN;
			return soap_in__ns1__SetDiecastSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMachineForGroupResponse"))
		{	*type = SOAP_TYPE__ns1__GetMachineForGroupResponse;
			return soap_in__ns1__GetMachineForGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMachineForGroup"))
		{	*type = SOAP_TYPE__ns1__GetMachineForGroup;
			return soap_in__ns1__GetMachineForGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadForHPResponse"))
		{	*type = SOAP_TYPE__ns1__UploadForHPResponse;
			return soap_in__ns1__UploadForHPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadForHP"))
		{	*type = SOAP_TYPE__ns1__UploadForHP;
			return soap_in__ns1__UploadForHP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelShelfLinkResponse"))
		{	*type = SOAP_TYPE__ns1__SelShelfLinkResponse;
			return soap_in__ns1__SelShelfLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelShelfLink"))
		{	*type = SOAP_TYPE__ns1__SelShelfLink;
			return soap_in__ns1__SelShelfLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SNLinkShelfResponse"))
		{	*type = SOAP_TYPE__ns1__SNLinkShelfResponse;
			return soap_in__ns1__SNLinkShelfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SNLinkShelf"))
		{	*type = SOAP_TYPE__ns1__SNLinkShelf;
			return soap_in__ns1__SNLinkShelf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelSNTestForFruitResponse"))
		{	*type = SOAP_TYPE__ns1__SelSNTestForFruitResponse;
			return soap_in__ns1__SelSNTestForFruitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelSNTestForFruit"))
		{	*type = SOAP_TYPE__ns1__SelSNTestForFruit;
			return soap_in__ns1__SelSNTestForFruit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsSNTestForFruitResponse"))
		{	*type = SOAP_TYPE__ns1__InsSNTestForFruitResponse;
			return soap_in__ns1__InsSNTestForFruitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsSNTestForFruit"))
		{	*type = SOAP_TYPE__ns1__InsSNTestForFruit;
			return soap_in__ns1__InsSNTestForFruit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStationNumberForSNResponse"))
		{	*type = SOAP_TYPE__ns1__GetStationNumberForSNResponse;
			return soap_in__ns1__GetStationNumberForSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStationNumberForSN"))
		{	*type = SOAP_TYPE__ns1__GetStationNumberForSN;
			return soap_in__ns1__GetStationNumberForSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTestValueResultResponse"))
		{	*type = SOAP_TYPE__ns1__GetTestValueResultResponse;
			return soap_in__ns1__GetTestValueResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTestValueResult"))
		{	*type = SOAP_TYPE__ns1__GetTestValueResult;
			return soap_in__ns1__GetTestValueResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsCLScadaResponse"))
		{	*type = SOAP_TYPE__ns1__InsCLScadaResponse;
			return soap_in__ns1__InsCLScadaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsCLScada"))
		{	*type = SOAP_TYPE__ns1__InsCLScada;
			return soap_in__ns1__InsCLScada(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsAoiMoResponse"))
		{	*type = SOAP_TYPE__ns1__InsAoiMoResponse;
			return soap_in__ns1__InsAoiMoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsAoiMo"))
		{	*type = SOAP_TYPE__ns1__InsAoiMo;
			return soap_in__ns1__InsAoiMo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkMoSNForAOIResponse"))
		{	*type = SOAP_TYPE__ns1__chkMoSNForAOIResponse;
			return soap_in__ns1__chkMoSNForAOIResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:chkMoSNForAOI"))
		{	*type = SOAP_TYPE__ns1__chkMoSNForAOI;
			return soap_in__ns1__chkMoSNForAOI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PunchOutResponse"))
		{	*type = SOAP_TYPE__ns1__PunchOutResponse;
			return soap_in__ns1__PunchOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PunchOut"))
		{	*type = SOAP_TYPE__ns1__PunchOut;
			return soap_in__ns1__PunchOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BasketLinkPunchResponse"))
		{	*type = SOAP_TYPE__ns1__BasketLinkPunchResponse;
			return soap_in__ns1__BasketLinkPunchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BasketLinkPunch"))
		{	*type = SOAP_TYPE__ns1__BasketLinkPunch;
			return soap_in__ns1__BasketLinkPunch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HPSNLinkBasketResponse"))
		{	*type = SOAP_TYPE__ns1__HPSNLinkBasketResponse;
			return soap_in__ns1__HPSNLinkBasketResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HPSNLinkBasket"))
		{	*type = SOAP_TYPE__ns1__HPSNLinkBasket;
			return soap_in__ns1__HPSNLinkBasket(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetAutoLineRecResponse"))
		{	*type = SOAP_TYPE__ns1__SetAutoLineRecResponse;
			return soap_in__ns1__SetAutoLineRecResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetAutoLineRec"))
		{	*type = SOAP_TYPE__ns1__SetAutoLineRec;
			return soap_in__ns1__SetAutoLineRec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSNForLinkResponse"))
		{	*type = SOAP_TYPE__ns1__GetSNForLinkResponse;
			return soap_in__ns1__GetSNForLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSNForLink"))
		{	*type = SOAP_TYPE__ns1__GetSNForLink;
			return soap_in__ns1__GetSNForLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetFlatnessFruitRecResponse"))
		{	*type = SOAP_TYPE__ns1__SetFlatnessFruitRecResponse;
			return soap_in__ns1__SetFlatnessFruitRecResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetFlatnessFruitRec"))
		{	*type = SOAP_TYPE__ns1__SetFlatnessFruitRec;
			return soap_in__ns1__SetFlatnessFruitRec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStationByMoForTestPadResponse"))
		{	*type = SOAP_TYPE__ns1__getStationByMoForTestPadResponse;
			return soap_in__ns1__getStationByMoForTestPadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStationByMoForTestPad"))
		{	*type = SOAP_TYPE__ns1__getStationByMoForTestPad;
			return soap_in__ns1__getStationByMoForTestPad(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingWeightResponse"))
		{	*type = SOAP_TYPE__ns1__GetShippingWeightResponse;
			return soap_in__ns1__GetShippingWeightResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingWeight"))
		{	*type = SOAP_TYPE__ns1__GetShippingWeight;
			return soap_in__ns1__GetShippingWeight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingForBerthResponse"))
		{	*type = SOAP_TYPE__ns1__GetShippingForBerthResponse;
			return soap_in__ns1__GetShippingForBerthResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingForBerth"))
		{	*type = SOAP_TYPE__ns1__GetShippingForBerth;
			return soap_in__ns1__GetShippingForBerth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsShippingBerthResponse"))
		{	*type = SOAP_TYPE__ns1__InsShippingBerthResponse;
			return soap_in__ns1__InsShippingBerthResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsShippingBerth"))
		{	*type = SOAP_TYPE__ns1__InsShippingBerth;
			return soap_in__ns1__InsShippingBerth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsShippingPalleResponse"))
		{	*type = SOAP_TYPE__ns1__InsShippingPalleResponse;
			return soap_in__ns1__InsShippingPalleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsShippingPalle"))
		{	*type = SOAP_TYPE__ns1__InsShippingPalle;
			return soap_in__ns1__InsShippingPalle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingPalleResponse"))
		{	*type = SOAP_TYPE__ns1__GetShippingPalleResponse;
			return soap_in__ns1__GetShippingPalleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingPalle"))
		{	*type = SOAP_TYPE__ns1__GetShippingPalle;
			return soap_in__ns1__GetShippingPalle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdShippingResponse"))
		{	*type = SOAP_TYPE__ns1__UpdShippingResponse;
			return soap_in__ns1__UpdShippingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdShipping"))
		{	*type = SOAP_TYPE__ns1__UpdShipping;
			return soap_in__ns1__UpdShipping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingBerthListResponse"))
		{	*type = SOAP_TYPE__ns1__GetShippingBerthListResponse;
			return soap_in__ns1__GetShippingBerthListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingBerthList"))
		{	*type = SOAP_TYPE__ns1__GetShippingBerthList;
			return soap_in__ns1__GetShippingBerthList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingListResponse"))
		{	*type = SOAP_TYPE__ns1__GetShippingListResponse;
			return soap_in__ns1__GetShippingListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShippingList"))
		{	*type = SOAP_TYPE__ns1__GetShippingList;
			return soap_in__ns1__GetShippingList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doLotLinkForAppleResponse"))
		{	*type = SOAP_TYPE__ns1__doLotLinkForAppleResponse;
			return soap_in__ns1__doLotLinkForAppleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doLotLinkForApple"))
		{	*type = SOAP_TYPE__ns1__doLotLinkForApple;
			return soap_in__ns1__doLotLinkForApple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotLinkCountResponse"))
		{	*type = SOAP_TYPE__ns1__GetLotLinkCountResponse;
			return soap_in__ns1__GetLotLinkCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotLinkCount"))
		{	*type = SOAP_TYPE__ns1__GetLotLinkCount;
			return soap_in__ns1__GetLotLinkCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFruitSNCheckResponse"))
		{	*type = SOAP_TYPE__ns1__GetFruitSNCheckResponse;
			return soap_in__ns1__GetFruitSNCheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFruitSNCheck"))
		{	*type = SOAP_TYPE__ns1__GetFruitSNCheck;
			return soap_in__ns1__GetFruitSNCheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObeNWResponse"))
		{	*type = SOAP_TYPE__ns1__GetObeNWResponse;
			return soap_in__ns1__GetObeNWResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObeNW"))
		{	*type = SOAP_TYPE__ns1__GetObeNW;
			return soap_in__ns1__GetObeNW(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doSnLinkForAppleResponse"))
		{	*type = SOAP_TYPE__ns1__doSnLinkForAppleResponse;
			return soap_in__ns1__doSnLinkForAppleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doSnLinkForApple"))
		{	*type = SOAP_TYPE__ns1__doSnLinkForApple;
			return soap_in__ns1__doSnLinkForApple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnLinkForAppleResponse"))
		{	*type = SOAP_TYPE__ns1__ChkSnLinkForAppleResponse;
			return soap_in__ns1__ChkSnLinkForAppleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkSnLinkForApple"))
		{	*type = SOAP_TYPE__ns1__ChkSnLinkForApple;
			return soap_in__ns1__ChkSnLinkForApple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DelSNTestResponse"))
		{	*type = SOAP_TYPE__ns1__DelSNTestResponse;
			return soap_in__ns1__DelSNTestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DelSNTest"))
		{	*type = SOAP_TYPE__ns1__DelSNTest;
			return soap_in__ns1__DelSNTest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelSNTestResponse"))
		{	*type = SOAP_TYPE__ns1__SelSNTestResponse;
			return soap_in__ns1__SelSNTestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelSNTest"))
		{	*type = SOAP_TYPE__ns1__SelSNTest;
			return soap_in__ns1__SelSNTest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsSNTestResponse"))
		{	*type = SOAP_TYPE__ns1__InsSNTestResponse;
			return soap_in__ns1__InsSNTestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsSNTest"))
		{	*type = SOAP_TYPE__ns1__InsSNTest;
			return soap_in__ns1__InsSNTest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkWeightTimeResponse"))
		{	*type = SOAP_TYPE__ns1__ChkWeightTimeResponse;
			return soap_in__ns1__ChkWeightTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChkWeightTime"))
		{	*type = SOAP_TYPE__ns1__ChkWeightTime;
			return soap_in__ns1__ChkWeightTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdAhsBarcodeResponse"))
		{	*type = SOAP_TYPE__ns1__UpdAhsBarcodeResponse;
			return soap_in__ns1__UpdAhsBarcodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdAhsBarcode"))
		{	*type = SOAP_TYPE__ns1__UpdAhsBarcode;
			return soap_in__ns1__UpdAhsBarcode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAhsBarcodeResponse"))
		{	*type = SOAP_TYPE__ns1__GetAhsBarcodeResponse;
			return soap_in__ns1__GetAhsBarcodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAhsBarcode"))
		{	*type = SOAP_TYPE__ns1__GetAhsBarcode;
			return soap_in__ns1__GetAhsBarcode(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult:
		return ((_ns1__GetAhsMoResponse_GetAhsMoResult *)ptr)->soap_out(soap, "ns1:GetAhsMoResponse-GetAhsMoResult", id, "");
	case SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		return ((_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *)ptr)->soap_out(soap, "ns1:GetPallentToWMSResponse-GetPallentToWMSResult", id, "");
	case SOAP_TYPE__ns1__doLinkOutSN_assyDt:
		return ((_ns1__doLinkOutSN_assyDt *)ptr)->soap_out(soap, "ns1:doLinkOutSN-assyDt", id, "");
	case SOAP_TYPE__ns1__doPmcSNLink_assyDt:
		return ((_ns1__doPmcSNLink_assyDt *)ptr)->soap_out(soap, "ns1:doPmcSNLink-assyDt", id, "");
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		return ((_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *)ptr)->soap_out(soap, "ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult", id, "");
	case SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult:
		return ((_ns1__getPmcAssyListResponse_getPmcAssyListResult *)ptr)->soap_out(soap, "ns1:getPmcAssyListResponse-getPmcAssyListResult", id, "");
	case SOAP_TYPE__ns1__doAssy_assyDt:
		return ((_ns1__doAssy_assyDt *)ptr)->soap_out(soap, "ns1:doAssy-assyDt", id, "");
	case SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		return ((_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *)ptr)->soap_out(soap, "ns1:GetLinkOutSnResponse-GetLinkOutSnResult", id, "");
	case SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult:
		return ((_ns1__getPartBomExtResponse_getPartBomExtResult *)ptr)->soap_out(soap, "ns1:getPartBomExtResponse-getPartBomExtResult", id, "");
	case SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult:
		return ((_ns1__getMoAssyListResponse_getMoAssyListResult *)ptr)->soap_out(soap, "ns1:getMoAssyListResponse-getMoAssyListResult", id, "");
	case SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult:
		return ((_ns1__getInfoByMoResponse_getInfoByMoResult *)ptr)->soap_out(soap, "ns1:getInfoByMoResponse-getInfoByMoResult", id, "");
	case SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		return ((_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *)ptr)->soap_out(soap, "ns1:GetMachineForGroupResponse-GetMachineForGroupResult", id, "");
	case SOAP_TYPE__ns1__SetFlatnessFruitRec_dt:
		return ((_ns1__SetFlatnessFruitRec_dt *)ptr)->soap_out(soap, "ns1:SetFlatnessFruitRec-dt", id, "");
	case SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult:
		return ((_ns1__GetShippingWeightResponse_GetShippingWeightResult *)ptr)->soap_out(soap, "ns1:GetShippingWeightResponse-GetShippingWeightResult", id, "");
	case SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		return ((_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *)ptr)->soap_out(soap, "ns1:GetShippingForBerthResponse-GetShippingForBerthResult", id, "");
	case SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		return ((_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *)ptr)->soap_out(soap, "ns1:GetShippingBerthListResponse-GetShippingBerthListResult", id, "");
	case SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult:
		return ((_ns1__GetShippingListResponse_GetShippingListResult *)ptr)->soap_out(soap, "ns1:GetShippingListResponse-GetShippingListResult", id, "");
	case SOAP_TYPE__ns1__doLotLinkForApple_assyDt:
		return ((_ns1__doLotLinkForApple_assyDt *)ptr)->soap_out(soap, "ns1:doLotLinkForApple-assyDt", id, "");
	case SOAP_TYPE__ns1__doSnLinkForApple_assyDt:
		return ((_ns1__doSnLinkForApple_assyDt *)ptr)->soap_out(soap, "ns1:doSnLinkForApple-assyDt", id, "");
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		return ((_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *)ptr)->soap_out(soap, "ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult", id, "");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__GetAhsMoResponse:
		return ((_ns1__GetAhsMoResponse *)ptr)->soap_out(soap, "ns1:GetAhsMoResponse", id, "");
	case SOAP_TYPE__ns1__GetAhsMo:
		return ((_ns1__GetAhsMo *)ptr)->soap_out(soap, "ns1:GetAhsMo", id, "");
	case SOAP_TYPE__ns1__GetPackWeigthResponse:
		return ((_ns1__GetPackWeigthResponse *)ptr)->soap_out(soap, "ns1:GetPackWeigthResponse", id, "");
	case SOAP_TYPE__ns1__GetPackWeigth:
		return ((_ns1__GetPackWeigth *)ptr)->soap_out(soap, "ns1:GetPackWeigth", id, "");
	case SOAP_TYPE__ns1__GetPackStationResponse:
		return ((_ns1__GetPackStationResponse *)ptr)->soap_out(soap, "ns1:GetPackStationResponse", id, "");
	case SOAP_TYPE__ns1__GetPackStation:
		return ((_ns1__GetPackStation *)ptr)->soap_out(soap, "ns1:GetPackStation", id, "");
	case SOAP_TYPE__ns1__SetPallentForWMSResponse:
		return ((_ns1__SetPallentForWMSResponse *)ptr)->soap_out(soap, "ns1:SetPallentForWMSResponse", id, "");
	case SOAP_TYPE__ns1__SetPallentForWMS:
		return ((_ns1__SetPallentForWMS *)ptr)->soap_out(soap, "ns1:SetPallentForWMS", id, "");
	case SOAP_TYPE__ns1__GetPallentToWMSResponse:
		return ((_ns1__GetPallentToWMSResponse *)ptr)->soap_out(soap, "ns1:GetPallentToWMSResponse", id, "");
	case SOAP_TYPE__ns1__GetPallentToWMS:
		return ((_ns1__GetPallentToWMS *)ptr)->soap_out(soap, "ns1:GetPallentToWMS", id, "");
	case SOAP_TYPE__ns1__GetPackToWMSResponse:
		return ((_ns1__GetPackToWMSResponse *)ptr)->soap_out(soap, "ns1:GetPackToWMSResponse", id, "");
	case SOAP_TYPE__ns1__GetPackToWMS:
		return ((_ns1__GetPackToWMS *)ptr)->soap_out(soap, "ns1:GetPackToWMS", id, "");
	case SOAP_TYPE__ns1__GetWeightSetResponse:
		return ((_ns1__GetWeightSetResponse *)ptr)->soap_out(soap, "ns1:GetWeightSetResponse", id, "");
	case SOAP_TYPE__ns1__GetWeightSet:
		return ((_ns1__GetWeightSet *)ptr)->soap_out(soap, "ns1:GetWeightSet", id, "");
	case SOAP_TYPE__ns1__CancelLnkSNResponse:
		return ((_ns1__CancelLnkSNResponse *)ptr)->soap_out(soap, "ns1:CancelLnkSNResponse", id, "");
	case SOAP_TYPE__ns1__CancelLnkSN:
		return ((_ns1__CancelLnkSN *)ptr)->soap_out(soap, "ns1:CancelLnkSN", id, "");
	case SOAP_TYPE__ns1__CancelGrillSNResponse:
		return ((_ns1__CancelGrillSNResponse *)ptr)->soap_out(soap, "ns1:CancelGrillSNResponse", id, "");
	case SOAP_TYPE__ns1__CancelGrillSN:
		return ((_ns1__CancelGrillSN *)ptr)->soap_out(soap, "ns1:CancelGrillSN", id, "");
	case SOAP_TYPE__ns1__OutGrillBySNResponse:
		return ((_ns1__OutGrillBySNResponse *)ptr)->soap_out(soap, "ns1:OutGrillBySNResponse", id, "");
	case SOAP_TYPE__ns1__OutGrillBySN:
		return ((_ns1__OutGrillBySN *)ptr)->soap_out(soap, "ns1:OutGrillBySN", id, "");
	case SOAP_TYPE__ns1__GetGrillTimeResponse:
		return ((_ns1__GetGrillTimeResponse *)ptr)->soap_out(soap, "ns1:GetGrillTimeResponse", id, "");
	case SOAP_TYPE__ns1__GetGrillTime:
		return ((_ns1__GetGrillTime *)ptr)->soap_out(soap, "ns1:GetGrillTime", id, "");
	case SOAP_TYPE__ns1__InsGrillBySNResponse:
		return ((_ns1__InsGrillBySNResponse *)ptr)->soap_out(soap, "ns1:InsGrillBySNResponse", id, "");
	case SOAP_TYPE__ns1__InsGrillBySN:
		return ((_ns1__InsGrillBySN *)ptr)->soap_out(soap, "ns1:InsGrillBySN", id, "");
	case SOAP_TYPE__ns1__CloseGrillSNResponse:
		return ((_ns1__CloseGrillSNResponse *)ptr)->soap_out(soap, "ns1:CloseGrillSNResponse", id, "");
	case SOAP_TYPE__ns1__CloseGrillSN:
		return ((_ns1__CloseGrillSN *)ptr)->soap_out(soap, "ns1:CloseGrillSN", id, "");
	case SOAP_TYPE__ns1__LnkGrillSNResponse:
		return ((_ns1__LnkGrillSNResponse *)ptr)->soap_out(soap, "ns1:LnkGrillSNResponse", id, "");
	case SOAP_TYPE__ns1__LnkGrillSN:
		return ((_ns1__LnkGrillSN *)ptr)->soap_out(soap, "ns1:LnkGrillSN", id, "");
	case SOAP_TYPE__ns1__chkGrillSNResponse:
		return ((_ns1__chkGrillSNResponse *)ptr)->soap_out(soap, "ns1:chkGrillSNResponse", id, "");
	case SOAP_TYPE__ns1__chkGrillSN:
		return ((_ns1__chkGrillSN *)ptr)->soap_out(soap, "ns1:chkGrillSN", id, "");
	case SOAP_TYPE__ns1__LnkSideSNResponse:
		return ((_ns1__LnkSideSNResponse *)ptr)->soap_out(soap, "ns1:LnkSideSNResponse", id, "");
	case SOAP_TYPE__ns1__LnkSideSN:
		return ((_ns1__LnkSideSN *)ptr)->soap_out(soap, "ns1:LnkSideSN", id, "");
	case SOAP_TYPE__ns1__LnkZJSNResponse:
		return ((_ns1__LnkZJSNResponse *)ptr)->soap_out(soap, "ns1:LnkZJSNResponse", id, "");
	case SOAP_TYPE__ns1__LnkZJSN:
		return ((_ns1__LnkZJSN *)ptr)->soap_out(soap, "ns1:LnkZJSN", id, "");
	case SOAP_TYPE__ns1__chkZJSNResponse:
		return ((_ns1__chkZJSNResponse *)ptr)->soap_out(soap, "ns1:chkZJSNResponse", id, "");
	case SOAP_TYPE__ns1__chkZJSN:
		return ((_ns1__chkZJSN *)ptr)->soap_out(soap, "ns1:chkZJSN", id, "");
	case SOAP_TYPE__ns1__chkDispensingResponse:
		return ((_ns1__chkDispensingResponse *)ptr)->soap_out(soap, "ns1:chkDispensingResponse", id, "");
	case SOAP_TYPE__ns1__chkDispensing:
		return ((_ns1__chkDispensing *)ptr)->soap_out(soap, "ns1:chkDispensing", id, "");
	case SOAP_TYPE__ns1__InsIotTestDataResponse:
		return ((_ns1__InsIotTestDataResponse *)ptr)->soap_out(soap, "ns1:InsIotTestDataResponse", id, "");
	case SOAP_TYPE__ns1__InsIotTestData:
		return ((_ns1__InsIotTestData *)ptr)->soap_out(soap, "ns1:InsIotTestData", id, "");
	case SOAP_TYPE__ns1__InsIotMachineRecResponse:
		return ((_ns1__InsIotMachineRecResponse *)ptr)->soap_out(soap, "ns1:InsIotMachineRecResponse", id, "");
	case SOAP_TYPE__ns1__InsIotMachineRec:
		return ((_ns1__InsIotMachineRec *)ptr)->soap_out(soap, "ns1:InsIotMachineRec", id, "");
	case SOAP_TYPE__ns1__GetLnkDataResponse:
		return ((_ns1__GetLnkDataResponse *)ptr)->soap_out(soap, "ns1:GetLnkDataResponse", id, "");
	case SOAP_TYPE__ns1__GetLnkData:
		return ((_ns1__GetLnkData *)ptr)->soap_out(soap, "ns1:GetLnkData", id, "");
	case SOAP_TYPE__ns1__GetTestValueResponse:
		return ((_ns1__GetTestValueResponse *)ptr)->soap_out(soap, "ns1:GetTestValueResponse", id, "");
	case SOAP_TYPE__ns1__GetTestValue:
		return ((_ns1__GetTestValue *)ptr)->soap_out(soap, "ns1:GetTestValue", id, "");
	case SOAP_TYPE__ns1__GetMoBaseResponse:
		return ((_ns1__GetMoBaseResponse *)ptr)->soap_out(soap, "ns1:GetMoBaseResponse", id, "");
	case SOAP_TYPE__ns1__GetMoBase:
		return ((_ns1__GetMoBase *)ptr)->soap_out(soap, "ns1:GetMoBase", id, "");
	case SOAP_TYPE__ns1__UpdSnRecInfoResponse:
		return ((_ns1__UpdSnRecInfoResponse *)ptr)->soap_out(soap, "ns1:UpdSnRecInfoResponse", id, "");
	case SOAP_TYPE__ns1__UpdSnRecInfo:
		return ((_ns1__UpdSnRecInfo *)ptr)->soap_out(soap, "ns1:UpdSnRecInfo", id, "");
	case SOAP_TYPE__ns1__InsBoxInfoResponse:
		return ((_ns1__InsBoxInfoResponse *)ptr)->soap_out(soap, "ns1:InsBoxInfoResponse", id, "");
	case SOAP_TYPE__ns1__InsBoxInfo:
		return ((_ns1__InsBoxInfo *)ptr)->soap_out(soap, "ns1:InsBoxInfo", id, "");
	case SOAP_TYPE__ns1__InsLnkOutSNResponse:
		return ((_ns1__InsLnkOutSNResponse *)ptr)->soap_out(soap, "ns1:InsLnkOutSNResponse", id, "");
	case SOAP_TYPE__ns1__InsLnkOutSN:
		return ((_ns1__InsLnkOutSN *)ptr)->soap_out(soap, "ns1:InsLnkOutSN", id, "");
	case SOAP_TYPE__ns1__InsSNStationEmpResponse:
		return ((_ns1__InsSNStationEmpResponse *)ptr)->soap_out(soap, "ns1:InsSNStationEmpResponse", id, "");
	case SOAP_TYPE__ns1__InsSNStationEmp:
		return ((_ns1__InsSNStationEmp *)ptr)->soap_out(soap, "ns1:InsSNStationEmp", id, "");
	case SOAP_TYPE__ns1__CancelBoxLnkResponse:
		return ((_ns1__CancelBoxLnkResponse *)ptr)->soap_out(soap, "ns1:CancelBoxLnkResponse", id, "");
	case SOAP_TYPE__ns1__CancelBoxLnk:
		return ((_ns1__CancelBoxLnk *)ptr)->soap_out(soap, "ns1:CancelBoxLnk", id, "");
	case SOAP_TYPE__ns1__OutStationbyBoxResponse:
		return ((_ns1__OutStationbyBoxResponse *)ptr)->soap_out(soap, "ns1:OutStationbyBoxResponse", id, "");
	case SOAP_TYPE__ns1__OutStationbyBox:
		return ((_ns1__OutStationbyBox *)ptr)->soap_out(soap, "ns1:OutStationbyBox", id, "");
	case SOAP_TYPE__ns1__InStationbyBoxResponse:
		return ((_ns1__InStationbyBoxResponse *)ptr)->soap_out(soap, "ns1:InStationbyBoxResponse", id, "");
	case SOAP_TYPE__ns1__InStationbyBox:
		return ((_ns1__InStationbyBox *)ptr)->soap_out(soap, "ns1:InStationbyBox", id, "");
	case SOAP_TYPE__ns1__EndSNtoBoxResponse:
		return ((_ns1__EndSNtoBoxResponse *)ptr)->soap_out(soap, "ns1:EndSNtoBoxResponse", id, "");
	case SOAP_TYPE__ns1__EndSNtoBox:
		return ((_ns1__EndSNtoBox *)ptr)->soap_out(soap, "ns1:EndSNtoBox", id, "");
	case SOAP_TYPE__ns1__InSNtoBoxResponse:
		return ((_ns1__InSNtoBoxResponse *)ptr)->soap_out(soap, "ns1:InSNtoBoxResponse", id, "");
	case SOAP_TYPE__ns1__InSNtoBox:
		return ((_ns1__InSNtoBox *)ptr)->soap_out(soap, "ns1:InSNtoBox", id, "");
	case SOAP_TYPE__ns1__chkBoxNoResponse:
		return ((_ns1__chkBoxNoResponse *)ptr)->soap_out(soap, "ns1:chkBoxNoResponse", id, "");
	case SOAP_TYPE__ns1__chkBoxNo:
		return ((_ns1__chkBoxNo *)ptr)->soap_out(soap, "ns1:chkBoxNo", id, "");
	case SOAP_TYPE__ns1__InsBoxNOTimeResponse:
		return ((_ns1__InsBoxNOTimeResponse *)ptr)->soap_out(soap, "ns1:InsBoxNOTimeResponse", id, "");
	case SOAP_TYPE__ns1__InsBoxNOTime:
		return ((_ns1__InsBoxNOTime *)ptr)->soap_out(soap, "ns1:InsBoxNOTime", id, "");
	case SOAP_TYPE__ns1__GetLinkZJCountResponse:
		return ((_ns1__GetLinkZJCountResponse *)ptr)->soap_out(soap, "ns1:GetLinkZJCountResponse", id, "");
	case SOAP_TYPE__ns1__GetLinkZJCount:
		return ((_ns1__GetLinkZJCount *)ptr)->soap_out(soap, "ns1:GetLinkZJCount", id, "");
	case SOAP_TYPE__ns1__InsLinkSNResponse:
		return ((_ns1__InsLinkSNResponse *)ptr)->soap_out(soap, "ns1:InsLinkSNResponse", id, "");
	case SOAP_TYPE__ns1__InsLinkSN:
		return ((_ns1__InsLinkSN *)ptr)->soap_out(soap, "ns1:InsLinkSN", id, "");
	case SOAP_TYPE__ns1__doLinkOutSNResponse:
		return ((_ns1__doLinkOutSNResponse *)ptr)->soap_out(soap, "ns1:doLinkOutSNResponse", id, "");
	case SOAP_TYPE__ns1__doLinkOutSN:
		return ((_ns1__doLinkOutSN *)ptr)->soap_out(soap, "ns1:doLinkOutSN", id, "");
	case SOAP_TYPE__ns1__ChkLinkOutSNResponse:
		return ((_ns1__ChkLinkOutSNResponse *)ptr)->soap_out(soap, "ns1:ChkLinkOutSNResponse", id, "");
	case SOAP_TYPE__ns1__ChkLinkOutSN:
		return ((_ns1__ChkLinkOutSN *)ptr)->soap_out(soap, "ns1:ChkLinkOutSN", id, "");
	case SOAP_TYPE__ns1__chkOutSNResponse:
		return ((_ns1__chkOutSNResponse *)ptr)->soap_out(soap, "ns1:chkOutSNResponse", id, "");
	case SOAP_TYPE__ns1__chkOutSN:
		return ((_ns1__chkOutSN *)ptr)->soap_out(soap, "ns1:chkOutSN", id, "");
	case SOAP_TYPE__ns1__GetLintOutQtyResponse:
		return ((_ns1__GetLintOutQtyResponse *)ptr)->soap_out(soap, "ns1:GetLintOutQtyResponse", id, "");
	case SOAP_TYPE__ns1__GetLintOutQty:
		return ((_ns1__GetLintOutQty *)ptr)->soap_out(soap, "ns1:GetLintOutQty", id, "");
	case SOAP_TYPE__ns1__SNLinkZJResponse:
		return ((_ns1__SNLinkZJResponse *)ptr)->soap_out(soap, "ns1:SNLinkZJResponse", id, "");
	case SOAP_TYPE__ns1__SNLinkZJ:
		return ((_ns1__SNLinkZJ *)ptr)->soap_out(soap, "ns1:SNLinkZJ", id, "");
	case SOAP_TYPE__ns1__InsZJTestDataResponse:
		return ((_ns1__InsZJTestDataResponse *)ptr)->soap_out(soap, "ns1:InsZJTestDataResponse", id, "");
	case SOAP_TYPE__ns1__InsZJTestData:
		return ((_ns1__InsZJTestData *)ptr)->soap_out(soap, "ns1:InsZJTestData", id, "");
	case SOAP_TYPE__ns1__doPmcSNLinkResponse:
		return ((_ns1__doPmcSNLinkResponse *)ptr)->soap_out(soap, "ns1:doPmcSNLinkResponse", id, "");
	case SOAP_TYPE__ns1__doPmcSNLink:
		return ((_ns1__doPmcSNLink *)ptr)->soap_out(soap, "ns1:doPmcSNLink", id, "");
	case SOAP_TYPE__ns1__GetPmcSNPartResponse:
		return ((_ns1__GetPmcSNPartResponse *)ptr)->soap_out(soap, "ns1:GetPmcSNPartResponse", id, "");
	case SOAP_TYPE__ns1__GetPmcSNPart:
		return ((_ns1__GetPmcSNPart *)ptr)->soap_out(soap, "ns1:GetPmcSNPart", id, "");
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse:
		return ((_ns1__getPmcPartAssyListResponse *)ptr)->soap_out(soap, "ns1:getPmcPartAssyListResponse", id, "");
	case SOAP_TYPE__ns1__getPmcPartAssyList:
		return ((_ns1__getPmcPartAssyList *)ptr)->soap_out(soap, "ns1:getPmcPartAssyList", id, "");
	case SOAP_TYPE__ns1__getPmcAssyListResponse:
		return ((_ns1__getPmcAssyListResponse *)ptr)->soap_out(soap, "ns1:getPmcAssyListResponse", id, "");
	case SOAP_TYPE__ns1__getPmcAssyList:
		return ((_ns1__getPmcAssyList *)ptr)->soap_out(soap, "ns1:getPmcAssyList", id, "");
	case SOAP_TYPE__ns1__doAssyResponse:
		return ((_ns1__doAssyResponse *)ptr)->soap_out(soap, "ns1:doAssyResponse", id, "");
	case SOAP_TYPE__ns1__doAssy:
		return ((_ns1__doAssy *)ptr)->soap_out(soap, "ns1:doAssy", id, "");
	case SOAP_TYPE__ns1__chkAssySNResponse:
		return ((_ns1__chkAssySNResponse *)ptr)->soap_out(soap, "ns1:chkAssySNResponse", id, "");
	case SOAP_TYPE__ns1__chkAssySN:
		return ((_ns1__chkAssySN *)ptr)->soap_out(soap, "ns1:chkAssySN", id, "");
	case SOAP_TYPE__ns1__getPNbySNResponse:
		return ((_ns1__getPNbySNResponse *)ptr)->soap_out(soap, "ns1:getPNbySNResponse", id, "");
	case SOAP_TYPE__ns1__getPNbySN:
		return ((_ns1__getPNbySN *)ptr)->soap_out(soap, "ns1:getPNbySN", id, "");
	case SOAP_TYPE__ns1__getMoAssyCountResponse:
		return ((_ns1__getMoAssyCountResponse *)ptr)->soap_out(soap, "ns1:getMoAssyCountResponse", id, "");
	case SOAP_TYPE__ns1__getMoAssyCount:
		return ((_ns1__getMoAssyCount *)ptr)->soap_out(soap, "ns1:getMoAssyCount", id, "");
	case SOAP_TYPE__ns1__GetLinkOutSnResponse:
		return ((_ns1__GetLinkOutSnResponse *)ptr)->soap_out(soap, "ns1:GetLinkOutSnResponse", id, "");
	case SOAP_TYPE__ns1__GetLinkOutSn:
		return ((_ns1__GetLinkOutSn *)ptr)->soap_out(soap, "ns1:GetLinkOutSn", id, "");
	case SOAP_TYPE__ns1__InsPartAssyResponse:
		return ((_ns1__InsPartAssyResponse *)ptr)->soap_out(soap, "ns1:InsPartAssyResponse", id, "");
	case SOAP_TYPE__ns1__InsPartAssy:
		return ((_ns1__InsPartAssy *)ptr)->soap_out(soap, "ns1:InsPartAssy", id, "");
	case SOAP_TYPE__ns1__getPartBomExtResponse:
		return ((_ns1__getPartBomExtResponse *)ptr)->soap_out(soap, "ns1:getPartBomExtResponse", id, "");
	case SOAP_TYPE__ns1__getPartBomExt:
		return ((_ns1__getPartBomExt *)ptr)->soap_out(soap, "ns1:getPartBomExt", id, "");
	case SOAP_TYPE__ns1__getMoAssyListResponse:
		return ((_ns1__getMoAssyListResponse *)ptr)->soap_out(soap, "ns1:getMoAssyListResponse", id, "");
	case SOAP_TYPE__ns1__getMoAssyList:
		return ((_ns1__getMoAssyList *)ptr)->soap_out(soap, "ns1:getMoAssyList", id, "");
	case SOAP_TYPE__ns1__chkSnMappingResponse:
		return ((_ns1__chkSnMappingResponse *)ptr)->soap_out(soap, "ns1:chkSnMappingResponse", id, "");
	case SOAP_TYPE__ns1__chkSnMapping:
		return ((_ns1__chkSnMapping *)ptr)->soap_out(soap, "ns1:chkSnMapping", id, "");
	case SOAP_TYPE__ns1__getStationTypeDescResponse:
		return ((_ns1__getStationTypeDescResponse *)ptr)->soap_out(soap, "ns1:getStationTypeDescResponse", id, "");
	case SOAP_TYPE__ns1__getStationTypeDesc:
		return ((_ns1__getStationTypeDesc *)ptr)->soap_out(soap, "ns1:getStationTypeDesc", id, "");
	case SOAP_TYPE__ns1__getStationByMoResponse:
		return ((_ns1__getStationByMoResponse *)ptr)->soap_out(soap, "ns1:getStationByMoResponse", id, "");
	case SOAP_TYPE__ns1__getStationByMo:
		return ((_ns1__getStationByMo *)ptr)->soap_out(soap, "ns1:getStationByMo", id, "");
	case SOAP_TYPE__ns1__SnDoMappingResponse:
		return ((_ns1__SnDoMappingResponse *)ptr)->soap_out(soap, "ns1:SnDoMappingResponse", id, "");
	case SOAP_TYPE__ns1__SnDoMapping:
		return ((_ns1__SnDoMapping *)ptr)->soap_out(soap, "ns1:SnDoMapping", id, "");
	case SOAP_TYPE__ns1__eMesNextMoResponse:
		return ((_ns1__eMesNextMoResponse *)ptr)->soap_out(soap, "ns1:eMesNextMoResponse", id, "");
	case SOAP_TYPE__ns1__eMesNextMo:
		return ((_ns1__eMesNextMo *)ptr)->soap_out(soap, "ns1:eMesNextMo", id, "");
	case SOAP_TYPE__ns1__sendResultForStationNumberResponse:
		return ((_ns1__sendResultForStationNumberResponse *)ptr)->soap_out(soap, "ns1:sendResultForStationNumberResponse", id, "");
	case SOAP_TYPE__ns1__sendResultForStationNumber:
		return ((_ns1__sendResultForStationNumber *)ptr)->soap_out(soap, "ns1:sendResultForStationNumber", id, "");
	case SOAP_TYPE__ns1__sendDataForStationNumberResponse:
		return ((_ns1__sendDataForStationNumberResponse *)ptr)->soap_out(soap, "ns1:sendDataForStationNumberResponse", id, "");
	case SOAP_TYPE__ns1__sendDataForStationNumber:
		return ((_ns1__sendDataForStationNumber *)ptr)->soap_out(soap, "ns1:sendDataForStationNumber", id, "");
	case SOAP_TYPE__ns1__checkEmpForStationNumberResponse:
		return ((_ns1__checkEmpForStationNumberResponse *)ptr)->soap_out(soap, "ns1:checkEmpForStationNumberResponse", id, "");
	case SOAP_TYPE__ns1__checkEmpForStationNumber:
		return ((_ns1__checkEmpForStationNumber *)ptr)->soap_out(soap, "ns1:checkEmpForStationNumber", id, "");
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse:
		return ((_ns1__checkSN_USCOREStationNumberResponse *)ptr)->soap_out(soap, "ns1:checkSN_StationNumberResponse", id, "");
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumber:
		return ((_ns1__checkSN_USCOREStationNumber *)ptr)->soap_out(soap, "ns1:checkSN_StationNumber", id, "");
	case SOAP_TYPE__ns1__ChkSnNextMoResponse:
		return ((_ns1__ChkSnNextMoResponse *)ptr)->soap_out(soap, "ns1:ChkSnNextMoResponse", id, "");
	case SOAP_TYPE__ns1__ChkSnNextMo:
		return ((_ns1__ChkSnNextMo *)ptr)->soap_out(soap, "ns1:ChkSnNextMo", id, "");
	case SOAP_TYPE__ns1__ChkSnMoResponse:
		return ((_ns1__ChkSnMoResponse *)ptr)->soap_out(soap, "ns1:ChkSnMoResponse", id, "");
	case SOAP_TYPE__ns1__ChkSnMo:
		return ((_ns1__ChkSnMo *)ptr)->soap_out(soap, "ns1:ChkSnMo", id, "");
	case SOAP_TYPE__ns1__chkMoStationResponse:
		return ((_ns1__chkMoStationResponse *)ptr)->soap_out(soap, "ns1:chkMoStationResponse", id, "");
	case SOAP_TYPE__ns1__chkMoStation:
		return ((_ns1__chkMoStation *)ptr)->soap_out(soap, "ns1:chkMoStation", id, "");
	case SOAP_TYPE__ns1__SetEnergyStatResponse:
		return ((_ns1__SetEnergyStatResponse *)ptr)->soap_out(soap, "ns1:SetEnergyStatResponse", id, "");
	case SOAP_TYPE__ns1__SetEnergyStat:
		return ((_ns1__SetEnergyStat *)ptr)->soap_out(soap, "ns1:SetEnergyStat", id, "");
	case SOAP_TYPE__ns1__getInfoByMoResponse:
		return ((_ns1__getInfoByMoResponse *)ptr)->soap_out(soap, "ns1:getInfoByMoResponse", id, "");
	case SOAP_TYPE__ns1__getInfoByMo:
		return ((_ns1__getInfoByMo *)ptr)->soap_out(soap, "ns1:getInfoByMo", id, "");
	case SOAP_TYPE__ns1__InsThermalNewResponse:
		return ((_ns1__InsThermalNewResponse *)ptr)->soap_out(soap, "ns1:InsThermalNewResponse", id, "");
	case SOAP_TYPE__ns1__InsThermalNew:
		return ((_ns1__InsThermalNew *)ptr)->soap_out(soap, "ns1:InsThermalNew", id, "");
	case SOAP_TYPE__ns1__ChkSnLinkResponse:
		return ((_ns1__ChkSnLinkResponse *)ptr)->soap_out(soap, "ns1:ChkSnLinkResponse", id, "");
	case SOAP_TYPE__ns1__ChkSnLink:
		return ((_ns1__ChkSnLink *)ptr)->soap_out(soap, "ns1:ChkSnLink", id, "");
	case SOAP_TYPE__ns1__InsThermalResponse:
		return ((_ns1__InsThermalResponse *)ptr)->soap_out(soap, "ns1:InsThermalResponse", id, "");
	case SOAP_TYPE__ns1__InsThermal:
		return ((_ns1__InsThermal *)ptr)->soap_out(soap, "ns1:InsThermal", id, "");
	case SOAP_TYPE__ns1__InsWHDetectionResponse:
		return ((_ns1__InsWHDetectionResponse *)ptr)->soap_out(soap, "ns1:InsWHDetectionResponse", id, "");
	case SOAP_TYPE__ns1__InsWHDetection:
		return ((_ns1__InsWHDetection *)ptr)->soap_out(soap, "ns1:InsWHDetection", id, "");
	case SOAP_TYPE__ns1__InsFlatNessForCLResponse:
		return ((_ns1__InsFlatNessForCLResponse *)ptr)->soap_out(soap, "ns1:InsFlatNessForCLResponse", id, "");
	case SOAP_TYPE__ns1__InsFlatNessForCL:
		return ((_ns1__InsFlatNessForCL *)ptr)->soap_out(soap, "ns1:InsFlatNessForCL", id, "");
	case SOAP_TYPE__ns1__InsFlatNessForLSDResponse:
		return ((_ns1__InsFlatNessForLSDResponse *)ptr)->soap_out(soap, "ns1:InsFlatNessForLSDResponse", id, "");
	case SOAP_TYPE__ns1__InsFlatNessForLSD:
		return ((_ns1__InsFlatNessForLSD *)ptr)->soap_out(soap, "ns1:InsFlatNessForLSD", id, "");
	case SOAP_TYPE__ns1__InsFlatNessResponse:
		return ((_ns1__InsFlatNessResponse *)ptr)->soap_out(soap, "ns1:InsFlatNessResponse", id, "");
	case SOAP_TYPE__ns1__InsFlatNess:
		return ((_ns1__InsFlatNess *)ptr)->soap_out(soap, "ns1:InsFlatNess", id, "");
	case SOAP_TYPE__ns1__ImpMesAteTestDataResponse:
		return ((_ns1__ImpMesAteTestDataResponse *)ptr)->soap_out(soap, "ns1:ImpMesAteTestDataResponse", id, "");
	case SOAP_TYPE__ns1__ImpMesAteTestData:
		return ((_ns1__ImpMesAteTestData *)ptr)->soap_out(soap, "ns1:ImpMesAteTestData", id, "");
	case SOAP_TYPE__ns1__chkStationTimeResponse:
		return ((_ns1__chkStationTimeResponse *)ptr)->soap_out(soap, "ns1:chkStationTimeResponse", id, "");
	case SOAP_TYPE__ns1__chkStationTime:
		return ((_ns1__chkStationTime *)ptr)->soap_out(soap, "ns1:chkStationTime", id, "");
	case SOAP_TYPE__ns1__InFruitsOrtQtyResponse:
		return ((_ns1__InFruitsOrtQtyResponse *)ptr)->soap_out(soap, "ns1:InFruitsOrtQtyResponse", id, "");
	case SOAP_TYPE__ns1__InFruitsOrtQty:
		return ((_ns1__InFruitsOrtQty *)ptr)->soap_out(soap, "ns1:InFruitsOrtQty", id, "");
	case SOAP_TYPE__ns1__sendTestResultResponse:
		return ((_ns1__sendTestResultResponse *)ptr)->soap_out(soap, "ns1:sendTestResultResponse", id, "");
	case SOAP_TYPE__ns1__sendTestResult:
		return ((_ns1__sendTestResult *)ptr)->soap_out(soap, "ns1:sendTestResult", id, "");
	case SOAP_TYPE__ns1__sendTestDataResponse:
		return ((_ns1__sendTestDataResponse *)ptr)->soap_out(soap, "ns1:sendTestDataResponse", id, "");
	case SOAP_TYPE__ns1__sendTestData:
		return ((_ns1__sendTestData *)ptr)->soap_out(soap, "ns1:sendTestData", id, "");
	case SOAP_TYPE__ns1__checkSN_USCOREStationResponse:
		return ((_ns1__checkSN_USCOREStationResponse *)ptr)->soap_out(soap, "ns1:checkSN_StationResponse", id, "");
	case SOAP_TYPE__ns1__checkSN_USCOREStation:
		return ((_ns1__checkSN_USCOREStation *)ptr)->soap_out(soap, "ns1:checkSN_Station", id, "");
	case SOAP_TYPE__ns1__checkEmpNoResponse:
		return ((_ns1__checkEmpNoResponse *)ptr)->soap_out(soap, "ns1:checkEmpNoResponse", id, "");
	case SOAP_TYPE__ns1__checkEmpNo:
		return ((_ns1__checkEmpNo *)ptr)->soap_out(soap, "ns1:checkEmpNo", id, "");
	case SOAP_TYPE__ns1__checkTestDataResponse:
		return ((_ns1__checkTestDataResponse *)ptr)->soap_out(soap, "ns1:checkTestDataResponse", id, "");
	case SOAP_TYPE__ns1__checkTestData:
		return ((_ns1__checkTestData *)ptr)->soap_out(soap, "ns1:checkTestData", id, "");
	case SOAP_TYPE__ns1__InsZjListResponse:
		return ((_ns1__InsZjListResponse *)ptr)->soap_out(soap, "ns1:InsZjListResponse", id, "");
	case SOAP_TYPE__ns1__InsZjList:
		return ((_ns1__InsZjList *)ptr)->soap_out(soap, "ns1:InsZjList", id, "");
	case SOAP_TYPE__ns1__GetFruitMachineChkResponse:
		return ((_ns1__GetFruitMachineChkResponse *)ptr)->soap_out(soap, "ns1:GetFruitMachineChkResponse", id, "");
	case SOAP_TYPE__ns1__GetFruitMachineChk:
		return ((_ns1__GetFruitMachineChk *)ptr)->soap_out(soap, "ns1:GetFruitMachineChk", id, "");
	case SOAP_TYPE__ns1__InsFruitMachineChkResponse:
		return ((_ns1__InsFruitMachineChkResponse *)ptr)->soap_out(soap, "ns1:InsFruitMachineChkResponse", id, "");
	case SOAP_TYPE__ns1__InsFruitMachineChk:
		return ((_ns1__InsFruitMachineChk *)ptr)->soap_out(soap, "ns1:InsFruitMachineChk", id, "");
	case SOAP_TYPE__ns1__SnLnkOutSNResponse:
		return ((_ns1__SnLnkOutSNResponse *)ptr)->soap_out(soap, "ns1:SnLnkOutSNResponse", id, "");
	case SOAP_TYPE__ns1__SnLnkOutSN:
		return ((_ns1__SnLnkOutSN *)ptr)->soap_out(soap, "ns1:SnLnkOutSN", id, "");
	case SOAP_TYPE__ns1__getMoBaseResponse:
		return ((_ns1__getMoBaseResponse *)ptr)->soap_out(soap, "ns1:getMoBaseResponse", id, "");
	case SOAP_TYPE__ns1__getMoBase:
		return ((_ns1__getMoBase *)ptr)->soap_out(soap, "ns1:getMoBase", id, "");
	case SOAP_TYPE__ns1__GetNgCodeResponse:
		return ((_ns1__GetNgCodeResponse *)ptr)->soap_out(soap, "ns1:GetNgCodeResponse", id, "");
	case SOAP_TYPE__ns1__GetNgCode:
		return ((_ns1__GetNgCode *)ptr)->soap_out(soap, "ns1:GetNgCode", id, "");
	case SOAP_TYPE__ns1__SetDiecastSNResponse:
		return ((_ns1__SetDiecastSNResponse *)ptr)->soap_out(soap, "ns1:SetDiecastSNResponse", id, "");
	case SOAP_TYPE__ns1__SetDiecastSN:
		return ((_ns1__SetDiecastSN *)ptr)->soap_out(soap, "ns1:SetDiecastSN", id, "");
	case SOAP_TYPE__ns1__GetMachineForGroupResponse:
		return ((_ns1__GetMachineForGroupResponse *)ptr)->soap_out(soap, "ns1:GetMachineForGroupResponse", id, "");
	case SOAP_TYPE__ns1__GetMachineForGroup:
		return ((_ns1__GetMachineForGroup *)ptr)->soap_out(soap, "ns1:GetMachineForGroup", id, "");
	case SOAP_TYPE__ns1__UploadForHPResponse:
		return ((_ns1__UploadForHPResponse *)ptr)->soap_out(soap, "ns1:UploadForHPResponse", id, "");
	case SOAP_TYPE__ns1__UploadForHP:
		return ((_ns1__UploadForHP *)ptr)->soap_out(soap, "ns1:UploadForHP", id, "");
	case SOAP_TYPE__ns1__SelShelfLinkResponse:
		return ((_ns1__SelShelfLinkResponse *)ptr)->soap_out(soap, "ns1:SelShelfLinkResponse", id, "");
	case SOAP_TYPE__ns1__SelShelfLink:
		return ((_ns1__SelShelfLink *)ptr)->soap_out(soap, "ns1:SelShelfLink", id, "");
	case SOAP_TYPE__ns1__SNLinkShelfResponse:
		return ((_ns1__SNLinkShelfResponse *)ptr)->soap_out(soap, "ns1:SNLinkShelfResponse", id, "");
	case SOAP_TYPE__ns1__SNLinkShelf:
		return ((_ns1__SNLinkShelf *)ptr)->soap_out(soap, "ns1:SNLinkShelf", id, "");
	case SOAP_TYPE__ns1__SelSNTestForFruitResponse:
		return ((_ns1__SelSNTestForFruitResponse *)ptr)->soap_out(soap, "ns1:SelSNTestForFruitResponse", id, "");
	case SOAP_TYPE__ns1__SelSNTestForFruit:
		return ((_ns1__SelSNTestForFruit *)ptr)->soap_out(soap, "ns1:SelSNTestForFruit", id, "");
	case SOAP_TYPE__ns1__InsSNTestForFruitResponse:
		return ((_ns1__InsSNTestForFruitResponse *)ptr)->soap_out(soap, "ns1:InsSNTestForFruitResponse", id, "");
	case SOAP_TYPE__ns1__InsSNTestForFruit:
		return ((_ns1__InsSNTestForFruit *)ptr)->soap_out(soap, "ns1:InsSNTestForFruit", id, "");
	case SOAP_TYPE__ns1__GetStationNumberForSNResponse:
		return ((_ns1__GetStationNumberForSNResponse *)ptr)->soap_out(soap, "ns1:GetStationNumberForSNResponse", id, "");
	case SOAP_TYPE__ns1__GetStationNumberForSN:
		return ((_ns1__GetStationNumberForSN *)ptr)->soap_out(soap, "ns1:GetStationNumberForSN", id, "");
	case SOAP_TYPE__ns1__GetTestValueResultResponse:
		return ((_ns1__GetTestValueResultResponse *)ptr)->soap_out(soap, "ns1:GetTestValueResultResponse", id, "");
	case SOAP_TYPE__ns1__GetTestValueResult:
		return ((_ns1__GetTestValueResult *)ptr)->soap_out(soap, "ns1:GetTestValueResult", id, "");
	case SOAP_TYPE__ns1__InsCLScadaResponse:
		return ((_ns1__InsCLScadaResponse *)ptr)->soap_out(soap, "ns1:InsCLScadaResponse", id, "");
	case SOAP_TYPE__ns1__InsCLScada:
		return ((_ns1__InsCLScada *)ptr)->soap_out(soap, "ns1:InsCLScada", id, "");
	case SOAP_TYPE__ns1__InsAoiMoResponse:
		return ((_ns1__InsAoiMoResponse *)ptr)->soap_out(soap, "ns1:InsAoiMoResponse", id, "");
	case SOAP_TYPE__ns1__InsAoiMo:
		return ((_ns1__InsAoiMo *)ptr)->soap_out(soap, "ns1:InsAoiMo", id, "");
	case SOAP_TYPE__ns1__chkMoSNForAOIResponse:
		return ((_ns1__chkMoSNForAOIResponse *)ptr)->soap_out(soap, "ns1:chkMoSNForAOIResponse", id, "");
	case SOAP_TYPE__ns1__chkMoSNForAOI:
		return ((_ns1__chkMoSNForAOI *)ptr)->soap_out(soap, "ns1:chkMoSNForAOI", id, "");
	case SOAP_TYPE__ns1__PunchOutResponse:
		return ((_ns1__PunchOutResponse *)ptr)->soap_out(soap, "ns1:PunchOutResponse", id, "");
	case SOAP_TYPE__ns1__PunchOut:
		return ((_ns1__PunchOut *)ptr)->soap_out(soap, "ns1:PunchOut", id, "");
	case SOAP_TYPE__ns1__BasketLinkPunchResponse:
		return ((_ns1__BasketLinkPunchResponse *)ptr)->soap_out(soap, "ns1:BasketLinkPunchResponse", id, "");
	case SOAP_TYPE__ns1__BasketLinkPunch:
		return ((_ns1__BasketLinkPunch *)ptr)->soap_out(soap, "ns1:BasketLinkPunch", id, "");
	case SOAP_TYPE__ns1__HPSNLinkBasketResponse:
		return ((_ns1__HPSNLinkBasketResponse *)ptr)->soap_out(soap, "ns1:HPSNLinkBasketResponse", id, "");
	case SOAP_TYPE__ns1__HPSNLinkBasket:
		return ((_ns1__HPSNLinkBasket *)ptr)->soap_out(soap, "ns1:HPSNLinkBasket", id, "");
	case SOAP_TYPE__ns1__SetAutoLineRecResponse:
		return ((_ns1__SetAutoLineRecResponse *)ptr)->soap_out(soap, "ns1:SetAutoLineRecResponse", id, "");
	case SOAP_TYPE__ns1__SetAutoLineRec:
		return ((_ns1__SetAutoLineRec *)ptr)->soap_out(soap, "ns1:SetAutoLineRec", id, "");
	case SOAP_TYPE__ns1__GetSNForLinkResponse:
		return ((_ns1__GetSNForLinkResponse *)ptr)->soap_out(soap, "ns1:GetSNForLinkResponse", id, "");
	case SOAP_TYPE__ns1__GetSNForLink:
		return ((_ns1__GetSNForLink *)ptr)->soap_out(soap, "ns1:GetSNForLink", id, "");
	case SOAP_TYPE__ns1__SetFlatnessFruitRecResponse:
		return ((_ns1__SetFlatnessFruitRecResponse *)ptr)->soap_out(soap, "ns1:SetFlatnessFruitRecResponse", id, "");
	case SOAP_TYPE__ns1__SetFlatnessFruitRec:
		return ((_ns1__SetFlatnessFruitRec *)ptr)->soap_out(soap, "ns1:SetFlatnessFruitRec", id, "");
	case SOAP_TYPE__ns1__getStationByMoForTestPadResponse:
		return ((_ns1__getStationByMoForTestPadResponse *)ptr)->soap_out(soap, "ns1:getStationByMoForTestPadResponse", id, "");
	case SOAP_TYPE__ns1__getStationByMoForTestPad:
		return ((_ns1__getStationByMoForTestPad *)ptr)->soap_out(soap, "ns1:getStationByMoForTestPad", id, "");
	case SOAP_TYPE__ns1__GetShippingWeightResponse:
		return ((_ns1__GetShippingWeightResponse *)ptr)->soap_out(soap, "ns1:GetShippingWeightResponse", id, "");
	case SOAP_TYPE__ns1__GetShippingWeight:
		return ((_ns1__GetShippingWeight *)ptr)->soap_out(soap, "ns1:GetShippingWeight", id, "");
	case SOAP_TYPE__ns1__GetShippingForBerthResponse:
		return ((_ns1__GetShippingForBerthResponse *)ptr)->soap_out(soap, "ns1:GetShippingForBerthResponse", id, "");
	case SOAP_TYPE__ns1__GetShippingForBerth:
		return ((_ns1__GetShippingForBerth *)ptr)->soap_out(soap, "ns1:GetShippingForBerth", id, "");
	case SOAP_TYPE__ns1__InsShippingBerthResponse:
		return ((_ns1__InsShippingBerthResponse *)ptr)->soap_out(soap, "ns1:InsShippingBerthResponse", id, "");
	case SOAP_TYPE__ns1__InsShippingBerth:
		return ((_ns1__InsShippingBerth *)ptr)->soap_out(soap, "ns1:InsShippingBerth", id, "");
	case SOAP_TYPE__ns1__InsShippingPalleResponse:
		return ((_ns1__InsShippingPalleResponse *)ptr)->soap_out(soap, "ns1:InsShippingPalleResponse", id, "");
	case SOAP_TYPE__ns1__InsShippingPalle:
		return ((_ns1__InsShippingPalle *)ptr)->soap_out(soap, "ns1:InsShippingPalle", id, "");
	case SOAP_TYPE__ns1__GetShippingPalleResponse:
		return ((_ns1__GetShippingPalleResponse *)ptr)->soap_out(soap, "ns1:GetShippingPalleResponse", id, "");
	case SOAP_TYPE__ns1__GetShippingPalle:
		return ((_ns1__GetShippingPalle *)ptr)->soap_out(soap, "ns1:GetShippingPalle", id, "");
	case SOAP_TYPE__ns1__UpdShippingResponse:
		return ((_ns1__UpdShippingResponse *)ptr)->soap_out(soap, "ns1:UpdShippingResponse", id, "");
	case SOAP_TYPE__ns1__UpdShipping:
		return ((_ns1__UpdShipping *)ptr)->soap_out(soap, "ns1:UpdShipping", id, "");
	case SOAP_TYPE__ns1__GetShippingBerthListResponse:
		return ((_ns1__GetShippingBerthListResponse *)ptr)->soap_out(soap, "ns1:GetShippingBerthListResponse", id, "");
	case SOAP_TYPE__ns1__GetShippingBerthList:
		return ((_ns1__GetShippingBerthList *)ptr)->soap_out(soap, "ns1:GetShippingBerthList", id, "");
	case SOAP_TYPE__ns1__GetShippingListResponse:
		return ((_ns1__GetShippingListResponse *)ptr)->soap_out(soap, "ns1:GetShippingListResponse", id, "");
	case SOAP_TYPE__ns1__GetShippingList:
		return ((_ns1__GetShippingList *)ptr)->soap_out(soap, "ns1:GetShippingList", id, "");
	case SOAP_TYPE__ns1__doLotLinkForAppleResponse:
		return ((_ns1__doLotLinkForAppleResponse *)ptr)->soap_out(soap, "ns1:doLotLinkForAppleResponse", id, "");
	case SOAP_TYPE__ns1__doLotLinkForApple:
		return ((_ns1__doLotLinkForApple *)ptr)->soap_out(soap, "ns1:doLotLinkForApple", id, "");
	case SOAP_TYPE__ns1__GetLotLinkCountResponse:
		return ((_ns1__GetLotLinkCountResponse *)ptr)->soap_out(soap, "ns1:GetLotLinkCountResponse", id, "");
	case SOAP_TYPE__ns1__GetLotLinkCount:
		return ((_ns1__GetLotLinkCount *)ptr)->soap_out(soap, "ns1:GetLotLinkCount", id, "");
	case SOAP_TYPE__ns1__GetFruitSNCheckResponse:
		return ((_ns1__GetFruitSNCheckResponse *)ptr)->soap_out(soap, "ns1:GetFruitSNCheckResponse", id, "");
	case SOAP_TYPE__ns1__GetFruitSNCheck:
		return ((_ns1__GetFruitSNCheck *)ptr)->soap_out(soap, "ns1:GetFruitSNCheck", id, "");
	case SOAP_TYPE__ns1__GetObeNWResponse:
		return ((_ns1__GetObeNWResponse *)ptr)->soap_out(soap, "ns1:GetObeNWResponse", id, "");
	case SOAP_TYPE__ns1__GetObeNW:
		return ((_ns1__GetObeNW *)ptr)->soap_out(soap, "ns1:GetObeNW", id, "");
	case SOAP_TYPE__ns1__doSnLinkForAppleResponse:
		return ((_ns1__doSnLinkForAppleResponse *)ptr)->soap_out(soap, "ns1:doSnLinkForAppleResponse", id, "");
	case SOAP_TYPE__ns1__doSnLinkForApple:
		return ((_ns1__doSnLinkForApple *)ptr)->soap_out(soap, "ns1:doSnLinkForApple", id, "");
	case SOAP_TYPE__ns1__ChkSnLinkForAppleResponse:
		return ((_ns1__ChkSnLinkForAppleResponse *)ptr)->soap_out(soap, "ns1:ChkSnLinkForAppleResponse", id, "");
	case SOAP_TYPE__ns1__ChkSnLinkForApple:
		return ((_ns1__ChkSnLinkForApple *)ptr)->soap_out(soap, "ns1:ChkSnLinkForApple", id, "");
	case SOAP_TYPE__ns1__DelSNTestResponse:
		return ((_ns1__DelSNTestResponse *)ptr)->soap_out(soap, "ns1:DelSNTestResponse", id, "");
	case SOAP_TYPE__ns1__DelSNTest:
		return ((_ns1__DelSNTest *)ptr)->soap_out(soap, "ns1:DelSNTest", id, "");
	case SOAP_TYPE__ns1__SelSNTestResponse:
		return ((_ns1__SelSNTestResponse *)ptr)->soap_out(soap, "ns1:SelSNTestResponse", id, "");
	case SOAP_TYPE__ns1__SelSNTest:
		return ((_ns1__SelSNTest *)ptr)->soap_out(soap, "ns1:SelSNTest", id, "");
	case SOAP_TYPE__ns1__InsSNTestResponse:
		return ((_ns1__InsSNTestResponse *)ptr)->soap_out(soap, "ns1:InsSNTestResponse", id, "");
	case SOAP_TYPE__ns1__InsSNTest:
		return ((_ns1__InsSNTest *)ptr)->soap_out(soap, "ns1:InsSNTest", id, "");
	case SOAP_TYPE__ns1__ChkWeightTimeResponse:
		return ((_ns1__ChkWeightTimeResponse *)ptr)->soap_out(soap, "ns1:ChkWeightTimeResponse", id, "");
	case SOAP_TYPE__ns1__ChkWeightTime:
		return ((_ns1__ChkWeightTime *)ptr)->soap_out(soap, "ns1:ChkWeightTime", id, "");
	case SOAP_TYPE__ns1__UpdAhsBarcodeResponse:
		return ((_ns1__UpdAhsBarcodeResponse *)ptr)->soap_out(soap, "ns1:UpdAhsBarcodeResponse", id, "");
	case SOAP_TYPE__ns1__UpdAhsBarcode:
		return ((_ns1__UpdAhsBarcode *)ptr)->soap_out(soap, "ns1:UpdAhsBarcode", id, "");
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse:
		return ((_ns1__GetAhsBarcodeResponse *)ptr)->soap_out(soap, "ns1:GetAhsBarcodeResponse", id, "");
	case SOAP_TYPE__ns1__GetAhsBarcode:
		return ((_ns1__GetAhsBarcode *)ptr)->soap_out(soap, "ns1:GetAhsBarcode", id, "");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTo_ns1__GetAhsMo:
		return soap_out_PointerTo_ns1__GetAhsMo(soap, tag, id, (_ns1__GetAhsMo *const*)ptr, "ns1:GetAhsMo");
	case SOAP_TYPE_PointerTo_ns1__GetPackWeigth:
		return soap_out_PointerTo_ns1__GetPackWeigth(soap, tag, id, (_ns1__GetPackWeigth *const*)ptr, "ns1:GetPackWeigth");
	case SOAP_TYPE_PointerTo_ns1__GetPackStation:
		return soap_out_PointerTo_ns1__GetPackStation(soap, tag, id, (_ns1__GetPackStation *const*)ptr, "ns1:GetPackStation");
	case SOAP_TYPE_PointerTo_ns1__SetPallentForWMS:
		return soap_out_PointerTo_ns1__SetPallentForWMS(soap, tag, id, (_ns1__SetPallentForWMS *const*)ptr, "ns1:SetPallentForWMS");
	case SOAP_TYPE_PointerTo_ns1__GetPallentToWMS:
		return soap_out_PointerTo_ns1__GetPallentToWMS(soap, tag, id, (_ns1__GetPallentToWMS *const*)ptr, "ns1:GetPallentToWMS");
	case SOAP_TYPE_PointerTo_ns1__GetPackToWMS:
		return soap_out_PointerTo_ns1__GetPackToWMS(soap, tag, id, (_ns1__GetPackToWMS *const*)ptr, "ns1:GetPackToWMS");
	case SOAP_TYPE_PointerTo_ns1__GetWeightSet:
		return soap_out_PointerTo_ns1__GetWeightSet(soap, tag, id, (_ns1__GetWeightSet *const*)ptr, "ns1:GetWeightSet");
	case SOAP_TYPE_PointerTo_ns1__CancelLnkSN:
		return soap_out_PointerTo_ns1__CancelLnkSN(soap, tag, id, (_ns1__CancelLnkSN *const*)ptr, "ns1:CancelLnkSN");
	case SOAP_TYPE_PointerTo_ns1__CancelGrillSN:
		return soap_out_PointerTo_ns1__CancelGrillSN(soap, tag, id, (_ns1__CancelGrillSN *const*)ptr, "ns1:CancelGrillSN");
	case SOAP_TYPE_PointerTo_ns1__OutGrillBySN:
		return soap_out_PointerTo_ns1__OutGrillBySN(soap, tag, id, (_ns1__OutGrillBySN *const*)ptr, "ns1:OutGrillBySN");
	case SOAP_TYPE_PointerTo_ns1__GetGrillTime:
		return soap_out_PointerTo_ns1__GetGrillTime(soap, tag, id, (_ns1__GetGrillTime *const*)ptr, "ns1:GetGrillTime");
	case SOAP_TYPE_PointerTo_ns1__InsGrillBySN:
		return soap_out_PointerTo_ns1__InsGrillBySN(soap, tag, id, (_ns1__InsGrillBySN *const*)ptr, "ns1:InsGrillBySN");
	case SOAP_TYPE_PointerTo_ns1__CloseGrillSN:
		return soap_out_PointerTo_ns1__CloseGrillSN(soap, tag, id, (_ns1__CloseGrillSN *const*)ptr, "ns1:CloseGrillSN");
	case SOAP_TYPE_PointerTo_ns1__LnkGrillSN:
		return soap_out_PointerTo_ns1__LnkGrillSN(soap, tag, id, (_ns1__LnkGrillSN *const*)ptr, "ns1:LnkGrillSN");
	case SOAP_TYPE_PointerTo_ns1__chkGrillSN:
		return soap_out_PointerTo_ns1__chkGrillSN(soap, tag, id, (_ns1__chkGrillSN *const*)ptr, "ns1:chkGrillSN");
	case SOAP_TYPE_PointerTo_ns1__LnkSideSN:
		return soap_out_PointerTo_ns1__LnkSideSN(soap, tag, id, (_ns1__LnkSideSN *const*)ptr, "ns1:LnkSideSN");
	case SOAP_TYPE_PointerTo_ns1__LnkZJSN:
		return soap_out_PointerTo_ns1__LnkZJSN(soap, tag, id, (_ns1__LnkZJSN *const*)ptr, "ns1:LnkZJSN");
	case SOAP_TYPE_PointerTo_ns1__chkZJSN:
		return soap_out_PointerTo_ns1__chkZJSN(soap, tag, id, (_ns1__chkZJSN *const*)ptr, "ns1:chkZJSN");
	case SOAP_TYPE_PointerTo_ns1__chkDispensing:
		return soap_out_PointerTo_ns1__chkDispensing(soap, tag, id, (_ns1__chkDispensing *const*)ptr, "ns1:chkDispensing");
	case SOAP_TYPE_PointerTo_ns1__InsIotTestData:
		return soap_out_PointerTo_ns1__InsIotTestData(soap, tag, id, (_ns1__InsIotTestData *const*)ptr, "ns1:InsIotTestData");
	case SOAP_TYPE_PointerTo_ns1__InsIotMachineRec:
		return soap_out_PointerTo_ns1__InsIotMachineRec(soap, tag, id, (_ns1__InsIotMachineRec *const*)ptr, "ns1:InsIotMachineRec");
	case SOAP_TYPE_PointerTo_ns1__GetLnkData:
		return soap_out_PointerTo_ns1__GetLnkData(soap, tag, id, (_ns1__GetLnkData *const*)ptr, "ns1:GetLnkData");
	case SOAP_TYPE_PointerTo_ns1__GetTestValue:
		return soap_out_PointerTo_ns1__GetTestValue(soap, tag, id, (_ns1__GetTestValue *const*)ptr, "ns1:GetTestValue");
	case SOAP_TYPE_PointerTo_ns1__GetMoBase:
		return soap_out_PointerTo_ns1__GetMoBase(soap, tag, id, (_ns1__GetMoBase *const*)ptr, "ns1:GetMoBase");
	case SOAP_TYPE_PointerTo_ns1__UpdSnRecInfo:
		return soap_out_PointerTo_ns1__UpdSnRecInfo(soap, tag, id, (_ns1__UpdSnRecInfo *const*)ptr, "ns1:UpdSnRecInfo");
	case SOAP_TYPE_PointerTo_ns1__InsBoxInfo:
		return soap_out_PointerTo_ns1__InsBoxInfo(soap, tag, id, (_ns1__InsBoxInfo *const*)ptr, "ns1:InsBoxInfo");
	case SOAP_TYPE_PointerTo_ns1__InsLnkOutSN:
		return soap_out_PointerTo_ns1__InsLnkOutSN(soap, tag, id, (_ns1__InsLnkOutSN *const*)ptr, "ns1:InsLnkOutSN");
	case SOAP_TYPE_PointerTo_ns1__InsSNStationEmp:
		return soap_out_PointerTo_ns1__InsSNStationEmp(soap, tag, id, (_ns1__InsSNStationEmp *const*)ptr, "ns1:InsSNStationEmp");
	case SOAP_TYPE_PointerTo_ns1__CancelBoxLnk:
		return soap_out_PointerTo_ns1__CancelBoxLnk(soap, tag, id, (_ns1__CancelBoxLnk *const*)ptr, "ns1:CancelBoxLnk");
	case SOAP_TYPE_PointerTo_ns1__OutStationbyBox:
		return soap_out_PointerTo_ns1__OutStationbyBox(soap, tag, id, (_ns1__OutStationbyBox *const*)ptr, "ns1:OutStationbyBox");
	case SOAP_TYPE_PointerTo_ns1__InStationbyBox:
		return soap_out_PointerTo_ns1__InStationbyBox(soap, tag, id, (_ns1__InStationbyBox *const*)ptr, "ns1:InStationbyBox");
	case SOAP_TYPE_PointerTo_ns1__EndSNtoBox:
		return soap_out_PointerTo_ns1__EndSNtoBox(soap, tag, id, (_ns1__EndSNtoBox *const*)ptr, "ns1:EndSNtoBox");
	case SOAP_TYPE_PointerTo_ns1__InSNtoBox:
		return soap_out_PointerTo_ns1__InSNtoBox(soap, tag, id, (_ns1__InSNtoBox *const*)ptr, "ns1:InSNtoBox");
	case SOAP_TYPE_PointerTo_ns1__chkBoxNo:
		return soap_out_PointerTo_ns1__chkBoxNo(soap, tag, id, (_ns1__chkBoxNo *const*)ptr, "ns1:chkBoxNo");
	case SOAP_TYPE_PointerTo_ns1__InsBoxNOTime:
		return soap_out_PointerTo_ns1__InsBoxNOTime(soap, tag, id, (_ns1__InsBoxNOTime *const*)ptr, "ns1:InsBoxNOTime");
	case SOAP_TYPE_PointerTo_ns1__GetLinkZJCount:
		return soap_out_PointerTo_ns1__GetLinkZJCount(soap, tag, id, (_ns1__GetLinkZJCount *const*)ptr, "ns1:GetLinkZJCount");
	case SOAP_TYPE_PointerTo_ns1__InsLinkSN:
		return soap_out_PointerTo_ns1__InsLinkSN(soap, tag, id, (_ns1__InsLinkSN *const*)ptr, "ns1:InsLinkSN");
	case SOAP_TYPE_PointerTo_ns1__doLinkOutSN:
		return soap_out_PointerTo_ns1__doLinkOutSN(soap, tag, id, (_ns1__doLinkOutSN *const*)ptr, "ns1:doLinkOutSN");
	case SOAP_TYPE_PointerTo_ns1__ChkLinkOutSN:
		return soap_out_PointerTo_ns1__ChkLinkOutSN(soap, tag, id, (_ns1__ChkLinkOutSN *const*)ptr, "ns1:ChkLinkOutSN");
	case SOAP_TYPE_PointerTo_ns1__chkOutSN:
		return soap_out_PointerTo_ns1__chkOutSN(soap, tag, id, (_ns1__chkOutSN *const*)ptr, "ns1:chkOutSN");
	case SOAP_TYPE_PointerTo_ns1__GetLintOutQty:
		return soap_out_PointerTo_ns1__GetLintOutQty(soap, tag, id, (_ns1__GetLintOutQty *const*)ptr, "ns1:GetLintOutQty");
	case SOAP_TYPE_PointerTo_ns1__SNLinkZJ:
		return soap_out_PointerTo_ns1__SNLinkZJ(soap, tag, id, (_ns1__SNLinkZJ *const*)ptr, "ns1:SNLinkZJ");
	case SOAP_TYPE_PointerTo_ns1__InsZJTestData:
		return soap_out_PointerTo_ns1__InsZJTestData(soap, tag, id, (_ns1__InsZJTestData *const*)ptr, "ns1:InsZJTestData");
	case SOAP_TYPE_PointerTo_ns1__doPmcSNLink:
		return soap_out_PointerTo_ns1__doPmcSNLink(soap, tag, id, (_ns1__doPmcSNLink *const*)ptr, "ns1:doPmcSNLink");
	case SOAP_TYPE_PointerTo_ns1__GetPmcSNPart:
		return soap_out_PointerTo_ns1__GetPmcSNPart(soap, tag, id, (_ns1__GetPmcSNPart *const*)ptr, "ns1:GetPmcSNPart");
	case SOAP_TYPE_PointerTo_ns1__getPmcPartAssyList:
		return soap_out_PointerTo_ns1__getPmcPartAssyList(soap, tag, id, (_ns1__getPmcPartAssyList *const*)ptr, "ns1:getPmcPartAssyList");
	case SOAP_TYPE_PointerTo_ns1__getPmcAssyList:
		return soap_out_PointerTo_ns1__getPmcAssyList(soap, tag, id, (_ns1__getPmcAssyList *const*)ptr, "ns1:getPmcAssyList");
	case SOAP_TYPE_PointerTo_ns1__doAssy:
		return soap_out_PointerTo_ns1__doAssy(soap, tag, id, (_ns1__doAssy *const*)ptr, "ns1:doAssy");
	case SOAP_TYPE_PointerTo_ns1__chkAssySN:
		return soap_out_PointerTo_ns1__chkAssySN(soap, tag, id, (_ns1__chkAssySN *const*)ptr, "ns1:chkAssySN");
	case SOAP_TYPE_PointerTo_ns1__getPNbySN:
		return soap_out_PointerTo_ns1__getPNbySN(soap, tag, id, (_ns1__getPNbySN *const*)ptr, "ns1:getPNbySN");
	case SOAP_TYPE_PointerTo_ns1__getMoAssyCount:
		return soap_out_PointerTo_ns1__getMoAssyCount(soap, tag, id, (_ns1__getMoAssyCount *const*)ptr, "ns1:getMoAssyCount");
	case SOAP_TYPE_PointerTo_ns1__GetLinkOutSn:
		return soap_out_PointerTo_ns1__GetLinkOutSn(soap, tag, id, (_ns1__GetLinkOutSn *const*)ptr, "ns1:GetLinkOutSn");
	case SOAP_TYPE_PointerTo_ns1__InsPartAssy:
		return soap_out_PointerTo_ns1__InsPartAssy(soap, tag, id, (_ns1__InsPartAssy *const*)ptr, "ns1:InsPartAssy");
	case SOAP_TYPE_PointerTo_ns1__getPartBomExt:
		return soap_out_PointerTo_ns1__getPartBomExt(soap, tag, id, (_ns1__getPartBomExt *const*)ptr, "ns1:getPartBomExt");
	case SOAP_TYPE_PointerTo_ns1__getMoAssyList:
		return soap_out_PointerTo_ns1__getMoAssyList(soap, tag, id, (_ns1__getMoAssyList *const*)ptr, "ns1:getMoAssyList");
	case SOAP_TYPE_PointerTo_ns1__chkSnMapping:
		return soap_out_PointerTo_ns1__chkSnMapping(soap, tag, id, (_ns1__chkSnMapping *const*)ptr, "ns1:chkSnMapping");
	case SOAP_TYPE_PointerTo_ns1__getStationTypeDesc:
		return soap_out_PointerTo_ns1__getStationTypeDesc(soap, tag, id, (_ns1__getStationTypeDesc *const*)ptr, "ns1:getStationTypeDesc");
	case SOAP_TYPE_PointerTo_ns1__getStationByMo:
		return soap_out_PointerTo_ns1__getStationByMo(soap, tag, id, (_ns1__getStationByMo *const*)ptr, "ns1:getStationByMo");
	case SOAP_TYPE_PointerTo_ns1__SnDoMapping:
		return soap_out_PointerTo_ns1__SnDoMapping(soap, tag, id, (_ns1__SnDoMapping *const*)ptr, "ns1:SnDoMapping");
	case SOAP_TYPE_PointerTo_ns1__eMesNextMo:
		return soap_out_PointerTo_ns1__eMesNextMo(soap, tag, id, (_ns1__eMesNextMo *const*)ptr, "ns1:eMesNextMo");
	case SOAP_TYPE_PointerTo_ns1__sendResultForStationNumber:
		return soap_out_PointerTo_ns1__sendResultForStationNumber(soap, tag, id, (_ns1__sendResultForStationNumber *const*)ptr, "ns1:sendResultForStationNumber");
	case SOAP_TYPE_PointerTo_ns1__sendDataForStationNumber:
		return soap_out_PointerTo_ns1__sendDataForStationNumber(soap, tag, id, (_ns1__sendDataForStationNumber *const*)ptr, "ns1:sendDataForStationNumber");
	case SOAP_TYPE_PointerTo_ns1__checkEmpForStationNumber:
		return soap_out_PointerTo_ns1__checkEmpForStationNumber(soap, tag, id, (_ns1__checkEmpForStationNumber *const*)ptr, "ns1:checkEmpForStationNumber");
	case SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStationNumber:
		return soap_out_PointerTo_ns1__checkSN_USCOREStationNumber(soap, tag, id, (_ns1__checkSN_USCOREStationNumber *const*)ptr, "ns1:checkSN_StationNumber");
	case SOAP_TYPE_PointerTo_ns1__ChkSnNextMo:
		return soap_out_PointerTo_ns1__ChkSnNextMo(soap, tag, id, (_ns1__ChkSnNextMo *const*)ptr, "ns1:ChkSnNextMo");
	case SOAP_TYPE_PointerTo_ns1__ChkSnMo:
		return soap_out_PointerTo_ns1__ChkSnMo(soap, tag, id, (_ns1__ChkSnMo *const*)ptr, "ns1:ChkSnMo");
	case SOAP_TYPE_PointerTo_ns1__chkMoStation:
		return soap_out_PointerTo_ns1__chkMoStation(soap, tag, id, (_ns1__chkMoStation *const*)ptr, "ns1:chkMoStation");
	case SOAP_TYPE_PointerTo_ns1__SetEnergyStat:
		return soap_out_PointerTo_ns1__SetEnergyStat(soap, tag, id, (_ns1__SetEnergyStat *const*)ptr, "ns1:SetEnergyStat");
	case SOAP_TYPE_PointerTo_ns1__getInfoByMo:
		return soap_out_PointerTo_ns1__getInfoByMo(soap, tag, id, (_ns1__getInfoByMo *const*)ptr, "ns1:getInfoByMo");
	case SOAP_TYPE_PointerTo_ns1__InsThermalNew:
		return soap_out_PointerTo_ns1__InsThermalNew(soap, tag, id, (_ns1__InsThermalNew *const*)ptr, "ns1:InsThermalNew");
	case SOAP_TYPE_PointerTo_ns1__ChkSnLink:
		return soap_out_PointerTo_ns1__ChkSnLink(soap, tag, id, (_ns1__ChkSnLink *const*)ptr, "ns1:ChkSnLink");
	case SOAP_TYPE_PointerTo_ns1__InsThermal:
		return soap_out_PointerTo_ns1__InsThermal(soap, tag, id, (_ns1__InsThermal *const*)ptr, "ns1:InsThermal");
	case SOAP_TYPE_PointerTo_ns1__InsWHDetection:
		return soap_out_PointerTo_ns1__InsWHDetection(soap, tag, id, (_ns1__InsWHDetection *const*)ptr, "ns1:InsWHDetection");
	case SOAP_TYPE_PointerTo_ns1__InsFlatNessForCL:
		return soap_out_PointerTo_ns1__InsFlatNessForCL(soap, tag, id, (_ns1__InsFlatNessForCL *const*)ptr, "ns1:InsFlatNessForCL");
	case SOAP_TYPE_PointerTo_ns1__InsFlatNessForLSD:
		return soap_out_PointerTo_ns1__InsFlatNessForLSD(soap, tag, id, (_ns1__InsFlatNessForLSD *const*)ptr, "ns1:InsFlatNessForLSD");
	case SOAP_TYPE_PointerTo_ns1__InsFlatNess:
		return soap_out_PointerTo_ns1__InsFlatNess(soap, tag, id, (_ns1__InsFlatNess *const*)ptr, "ns1:InsFlatNess");
	case SOAP_TYPE_PointerTo_ns1__ImpMesAteTestData:
		return soap_out_PointerTo_ns1__ImpMesAteTestData(soap, tag, id, (_ns1__ImpMesAteTestData *const*)ptr, "ns1:ImpMesAteTestData");
	case SOAP_TYPE_PointerTo_ns1__chkStationTime:
		return soap_out_PointerTo_ns1__chkStationTime(soap, tag, id, (_ns1__chkStationTime *const*)ptr, "ns1:chkStationTime");
	case SOAP_TYPE_PointerTo_ns1__InFruitsOrtQty:
		return soap_out_PointerTo_ns1__InFruitsOrtQty(soap, tag, id, (_ns1__InFruitsOrtQty *const*)ptr, "ns1:InFruitsOrtQty");
	case SOAP_TYPE_PointerTo_ns1__sendTestResult:
		return soap_out_PointerTo_ns1__sendTestResult(soap, tag, id, (_ns1__sendTestResult *const*)ptr, "ns1:sendTestResult");
	case SOAP_TYPE_PointerTo_ns1__sendTestData:
		return soap_out_PointerTo_ns1__sendTestData(soap, tag, id, (_ns1__sendTestData *const*)ptr, "ns1:sendTestData");
	case SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStation:
		return soap_out_PointerTo_ns1__checkSN_USCOREStation(soap, tag, id, (_ns1__checkSN_USCOREStation *const*)ptr, "ns1:checkSN_Station");
	case SOAP_TYPE_PointerTo_ns1__checkEmpNo:
		return soap_out_PointerTo_ns1__checkEmpNo(soap, tag, id, (_ns1__checkEmpNo *const*)ptr, "ns1:checkEmpNo");
	case SOAP_TYPE_PointerTo_ns1__checkTestData:
		return soap_out_PointerTo_ns1__checkTestData(soap, tag, id, (_ns1__checkTestData *const*)ptr, "ns1:checkTestData");
	case SOAP_TYPE_PointerTo_ns1__InsZjList:
		return soap_out_PointerTo_ns1__InsZjList(soap, tag, id, (_ns1__InsZjList *const*)ptr, "ns1:InsZjList");
	case SOAP_TYPE_PointerTo_ns1__GetFruitMachineChk:
		return soap_out_PointerTo_ns1__GetFruitMachineChk(soap, tag, id, (_ns1__GetFruitMachineChk *const*)ptr, "ns1:GetFruitMachineChk");
	case SOAP_TYPE_PointerTo_ns1__InsFruitMachineChk:
		return soap_out_PointerTo_ns1__InsFruitMachineChk(soap, tag, id, (_ns1__InsFruitMachineChk *const*)ptr, "ns1:InsFruitMachineChk");
	case SOAP_TYPE_PointerTo_ns1__SnLnkOutSN:
		return soap_out_PointerTo_ns1__SnLnkOutSN(soap, tag, id, (_ns1__SnLnkOutSN *const*)ptr, "ns1:SnLnkOutSN");
	case SOAP_TYPE_PointerTo_ns1__getMoBase:
		return soap_out_PointerTo_ns1__getMoBase(soap, tag, id, (_ns1__getMoBase *const*)ptr, "ns1:getMoBase");
	case SOAP_TYPE_PointerTo_ns1__GetNgCode:
		return soap_out_PointerTo_ns1__GetNgCode(soap, tag, id, (_ns1__GetNgCode *const*)ptr, "ns1:GetNgCode");
	case SOAP_TYPE_PointerTo_ns1__SetDiecastSN:
		return soap_out_PointerTo_ns1__SetDiecastSN(soap, tag, id, (_ns1__SetDiecastSN *const*)ptr, "ns1:SetDiecastSN");
	case SOAP_TYPE_PointerTo_ns1__GetMachineForGroup:
		return soap_out_PointerTo_ns1__GetMachineForGroup(soap, tag, id, (_ns1__GetMachineForGroup *const*)ptr, "ns1:GetMachineForGroup");
	case SOAP_TYPE_PointerTo_ns1__UploadForHP:
		return soap_out_PointerTo_ns1__UploadForHP(soap, tag, id, (_ns1__UploadForHP *const*)ptr, "ns1:UploadForHP");
	case SOAP_TYPE_PointerTo_ns1__SelShelfLink:
		return soap_out_PointerTo_ns1__SelShelfLink(soap, tag, id, (_ns1__SelShelfLink *const*)ptr, "ns1:SelShelfLink");
	case SOAP_TYPE_PointerTo_ns1__SNLinkShelf:
		return soap_out_PointerTo_ns1__SNLinkShelf(soap, tag, id, (_ns1__SNLinkShelf *const*)ptr, "ns1:SNLinkShelf");
	case SOAP_TYPE_PointerTo_ns1__SelSNTestForFruit:
		return soap_out_PointerTo_ns1__SelSNTestForFruit(soap, tag, id, (_ns1__SelSNTestForFruit *const*)ptr, "ns1:SelSNTestForFruit");
	case SOAP_TYPE_PointerTo_ns1__InsSNTestForFruit:
		return soap_out_PointerTo_ns1__InsSNTestForFruit(soap, tag, id, (_ns1__InsSNTestForFruit *const*)ptr, "ns1:InsSNTestForFruit");
	case SOAP_TYPE_PointerTo_ns1__GetStationNumberForSN:
		return soap_out_PointerTo_ns1__GetStationNumberForSN(soap, tag, id, (_ns1__GetStationNumberForSN *const*)ptr, "ns1:GetStationNumberForSN");
	case SOAP_TYPE_PointerTo_ns1__GetTestValueResult:
		return soap_out_PointerTo_ns1__GetTestValueResult(soap, tag, id, (_ns1__GetTestValueResult *const*)ptr, "ns1:GetTestValueResult");
	case SOAP_TYPE_PointerTo_ns1__InsCLScada:
		return soap_out_PointerTo_ns1__InsCLScada(soap, tag, id, (_ns1__InsCLScada *const*)ptr, "ns1:InsCLScada");
	case SOAP_TYPE_PointerTo_ns1__InsAoiMo:
		return soap_out_PointerTo_ns1__InsAoiMo(soap, tag, id, (_ns1__InsAoiMo *const*)ptr, "ns1:InsAoiMo");
	case SOAP_TYPE_PointerTo_ns1__chkMoSNForAOI:
		return soap_out_PointerTo_ns1__chkMoSNForAOI(soap, tag, id, (_ns1__chkMoSNForAOI *const*)ptr, "ns1:chkMoSNForAOI");
	case SOAP_TYPE_PointerTo_ns1__PunchOut:
		return soap_out_PointerTo_ns1__PunchOut(soap, tag, id, (_ns1__PunchOut *const*)ptr, "ns1:PunchOut");
	case SOAP_TYPE_PointerTo_ns1__BasketLinkPunch:
		return soap_out_PointerTo_ns1__BasketLinkPunch(soap, tag, id, (_ns1__BasketLinkPunch *const*)ptr, "ns1:BasketLinkPunch");
	case SOAP_TYPE_PointerTo_ns1__HPSNLinkBasket:
		return soap_out_PointerTo_ns1__HPSNLinkBasket(soap, tag, id, (_ns1__HPSNLinkBasket *const*)ptr, "ns1:HPSNLinkBasket");
	case SOAP_TYPE_PointerTo_ns1__SetAutoLineRec:
		return soap_out_PointerTo_ns1__SetAutoLineRec(soap, tag, id, (_ns1__SetAutoLineRec *const*)ptr, "ns1:SetAutoLineRec");
	case SOAP_TYPE_PointerTo_ns1__GetSNForLink:
		return soap_out_PointerTo_ns1__GetSNForLink(soap, tag, id, (_ns1__GetSNForLink *const*)ptr, "ns1:GetSNForLink");
	case SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec:
		return soap_out_PointerTo_ns1__SetFlatnessFruitRec(soap, tag, id, (_ns1__SetFlatnessFruitRec *const*)ptr, "ns1:SetFlatnessFruitRec");
	case SOAP_TYPE_PointerTo_ns1__getStationByMoForTestPad:
		return soap_out_PointerTo_ns1__getStationByMoForTestPad(soap, tag, id, (_ns1__getStationByMoForTestPad *const*)ptr, "ns1:getStationByMoForTestPad");
	case SOAP_TYPE_PointerTo_ns1__GetShippingWeight:
		return soap_out_PointerTo_ns1__GetShippingWeight(soap, tag, id, (_ns1__GetShippingWeight *const*)ptr, "ns1:GetShippingWeight");
	case SOAP_TYPE_PointerTo_ns1__GetShippingForBerth:
		return soap_out_PointerTo_ns1__GetShippingForBerth(soap, tag, id, (_ns1__GetShippingForBerth *const*)ptr, "ns1:GetShippingForBerth");
	case SOAP_TYPE_PointerTo_ns1__InsShippingBerth:
		return soap_out_PointerTo_ns1__InsShippingBerth(soap, tag, id, (_ns1__InsShippingBerth *const*)ptr, "ns1:InsShippingBerth");
	case SOAP_TYPE_PointerTo_ns1__InsShippingPalle:
		return soap_out_PointerTo_ns1__InsShippingPalle(soap, tag, id, (_ns1__InsShippingPalle *const*)ptr, "ns1:InsShippingPalle");
	case SOAP_TYPE_PointerTo_ns1__GetShippingPalle:
		return soap_out_PointerTo_ns1__GetShippingPalle(soap, tag, id, (_ns1__GetShippingPalle *const*)ptr, "ns1:GetShippingPalle");
	case SOAP_TYPE_PointerTo_ns1__UpdShipping:
		return soap_out_PointerTo_ns1__UpdShipping(soap, tag, id, (_ns1__UpdShipping *const*)ptr, "ns1:UpdShipping");
	case SOAP_TYPE_PointerTo_ns1__GetShippingBerthList:
		return soap_out_PointerTo_ns1__GetShippingBerthList(soap, tag, id, (_ns1__GetShippingBerthList *const*)ptr, "ns1:GetShippingBerthList");
	case SOAP_TYPE_PointerTo_ns1__GetShippingList:
		return soap_out_PointerTo_ns1__GetShippingList(soap, tag, id, (_ns1__GetShippingList *const*)ptr, "ns1:GetShippingList");
	case SOAP_TYPE_PointerTo_ns1__doLotLinkForApple:
		return soap_out_PointerTo_ns1__doLotLinkForApple(soap, tag, id, (_ns1__doLotLinkForApple *const*)ptr, "ns1:doLotLinkForApple");
	case SOAP_TYPE_PointerTo_ns1__GetLotLinkCount:
		return soap_out_PointerTo_ns1__GetLotLinkCount(soap, tag, id, (_ns1__GetLotLinkCount *const*)ptr, "ns1:GetLotLinkCount");
	case SOAP_TYPE_PointerTo_ns1__GetFruitSNCheck:
		return soap_out_PointerTo_ns1__GetFruitSNCheck(soap, tag, id, (_ns1__GetFruitSNCheck *const*)ptr, "ns1:GetFruitSNCheck");
	case SOAP_TYPE_PointerTo_ns1__GetObeNW:
		return soap_out_PointerTo_ns1__GetObeNW(soap, tag, id, (_ns1__GetObeNW *const*)ptr, "ns1:GetObeNW");
	case SOAP_TYPE_PointerTo_ns1__doSnLinkForApple:
		return soap_out_PointerTo_ns1__doSnLinkForApple(soap, tag, id, (_ns1__doSnLinkForApple *const*)ptr, "ns1:doSnLinkForApple");
	case SOAP_TYPE_PointerTo_ns1__ChkSnLinkForApple:
		return soap_out_PointerTo_ns1__ChkSnLinkForApple(soap, tag, id, (_ns1__ChkSnLinkForApple *const*)ptr, "ns1:ChkSnLinkForApple");
	case SOAP_TYPE_PointerTo_ns1__DelSNTest:
		return soap_out_PointerTo_ns1__DelSNTest(soap, tag, id, (_ns1__DelSNTest *const*)ptr, "ns1:DelSNTest");
	case SOAP_TYPE_PointerTo_ns1__SelSNTest:
		return soap_out_PointerTo_ns1__SelSNTest(soap, tag, id, (_ns1__SelSNTest *const*)ptr, "ns1:SelSNTest");
	case SOAP_TYPE_PointerTo_ns1__InsSNTest:
		return soap_out_PointerTo_ns1__InsSNTest(soap, tag, id, (_ns1__InsSNTest *const*)ptr, "ns1:InsSNTest");
	case SOAP_TYPE_PointerTo_ns1__ChkWeightTime:
		return soap_out_PointerTo_ns1__ChkWeightTime(soap, tag, id, (_ns1__ChkWeightTime *const*)ptr, "ns1:ChkWeightTime");
	case SOAP_TYPE_PointerTo_ns1__UpdAhsBarcode:
		return soap_out_PointerTo_ns1__UpdAhsBarcode(soap, tag, id, (_ns1__UpdAhsBarcode *const*)ptr, "ns1:UpdAhsBarcode");
	case SOAP_TYPE_PointerTo_ns1__GetAhsBarcode:
		return soap_out_PointerTo_ns1__GetAhsBarcode(soap, tag, id, (_ns1__GetAhsBarcode *const*)ptr, "ns1:GetAhsBarcode");
	case SOAP_TYPE_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult:
		return soap_out_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag, id, (_ns1__GetAhsMoResponse_GetAhsMoResult *const*)ptr, "ns1:GetAhsMoResponse-GetAhsMoResult");
	case SOAP_TYPE_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		return soap_out_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag, id, (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *const*)ptr, "ns1:GetPallentToWMSResponse-GetPallentToWMSResult");
	case SOAP_TYPE_PointerTo_ns1__doLinkOutSN_assyDt:
		return soap_out_PointerTo_ns1__doLinkOutSN_assyDt(soap, tag, id, (_ns1__doLinkOutSN_assyDt *const*)ptr, "ns1:doLinkOutSN-assyDt");
	case SOAP_TYPE_PointerTo_ns1__doPmcSNLink_assyDt:
		return soap_out_PointerTo_ns1__doPmcSNLink_assyDt(soap, tag, id, (_ns1__doPmcSNLink_assyDt *const*)ptr, "ns1:doPmcSNLink-assyDt");
	case SOAP_TYPE_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		return soap_out_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag, id, (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *const*)ptr, "ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult");
	case SOAP_TYPE_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult:
		return soap_out_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag, id, (_ns1__getPmcAssyListResponse_getPmcAssyListResult *const*)ptr, "ns1:getPmcAssyListResponse-getPmcAssyListResult");
	case SOAP_TYPE_PointerTo_ns1__doAssy_assyDt:
		return soap_out_PointerTo_ns1__doAssy_assyDt(soap, tag, id, (_ns1__doAssy_assyDt *const*)ptr, "ns1:doAssy-assyDt");
	case SOAP_TYPE_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		return soap_out_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag, id, (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *const*)ptr, "ns1:GetLinkOutSnResponse-GetLinkOutSnResult");
	case SOAP_TYPE_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult:
		return soap_out_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag, id, (_ns1__getPartBomExtResponse_getPartBomExtResult *const*)ptr, "ns1:getPartBomExtResponse-getPartBomExtResult");
	case SOAP_TYPE_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult:
		return soap_out_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag, id, (_ns1__getMoAssyListResponse_getMoAssyListResult *const*)ptr, "ns1:getMoAssyListResponse-getMoAssyListResult");
	case SOAP_TYPE_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult:
		return soap_out_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag, id, (_ns1__getInfoByMoResponse_getInfoByMoResult *const*)ptr, "ns1:getInfoByMoResponse-getInfoByMoResult");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		return soap_out_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag, id, (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *const*)ptr, "ns1:GetMachineForGroupResponse-GetMachineForGroupResult");
	case SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec_dt:
		return soap_out_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, tag, id, (_ns1__SetFlatnessFruitRec_dt *const*)ptr, "ns1:SetFlatnessFruitRec-dt");
	case SOAP_TYPE_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult:
		return soap_out_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag, id, (_ns1__GetShippingWeightResponse_GetShippingWeightResult *const*)ptr, "ns1:GetShippingWeightResponse-GetShippingWeightResult");
	case SOAP_TYPE_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		return soap_out_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag, id, (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *const*)ptr, "ns1:GetShippingForBerthResponse-GetShippingForBerthResult");
	case SOAP_TYPE_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		return soap_out_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag, id, (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *const*)ptr, "ns1:GetShippingBerthListResponse-GetShippingBerthListResult");
	case SOAP_TYPE_PointerTo_ns1__GetShippingListResponse_GetShippingListResult:
		return soap_out_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, tag, id, (_ns1__GetShippingListResponse_GetShippingListResult *const*)ptr, "ns1:GetShippingListResponse-GetShippingListResult");
	case SOAP_TYPE_PointerTo_ns1__doLotLinkForApple_assyDt:
		return soap_out_PointerTo_ns1__doLotLinkForApple_assyDt(soap, tag, id, (_ns1__doLotLinkForApple_assyDt *const*)ptr, "ns1:doLotLinkForApple-assyDt");
	case SOAP_TYPE_PointerTo_ns1__doSnLinkForApple_assyDt:
		return soap_out_PointerTo_ns1__doSnLinkForApple_assyDt(soap, tag, id, (_ns1__doSnLinkForApple_assyDt *const*)ptr, "ns1:doSnLinkForApple-assyDt");
	case SOAP_TYPE_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		return soap_out_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag, id, (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *const*)ptr, "ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult:
		((_ns1__GetAhsMoResponse_GetAhsMoResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		((_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doLinkOutSN_assyDt:
		((_ns1__doLinkOutSN_assyDt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doPmcSNLink_assyDt:
		((_ns1__doPmcSNLink_assyDt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		((_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult:
		((_ns1__getPmcAssyListResponse_getPmcAssyListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doAssy_assyDt:
		((_ns1__doAssy_assyDt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		((_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult:
		((_ns1__getPartBomExtResponse_getPartBomExtResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult:
		((_ns1__getMoAssyListResponse_getMoAssyListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult:
		((_ns1__getInfoByMoResponse_getInfoByMoResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		((_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRec_dt:
		((_ns1__SetFlatnessFruitRec_dt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult:
		((_ns1__GetShippingWeightResponse_GetShippingWeightResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		((_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		((_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult:
		((_ns1__GetShippingListResponse_GetShippingListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doLotLinkForApple_assyDt:
		((_ns1__doLotLinkForApple_assyDt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doSnLinkForApple_assyDt:
		((_ns1__doSnLinkForApple_assyDt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		((_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__GetAhsMoResponse:
		((_ns1__GetAhsMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAhsMo:
		((_ns1__GetAhsMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPackWeigthResponse:
		((_ns1__GetPackWeigthResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPackWeigth:
		((_ns1__GetPackWeigth *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPackStationResponse:
		((_ns1__GetPackStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPackStation:
		((_ns1__GetPackStation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPallentForWMSResponse:
		((_ns1__SetPallentForWMSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPallentForWMS:
		((_ns1__SetPallentForWMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPallentToWMSResponse:
		((_ns1__GetPallentToWMSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPallentToWMS:
		((_ns1__GetPallentToWMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPackToWMSResponse:
		((_ns1__GetPackToWMSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPackToWMS:
		((_ns1__GetPackToWMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWeightSetResponse:
		((_ns1__GetWeightSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWeightSet:
		((_ns1__GetWeightSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelLnkSNResponse:
		((_ns1__CancelLnkSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelLnkSN:
		((_ns1__CancelLnkSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelGrillSNResponse:
		((_ns1__CancelGrillSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelGrillSN:
		((_ns1__CancelGrillSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutGrillBySNResponse:
		((_ns1__OutGrillBySNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutGrillBySN:
		((_ns1__OutGrillBySN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGrillTimeResponse:
		((_ns1__GetGrillTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGrillTime:
		((_ns1__GetGrillTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsGrillBySNResponse:
		((_ns1__InsGrillBySNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsGrillBySN:
		((_ns1__InsGrillBySN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseGrillSNResponse:
		((_ns1__CloseGrillSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseGrillSN:
		((_ns1__CloseGrillSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LnkGrillSNResponse:
		((_ns1__LnkGrillSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LnkGrillSN:
		((_ns1__LnkGrillSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkGrillSNResponse:
		((_ns1__chkGrillSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkGrillSN:
		((_ns1__chkGrillSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LnkSideSNResponse:
		((_ns1__LnkSideSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LnkSideSN:
		((_ns1__LnkSideSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LnkZJSNResponse:
		((_ns1__LnkZJSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LnkZJSN:
		((_ns1__LnkZJSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkZJSNResponse:
		((_ns1__chkZJSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkZJSN:
		((_ns1__chkZJSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkDispensingResponse:
		((_ns1__chkDispensingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkDispensing:
		((_ns1__chkDispensing *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsIotTestDataResponse:
		((_ns1__InsIotTestDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsIotTestData:
		((_ns1__InsIotTestData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsIotMachineRecResponse:
		((_ns1__InsIotMachineRecResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsIotMachineRec:
		((_ns1__InsIotMachineRec *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLnkDataResponse:
		((_ns1__GetLnkDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLnkData:
		((_ns1__GetLnkData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTestValueResponse:
		((_ns1__GetTestValueResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTestValue:
		((_ns1__GetTestValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMoBaseResponse:
		((_ns1__GetMoBaseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMoBase:
		((_ns1__GetMoBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdSnRecInfoResponse:
		((_ns1__UpdSnRecInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdSnRecInfo:
		((_ns1__UpdSnRecInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsBoxInfoResponse:
		((_ns1__InsBoxInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsBoxInfo:
		((_ns1__InsBoxInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsLnkOutSNResponse:
		((_ns1__InsLnkOutSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsLnkOutSN:
		((_ns1__InsLnkOutSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsSNStationEmpResponse:
		((_ns1__InsSNStationEmpResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsSNStationEmp:
		((_ns1__InsSNStationEmp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelBoxLnkResponse:
		((_ns1__CancelBoxLnkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelBoxLnk:
		((_ns1__CancelBoxLnk *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutStationbyBoxResponse:
		((_ns1__OutStationbyBoxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OutStationbyBox:
		((_ns1__OutStationbyBox *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InStationbyBoxResponse:
		((_ns1__InStationbyBoxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InStationbyBox:
		((_ns1__InStationbyBox *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndSNtoBoxResponse:
		((_ns1__EndSNtoBoxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndSNtoBox:
		((_ns1__EndSNtoBox *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InSNtoBoxResponse:
		((_ns1__InSNtoBoxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InSNtoBox:
		((_ns1__InSNtoBox *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkBoxNoResponse:
		((_ns1__chkBoxNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkBoxNo:
		((_ns1__chkBoxNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsBoxNOTimeResponse:
		((_ns1__InsBoxNOTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsBoxNOTime:
		((_ns1__InsBoxNOTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLinkZJCountResponse:
		((_ns1__GetLinkZJCountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLinkZJCount:
		((_ns1__GetLinkZJCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsLinkSNResponse:
		((_ns1__InsLinkSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsLinkSN:
		((_ns1__InsLinkSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doLinkOutSNResponse:
		((_ns1__doLinkOutSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doLinkOutSN:
		((_ns1__doLinkOutSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkLinkOutSNResponse:
		((_ns1__ChkLinkOutSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkLinkOutSN:
		((_ns1__ChkLinkOutSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkOutSNResponse:
		((_ns1__chkOutSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkOutSN:
		((_ns1__chkOutSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLintOutQtyResponse:
		((_ns1__GetLintOutQtyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLintOutQty:
		((_ns1__GetLintOutQty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SNLinkZJResponse:
		((_ns1__SNLinkZJResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SNLinkZJ:
		((_ns1__SNLinkZJ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsZJTestDataResponse:
		((_ns1__InsZJTestDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsZJTestData:
		((_ns1__InsZJTestData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doPmcSNLinkResponse:
		((_ns1__doPmcSNLinkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doPmcSNLink:
		((_ns1__doPmcSNLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPmcSNPartResponse:
		((_ns1__GetPmcSNPartResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPmcSNPart:
		((_ns1__GetPmcSNPart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse:
		((_ns1__getPmcPartAssyListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyList:
		((_ns1__getPmcPartAssyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPmcAssyListResponse:
		((_ns1__getPmcAssyListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPmcAssyList:
		((_ns1__getPmcAssyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doAssyResponse:
		((_ns1__doAssyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doAssy:
		((_ns1__doAssy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkAssySNResponse:
		((_ns1__chkAssySNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkAssySN:
		((_ns1__chkAssySN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPNbySNResponse:
		((_ns1__getPNbySNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPNbySN:
		((_ns1__getPNbySN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoAssyCountResponse:
		((_ns1__getMoAssyCountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoAssyCount:
		((_ns1__getMoAssyCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLinkOutSnResponse:
		((_ns1__GetLinkOutSnResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLinkOutSn:
		((_ns1__GetLinkOutSn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsPartAssyResponse:
		((_ns1__InsPartAssyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsPartAssy:
		((_ns1__InsPartAssy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPartBomExtResponse:
		((_ns1__getPartBomExtResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPartBomExt:
		((_ns1__getPartBomExt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoAssyListResponse:
		((_ns1__getMoAssyListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoAssyList:
		((_ns1__getMoAssyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkSnMappingResponse:
		((_ns1__chkSnMappingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkSnMapping:
		((_ns1__chkSnMapping *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getStationTypeDescResponse:
		((_ns1__getStationTypeDescResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getStationTypeDesc:
		((_ns1__getStationTypeDesc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getStationByMoResponse:
		((_ns1__getStationByMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getStationByMo:
		((_ns1__getStationByMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnDoMappingResponse:
		((_ns1__SnDoMappingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnDoMapping:
		((_ns1__SnDoMapping *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__eMesNextMoResponse:
		((_ns1__eMesNextMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__eMesNextMo:
		((_ns1__eMesNextMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendResultForStationNumberResponse:
		((_ns1__sendResultForStationNumberResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendResultForStationNumber:
		((_ns1__sendResultForStationNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendDataForStationNumberResponse:
		((_ns1__sendDataForStationNumberResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendDataForStationNumber:
		((_ns1__sendDataForStationNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkEmpForStationNumberResponse:
		((_ns1__checkEmpForStationNumberResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkEmpForStationNumber:
		((_ns1__checkEmpForStationNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse:
		((_ns1__checkSN_USCOREStationNumberResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumber:
		((_ns1__checkSN_USCOREStationNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnNextMoResponse:
		((_ns1__ChkSnNextMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnNextMo:
		((_ns1__ChkSnNextMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnMoResponse:
		((_ns1__ChkSnMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnMo:
		((_ns1__ChkSnMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkMoStationResponse:
		((_ns1__chkMoStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkMoStation:
		((_ns1__chkMoStation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetEnergyStatResponse:
		((_ns1__SetEnergyStatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetEnergyStat:
		((_ns1__SetEnergyStat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getInfoByMoResponse:
		((_ns1__getInfoByMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getInfoByMo:
		((_ns1__getInfoByMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsThermalNewResponse:
		((_ns1__InsThermalNewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsThermalNew:
		((_ns1__InsThermalNew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnLinkResponse:
		((_ns1__ChkSnLinkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnLink:
		((_ns1__ChkSnLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsThermalResponse:
		((_ns1__InsThermalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsThermal:
		((_ns1__InsThermal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsWHDetectionResponse:
		((_ns1__InsWHDetectionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsWHDetection:
		((_ns1__InsWHDetection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFlatNessForCLResponse:
		((_ns1__InsFlatNessForCLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFlatNessForCL:
		((_ns1__InsFlatNessForCL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFlatNessForLSDResponse:
		((_ns1__InsFlatNessForLSDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFlatNessForLSD:
		((_ns1__InsFlatNessForLSD *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFlatNessResponse:
		((_ns1__InsFlatNessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFlatNess:
		((_ns1__InsFlatNess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ImpMesAteTestDataResponse:
		((_ns1__ImpMesAteTestDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ImpMesAteTestData:
		((_ns1__ImpMesAteTestData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkStationTimeResponse:
		((_ns1__chkStationTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkStationTime:
		((_ns1__chkStationTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InFruitsOrtQtyResponse:
		((_ns1__InFruitsOrtQtyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InFruitsOrtQty:
		((_ns1__InFruitsOrtQty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendTestResultResponse:
		((_ns1__sendTestResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendTestResult:
		((_ns1__sendTestResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendTestDataResponse:
		((_ns1__sendTestDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__sendTestData:
		((_ns1__sendTestData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationResponse:
		((_ns1__checkSN_USCOREStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStation:
		((_ns1__checkSN_USCOREStation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkEmpNoResponse:
		((_ns1__checkEmpNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkEmpNo:
		((_ns1__checkEmpNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkTestDataResponse:
		((_ns1__checkTestDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkTestData:
		((_ns1__checkTestData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsZjListResponse:
		((_ns1__InsZjListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsZjList:
		((_ns1__InsZjList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFruitMachineChkResponse:
		((_ns1__GetFruitMachineChkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFruitMachineChk:
		((_ns1__GetFruitMachineChk *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFruitMachineChkResponse:
		((_ns1__InsFruitMachineChkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsFruitMachineChk:
		((_ns1__InsFruitMachineChk *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnLnkOutSNResponse:
		((_ns1__SnLnkOutSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnLnkOutSN:
		((_ns1__SnLnkOutSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoBaseResponse:
		((_ns1__getMoBaseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMoBase:
		((_ns1__getMoBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNgCodeResponse:
		((_ns1__GetNgCodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNgCode:
		((_ns1__GetNgCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetDiecastSNResponse:
		((_ns1__SetDiecastSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetDiecastSN:
		((_ns1__SetDiecastSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMachineForGroupResponse:
		((_ns1__GetMachineForGroupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMachineForGroup:
		((_ns1__GetMachineForGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadForHPResponse:
		((_ns1__UploadForHPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadForHP:
		((_ns1__UploadForHP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelShelfLinkResponse:
		((_ns1__SelShelfLinkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelShelfLink:
		((_ns1__SelShelfLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SNLinkShelfResponse:
		((_ns1__SNLinkShelfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SNLinkShelf:
		((_ns1__SNLinkShelf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelSNTestForFruitResponse:
		((_ns1__SelSNTestForFruitResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelSNTestForFruit:
		((_ns1__SelSNTestForFruit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsSNTestForFruitResponse:
		((_ns1__InsSNTestForFruitResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsSNTestForFruit:
		((_ns1__InsSNTestForFruit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStationNumberForSNResponse:
		((_ns1__GetStationNumberForSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStationNumberForSN:
		((_ns1__GetStationNumberForSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTestValueResultResponse:
		((_ns1__GetTestValueResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTestValueResult:
		((_ns1__GetTestValueResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsCLScadaResponse:
		((_ns1__InsCLScadaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsCLScada:
		((_ns1__InsCLScada *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsAoiMoResponse:
		((_ns1__InsAoiMoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsAoiMo:
		((_ns1__InsAoiMo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkMoSNForAOIResponse:
		((_ns1__chkMoSNForAOIResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__chkMoSNForAOI:
		((_ns1__chkMoSNForAOI *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PunchOutResponse:
		((_ns1__PunchOutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PunchOut:
		((_ns1__PunchOut *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BasketLinkPunchResponse:
		((_ns1__BasketLinkPunchResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BasketLinkPunch:
		((_ns1__BasketLinkPunch *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HPSNLinkBasketResponse:
		((_ns1__HPSNLinkBasketResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HPSNLinkBasket:
		((_ns1__HPSNLinkBasket *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetAutoLineRecResponse:
		((_ns1__SetAutoLineRecResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetAutoLineRec:
		((_ns1__SetAutoLineRec *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSNForLinkResponse:
		((_ns1__GetSNForLinkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSNForLink:
		((_ns1__GetSNForLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRecResponse:
		((_ns1__SetFlatnessFruitRecResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRec:
		((_ns1__SetFlatnessFruitRec *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getStationByMoForTestPadResponse:
		((_ns1__getStationByMoForTestPadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getStationByMoForTestPad:
		((_ns1__getStationByMoForTestPad *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingWeightResponse:
		((_ns1__GetShippingWeightResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingWeight:
		((_ns1__GetShippingWeight *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingForBerthResponse:
		((_ns1__GetShippingForBerthResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingForBerth:
		((_ns1__GetShippingForBerth *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsShippingBerthResponse:
		((_ns1__InsShippingBerthResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsShippingBerth:
		((_ns1__InsShippingBerth *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsShippingPalleResponse:
		((_ns1__InsShippingPalleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsShippingPalle:
		((_ns1__InsShippingPalle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingPalleResponse:
		((_ns1__GetShippingPalleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingPalle:
		((_ns1__GetShippingPalle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdShippingResponse:
		((_ns1__UpdShippingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdShipping:
		((_ns1__UpdShipping *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingBerthListResponse:
		((_ns1__GetShippingBerthListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingBerthList:
		((_ns1__GetShippingBerthList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingListResponse:
		((_ns1__GetShippingListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShippingList:
		((_ns1__GetShippingList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doLotLinkForAppleResponse:
		((_ns1__doLotLinkForAppleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doLotLinkForApple:
		((_ns1__doLotLinkForApple *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotLinkCountResponse:
		((_ns1__GetLotLinkCountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotLinkCount:
		((_ns1__GetLotLinkCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFruitSNCheckResponse:
		((_ns1__GetFruitSNCheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFruitSNCheck:
		((_ns1__GetFruitSNCheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObeNWResponse:
		((_ns1__GetObeNWResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObeNW:
		((_ns1__GetObeNW *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doSnLinkForAppleResponse:
		((_ns1__doSnLinkForAppleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__doSnLinkForApple:
		((_ns1__doSnLinkForApple *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnLinkForAppleResponse:
		((_ns1__ChkSnLinkForAppleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkSnLinkForApple:
		((_ns1__ChkSnLinkForApple *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DelSNTestResponse:
		((_ns1__DelSNTestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DelSNTest:
		((_ns1__DelSNTest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelSNTestResponse:
		((_ns1__SelSNTestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelSNTest:
		((_ns1__SelSNTest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsSNTestResponse:
		((_ns1__InsSNTestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsSNTest:
		((_ns1__InsSNTest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkWeightTimeResponse:
		((_ns1__ChkWeightTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChkWeightTime:
		((_ns1__ChkWeightTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdAhsBarcodeResponse:
		((_ns1__UpdAhsBarcodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdAhsBarcode:
		((_ns1__UpdAhsBarcode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse:
		((_ns1__GetAhsBarcodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAhsBarcode:
		((_ns1__GetAhsBarcode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__GetAhsMo_:
		soap_serialize___ns1__GetAhsMo_(soap, (const struct __ns1__GetAhsMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPackWeigth_:
		soap_serialize___ns1__GetPackWeigth_(soap, (const struct __ns1__GetPackWeigth_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPackStation_:
		soap_serialize___ns1__GetPackStation_(soap, (const struct __ns1__GetPackStation_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetPallentForWMS_:
		soap_serialize___ns1__SetPallentForWMS_(soap, (const struct __ns1__SetPallentForWMS_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPallentToWMS_:
		soap_serialize___ns1__GetPallentToWMS_(soap, (const struct __ns1__GetPallentToWMS_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPackToWMS_:
		soap_serialize___ns1__GetPackToWMS_(soap, (const struct __ns1__GetPackToWMS_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetWeightSet_:
		soap_serialize___ns1__GetWeightSet_(soap, (const struct __ns1__GetWeightSet_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CancelLnkSN_:
		soap_serialize___ns1__CancelLnkSN_(soap, (const struct __ns1__CancelLnkSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CancelGrillSN_:
		soap_serialize___ns1__CancelGrillSN_(soap, (const struct __ns1__CancelGrillSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OutGrillBySN_:
		soap_serialize___ns1__OutGrillBySN_(soap, (const struct __ns1__OutGrillBySN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGrillTime_:
		soap_serialize___ns1__GetGrillTime_(soap, (const struct __ns1__GetGrillTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsGrillBySN_:
		soap_serialize___ns1__InsGrillBySN_(soap, (const struct __ns1__InsGrillBySN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseGrillSN_:
		soap_serialize___ns1__CloseGrillSN_(soap, (const struct __ns1__CloseGrillSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__LnkGrillSN_:
		soap_serialize___ns1__LnkGrillSN_(soap, (const struct __ns1__LnkGrillSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkGrillSN_:
		soap_serialize___ns1__chkGrillSN_(soap, (const struct __ns1__chkGrillSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__LnkSideSN_:
		soap_serialize___ns1__LnkSideSN_(soap, (const struct __ns1__LnkSideSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__LnkZJSN_:
		soap_serialize___ns1__LnkZJSN_(soap, (const struct __ns1__LnkZJSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkZJSN_:
		soap_serialize___ns1__chkZJSN_(soap, (const struct __ns1__chkZJSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkDispensing_:
		soap_serialize___ns1__chkDispensing_(soap, (const struct __ns1__chkDispensing_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsIotTestData_:
		soap_serialize___ns1__InsIotTestData_(soap, (const struct __ns1__InsIotTestData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsIotMachineRec_:
		soap_serialize___ns1__InsIotMachineRec_(soap, (const struct __ns1__InsIotMachineRec_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLnkData_:
		soap_serialize___ns1__GetLnkData_(soap, (const struct __ns1__GetLnkData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTestValue_:
		soap_serialize___ns1__GetTestValue_(soap, (const struct __ns1__GetTestValue_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMoBase_:
		soap_serialize___ns1__GetMoBase_(soap, (const struct __ns1__GetMoBase_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdSnRecInfo_:
		soap_serialize___ns1__UpdSnRecInfo_(soap, (const struct __ns1__UpdSnRecInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsBoxInfo_:
		soap_serialize___ns1__InsBoxInfo_(soap, (const struct __ns1__InsBoxInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsLnkOutSN_:
		soap_serialize___ns1__InsLnkOutSN_(soap, (const struct __ns1__InsLnkOutSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsSNStationEmp_:
		soap_serialize___ns1__InsSNStationEmp_(soap, (const struct __ns1__InsSNStationEmp_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CancelBoxLnk_:
		soap_serialize___ns1__CancelBoxLnk_(soap, (const struct __ns1__CancelBoxLnk_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OutStationbyBox_:
		soap_serialize___ns1__OutStationbyBox_(soap, (const struct __ns1__OutStationbyBox_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InStationbyBox_:
		soap_serialize___ns1__InStationbyBox_(soap, (const struct __ns1__InStationbyBox_ *)ptr);
		break;
	case SOAP_TYPE___ns1__EndSNtoBox_:
		soap_serialize___ns1__EndSNtoBox_(soap, (const struct __ns1__EndSNtoBox_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InSNtoBox_:
		soap_serialize___ns1__InSNtoBox_(soap, (const struct __ns1__InSNtoBox_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkBoxNo_:
		soap_serialize___ns1__chkBoxNo_(soap, (const struct __ns1__chkBoxNo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsBoxNOTime_:
		soap_serialize___ns1__InsBoxNOTime_(soap, (const struct __ns1__InsBoxNOTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLinkZJCount_:
		soap_serialize___ns1__GetLinkZJCount_(soap, (const struct __ns1__GetLinkZJCount_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsLinkSN_:
		soap_serialize___ns1__InsLinkSN_(soap, (const struct __ns1__InsLinkSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doLinkOutSN_:
		soap_serialize___ns1__doLinkOutSN_(soap, (const struct __ns1__doLinkOutSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkLinkOutSN_:
		soap_serialize___ns1__ChkLinkOutSN_(soap, (const struct __ns1__ChkLinkOutSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkOutSN_:
		soap_serialize___ns1__chkOutSN_(soap, (const struct __ns1__chkOutSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLintOutQty_:
		soap_serialize___ns1__GetLintOutQty_(soap, (const struct __ns1__GetLintOutQty_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SNLinkZJ_:
		soap_serialize___ns1__SNLinkZJ_(soap, (const struct __ns1__SNLinkZJ_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsZJTestData_:
		soap_serialize___ns1__InsZJTestData_(soap, (const struct __ns1__InsZJTestData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doPmcSNLink_:
		soap_serialize___ns1__doPmcSNLink_(soap, (const struct __ns1__doPmcSNLink_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPmcSNPart_:
		soap_serialize___ns1__GetPmcSNPart_(soap, (const struct __ns1__GetPmcSNPart_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getPmcPartAssyList_:
		soap_serialize___ns1__getPmcPartAssyList_(soap, (const struct __ns1__getPmcPartAssyList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getPmcAssyList_:
		soap_serialize___ns1__getPmcAssyList_(soap, (const struct __ns1__getPmcAssyList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doAssy_:
		soap_serialize___ns1__doAssy_(soap, (const struct __ns1__doAssy_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkAssySN_:
		soap_serialize___ns1__chkAssySN_(soap, (const struct __ns1__chkAssySN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getPNbySN_:
		soap_serialize___ns1__getPNbySN_(soap, (const struct __ns1__getPNbySN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getMoAssyCount_:
		soap_serialize___ns1__getMoAssyCount_(soap, (const struct __ns1__getMoAssyCount_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLinkOutSn_:
		soap_serialize___ns1__GetLinkOutSn_(soap, (const struct __ns1__GetLinkOutSn_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsPartAssy_:
		soap_serialize___ns1__InsPartAssy_(soap, (const struct __ns1__InsPartAssy_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getPartBomExt_:
		soap_serialize___ns1__getPartBomExt_(soap, (const struct __ns1__getPartBomExt_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getMoAssyList_:
		soap_serialize___ns1__getMoAssyList_(soap, (const struct __ns1__getMoAssyList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkSnMapping_:
		soap_serialize___ns1__chkSnMapping_(soap, (const struct __ns1__chkSnMapping_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getStationTypeDesc_:
		soap_serialize___ns1__getStationTypeDesc_(soap, (const struct __ns1__getStationTypeDesc_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getStationByMo_:
		soap_serialize___ns1__getStationByMo_(soap, (const struct __ns1__getStationByMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SnDoMapping_:
		soap_serialize___ns1__SnDoMapping_(soap, (const struct __ns1__SnDoMapping_ *)ptr);
		break;
	case SOAP_TYPE___ns1__eMesNextMo_:
		soap_serialize___ns1__eMesNextMo_(soap, (const struct __ns1__eMesNextMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sendResultForStationNumber_:
		soap_serialize___ns1__sendResultForStationNumber_(soap, (const struct __ns1__sendResultForStationNumber_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sendDataForStationNumber_:
		soap_serialize___ns1__sendDataForStationNumber_(soap, (const struct __ns1__sendDataForStationNumber_ *)ptr);
		break;
	case SOAP_TYPE___ns1__checkEmpForStationNumber_:
		soap_serialize___ns1__checkEmpForStationNumber_(soap, (const struct __ns1__checkEmpForStationNumber_ *)ptr);
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber_:
		soap_serialize___ns1__checkSN_USCOREStationNumber_(soap, (const struct __ns1__checkSN_USCOREStationNumber_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnNextMo_:
		soap_serialize___ns1__ChkSnNextMo_(soap, (const struct __ns1__ChkSnNextMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnMo_:
		soap_serialize___ns1__ChkSnMo_(soap, (const struct __ns1__ChkSnMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkMoStation_:
		soap_serialize___ns1__chkMoStation_(soap, (const struct __ns1__chkMoStation_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetEnergyStat_:
		soap_serialize___ns1__SetEnergyStat_(soap, (const struct __ns1__SetEnergyStat_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getInfoByMo_:
		soap_serialize___ns1__getInfoByMo_(soap, (const struct __ns1__getInfoByMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsThermalNew_:
		soap_serialize___ns1__InsThermalNew_(soap, (const struct __ns1__InsThermalNew_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnLink_:
		soap_serialize___ns1__ChkSnLink_(soap, (const struct __ns1__ChkSnLink_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsThermal_:
		soap_serialize___ns1__InsThermal_(soap, (const struct __ns1__InsThermal_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsWHDetection_:
		soap_serialize___ns1__InsWHDetection_(soap, (const struct __ns1__InsWHDetection_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFlatNessForCL_:
		soap_serialize___ns1__InsFlatNessForCL_(soap, (const struct __ns1__InsFlatNessForCL_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFlatNessForLSD_:
		soap_serialize___ns1__InsFlatNessForLSD_(soap, (const struct __ns1__InsFlatNessForLSD_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFlatNess_:
		soap_serialize___ns1__InsFlatNess_(soap, (const struct __ns1__InsFlatNess_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ImpMesAteTestData_:
		soap_serialize___ns1__ImpMesAteTestData_(soap, (const struct __ns1__ImpMesAteTestData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkStationTime_:
		soap_serialize___ns1__chkStationTime_(soap, (const struct __ns1__chkStationTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InFruitsOrtQty_:
		soap_serialize___ns1__InFruitsOrtQty_(soap, (const struct __ns1__InFruitsOrtQty_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sendTestResult_:
		soap_serialize___ns1__sendTestResult_(soap, (const struct __ns1__sendTestResult_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sendTestData_:
		soap_serialize___ns1__sendTestData_(soap, (const struct __ns1__sendTestData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStation_:
		soap_serialize___ns1__checkSN_USCOREStation_(soap, (const struct __ns1__checkSN_USCOREStation_ *)ptr);
		break;
	case SOAP_TYPE___ns1__checkEmpNo_:
		soap_serialize___ns1__checkEmpNo_(soap, (const struct __ns1__checkEmpNo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__checkTestData_:
		soap_serialize___ns1__checkTestData_(soap, (const struct __ns1__checkTestData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsZjList_:
		soap_serialize___ns1__InsZjList_(soap, (const struct __ns1__InsZjList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFruitMachineChk_:
		soap_serialize___ns1__GetFruitMachineChk_(soap, (const struct __ns1__GetFruitMachineChk_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFruitMachineChk_:
		soap_serialize___ns1__InsFruitMachineChk_(soap, (const struct __ns1__InsFruitMachineChk_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SnLnkOutSN_:
		soap_serialize___ns1__SnLnkOutSN_(soap, (const struct __ns1__SnLnkOutSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getMoBase_:
		soap_serialize___ns1__getMoBase_(soap, (const struct __ns1__getMoBase_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetNgCode_:
		soap_serialize___ns1__GetNgCode_(soap, (const struct __ns1__GetNgCode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetDiecastSN_:
		soap_serialize___ns1__SetDiecastSN_(soap, (const struct __ns1__SetDiecastSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMachineForGroup_:
		soap_serialize___ns1__GetMachineForGroup_(soap, (const struct __ns1__GetMachineForGroup_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadForHP_:
		soap_serialize___ns1__UploadForHP_(soap, (const struct __ns1__UploadForHP_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SelShelfLink_:
		soap_serialize___ns1__SelShelfLink_(soap, (const struct __ns1__SelShelfLink_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SNLinkShelf_:
		soap_serialize___ns1__SNLinkShelf_(soap, (const struct __ns1__SNLinkShelf_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SelSNTestForFruit_:
		soap_serialize___ns1__SelSNTestForFruit_(soap, (const struct __ns1__SelSNTestForFruit_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsSNTestForFruit_:
		soap_serialize___ns1__InsSNTestForFruit_(soap, (const struct __ns1__InsSNTestForFruit_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStationNumberForSN_:
		soap_serialize___ns1__GetStationNumberForSN_(soap, (const struct __ns1__GetStationNumberForSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTestValueResult_:
		soap_serialize___ns1__GetTestValueResult_(soap, (const struct __ns1__GetTestValueResult_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsCLScada_:
		soap_serialize___ns1__InsCLScada_(soap, (const struct __ns1__InsCLScada_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsAoiMo_:
		soap_serialize___ns1__InsAoiMo_(soap, (const struct __ns1__InsAoiMo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__chkMoSNForAOI_:
		soap_serialize___ns1__chkMoSNForAOI_(soap, (const struct __ns1__chkMoSNForAOI_ *)ptr);
		break;
	case SOAP_TYPE___ns1__PunchOut_:
		soap_serialize___ns1__PunchOut_(soap, (const struct __ns1__PunchOut_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BasketLinkPunch_:
		soap_serialize___ns1__BasketLinkPunch_(soap, (const struct __ns1__BasketLinkPunch_ *)ptr);
		break;
	case SOAP_TYPE___ns1__HPSNLinkBasket_:
		soap_serialize___ns1__HPSNLinkBasket_(soap, (const struct __ns1__HPSNLinkBasket_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetAutoLineRec_:
		soap_serialize___ns1__SetAutoLineRec_(soap, (const struct __ns1__SetAutoLineRec_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSNForLink_:
		soap_serialize___ns1__GetSNForLink_(soap, (const struct __ns1__GetSNForLink_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetFlatnessFruitRec_:
		soap_serialize___ns1__SetFlatnessFruitRec_(soap, (const struct __ns1__SetFlatnessFruitRec_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getStationByMoForTestPad_:
		soap_serialize___ns1__getStationByMoForTestPad_(soap, (const struct __ns1__getStationByMoForTestPad_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingWeight_:
		soap_serialize___ns1__GetShippingWeight_(soap, (const struct __ns1__GetShippingWeight_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingForBerth_:
		soap_serialize___ns1__GetShippingForBerth_(soap, (const struct __ns1__GetShippingForBerth_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsShippingBerth_:
		soap_serialize___ns1__InsShippingBerth_(soap, (const struct __ns1__InsShippingBerth_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsShippingPalle_:
		soap_serialize___ns1__InsShippingPalle_(soap, (const struct __ns1__InsShippingPalle_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingPalle_:
		soap_serialize___ns1__GetShippingPalle_(soap, (const struct __ns1__GetShippingPalle_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdShipping_:
		soap_serialize___ns1__UpdShipping_(soap, (const struct __ns1__UpdShipping_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingBerthList_:
		soap_serialize___ns1__GetShippingBerthList_(soap, (const struct __ns1__GetShippingBerthList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingList_:
		soap_serialize___ns1__GetShippingList_(soap, (const struct __ns1__GetShippingList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doLotLinkForApple_:
		soap_serialize___ns1__doLotLinkForApple_(soap, (const struct __ns1__doLotLinkForApple_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotLinkCount_:
		soap_serialize___ns1__GetLotLinkCount_(soap, (const struct __ns1__GetLotLinkCount_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFruitSNCheck_:
		soap_serialize___ns1__GetFruitSNCheck_(soap, (const struct __ns1__GetFruitSNCheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetObeNW_:
		soap_serialize___ns1__GetObeNW_(soap, (const struct __ns1__GetObeNW_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doSnLinkForApple_:
		soap_serialize___ns1__doSnLinkForApple_(soap, (const struct __ns1__doSnLinkForApple_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnLinkForApple_:
		soap_serialize___ns1__ChkSnLinkForApple_(soap, (const struct __ns1__ChkSnLinkForApple_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DelSNTest_:
		soap_serialize___ns1__DelSNTest_(soap, (const struct __ns1__DelSNTest_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SelSNTest_:
		soap_serialize___ns1__SelSNTest_(soap, (const struct __ns1__SelSNTest_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsSNTest_:
		soap_serialize___ns1__InsSNTest_(soap, (const struct __ns1__InsSNTest_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkWeightTime_:
		soap_serialize___ns1__ChkWeightTime_(soap, (const struct __ns1__ChkWeightTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdAhsBarcode_:
		soap_serialize___ns1__UpdAhsBarcode_(soap, (const struct __ns1__UpdAhsBarcode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAhsBarcode_:
		soap_serialize___ns1__GetAhsBarcode_(soap, (const struct __ns1__GetAhsBarcode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAhsMo:
		soap_serialize___ns1__GetAhsMo(soap, (const struct __ns1__GetAhsMo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPackWeigth:
		soap_serialize___ns1__GetPackWeigth(soap, (const struct __ns1__GetPackWeigth *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPackStation:
		soap_serialize___ns1__GetPackStation(soap, (const struct __ns1__GetPackStation *)ptr);
		break;
	case SOAP_TYPE___ns1__SetPallentForWMS:
		soap_serialize___ns1__SetPallentForWMS(soap, (const struct __ns1__SetPallentForWMS *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPallentToWMS:
		soap_serialize___ns1__GetPallentToWMS(soap, (const struct __ns1__GetPallentToWMS *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPackToWMS:
		soap_serialize___ns1__GetPackToWMS(soap, (const struct __ns1__GetPackToWMS *)ptr);
		break;
	case SOAP_TYPE___ns1__GetWeightSet:
		soap_serialize___ns1__GetWeightSet(soap, (const struct __ns1__GetWeightSet *)ptr);
		break;
	case SOAP_TYPE___ns1__CancelLnkSN:
		soap_serialize___ns1__CancelLnkSN(soap, (const struct __ns1__CancelLnkSN *)ptr);
		break;
	case SOAP_TYPE___ns1__CancelGrillSN:
		soap_serialize___ns1__CancelGrillSN(soap, (const struct __ns1__CancelGrillSN *)ptr);
		break;
	case SOAP_TYPE___ns1__OutGrillBySN:
		soap_serialize___ns1__OutGrillBySN(soap, (const struct __ns1__OutGrillBySN *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGrillTime:
		soap_serialize___ns1__GetGrillTime(soap, (const struct __ns1__GetGrillTime *)ptr);
		break;
	case SOAP_TYPE___ns1__InsGrillBySN:
		soap_serialize___ns1__InsGrillBySN(soap, (const struct __ns1__InsGrillBySN *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseGrillSN:
		soap_serialize___ns1__CloseGrillSN(soap, (const struct __ns1__CloseGrillSN *)ptr);
		break;
	case SOAP_TYPE___ns1__LnkGrillSN:
		soap_serialize___ns1__LnkGrillSN(soap, (const struct __ns1__LnkGrillSN *)ptr);
		break;
	case SOAP_TYPE___ns1__chkGrillSN:
		soap_serialize___ns1__chkGrillSN(soap, (const struct __ns1__chkGrillSN *)ptr);
		break;
	case SOAP_TYPE___ns1__LnkSideSN:
		soap_serialize___ns1__LnkSideSN(soap, (const struct __ns1__LnkSideSN *)ptr);
		break;
	case SOAP_TYPE___ns1__LnkZJSN:
		soap_serialize___ns1__LnkZJSN(soap, (const struct __ns1__LnkZJSN *)ptr);
		break;
	case SOAP_TYPE___ns1__chkZJSN:
		soap_serialize___ns1__chkZJSN(soap, (const struct __ns1__chkZJSN *)ptr);
		break;
	case SOAP_TYPE___ns1__chkDispensing:
		soap_serialize___ns1__chkDispensing(soap, (const struct __ns1__chkDispensing *)ptr);
		break;
	case SOAP_TYPE___ns1__InsIotTestData:
		soap_serialize___ns1__InsIotTestData(soap, (const struct __ns1__InsIotTestData *)ptr);
		break;
	case SOAP_TYPE___ns1__InsIotMachineRec:
		soap_serialize___ns1__InsIotMachineRec(soap, (const struct __ns1__InsIotMachineRec *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLnkData:
		soap_serialize___ns1__GetLnkData(soap, (const struct __ns1__GetLnkData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTestValue:
		soap_serialize___ns1__GetTestValue(soap, (const struct __ns1__GetTestValue *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMoBase:
		soap_serialize___ns1__GetMoBase(soap, (const struct __ns1__GetMoBase *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdSnRecInfo:
		soap_serialize___ns1__UpdSnRecInfo(soap, (const struct __ns1__UpdSnRecInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InsBoxInfo:
		soap_serialize___ns1__InsBoxInfo(soap, (const struct __ns1__InsBoxInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InsLnkOutSN:
		soap_serialize___ns1__InsLnkOutSN(soap, (const struct __ns1__InsLnkOutSN *)ptr);
		break;
	case SOAP_TYPE___ns1__InsSNStationEmp:
		soap_serialize___ns1__InsSNStationEmp(soap, (const struct __ns1__InsSNStationEmp *)ptr);
		break;
	case SOAP_TYPE___ns1__CancelBoxLnk:
		soap_serialize___ns1__CancelBoxLnk(soap, (const struct __ns1__CancelBoxLnk *)ptr);
		break;
	case SOAP_TYPE___ns1__OutStationbyBox:
		soap_serialize___ns1__OutStationbyBox(soap, (const struct __ns1__OutStationbyBox *)ptr);
		break;
	case SOAP_TYPE___ns1__InStationbyBox:
		soap_serialize___ns1__InStationbyBox(soap, (const struct __ns1__InStationbyBox *)ptr);
		break;
	case SOAP_TYPE___ns1__EndSNtoBox:
		soap_serialize___ns1__EndSNtoBox(soap, (const struct __ns1__EndSNtoBox *)ptr);
		break;
	case SOAP_TYPE___ns1__InSNtoBox:
		soap_serialize___ns1__InSNtoBox(soap, (const struct __ns1__InSNtoBox *)ptr);
		break;
	case SOAP_TYPE___ns1__chkBoxNo:
		soap_serialize___ns1__chkBoxNo(soap, (const struct __ns1__chkBoxNo *)ptr);
		break;
	case SOAP_TYPE___ns1__InsBoxNOTime:
		soap_serialize___ns1__InsBoxNOTime(soap, (const struct __ns1__InsBoxNOTime *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLinkZJCount:
		soap_serialize___ns1__GetLinkZJCount(soap, (const struct __ns1__GetLinkZJCount *)ptr);
		break;
	case SOAP_TYPE___ns1__InsLinkSN:
		soap_serialize___ns1__InsLinkSN(soap, (const struct __ns1__InsLinkSN *)ptr);
		break;
	case SOAP_TYPE___ns1__doLinkOutSN:
		soap_serialize___ns1__doLinkOutSN(soap, (const struct __ns1__doLinkOutSN *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkLinkOutSN:
		soap_serialize___ns1__ChkLinkOutSN(soap, (const struct __ns1__ChkLinkOutSN *)ptr);
		break;
	case SOAP_TYPE___ns1__chkOutSN:
		soap_serialize___ns1__chkOutSN(soap, (const struct __ns1__chkOutSN *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLintOutQty:
		soap_serialize___ns1__GetLintOutQty(soap, (const struct __ns1__GetLintOutQty *)ptr);
		break;
	case SOAP_TYPE___ns1__SNLinkZJ:
		soap_serialize___ns1__SNLinkZJ(soap, (const struct __ns1__SNLinkZJ *)ptr);
		break;
	case SOAP_TYPE___ns1__InsZJTestData:
		soap_serialize___ns1__InsZJTestData(soap, (const struct __ns1__InsZJTestData *)ptr);
		break;
	case SOAP_TYPE___ns1__doPmcSNLink:
		soap_serialize___ns1__doPmcSNLink(soap, (const struct __ns1__doPmcSNLink *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPmcSNPart:
		soap_serialize___ns1__GetPmcSNPart(soap, (const struct __ns1__GetPmcSNPart *)ptr);
		break;
	case SOAP_TYPE___ns1__getPmcPartAssyList:
		soap_serialize___ns1__getPmcPartAssyList(soap, (const struct __ns1__getPmcPartAssyList *)ptr);
		break;
	case SOAP_TYPE___ns1__getPmcAssyList:
		soap_serialize___ns1__getPmcAssyList(soap, (const struct __ns1__getPmcAssyList *)ptr);
		break;
	case SOAP_TYPE___ns1__doAssy:
		soap_serialize___ns1__doAssy(soap, (const struct __ns1__doAssy *)ptr);
		break;
	case SOAP_TYPE___ns1__chkAssySN:
		soap_serialize___ns1__chkAssySN(soap, (const struct __ns1__chkAssySN *)ptr);
		break;
	case SOAP_TYPE___ns1__getPNbySN:
		soap_serialize___ns1__getPNbySN(soap, (const struct __ns1__getPNbySN *)ptr);
		break;
	case SOAP_TYPE___ns1__getMoAssyCount:
		soap_serialize___ns1__getMoAssyCount(soap, (const struct __ns1__getMoAssyCount *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLinkOutSn:
		soap_serialize___ns1__GetLinkOutSn(soap, (const struct __ns1__GetLinkOutSn *)ptr);
		break;
	case SOAP_TYPE___ns1__InsPartAssy:
		soap_serialize___ns1__InsPartAssy(soap, (const struct __ns1__InsPartAssy *)ptr);
		break;
	case SOAP_TYPE___ns1__getPartBomExt:
		soap_serialize___ns1__getPartBomExt(soap, (const struct __ns1__getPartBomExt *)ptr);
		break;
	case SOAP_TYPE___ns1__getMoAssyList:
		soap_serialize___ns1__getMoAssyList(soap, (const struct __ns1__getMoAssyList *)ptr);
		break;
	case SOAP_TYPE___ns1__chkSnMapping:
		soap_serialize___ns1__chkSnMapping(soap, (const struct __ns1__chkSnMapping *)ptr);
		break;
	case SOAP_TYPE___ns1__getStationTypeDesc:
		soap_serialize___ns1__getStationTypeDesc(soap, (const struct __ns1__getStationTypeDesc *)ptr);
		break;
	case SOAP_TYPE___ns1__getStationByMo:
		soap_serialize___ns1__getStationByMo(soap, (const struct __ns1__getStationByMo *)ptr);
		break;
	case SOAP_TYPE___ns1__SnDoMapping:
		soap_serialize___ns1__SnDoMapping(soap, (const struct __ns1__SnDoMapping *)ptr);
		break;
	case SOAP_TYPE___ns1__eMesNextMo:
		soap_serialize___ns1__eMesNextMo(soap, (const struct __ns1__eMesNextMo *)ptr);
		break;
	case SOAP_TYPE___ns1__sendResultForStationNumber:
		soap_serialize___ns1__sendResultForStationNumber(soap, (const struct __ns1__sendResultForStationNumber *)ptr);
		break;
	case SOAP_TYPE___ns1__sendDataForStationNumber:
		soap_serialize___ns1__sendDataForStationNumber(soap, (const struct __ns1__sendDataForStationNumber *)ptr);
		break;
	case SOAP_TYPE___ns1__checkEmpForStationNumber:
		soap_serialize___ns1__checkEmpForStationNumber(soap, (const struct __ns1__checkEmpForStationNumber *)ptr);
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber:
		soap_serialize___ns1__checkSN_USCOREStationNumber(soap, (const struct __ns1__checkSN_USCOREStationNumber *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnNextMo:
		soap_serialize___ns1__ChkSnNextMo(soap, (const struct __ns1__ChkSnNextMo *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnMo:
		soap_serialize___ns1__ChkSnMo(soap, (const struct __ns1__ChkSnMo *)ptr);
		break;
	case SOAP_TYPE___ns1__chkMoStation:
		soap_serialize___ns1__chkMoStation(soap, (const struct __ns1__chkMoStation *)ptr);
		break;
	case SOAP_TYPE___ns1__SetEnergyStat:
		soap_serialize___ns1__SetEnergyStat(soap, (const struct __ns1__SetEnergyStat *)ptr);
		break;
	case SOAP_TYPE___ns1__getInfoByMo:
		soap_serialize___ns1__getInfoByMo(soap, (const struct __ns1__getInfoByMo *)ptr);
		break;
	case SOAP_TYPE___ns1__InsThermalNew:
		soap_serialize___ns1__InsThermalNew(soap, (const struct __ns1__InsThermalNew *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnLink:
		soap_serialize___ns1__ChkSnLink(soap, (const struct __ns1__ChkSnLink *)ptr);
		break;
	case SOAP_TYPE___ns1__InsThermal:
		soap_serialize___ns1__InsThermal(soap, (const struct __ns1__InsThermal *)ptr);
		break;
	case SOAP_TYPE___ns1__InsWHDetection:
		soap_serialize___ns1__InsWHDetection(soap, (const struct __ns1__InsWHDetection *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFlatNessForCL:
		soap_serialize___ns1__InsFlatNessForCL(soap, (const struct __ns1__InsFlatNessForCL *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFlatNessForLSD:
		soap_serialize___ns1__InsFlatNessForLSD(soap, (const struct __ns1__InsFlatNessForLSD *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFlatNess:
		soap_serialize___ns1__InsFlatNess(soap, (const struct __ns1__InsFlatNess *)ptr);
		break;
	case SOAP_TYPE___ns1__ImpMesAteTestData:
		soap_serialize___ns1__ImpMesAteTestData(soap, (const struct __ns1__ImpMesAteTestData *)ptr);
		break;
	case SOAP_TYPE___ns1__chkStationTime:
		soap_serialize___ns1__chkStationTime(soap, (const struct __ns1__chkStationTime *)ptr);
		break;
	case SOAP_TYPE___ns1__InFruitsOrtQty:
		soap_serialize___ns1__InFruitsOrtQty(soap, (const struct __ns1__InFruitsOrtQty *)ptr);
		break;
	case SOAP_TYPE___ns1__sendTestResult:
		soap_serialize___ns1__sendTestResult(soap, (const struct __ns1__sendTestResult *)ptr);
		break;
	case SOAP_TYPE___ns1__sendTestData:
		soap_serialize___ns1__sendTestData(soap, (const struct __ns1__sendTestData *)ptr);
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStation:
		soap_serialize___ns1__checkSN_USCOREStation(soap, (const struct __ns1__checkSN_USCOREStation *)ptr);
		break;
	case SOAP_TYPE___ns1__checkEmpNo:
		soap_serialize___ns1__checkEmpNo(soap, (const struct __ns1__checkEmpNo *)ptr);
		break;
	case SOAP_TYPE___ns1__checkTestData:
		soap_serialize___ns1__checkTestData(soap, (const struct __ns1__checkTestData *)ptr);
		break;
	case SOAP_TYPE___ns1__InsZjList:
		soap_serialize___ns1__InsZjList(soap, (const struct __ns1__InsZjList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFruitMachineChk:
		soap_serialize___ns1__GetFruitMachineChk(soap, (const struct __ns1__GetFruitMachineChk *)ptr);
		break;
	case SOAP_TYPE___ns1__InsFruitMachineChk:
		soap_serialize___ns1__InsFruitMachineChk(soap, (const struct __ns1__InsFruitMachineChk *)ptr);
		break;
	case SOAP_TYPE___ns1__SnLnkOutSN:
		soap_serialize___ns1__SnLnkOutSN(soap, (const struct __ns1__SnLnkOutSN *)ptr);
		break;
	case SOAP_TYPE___ns1__getMoBase:
		soap_serialize___ns1__getMoBase(soap, (const struct __ns1__getMoBase *)ptr);
		break;
	case SOAP_TYPE___ns1__GetNgCode:
		soap_serialize___ns1__GetNgCode(soap, (const struct __ns1__GetNgCode *)ptr);
		break;
	case SOAP_TYPE___ns1__SetDiecastSN:
		soap_serialize___ns1__SetDiecastSN(soap, (const struct __ns1__SetDiecastSN *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMachineForGroup:
		soap_serialize___ns1__GetMachineForGroup(soap, (const struct __ns1__GetMachineForGroup *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadForHP:
		soap_serialize___ns1__UploadForHP(soap, (const struct __ns1__UploadForHP *)ptr);
		break;
	case SOAP_TYPE___ns1__SelShelfLink:
		soap_serialize___ns1__SelShelfLink(soap, (const struct __ns1__SelShelfLink *)ptr);
		break;
	case SOAP_TYPE___ns1__SNLinkShelf:
		soap_serialize___ns1__SNLinkShelf(soap, (const struct __ns1__SNLinkShelf *)ptr);
		break;
	case SOAP_TYPE___ns1__SelSNTestForFruit:
		soap_serialize___ns1__SelSNTestForFruit(soap, (const struct __ns1__SelSNTestForFruit *)ptr);
		break;
	case SOAP_TYPE___ns1__InsSNTestForFruit:
		soap_serialize___ns1__InsSNTestForFruit(soap, (const struct __ns1__InsSNTestForFruit *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStationNumberForSN:
		soap_serialize___ns1__GetStationNumberForSN(soap, (const struct __ns1__GetStationNumberForSN *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTestValueResult:
		soap_serialize___ns1__GetTestValueResult(soap, (const struct __ns1__GetTestValueResult *)ptr);
		break;
	case SOAP_TYPE___ns1__InsCLScada:
		soap_serialize___ns1__InsCLScada(soap, (const struct __ns1__InsCLScada *)ptr);
		break;
	case SOAP_TYPE___ns1__InsAoiMo:
		soap_serialize___ns1__InsAoiMo(soap, (const struct __ns1__InsAoiMo *)ptr);
		break;
	case SOAP_TYPE___ns1__chkMoSNForAOI:
		soap_serialize___ns1__chkMoSNForAOI(soap, (const struct __ns1__chkMoSNForAOI *)ptr);
		break;
	case SOAP_TYPE___ns1__PunchOut:
		soap_serialize___ns1__PunchOut(soap, (const struct __ns1__PunchOut *)ptr);
		break;
	case SOAP_TYPE___ns1__BasketLinkPunch:
		soap_serialize___ns1__BasketLinkPunch(soap, (const struct __ns1__BasketLinkPunch *)ptr);
		break;
	case SOAP_TYPE___ns1__HPSNLinkBasket:
		soap_serialize___ns1__HPSNLinkBasket(soap, (const struct __ns1__HPSNLinkBasket *)ptr);
		break;
	case SOAP_TYPE___ns1__SetAutoLineRec:
		soap_serialize___ns1__SetAutoLineRec(soap, (const struct __ns1__SetAutoLineRec *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSNForLink:
		soap_serialize___ns1__GetSNForLink(soap, (const struct __ns1__GetSNForLink *)ptr);
		break;
	case SOAP_TYPE___ns1__SetFlatnessFruitRec:
		soap_serialize___ns1__SetFlatnessFruitRec(soap, (const struct __ns1__SetFlatnessFruitRec *)ptr);
		break;
	case SOAP_TYPE___ns1__getStationByMoForTestPad:
		soap_serialize___ns1__getStationByMoForTestPad(soap, (const struct __ns1__getStationByMoForTestPad *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingWeight:
		soap_serialize___ns1__GetShippingWeight(soap, (const struct __ns1__GetShippingWeight *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingForBerth:
		soap_serialize___ns1__GetShippingForBerth(soap, (const struct __ns1__GetShippingForBerth *)ptr);
		break;
	case SOAP_TYPE___ns1__InsShippingBerth:
		soap_serialize___ns1__InsShippingBerth(soap, (const struct __ns1__InsShippingBerth *)ptr);
		break;
	case SOAP_TYPE___ns1__InsShippingPalle:
		soap_serialize___ns1__InsShippingPalle(soap, (const struct __ns1__InsShippingPalle *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingPalle:
		soap_serialize___ns1__GetShippingPalle(soap, (const struct __ns1__GetShippingPalle *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdShipping:
		soap_serialize___ns1__UpdShipping(soap, (const struct __ns1__UpdShipping *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingBerthList:
		soap_serialize___ns1__GetShippingBerthList(soap, (const struct __ns1__GetShippingBerthList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShippingList:
		soap_serialize___ns1__GetShippingList(soap, (const struct __ns1__GetShippingList *)ptr);
		break;
	case SOAP_TYPE___ns1__doLotLinkForApple:
		soap_serialize___ns1__doLotLinkForApple(soap, (const struct __ns1__doLotLinkForApple *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotLinkCount:
		soap_serialize___ns1__GetLotLinkCount(soap, (const struct __ns1__GetLotLinkCount *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFruitSNCheck:
		soap_serialize___ns1__GetFruitSNCheck(soap, (const struct __ns1__GetFruitSNCheck *)ptr);
		break;
	case SOAP_TYPE___ns1__GetObeNW:
		soap_serialize___ns1__GetObeNW(soap, (const struct __ns1__GetObeNW *)ptr);
		break;
	case SOAP_TYPE___ns1__doSnLinkForApple:
		soap_serialize___ns1__doSnLinkForApple(soap, (const struct __ns1__doSnLinkForApple *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkSnLinkForApple:
		soap_serialize___ns1__ChkSnLinkForApple(soap, (const struct __ns1__ChkSnLinkForApple *)ptr);
		break;
	case SOAP_TYPE___ns1__DelSNTest:
		soap_serialize___ns1__DelSNTest(soap, (const struct __ns1__DelSNTest *)ptr);
		break;
	case SOAP_TYPE___ns1__SelSNTest:
		soap_serialize___ns1__SelSNTest(soap, (const struct __ns1__SelSNTest *)ptr);
		break;
	case SOAP_TYPE___ns1__InsSNTest:
		soap_serialize___ns1__InsSNTest(soap, (const struct __ns1__InsSNTest *)ptr);
		break;
	case SOAP_TYPE___ns1__ChkWeightTime:
		soap_serialize___ns1__ChkWeightTime(soap, (const struct __ns1__ChkWeightTime *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdAhsBarcode:
		soap_serialize___ns1__UpdAhsBarcode(soap, (const struct __ns1__UpdAhsBarcode *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAhsBarcode:
		soap_serialize___ns1__GetAhsBarcode(soap, (const struct __ns1__GetAhsBarcode *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAhsMo:
		soap_serialize_PointerTo_ns1__GetAhsMo(soap, (_ns1__GetAhsMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPackWeigth:
		soap_serialize_PointerTo_ns1__GetPackWeigth(soap, (_ns1__GetPackWeigth *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPackStation:
		soap_serialize_PointerTo_ns1__GetPackStation(soap, (_ns1__GetPackStation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPallentForWMS:
		soap_serialize_PointerTo_ns1__SetPallentForWMS(soap, (_ns1__SetPallentForWMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPallentToWMS:
		soap_serialize_PointerTo_ns1__GetPallentToWMS(soap, (_ns1__GetPallentToWMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPackToWMS:
		soap_serialize_PointerTo_ns1__GetPackToWMS(soap, (_ns1__GetPackToWMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetWeightSet:
		soap_serialize_PointerTo_ns1__GetWeightSet(soap, (_ns1__GetWeightSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CancelLnkSN:
		soap_serialize_PointerTo_ns1__CancelLnkSN(soap, (_ns1__CancelLnkSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CancelGrillSN:
		soap_serialize_PointerTo_ns1__CancelGrillSN(soap, (_ns1__CancelGrillSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OutGrillBySN:
		soap_serialize_PointerTo_ns1__OutGrillBySN(soap, (_ns1__OutGrillBySN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetGrillTime:
		soap_serialize_PointerTo_ns1__GetGrillTime(soap, (_ns1__GetGrillTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsGrillBySN:
		soap_serialize_PointerTo_ns1__InsGrillBySN(soap, (_ns1__InsGrillBySN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CloseGrillSN:
		soap_serialize_PointerTo_ns1__CloseGrillSN(soap, (_ns1__CloseGrillSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LnkGrillSN:
		soap_serialize_PointerTo_ns1__LnkGrillSN(soap, (_ns1__LnkGrillSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkGrillSN:
		soap_serialize_PointerTo_ns1__chkGrillSN(soap, (_ns1__chkGrillSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LnkSideSN:
		soap_serialize_PointerTo_ns1__LnkSideSN(soap, (_ns1__LnkSideSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LnkZJSN:
		soap_serialize_PointerTo_ns1__LnkZJSN(soap, (_ns1__LnkZJSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkZJSN:
		soap_serialize_PointerTo_ns1__chkZJSN(soap, (_ns1__chkZJSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkDispensing:
		soap_serialize_PointerTo_ns1__chkDispensing(soap, (_ns1__chkDispensing *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsIotTestData:
		soap_serialize_PointerTo_ns1__InsIotTestData(soap, (_ns1__InsIotTestData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsIotMachineRec:
		soap_serialize_PointerTo_ns1__InsIotMachineRec(soap, (_ns1__InsIotMachineRec *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLnkData:
		soap_serialize_PointerTo_ns1__GetLnkData(soap, (_ns1__GetLnkData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTestValue:
		soap_serialize_PointerTo_ns1__GetTestValue(soap, (_ns1__GetTestValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMoBase:
		soap_serialize_PointerTo_ns1__GetMoBase(soap, (_ns1__GetMoBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdSnRecInfo:
		soap_serialize_PointerTo_ns1__UpdSnRecInfo(soap, (_ns1__UpdSnRecInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsBoxInfo:
		soap_serialize_PointerTo_ns1__InsBoxInfo(soap, (_ns1__InsBoxInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsLnkOutSN:
		soap_serialize_PointerTo_ns1__InsLnkOutSN(soap, (_ns1__InsLnkOutSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsSNStationEmp:
		soap_serialize_PointerTo_ns1__InsSNStationEmp(soap, (_ns1__InsSNStationEmp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CancelBoxLnk:
		soap_serialize_PointerTo_ns1__CancelBoxLnk(soap, (_ns1__CancelBoxLnk *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OutStationbyBox:
		soap_serialize_PointerTo_ns1__OutStationbyBox(soap, (_ns1__OutStationbyBox *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InStationbyBox:
		soap_serialize_PointerTo_ns1__InStationbyBox(soap, (_ns1__InStationbyBox *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EndSNtoBox:
		soap_serialize_PointerTo_ns1__EndSNtoBox(soap, (_ns1__EndSNtoBox *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InSNtoBox:
		soap_serialize_PointerTo_ns1__InSNtoBox(soap, (_ns1__InSNtoBox *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkBoxNo:
		soap_serialize_PointerTo_ns1__chkBoxNo(soap, (_ns1__chkBoxNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsBoxNOTime:
		soap_serialize_PointerTo_ns1__InsBoxNOTime(soap, (_ns1__InsBoxNOTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLinkZJCount:
		soap_serialize_PointerTo_ns1__GetLinkZJCount(soap, (_ns1__GetLinkZJCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsLinkSN:
		soap_serialize_PointerTo_ns1__InsLinkSN(soap, (_ns1__InsLinkSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doLinkOutSN:
		soap_serialize_PointerTo_ns1__doLinkOutSN(soap, (_ns1__doLinkOutSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChkLinkOutSN:
		soap_serialize_PointerTo_ns1__ChkLinkOutSN(soap, (_ns1__ChkLinkOutSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkOutSN:
		soap_serialize_PointerTo_ns1__chkOutSN(soap, (_ns1__chkOutSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLintOutQty:
		soap_serialize_PointerTo_ns1__GetLintOutQty(soap, (_ns1__GetLintOutQty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SNLinkZJ:
		soap_serialize_PointerTo_ns1__SNLinkZJ(soap, (_ns1__SNLinkZJ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsZJTestData:
		soap_serialize_PointerTo_ns1__InsZJTestData(soap, (_ns1__InsZJTestData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doPmcSNLink:
		soap_serialize_PointerTo_ns1__doPmcSNLink(soap, (_ns1__doPmcSNLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPmcSNPart:
		soap_serialize_PointerTo_ns1__GetPmcSNPart(soap, (_ns1__GetPmcSNPart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPmcPartAssyList:
		soap_serialize_PointerTo_ns1__getPmcPartAssyList(soap, (_ns1__getPmcPartAssyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPmcAssyList:
		soap_serialize_PointerTo_ns1__getPmcAssyList(soap, (_ns1__getPmcAssyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doAssy:
		soap_serialize_PointerTo_ns1__doAssy(soap, (_ns1__doAssy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkAssySN:
		soap_serialize_PointerTo_ns1__chkAssySN(soap, (_ns1__chkAssySN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPNbySN:
		soap_serialize_PointerTo_ns1__getPNbySN(soap, (_ns1__getPNbySN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMoAssyCount:
		soap_serialize_PointerTo_ns1__getMoAssyCount(soap, (_ns1__getMoAssyCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLinkOutSn:
		soap_serialize_PointerTo_ns1__GetLinkOutSn(soap, (_ns1__GetLinkOutSn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsPartAssy:
		soap_serialize_PointerTo_ns1__InsPartAssy(soap, (_ns1__InsPartAssy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPartBomExt:
		soap_serialize_PointerTo_ns1__getPartBomExt(soap, (_ns1__getPartBomExt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMoAssyList:
		soap_serialize_PointerTo_ns1__getMoAssyList(soap, (_ns1__getMoAssyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkSnMapping:
		soap_serialize_PointerTo_ns1__chkSnMapping(soap, (_ns1__chkSnMapping *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getStationTypeDesc:
		soap_serialize_PointerTo_ns1__getStationTypeDesc(soap, (_ns1__getStationTypeDesc *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getStationByMo:
		soap_serialize_PointerTo_ns1__getStationByMo(soap, (_ns1__getStationByMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SnDoMapping:
		soap_serialize_PointerTo_ns1__SnDoMapping(soap, (_ns1__SnDoMapping *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__eMesNextMo:
		soap_serialize_PointerTo_ns1__eMesNextMo(soap, (_ns1__eMesNextMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sendResultForStationNumber:
		soap_serialize_PointerTo_ns1__sendResultForStationNumber(soap, (_ns1__sendResultForStationNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sendDataForStationNumber:
		soap_serialize_PointerTo_ns1__sendDataForStationNumber(soap, (_ns1__sendDataForStationNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkEmpForStationNumber:
		soap_serialize_PointerTo_ns1__checkEmpForStationNumber(soap, (_ns1__checkEmpForStationNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStationNumber:
		soap_serialize_PointerTo_ns1__checkSN_USCOREStationNumber(soap, (_ns1__checkSN_USCOREStationNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChkSnNextMo:
		soap_serialize_PointerTo_ns1__ChkSnNextMo(soap, (_ns1__ChkSnNextMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChkSnMo:
		soap_serialize_PointerTo_ns1__ChkSnMo(soap, (_ns1__ChkSnMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkMoStation:
		soap_serialize_PointerTo_ns1__chkMoStation(soap, (_ns1__chkMoStation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetEnergyStat:
		soap_serialize_PointerTo_ns1__SetEnergyStat(soap, (_ns1__SetEnergyStat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getInfoByMo:
		soap_serialize_PointerTo_ns1__getInfoByMo(soap, (_ns1__getInfoByMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsThermalNew:
		soap_serialize_PointerTo_ns1__InsThermalNew(soap, (_ns1__InsThermalNew *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChkSnLink:
		soap_serialize_PointerTo_ns1__ChkSnLink(soap, (_ns1__ChkSnLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsThermal:
		soap_serialize_PointerTo_ns1__InsThermal(soap, (_ns1__InsThermal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsWHDetection:
		soap_serialize_PointerTo_ns1__InsWHDetection(soap, (_ns1__InsWHDetection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsFlatNessForCL:
		soap_serialize_PointerTo_ns1__InsFlatNessForCL(soap, (_ns1__InsFlatNessForCL *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsFlatNessForLSD:
		soap_serialize_PointerTo_ns1__InsFlatNessForLSD(soap, (_ns1__InsFlatNessForLSD *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsFlatNess:
		soap_serialize_PointerTo_ns1__InsFlatNess(soap, (_ns1__InsFlatNess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ImpMesAteTestData:
		soap_serialize_PointerTo_ns1__ImpMesAteTestData(soap, (_ns1__ImpMesAteTestData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkStationTime:
		soap_serialize_PointerTo_ns1__chkStationTime(soap, (_ns1__chkStationTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InFruitsOrtQty:
		soap_serialize_PointerTo_ns1__InFruitsOrtQty(soap, (_ns1__InFruitsOrtQty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sendTestResult:
		soap_serialize_PointerTo_ns1__sendTestResult(soap, (_ns1__sendTestResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sendTestData:
		soap_serialize_PointerTo_ns1__sendTestData(soap, (_ns1__sendTestData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkSN_USCOREStation:
		soap_serialize_PointerTo_ns1__checkSN_USCOREStation(soap, (_ns1__checkSN_USCOREStation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkEmpNo:
		soap_serialize_PointerTo_ns1__checkEmpNo(soap, (_ns1__checkEmpNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkTestData:
		soap_serialize_PointerTo_ns1__checkTestData(soap, (_ns1__checkTestData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsZjList:
		soap_serialize_PointerTo_ns1__InsZjList(soap, (_ns1__InsZjList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFruitMachineChk:
		soap_serialize_PointerTo_ns1__GetFruitMachineChk(soap, (_ns1__GetFruitMachineChk *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsFruitMachineChk:
		soap_serialize_PointerTo_ns1__InsFruitMachineChk(soap, (_ns1__InsFruitMachineChk *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SnLnkOutSN:
		soap_serialize_PointerTo_ns1__SnLnkOutSN(soap, (_ns1__SnLnkOutSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMoBase:
		soap_serialize_PointerTo_ns1__getMoBase(soap, (_ns1__getMoBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNgCode:
		soap_serialize_PointerTo_ns1__GetNgCode(soap, (_ns1__GetNgCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetDiecastSN:
		soap_serialize_PointerTo_ns1__SetDiecastSN(soap, (_ns1__SetDiecastSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMachineForGroup:
		soap_serialize_PointerTo_ns1__GetMachineForGroup(soap, (_ns1__GetMachineForGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadForHP:
		soap_serialize_PointerTo_ns1__UploadForHP(soap, (_ns1__UploadForHP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SelShelfLink:
		soap_serialize_PointerTo_ns1__SelShelfLink(soap, (_ns1__SelShelfLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SNLinkShelf:
		soap_serialize_PointerTo_ns1__SNLinkShelf(soap, (_ns1__SNLinkShelf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SelSNTestForFruit:
		soap_serialize_PointerTo_ns1__SelSNTestForFruit(soap, (_ns1__SelSNTestForFruit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsSNTestForFruit:
		soap_serialize_PointerTo_ns1__InsSNTestForFruit(soap, (_ns1__InsSNTestForFruit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStationNumberForSN:
		soap_serialize_PointerTo_ns1__GetStationNumberForSN(soap, (_ns1__GetStationNumberForSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTestValueResult:
		soap_serialize_PointerTo_ns1__GetTestValueResult(soap, (_ns1__GetTestValueResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsCLScada:
		soap_serialize_PointerTo_ns1__InsCLScada(soap, (_ns1__InsCLScada *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsAoiMo:
		soap_serialize_PointerTo_ns1__InsAoiMo(soap, (_ns1__InsAoiMo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__chkMoSNForAOI:
		soap_serialize_PointerTo_ns1__chkMoSNForAOI(soap, (_ns1__chkMoSNForAOI *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PunchOut:
		soap_serialize_PointerTo_ns1__PunchOut(soap, (_ns1__PunchOut *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BasketLinkPunch:
		soap_serialize_PointerTo_ns1__BasketLinkPunch(soap, (_ns1__BasketLinkPunch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__HPSNLinkBasket:
		soap_serialize_PointerTo_ns1__HPSNLinkBasket(soap, (_ns1__HPSNLinkBasket *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetAutoLineRec:
		soap_serialize_PointerTo_ns1__SetAutoLineRec(soap, (_ns1__SetAutoLineRec *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSNForLink:
		soap_serialize_PointerTo_ns1__GetSNForLink(soap, (_ns1__GetSNForLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec:
		soap_serialize_PointerTo_ns1__SetFlatnessFruitRec(soap, (_ns1__SetFlatnessFruitRec *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getStationByMoForTestPad:
		soap_serialize_PointerTo_ns1__getStationByMoForTestPad(soap, (_ns1__getStationByMoForTestPad *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingWeight:
		soap_serialize_PointerTo_ns1__GetShippingWeight(soap, (_ns1__GetShippingWeight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingForBerth:
		soap_serialize_PointerTo_ns1__GetShippingForBerth(soap, (_ns1__GetShippingForBerth *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsShippingBerth:
		soap_serialize_PointerTo_ns1__InsShippingBerth(soap, (_ns1__InsShippingBerth *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsShippingPalle:
		soap_serialize_PointerTo_ns1__InsShippingPalle(soap, (_ns1__InsShippingPalle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingPalle:
		soap_serialize_PointerTo_ns1__GetShippingPalle(soap, (_ns1__GetShippingPalle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdShipping:
		soap_serialize_PointerTo_ns1__UpdShipping(soap, (_ns1__UpdShipping *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingBerthList:
		soap_serialize_PointerTo_ns1__GetShippingBerthList(soap, (_ns1__GetShippingBerthList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingList:
		soap_serialize_PointerTo_ns1__GetShippingList(soap, (_ns1__GetShippingList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doLotLinkForApple:
		soap_serialize_PointerTo_ns1__doLotLinkForApple(soap, (_ns1__doLotLinkForApple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotLinkCount:
		soap_serialize_PointerTo_ns1__GetLotLinkCount(soap, (_ns1__GetLotLinkCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFruitSNCheck:
		soap_serialize_PointerTo_ns1__GetFruitSNCheck(soap, (_ns1__GetFruitSNCheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObeNW:
		soap_serialize_PointerTo_ns1__GetObeNW(soap, (_ns1__GetObeNW *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doSnLinkForApple:
		soap_serialize_PointerTo_ns1__doSnLinkForApple(soap, (_ns1__doSnLinkForApple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChkSnLinkForApple:
		soap_serialize_PointerTo_ns1__ChkSnLinkForApple(soap, (_ns1__ChkSnLinkForApple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DelSNTest:
		soap_serialize_PointerTo_ns1__DelSNTest(soap, (_ns1__DelSNTest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SelSNTest:
		soap_serialize_PointerTo_ns1__SelSNTest(soap, (_ns1__SelSNTest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsSNTest:
		soap_serialize_PointerTo_ns1__InsSNTest(soap, (_ns1__InsSNTest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChkWeightTime:
		soap_serialize_PointerTo_ns1__ChkWeightTime(soap, (_ns1__ChkWeightTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdAhsBarcode:
		soap_serialize_PointerTo_ns1__UpdAhsBarcode(soap, (_ns1__UpdAhsBarcode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAhsBarcode:
		soap_serialize_PointerTo_ns1__GetAhsBarcode(soap, (_ns1__GetAhsBarcode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult:
		soap_serialize_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, (_ns1__GetAhsMoResponse_GetAhsMoResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		soap_serialize_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doLinkOutSN_assyDt:
		soap_serialize_PointerTo_ns1__doLinkOutSN_assyDt(soap, (_ns1__doLinkOutSN_assyDt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doPmcSNLink_assyDt:
		soap_serialize_PointerTo_ns1__doPmcSNLink_assyDt(soap, (_ns1__doPmcSNLink_assyDt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		soap_serialize_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult:
		soap_serialize_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, (_ns1__getPmcAssyListResponse_getPmcAssyListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doAssy_assyDt:
		soap_serialize_PointerTo_ns1__doAssy_assyDt(soap, (_ns1__doAssy_assyDt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		soap_serialize_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult:
		soap_serialize_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, (_ns1__getPartBomExtResponse_getPartBomExtResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult:
		soap_serialize_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, (_ns1__getMoAssyListResponse_getMoAssyListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult:
		soap_serialize_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, (_ns1__getInfoByMoResponse_getInfoByMoResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		soap_serialize_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetFlatnessFruitRec_dt:
		soap_serialize_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, (_ns1__SetFlatnessFruitRec_dt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult:
		soap_serialize_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, (_ns1__GetShippingWeightResponse_GetShippingWeightResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		soap_serialize_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		soap_serialize_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShippingListResponse_GetShippingListResult:
		soap_serialize_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, (_ns1__GetShippingListResponse_GetShippingListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doLotLinkForApple_assyDt:
		soap_serialize_PointerTo_ns1__doLotLinkForApple_assyDt(soap, (_ns1__doLotLinkForApple_assyDt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__doSnLinkForApple_assyDt:
		soap_serialize_PointerTo_ns1__doSnLinkForApple_assyDt(soap, (_ns1__doSnLinkForApple_assyDt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		soap_serialize_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAhsBarcode:
		return (void*)soap_instantiate__ns1__GetAhsBarcode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		return (void*)soap_instantiate__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse:
		return (void*)soap_instantiate__ns1__GetAhsBarcodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdAhsBarcode:
		return (void*)soap_instantiate__ns1__UpdAhsBarcode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdAhsBarcodeResponse:
		return (void*)soap_instantiate__ns1__UpdAhsBarcodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkWeightTime:
		return (void*)soap_instantiate__ns1__ChkWeightTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkWeightTimeResponse:
		return (void*)soap_instantiate__ns1__ChkWeightTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsSNTest:
		return (void*)soap_instantiate__ns1__InsSNTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsSNTestResponse:
		return (void*)soap_instantiate__ns1__InsSNTestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelSNTest:
		return (void*)soap_instantiate__ns1__SelSNTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelSNTestResponse:
		return (void*)soap_instantiate__ns1__SelSNTestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DelSNTest:
		return (void*)soap_instantiate__ns1__DelSNTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DelSNTestResponse:
		return (void*)soap_instantiate__ns1__DelSNTestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnLinkForApple:
		return (void*)soap_instantiate__ns1__ChkSnLinkForApple(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnLinkForAppleResponse:
		return (void*)soap_instantiate__ns1__ChkSnLinkForAppleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doSnLinkForApple_assyDt:
		return (void*)soap_instantiate__ns1__doSnLinkForApple_assyDt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doSnLinkForApple:
		return (void*)soap_instantiate__ns1__doSnLinkForApple(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doSnLinkForAppleResponse:
		return (void*)soap_instantiate__ns1__doSnLinkForAppleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObeNW:
		return (void*)soap_instantiate__ns1__GetObeNW(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObeNWResponse:
		return (void*)soap_instantiate__ns1__GetObeNWResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFruitSNCheck:
		return (void*)soap_instantiate__ns1__GetFruitSNCheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFruitSNCheckResponse:
		return (void*)soap_instantiate__ns1__GetFruitSNCheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotLinkCount:
		return (void*)soap_instantiate__ns1__GetLotLinkCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotLinkCountResponse:
		return (void*)soap_instantiate__ns1__GetLotLinkCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doLotLinkForApple_assyDt:
		return (void*)soap_instantiate__ns1__doLotLinkForApple_assyDt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doLotLinkForApple:
		return (void*)soap_instantiate__ns1__doLotLinkForApple(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doLotLinkForAppleResponse:
		return (void*)soap_instantiate__ns1__doLotLinkForAppleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingList:
		return (void*)soap_instantiate__ns1__GetShippingList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult:
		return (void*)soap_instantiate__ns1__GetShippingListResponse_GetShippingListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingListResponse:
		return (void*)soap_instantiate__ns1__GetShippingListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingBerthList:
		return (void*)soap_instantiate__ns1__GetShippingBerthList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		return (void*)soap_instantiate__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingBerthListResponse:
		return (void*)soap_instantiate__ns1__GetShippingBerthListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdShipping:
		return (void*)soap_instantiate__ns1__UpdShipping(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdShippingResponse:
		return (void*)soap_instantiate__ns1__UpdShippingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingPalle:
		return (void*)soap_instantiate__ns1__GetShippingPalle(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingPalleResponse:
		return (void*)soap_instantiate__ns1__GetShippingPalleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsShippingPalle:
		return (void*)soap_instantiate__ns1__InsShippingPalle(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsShippingPalleResponse:
		return (void*)soap_instantiate__ns1__InsShippingPalleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsShippingBerth:
		return (void*)soap_instantiate__ns1__InsShippingBerth(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsShippingBerthResponse:
		return (void*)soap_instantiate__ns1__InsShippingBerthResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingForBerth:
		return (void*)soap_instantiate__ns1__GetShippingForBerth(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		return (void*)soap_instantiate__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingForBerthResponse:
		return (void*)soap_instantiate__ns1__GetShippingForBerthResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingWeight:
		return (void*)soap_instantiate__ns1__GetShippingWeight(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult:
		return (void*)soap_instantiate__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShippingWeightResponse:
		return (void*)soap_instantiate__ns1__GetShippingWeightResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getStationByMoForTestPad:
		return (void*)soap_instantiate__ns1__getStationByMoForTestPad(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getStationByMoForTestPadResponse:
		return (void*)soap_instantiate__ns1__getStationByMoForTestPadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetFlatnessFruitRec_dt:
		return (void*)soap_instantiate__ns1__SetFlatnessFruitRec_dt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetFlatnessFruitRec:
		return (void*)soap_instantiate__ns1__SetFlatnessFruitRec(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetFlatnessFruitRecResponse:
		return (void*)soap_instantiate__ns1__SetFlatnessFruitRecResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSNForLink:
		return (void*)soap_instantiate__ns1__GetSNForLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSNForLinkResponse:
		return (void*)soap_instantiate__ns1__GetSNForLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetAutoLineRec:
		return (void*)soap_instantiate__ns1__SetAutoLineRec(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetAutoLineRecResponse:
		return (void*)soap_instantiate__ns1__SetAutoLineRecResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HPSNLinkBasket:
		return (void*)soap_instantiate__ns1__HPSNLinkBasket(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HPSNLinkBasketResponse:
		return (void*)soap_instantiate__ns1__HPSNLinkBasketResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BasketLinkPunch:
		return (void*)soap_instantiate__ns1__BasketLinkPunch(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BasketLinkPunchResponse:
		return (void*)soap_instantiate__ns1__BasketLinkPunchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PunchOut:
		return (void*)soap_instantiate__ns1__PunchOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PunchOutResponse:
		return (void*)soap_instantiate__ns1__PunchOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkMoSNForAOI:
		return (void*)soap_instantiate__ns1__chkMoSNForAOI(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkMoSNForAOIResponse:
		return (void*)soap_instantiate__ns1__chkMoSNForAOIResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsAoiMo:
		return (void*)soap_instantiate__ns1__InsAoiMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsAoiMoResponse:
		return (void*)soap_instantiate__ns1__InsAoiMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsCLScada:
		return (void*)soap_instantiate__ns1__InsCLScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsCLScadaResponse:
		return (void*)soap_instantiate__ns1__InsCLScadaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTestValueResult:
		return (void*)soap_instantiate__ns1__GetTestValueResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTestValueResultResponse:
		return (void*)soap_instantiate__ns1__GetTestValueResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStationNumberForSN:
		return (void*)soap_instantiate__ns1__GetStationNumberForSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStationNumberForSNResponse:
		return (void*)soap_instantiate__ns1__GetStationNumberForSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsSNTestForFruit:
		return (void*)soap_instantiate__ns1__InsSNTestForFruit(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsSNTestForFruitResponse:
		return (void*)soap_instantiate__ns1__InsSNTestForFruitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelSNTestForFruit:
		return (void*)soap_instantiate__ns1__SelSNTestForFruit(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelSNTestForFruitResponse:
		return (void*)soap_instantiate__ns1__SelSNTestForFruitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SNLinkShelf:
		return (void*)soap_instantiate__ns1__SNLinkShelf(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SNLinkShelfResponse:
		return (void*)soap_instantiate__ns1__SNLinkShelfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelShelfLink:
		return (void*)soap_instantiate__ns1__SelShelfLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelShelfLinkResponse:
		return (void*)soap_instantiate__ns1__SelShelfLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadForHP:
		return (void*)soap_instantiate__ns1__UploadForHP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadForHPResponse:
		return (void*)soap_instantiate__ns1__UploadForHPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMachineForGroup:
		return (void*)soap_instantiate__ns1__GetMachineForGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		return (void*)soap_instantiate__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMachineForGroupResponse:
		return (void*)soap_instantiate__ns1__GetMachineForGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetDiecastSN:
		return (void*)soap_instantiate__ns1__SetDiecastSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetDiecastSNResponse:
		return (void*)soap_instantiate__ns1__SetDiecastSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNgCode:
		return (void*)soap_instantiate__ns1__GetNgCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNgCodeResponse:
		return (void*)soap_instantiate__ns1__GetNgCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoBase:
		return (void*)soap_instantiate__ns1__getMoBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoBaseResponse:
		return (void*)soap_instantiate__ns1__getMoBaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnLnkOutSN:
		return (void*)soap_instantiate__ns1__SnLnkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnLnkOutSNResponse:
		return (void*)soap_instantiate__ns1__SnLnkOutSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFruitMachineChk:
		return (void*)soap_instantiate__ns1__InsFruitMachineChk(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFruitMachineChkResponse:
		return (void*)soap_instantiate__ns1__InsFruitMachineChkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFruitMachineChk:
		return (void*)soap_instantiate__ns1__GetFruitMachineChk(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFruitMachineChkResponse:
		return (void*)soap_instantiate__ns1__GetFruitMachineChkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsZjList:
		return (void*)soap_instantiate__ns1__InsZjList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsZjListResponse:
		return (void*)soap_instantiate__ns1__InsZjListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkTestData:
		return (void*)soap_instantiate__ns1__checkTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkTestDataResponse:
		return (void*)soap_instantiate__ns1__checkTestDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkEmpNo:
		return (void*)soap_instantiate__ns1__checkEmpNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkEmpNoResponse:
		return (void*)soap_instantiate__ns1__checkEmpNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSN_USCOREStation:
		return (void*)soap_instantiate__ns1__checkSN_USCOREStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSN_USCOREStationResponse:
		return (void*)soap_instantiate__ns1__checkSN_USCOREStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendTestData:
		return (void*)soap_instantiate__ns1__sendTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendTestDataResponse:
		return (void*)soap_instantiate__ns1__sendTestDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendTestResult:
		return (void*)soap_instantiate__ns1__sendTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendTestResultResponse:
		return (void*)soap_instantiate__ns1__sendTestResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InFruitsOrtQty:
		return (void*)soap_instantiate__ns1__InFruitsOrtQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InFruitsOrtQtyResponse:
		return (void*)soap_instantiate__ns1__InFruitsOrtQtyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkStationTime:
		return (void*)soap_instantiate__ns1__chkStationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkStationTimeResponse:
		return (void*)soap_instantiate__ns1__chkStationTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ImpMesAteTestData:
		return (void*)soap_instantiate__ns1__ImpMesAteTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ImpMesAteTestDataResponse:
		return (void*)soap_instantiate__ns1__ImpMesAteTestDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFlatNess:
		return (void*)soap_instantiate__ns1__InsFlatNess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFlatNessResponse:
		return (void*)soap_instantiate__ns1__InsFlatNessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFlatNessForLSD:
		return (void*)soap_instantiate__ns1__InsFlatNessForLSD(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFlatNessForLSDResponse:
		return (void*)soap_instantiate__ns1__InsFlatNessForLSDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFlatNessForCL:
		return (void*)soap_instantiate__ns1__InsFlatNessForCL(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsFlatNessForCLResponse:
		return (void*)soap_instantiate__ns1__InsFlatNessForCLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsWHDetection:
		return (void*)soap_instantiate__ns1__InsWHDetection(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsWHDetectionResponse:
		return (void*)soap_instantiate__ns1__InsWHDetectionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsThermal:
		return (void*)soap_instantiate__ns1__InsThermal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsThermalResponse:
		return (void*)soap_instantiate__ns1__InsThermalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnLink:
		return (void*)soap_instantiate__ns1__ChkSnLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnLinkResponse:
		return (void*)soap_instantiate__ns1__ChkSnLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsThermalNew:
		return (void*)soap_instantiate__ns1__InsThermalNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsThermalNewResponse:
		return (void*)soap_instantiate__ns1__InsThermalNewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getInfoByMo:
		return (void*)soap_instantiate__ns1__getInfoByMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult:
		return (void*)soap_instantiate__ns1__getInfoByMoResponse_getInfoByMoResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getInfoByMoResponse:
		return (void*)soap_instantiate__ns1__getInfoByMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetEnergyStat:
		return (void*)soap_instantiate__ns1__SetEnergyStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetEnergyStatResponse:
		return (void*)soap_instantiate__ns1__SetEnergyStatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkMoStation:
		return (void*)soap_instantiate__ns1__chkMoStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkMoStationResponse:
		return (void*)soap_instantiate__ns1__chkMoStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnMo:
		return (void*)soap_instantiate__ns1__ChkSnMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnMoResponse:
		return (void*)soap_instantiate__ns1__ChkSnMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnNextMo:
		return (void*)soap_instantiate__ns1__ChkSnNextMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkSnNextMoResponse:
		return (void*)soap_instantiate__ns1__ChkSnNextMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumber:
		return (void*)soap_instantiate__ns1__checkSN_USCOREStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse:
		return (void*)soap_instantiate__ns1__checkSN_USCOREStationNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkEmpForStationNumber:
		return (void*)soap_instantiate__ns1__checkEmpForStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkEmpForStationNumberResponse:
		return (void*)soap_instantiate__ns1__checkEmpForStationNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendDataForStationNumber:
		return (void*)soap_instantiate__ns1__sendDataForStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendDataForStationNumberResponse:
		return (void*)soap_instantiate__ns1__sendDataForStationNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendResultForStationNumber:
		return (void*)soap_instantiate__ns1__sendResultForStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendResultForStationNumberResponse:
		return (void*)soap_instantiate__ns1__sendResultForStationNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__eMesNextMo:
		return (void*)soap_instantiate__ns1__eMesNextMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__eMesNextMoResponse:
		return (void*)soap_instantiate__ns1__eMesNextMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnDoMapping:
		return (void*)soap_instantiate__ns1__SnDoMapping(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnDoMappingResponse:
		return (void*)soap_instantiate__ns1__SnDoMappingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getStationByMo:
		return (void*)soap_instantiate__ns1__getStationByMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getStationByMoResponse:
		return (void*)soap_instantiate__ns1__getStationByMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getStationTypeDesc:
		return (void*)soap_instantiate__ns1__getStationTypeDesc(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getStationTypeDescResponse:
		return (void*)soap_instantiate__ns1__getStationTypeDescResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkSnMapping:
		return (void*)soap_instantiate__ns1__chkSnMapping(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkSnMappingResponse:
		return (void*)soap_instantiate__ns1__chkSnMappingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoAssyList:
		return (void*)soap_instantiate__ns1__getMoAssyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult:
		return (void*)soap_instantiate__ns1__getMoAssyListResponse_getMoAssyListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoAssyListResponse:
		return (void*)soap_instantiate__ns1__getMoAssyListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPartBomExt:
		return (void*)soap_instantiate__ns1__getPartBomExt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult:
		return (void*)soap_instantiate__ns1__getPartBomExtResponse_getPartBomExtResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPartBomExtResponse:
		return (void*)soap_instantiate__ns1__getPartBomExtResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsPartAssy:
		return (void*)soap_instantiate__ns1__InsPartAssy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsPartAssyResponse:
		return (void*)soap_instantiate__ns1__InsPartAssyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLinkOutSn:
		return (void*)soap_instantiate__ns1__GetLinkOutSn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		return (void*)soap_instantiate__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLinkOutSnResponse:
		return (void*)soap_instantiate__ns1__GetLinkOutSnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoAssyCount:
		return (void*)soap_instantiate__ns1__getMoAssyCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMoAssyCountResponse:
		return (void*)soap_instantiate__ns1__getMoAssyCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPNbySN:
		return (void*)soap_instantiate__ns1__getPNbySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPNbySNResponse:
		return (void*)soap_instantiate__ns1__getPNbySNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkAssySN:
		return (void*)soap_instantiate__ns1__chkAssySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkAssySNResponse:
		return (void*)soap_instantiate__ns1__chkAssySNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doAssy_assyDt:
		return (void*)soap_instantiate__ns1__doAssy_assyDt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doAssy:
		return (void*)soap_instantiate__ns1__doAssy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doAssyResponse:
		return (void*)soap_instantiate__ns1__doAssyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPmcAssyList:
		return (void*)soap_instantiate__ns1__getPmcAssyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult:
		return (void*)soap_instantiate__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPmcAssyListResponse:
		return (void*)soap_instantiate__ns1__getPmcAssyListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPmcPartAssyList:
		return (void*)soap_instantiate__ns1__getPmcPartAssyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		return (void*)soap_instantiate__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse:
		return (void*)soap_instantiate__ns1__getPmcPartAssyListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPmcSNPart:
		return (void*)soap_instantiate__ns1__GetPmcSNPart(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPmcSNPartResponse:
		return (void*)soap_instantiate__ns1__GetPmcSNPartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doPmcSNLink_assyDt:
		return (void*)soap_instantiate__ns1__doPmcSNLink_assyDt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doPmcSNLink:
		return (void*)soap_instantiate__ns1__doPmcSNLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doPmcSNLinkResponse:
		return (void*)soap_instantiate__ns1__doPmcSNLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsZJTestData:
		return (void*)soap_instantiate__ns1__InsZJTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsZJTestDataResponse:
		return (void*)soap_instantiate__ns1__InsZJTestDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SNLinkZJ:
		return (void*)soap_instantiate__ns1__SNLinkZJ(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SNLinkZJResponse:
		return (void*)soap_instantiate__ns1__SNLinkZJResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLintOutQty:
		return (void*)soap_instantiate__ns1__GetLintOutQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLintOutQtyResponse:
		return (void*)soap_instantiate__ns1__GetLintOutQtyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkOutSN:
		return (void*)soap_instantiate__ns1__chkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkOutSNResponse:
		return (void*)soap_instantiate__ns1__chkOutSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkLinkOutSN:
		return (void*)soap_instantiate__ns1__ChkLinkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChkLinkOutSNResponse:
		return (void*)soap_instantiate__ns1__ChkLinkOutSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doLinkOutSN_assyDt:
		return (void*)soap_instantiate__ns1__doLinkOutSN_assyDt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doLinkOutSN:
		return (void*)soap_instantiate__ns1__doLinkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__doLinkOutSNResponse:
		return (void*)soap_instantiate__ns1__doLinkOutSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsLinkSN:
		return (void*)soap_instantiate__ns1__InsLinkSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsLinkSNResponse:
		return (void*)soap_instantiate__ns1__InsLinkSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLinkZJCount:
		return (void*)soap_instantiate__ns1__GetLinkZJCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLinkZJCountResponse:
		return (void*)soap_instantiate__ns1__GetLinkZJCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsBoxNOTime:
		return (void*)soap_instantiate__ns1__InsBoxNOTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsBoxNOTimeResponse:
		return (void*)soap_instantiate__ns1__InsBoxNOTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkBoxNo:
		return (void*)soap_instantiate__ns1__chkBoxNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkBoxNoResponse:
		return (void*)soap_instantiate__ns1__chkBoxNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InSNtoBox:
		return (void*)soap_instantiate__ns1__InSNtoBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InSNtoBoxResponse:
		return (void*)soap_instantiate__ns1__InSNtoBoxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndSNtoBox:
		return (void*)soap_instantiate__ns1__EndSNtoBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndSNtoBoxResponse:
		return (void*)soap_instantiate__ns1__EndSNtoBoxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InStationbyBox:
		return (void*)soap_instantiate__ns1__InStationbyBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InStationbyBoxResponse:
		return (void*)soap_instantiate__ns1__InStationbyBoxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutStationbyBox:
		return (void*)soap_instantiate__ns1__OutStationbyBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutStationbyBoxResponse:
		return (void*)soap_instantiate__ns1__OutStationbyBoxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelBoxLnk:
		return (void*)soap_instantiate__ns1__CancelBoxLnk(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelBoxLnkResponse:
		return (void*)soap_instantiate__ns1__CancelBoxLnkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsSNStationEmp:
		return (void*)soap_instantiate__ns1__InsSNStationEmp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsSNStationEmpResponse:
		return (void*)soap_instantiate__ns1__InsSNStationEmpResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsLnkOutSN:
		return (void*)soap_instantiate__ns1__InsLnkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsLnkOutSNResponse:
		return (void*)soap_instantiate__ns1__InsLnkOutSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsBoxInfo:
		return (void*)soap_instantiate__ns1__InsBoxInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsBoxInfoResponse:
		return (void*)soap_instantiate__ns1__InsBoxInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdSnRecInfo:
		return (void*)soap_instantiate__ns1__UpdSnRecInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdSnRecInfoResponse:
		return (void*)soap_instantiate__ns1__UpdSnRecInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMoBase:
		return (void*)soap_instantiate__ns1__GetMoBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMoBaseResponse:
		return (void*)soap_instantiate__ns1__GetMoBaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTestValue:
		return (void*)soap_instantiate__ns1__GetTestValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTestValueResponse:
		return (void*)soap_instantiate__ns1__GetTestValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLnkData:
		return (void*)soap_instantiate__ns1__GetLnkData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLnkDataResponse:
		return (void*)soap_instantiate__ns1__GetLnkDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsIotMachineRec:
		return (void*)soap_instantiate__ns1__InsIotMachineRec(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsIotMachineRecResponse:
		return (void*)soap_instantiate__ns1__InsIotMachineRecResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsIotTestData:
		return (void*)soap_instantiate__ns1__InsIotTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsIotTestDataResponse:
		return (void*)soap_instantiate__ns1__InsIotTestDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkDispensing:
		return (void*)soap_instantiate__ns1__chkDispensing(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkDispensingResponse:
		return (void*)soap_instantiate__ns1__chkDispensingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkZJSN:
		return (void*)soap_instantiate__ns1__chkZJSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkZJSNResponse:
		return (void*)soap_instantiate__ns1__chkZJSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LnkZJSN:
		return (void*)soap_instantiate__ns1__LnkZJSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LnkZJSNResponse:
		return (void*)soap_instantiate__ns1__LnkZJSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LnkSideSN:
		return (void*)soap_instantiate__ns1__LnkSideSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LnkSideSNResponse:
		return (void*)soap_instantiate__ns1__LnkSideSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkGrillSN:
		return (void*)soap_instantiate__ns1__chkGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__chkGrillSNResponse:
		return (void*)soap_instantiate__ns1__chkGrillSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LnkGrillSN:
		return (void*)soap_instantiate__ns1__LnkGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LnkGrillSNResponse:
		return (void*)soap_instantiate__ns1__LnkGrillSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseGrillSN:
		return (void*)soap_instantiate__ns1__CloseGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseGrillSNResponse:
		return (void*)soap_instantiate__ns1__CloseGrillSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsGrillBySN:
		return (void*)soap_instantiate__ns1__InsGrillBySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsGrillBySNResponse:
		return (void*)soap_instantiate__ns1__InsGrillBySNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGrillTime:
		return (void*)soap_instantiate__ns1__GetGrillTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGrillTimeResponse:
		return (void*)soap_instantiate__ns1__GetGrillTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutGrillBySN:
		return (void*)soap_instantiate__ns1__OutGrillBySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OutGrillBySNResponse:
		return (void*)soap_instantiate__ns1__OutGrillBySNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelGrillSN:
		return (void*)soap_instantiate__ns1__CancelGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelGrillSNResponse:
		return (void*)soap_instantiate__ns1__CancelGrillSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelLnkSN:
		return (void*)soap_instantiate__ns1__CancelLnkSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelLnkSNResponse:
		return (void*)soap_instantiate__ns1__CancelLnkSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWeightSet:
		return (void*)soap_instantiate__ns1__GetWeightSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWeightSetResponse:
		return (void*)soap_instantiate__ns1__GetWeightSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPackToWMS:
		return (void*)soap_instantiate__ns1__GetPackToWMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPackToWMSResponse:
		return (void*)soap_instantiate__ns1__GetPackToWMSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPallentToWMS:
		return (void*)soap_instantiate__ns1__GetPallentToWMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		return (void*)soap_instantiate__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPallentToWMSResponse:
		return (void*)soap_instantiate__ns1__GetPallentToWMSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPallentForWMS:
		return (void*)soap_instantiate__ns1__SetPallentForWMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPallentForWMSResponse:
		return (void*)soap_instantiate__ns1__SetPallentForWMSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPackStation:
		return (void*)soap_instantiate__ns1__GetPackStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPackStationResponse:
		return (void*)soap_instantiate__ns1__GetPackStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPackWeigth:
		return (void*)soap_instantiate__ns1__GetPackWeigth(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPackWeigthResponse:
		return (void*)soap_instantiate__ns1__GetPackWeigthResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAhsMo:
		return (void*)soap_instantiate__ns1__GetAhsMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult:
		return (void*)soap_instantiate__ns1__GetAhsMoResponse_GetAhsMoResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAhsMoResponse:
		return (void*)soap_instantiate__ns1__GetAhsMoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAhsBarcode:
		return (void*)soap_instantiate___ns1__GetAhsBarcode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdAhsBarcode:
		return (void*)soap_instantiate___ns1__UpdAhsBarcode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkWeightTime:
		return (void*)soap_instantiate___ns1__ChkWeightTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsSNTest:
		return (void*)soap_instantiate___ns1__InsSNTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelSNTest:
		return (void*)soap_instantiate___ns1__SelSNTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DelSNTest:
		return (void*)soap_instantiate___ns1__DelSNTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnLinkForApple:
		return (void*)soap_instantiate___ns1__ChkSnLinkForApple(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doSnLinkForApple:
		return (void*)soap_instantiate___ns1__doSnLinkForApple(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetObeNW:
		return (void*)soap_instantiate___ns1__GetObeNW(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFruitSNCheck:
		return (void*)soap_instantiate___ns1__GetFruitSNCheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotLinkCount:
		return (void*)soap_instantiate___ns1__GetLotLinkCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doLotLinkForApple:
		return (void*)soap_instantiate___ns1__doLotLinkForApple(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingList:
		return (void*)soap_instantiate___ns1__GetShippingList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingBerthList:
		return (void*)soap_instantiate___ns1__GetShippingBerthList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdShipping:
		return (void*)soap_instantiate___ns1__UpdShipping(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingPalle:
		return (void*)soap_instantiate___ns1__GetShippingPalle(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsShippingPalle:
		return (void*)soap_instantiate___ns1__InsShippingPalle(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsShippingBerth:
		return (void*)soap_instantiate___ns1__InsShippingBerth(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingForBerth:
		return (void*)soap_instantiate___ns1__GetShippingForBerth(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingWeight:
		return (void*)soap_instantiate___ns1__GetShippingWeight(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStationByMoForTestPad:
		return (void*)soap_instantiate___ns1__getStationByMoForTestPad(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetFlatnessFruitRec:
		return (void*)soap_instantiate___ns1__SetFlatnessFruitRec(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSNForLink:
		return (void*)soap_instantiate___ns1__GetSNForLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetAutoLineRec:
		return (void*)soap_instantiate___ns1__SetAutoLineRec(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__HPSNLinkBasket:
		return (void*)soap_instantiate___ns1__HPSNLinkBasket(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BasketLinkPunch:
		return (void*)soap_instantiate___ns1__BasketLinkPunch(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PunchOut:
		return (void*)soap_instantiate___ns1__PunchOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkMoSNForAOI:
		return (void*)soap_instantiate___ns1__chkMoSNForAOI(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsAoiMo:
		return (void*)soap_instantiate___ns1__InsAoiMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsCLScada:
		return (void*)soap_instantiate___ns1__InsCLScada(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTestValueResult:
		return (void*)soap_instantiate___ns1__GetTestValueResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStationNumberForSN:
		return (void*)soap_instantiate___ns1__GetStationNumberForSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsSNTestForFruit:
		return (void*)soap_instantiate___ns1__InsSNTestForFruit(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelSNTestForFruit:
		return (void*)soap_instantiate___ns1__SelSNTestForFruit(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SNLinkShelf:
		return (void*)soap_instantiate___ns1__SNLinkShelf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelShelfLink:
		return (void*)soap_instantiate___ns1__SelShelfLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadForHP:
		return (void*)soap_instantiate___ns1__UploadForHP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMachineForGroup:
		return (void*)soap_instantiate___ns1__GetMachineForGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetDiecastSN:
		return (void*)soap_instantiate___ns1__SetDiecastSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetNgCode:
		return (void*)soap_instantiate___ns1__GetNgCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMoBase:
		return (void*)soap_instantiate___ns1__getMoBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SnLnkOutSN:
		return (void*)soap_instantiate___ns1__SnLnkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFruitMachineChk:
		return (void*)soap_instantiate___ns1__InsFruitMachineChk(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFruitMachineChk:
		return (void*)soap_instantiate___ns1__GetFruitMachineChk(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsZjList:
		return (void*)soap_instantiate___ns1__InsZjList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkTestData:
		return (void*)soap_instantiate___ns1__checkTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkEmpNo:
		return (void*)soap_instantiate___ns1__checkEmpNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkSN_USCOREStation:
		return (void*)soap_instantiate___ns1__checkSN_USCOREStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendTestData:
		return (void*)soap_instantiate___ns1__sendTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendTestResult:
		return (void*)soap_instantiate___ns1__sendTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InFruitsOrtQty:
		return (void*)soap_instantiate___ns1__InFruitsOrtQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkStationTime:
		return (void*)soap_instantiate___ns1__chkStationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ImpMesAteTestData:
		return (void*)soap_instantiate___ns1__ImpMesAteTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFlatNess:
		return (void*)soap_instantiate___ns1__InsFlatNess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFlatNessForLSD:
		return (void*)soap_instantiate___ns1__InsFlatNessForLSD(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFlatNessForCL:
		return (void*)soap_instantiate___ns1__InsFlatNessForCL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsWHDetection:
		return (void*)soap_instantiate___ns1__InsWHDetection(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsThermal:
		return (void*)soap_instantiate___ns1__InsThermal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnLink:
		return (void*)soap_instantiate___ns1__ChkSnLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsThermalNew:
		return (void*)soap_instantiate___ns1__InsThermalNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInfoByMo:
		return (void*)soap_instantiate___ns1__getInfoByMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetEnergyStat:
		return (void*)soap_instantiate___ns1__SetEnergyStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkMoStation:
		return (void*)soap_instantiate___ns1__chkMoStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnMo:
		return (void*)soap_instantiate___ns1__ChkSnMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnNextMo:
		return (void*)soap_instantiate___ns1__ChkSnNextMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber:
		return (void*)soap_instantiate___ns1__checkSN_USCOREStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkEmpForStationNumber:
		return (void*)soap_instantiate___ns1__checkEmpForStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendDataForStationNumber:
		return (void*)soap_instantiate___ns1__sendDataForStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendResultForStationNumber:
		return (void*)soap_instantiate___ns1__sendResultForStationNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__eMesNextMo:
		return (void*)soap_instantiate___ns1__eMesNextMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SnDoMapping:
		return (void*)soap_instantiate___ns1__SnDoMapping(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStationByMo:
		return (void*)soap_instantiate___ns1__getStationByMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStationTypeDesc:
		return (void*)soap_instantiate___ns1__getStationTypeDesc(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkSnMapping:
		return (void*)soap_instantiate___ns1__chkSnMapping(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMoAssyList:
		return (void*)soap_instantiate___ns1__getMoAssyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPartBomExt:
		return (void*)soap_instantiate___ns1__getPartBomExt(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsPartAssy:
		return (void*)soap_instantiate___ns1__InsPartAssy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLinkOutSn:
		return (void*)soap_instantiate___ns1__GetLinkOutSn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMoAssyCount:
		return (void*)soap_instantiate___ns1__getMoAssyCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPNbySN:
		return (void*)soap_instantiate___ns1__getPNbySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkAssySN:
		return (void*)soap_instantiate___ns1__chkAssySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doAssy:
		return (void*)soap_instantiate___ns1__doAssy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPmcAssyList:
		return (void*)soap_instantiate___ns1__getPmcAssyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPmcPartAssyList:
		return (void*)soap_instantiate___ns1__getPmcPartAssyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPmcSNPart:
		return (void*)soap_instantiate___ns1__GetPmcSNPart(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doPmcSNLink:
		return (void*)soap_instantiate___ns1__doPmcSNLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsZJTestData:
		return (void*)soap_instantiate___ns1__InsZJTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SNLinkZJ:
		return (void*)soap_instantiate___ns1__SNLinkZJ(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLintOutQty:
		return (void*)soap_instantiate___ns1__GetLintOutQty(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkOutSN:
		return (void*)soap_instantiate___ns1__chkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkLinkOutSN:
		return (void*)soap_instantiate___ns1__ChkLinkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doLinkOutSN:
		return (void*)soap_instantiate___ns1__doLinkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsLinkSN:
		return (void*)soap_instantiate___ns1__InsLinkSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLinkZJCount:
		return (void*)soap_instantiate___ns1__GetLinkZJCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsBoxNOTime:
		return (void*)soap_instantiate___ns1__InsBoxNOTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkBoxNo:
		return (void*)soap_instantiate___ns1__chkBoxNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InSNtoBox:
		return (void*)soap_instantiate___ns1__InSNtoBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndSNtoBox:
		return (void*)soap_instantiate___ns1__EndSNtoBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InStationbyBox:
		return (void*)soap_instantiate___ns1__InStationbyBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutStationbyBox:
		return (void*)soap_instantiate___ns1__OutStationbyBox(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CancelBoxLnk:
		return (void*)soap_instantiate___ns1__CancelBoxLnk(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsSNStationEmp:
		return (void*)soap_instantiate___ns1__InsSNStationEmp(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsLnkOutSN:
		return (void*)soap_instantiate___ns1__InsLnkOutSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsBoxInfo:
		return (void*)soap_instantiate___ns1__InsBoxInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdSnRecInfo:
		return (void*)soap_instantiate___ns1__UpdSnRecInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMoBase:
		return (void*)soap_instantiate___ns1__GetMoBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTestValue:
		return (void*)soap_instantiate___ns1__GetTestValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLnkData:
		return (void*)soap_instantiate___ns1__GetLnkData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsIotMachineRec:
		return (void*)soap_instantiate___ns1__InsIotMachineRec(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsIotTestData:
		return (void*)soap_instantiate___ns1__InsIotTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkDispensing:
		return (void*)soap_instantiate___ns1__chkDispensing(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkZJSN:
		return (void*)soap_instantiate___ns1__chkZJSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LnkZJSN:
		return (void*)soap_instantiate___ns1__LnkZJSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LnkSideSN:
		return (void*)soap_instantiate___ns1__LnkSideSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkGrillSN:
		return (void*)soap_instantiate___ns1__chkGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LnkGrillSN:
		return (void*)soap_instantiate___ns1__LnkGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseGrillSN:
		return (void*)soap_instantiate___ns1__CloseGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsGrillBySN:
		return (void*)soap_instantiate___ns1__InsGrillBySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGrillTime:
		return (void*)soap_instantiate___ns1__GetGrillTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutGrillBySN:
		return (void*)soap_instantiate___ns1__OutGrillBySN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CancelGrillSN:
		return (void*)soap_instantiate___ns1__CancelGrillSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CancelLnkSN:
		return (void*)soap_instantiate___ns1__CancelLnkSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetWeightSet:
		return (void*)soap_instantiate___ns1__GetWeightSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPackToWMS:
		return (void*)soap_instantiate___ns1__GetPackToWMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPallentToWMS:
		return (void*)soap_instantiate___ns1__GetPallentToWMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetPallentForWMS:
		return (void*)soap_instantiate___ns1__SetPallentForWMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPackStation:
		return (void*)soap_instantiate___ns1__GetPackStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPackWeigth:
		return (void*)soap_instantiate___ns1__GetPackWeigth(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAhsMo:
		return (void*)soap_instantiate___ns1__GetAhsMo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAhsBarcode_:
		return (void*)soap_instantiate___ns1__GetAhsBarcode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdAhsBarcode_:
		return (void*)soap_instantiate___ns1__UpdAhsBarcode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkWeightTime_:
		return (void*)soap_instantiate___ns1__ChkWeightTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsSNTest_:
		return (void*)soap_instantiate___ns1__InsSNTest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelSNTest_:
		return (void*)soap_instantiate___ns1__SelSNTest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DelSNTest_:
		return (void*)soap_instantiate___ns1__DelSNTest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnLinkForApple_:
		return (void*)soap_instantiate___ns1__ChkSnLinkForApple_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doSnLinkForApple_:
		return (void*)soap_instantiate___ns1__doSnLinkForApple_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetObeNW_:
		return (void*)soap_instantiate___ns1__GetObeNW_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFruitSNCheck_:
		return (void*)soap_instantiate___ns1__GetFruitSNCheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotLinkCount_:
		return (void*)soap_instantiate___ns1__GetLotLinkCount_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doLotLinkForApple_:
		return (void*)soap_instantiate___ns1__doLotLinkForApple_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingList_:
		return (void*)soap_instantiate___ns1__GetShippingList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingBerthList_:
		return (void*)soap_instantiate___ns1__GetShippingBerthList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdShipping_:
		return (void*)soap_instantiate___ns1__UpdShipping_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingPalle_:
		return (void*)soap_instantiate___ns1__GetShippingPalle_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsShippingPalle_:
		return (void*)soap_instantiate___ns1__InsShippingPalle_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsShippingBerth_:
		return (void*)soap_instantiate___ns1__InsShippingBerth_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingForBerth_:
		return (void*)soap_instantiate___ns1__GetShippingForBerth_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShippingWeight_:
		return (void*)soap_instantiate___ns1__GetShippingWeight_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStationByMoForTestPad_:
		return (void*)soap_instantiate___ns1__getStationByMoForTestPad_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetFlatnessFruitRec_:
		return (void*)soap_instantiate___ns1__SetFlatnessFruitRec_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSNForLink_:
		return (void*)soap_instantiate___ns1__GetSNForLink_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetAutoLineRec_:
		return (void*)soap_instantiate___ns1__SetAutoLineRec_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__HPSNLinkBasket_:
		return (void*)soap_instantiate___ns1__HPSNLinkBasket_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BasketLinkPunch_:
		return (void*)soap_instantiate___ns1__BasketLinkPunch_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PunchOut_:
		return (void*)soap_instantiate___ns1__PunchOut_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkMoSNForAOI_:
		return (void*)soap_instantiate___ns1__chkMoSNForAOI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsAoiMo_:
		return (void*)soap_instantiate___ns1__InsAoiMo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsCLScada_:
		return (void*)soap_instantiate___ns1__InsCLScada_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTestValueResult_:
		return (void*)soap_instantiate___ns1__GetTestValueResult_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStationNumberForSN_:
		return (void*)soap_instantiate___ns1__GetStationNumberForSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsSNTestForFruit_:
		return (void*)soap_instantiate___ns1__InsSNTestForFruit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelSNTestForFruit_:
		return (void*)soap_instantiate___ns1__SelSNTestForFruit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SNLinkShelf_:
		return (void*)soap_instantiate___ns1__SNLinkShelf_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelShelfLink_:
		return (void*)soap_instantiate___ns1__SelShelfLink_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadForHP_:
		return (void*)soap_instantiate___ns1__UploadForHP_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMachineForGroup_:
		return (void*)soap_instantiate___ns1__GetMachineForGroup_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetDiecastSN_:
		return (void*)soap_instantiate___ns1__SetDiecastSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetNgCode_:
		return (void*)soap_instantiate___ns1__GetNgCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMoBase_:
		return (void*)soap_instantiate___ns1__getMoBase_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SnLnkOutSN_:
		return (void*)soap_instantiate___ns1__SnLnkOutSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFruitMachineChk_:
		return (void*)soap_instantiate___ns1__InsFruitMachineChk_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFruitMachineChk_:
		return (void*)soap_instantiate___ns1__GetFruitMachineChk_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsZjList_:
		return (void*)soap_instantiate___ns1__InsZjList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkTestData_:
		return (void*)soap_instantiate___ns1__checkTestData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkEmpNo_:
		return (void*)soap_instantiate___ns1__checkEmpNo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkSN_USCOREStation_:
		return (void*)soap_instantiate___ns1__checkSN_USCOREStation_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendTestData_:
		return (void*)soap_instantiate___ns1__sendTestData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendTestResult_:
		return (void*)soap_instantiate___ns1__sendTestResult_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InFruitsOrtQty_:
		return (void*)soap_instantiate___ns1__InFruitsOrtQty_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkStationTime_:
		return (void*)soap_instantiate___ns1__chkStationTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ImpMesAteTestData_:
		return (void*)soap_instantiate___ns1__ImpMesAteTestData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFlatNess_:
		return (void*)soap_instantiate___ns1__InsFlatNess_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFlatNessForLSD_:
		return (void*)soap_instantiate___ns1__InsFlatNessForLSD_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsFlatNessForCL_:
		return (void*)soap_instantiate___ns1__InsFlatNessForCL_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsWHDetection_:
		return (void*)soap_instantiate___ns1__InsWHDetection_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsThermal_:
		return (void*)soap_instantiate___ns1__InsThermal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnLink_:
		return (void*)soap_instantiate___ns1__ChkSnLink_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsThermalNew_:
		return (void*)soap_instantiate___ns1__InsThermalNew_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInfoByMo_:
		return (void*)soap_instantiate___ns1__getInfoByMo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetEnergyStat_:
		return (void*)soap_instantiate___ns1__SetEnergyStat_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkMoStation_:
		return (void*)soap_instantiate___ns1__chkMoStation_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnMo_:
		return (void*)soap_instantiate___ns1__ChkSnMo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkSnNextMo_:
		return (void*)soap_instantiate___ns1__ChkSnNextMo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber_:
		return (void*)soap_instantiate___ns1__checkSN_USCOREStationNumber_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkEmpForStationNumber_:
		return (void*)soap_instantiate___ns1__checkEmpForStationNumber_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendDataForStationNumber_:
		return (void*)soap_instantiate___ns1__sendDataForStationNumber_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendResultForStationNumber_:
		return (void*)soap_instantiate___ns1__sendResultForStationNumber_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__eMesNextMo_:
		return (void*)soap_instantiate___ns1__eMesNextMo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SnDoMapping_:
		return (void*)soap_instantiate___ns1__SnDoMapping_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStationByMo_:
		return (void*)soap_instantiate___ns1__getStationByMo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStationTypeDesc_:
		return (void*)soap_instantiate___ns1__getStationTypeDesc_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkSnMapping_:
		return (void*)soap_instantiate___ns1__chkSnMapping_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMoAssyList_:
		return (void*)soap_instantiate___ns1__getMoAssyList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPartBomExt_:
		return (void*)soap_instantiate___ns1__getPartBomExt_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsPartAssy_:
		return (void*)soap_instantiate___ns1__InsPartAssy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLinkOutSn_:
		return (void*)soap_instantiate___ns1__GetLinkOutSn_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMoAssyCount_:
		return (void*)soap_instantiate___ns1__getMoAssyCount_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPNbySN_:
		return (void*)soap_instantiate___ns1__getPNbySN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkAssySN_:
		return (void*)soap_instantiate___ns1__chkAssySN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doAssy_:
		return (void*)soap_instantiate___ns1__doAssy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPmcAssyList_:
		return (void*)soap_instantiate___ns1__getPmcAssyList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPmcPartAssyList_:
		return (void*)soap_instantiate___ns1__getPmcPartAssyList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPmcSNPart_:
		return (void*)soap_instantiate___ns1__GetPmcSNPart_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doPmcSNLink_:
		return (void*)soap_instantiate___ns1__doPmcSNLink_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsZJTestData_:
		return (void*)soap_instantiate___ns1__InsZJTestData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SNLinkZJ_:
		return (void*)soap_instantiate___ns1__SNLinkZJ_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLintOutQty_:
		return (void*)soap_instantiate___ns1__GetLintOutQty_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkOutSN_:
		return (void*)soap_instantiate___ns1__chkOutSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChkLinkOutSN_:
		return (void*)soap_instantiate___ns1__ChkLinkOutSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doLinkOutSN_:
		return (void*)soap_instantiate___ns1__doLinkOutSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsLinkSN_:
		return (void*)soap_instantiate___ns1__InsLinkSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLinkZJCount_:
		return (void*)soap_instantiate___ns1__GetLinkZJCount_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsBoxNOTime_:
		return (void*)soap_instantiate___ns1__InsBoxNOTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkBoxNo_:
		return (void*)soap_instantiate___ns1__chkBoxNo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InSNtoBox_:
		return (void*)soap_instantiate___ns1__InSNtoBox_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndSNtoBox_:
		return (void*)soap_instantiate___ns1__EndSNtoBox_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InStationbyBox_:
		return (void*)soap_instantiate___ns1__InStationbyBox_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutStationbyBox_:
		return (void*)soap_instantiate___ns1__OutStationbyBox_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CancelBoxLnk_:
		return (void*)soap_instantiate___ns1__CancelBoxLnk_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsSNStationEmp_:
		return (void*)soap_instantiate___ns1__InsSNStationEmp_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsLnkOutSN_:
		return (void*)soap_instantiate___ns1__InsLnkOutSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsBoxInfo_:
		return (void*)soap_instantiate___ns1__InsBoxInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdSnRecInfo_:
		return (void*)soap_instantiate___ns1__UpdSnRecInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMoBase_:
		return (void*)soap_instantiate___ns1__GetMoBase_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTestValue_:
		return (void*)soap_instantiate___ns1__GetTestValue_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLnkData_:
		return (void*)soap_instantiate___ns1__GetLnkData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsIotMachineRec_:
		return (void*)soap_instantiate___ns1__InsIotMachineRec_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsIotTestData_:
		return (void*)soap_instantiate___ns1__InsIotTestData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkDispensing_:
		return (void*)soap_instantiate___ns1__chkDispensing_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkZJSN_:
		return (void*)soap_instantiate___ns1__chkZJSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LnkZJSN_:
		return (void*)soap_instantiate___ns1__LnkZJSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LnkSideSN_:
		return (void*)soap_instantiate___ns1__LnkSideSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__chkGrillSN_:
		return (void*)soap_instantiate___ns1__chkGrillSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LnkGrillSN_:
		return (void*)soap_instantiate___ns1__LnkGrillSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseGrillSN_:
		return (void*)soap_instantiate___ns1__CloseGrillSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsGrillBySN_:
		return (void*)soap_instantiate___ns1__InsGrillBySN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGrillTime_:
		return (void*)soap_instantiate___ns1__GetGrillTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OutGrillBySN_:
		return (void*)soap_instantiate___ns1__OutGrillBySN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CancelGrillSN_:
		return (void*)soap_instantiate___ns1__CancelGrillSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CancelLnkSN_:
		return (void*)soap_instantiate___ns1__CancelLnkSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetWeightSet_:
		return (void*)soap_instantiate___ns1__GetWeightSet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPackToWMS_:
		return (void*)soap_instantiate___ns1__GetPackToWMS_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPallentToWMS_:
		return (void*)soap_instantiate___ns1__GetPallentToWMS_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetPallentForWMS_:
		return (void*)soap_instantiate___ns1__SetPallentForWMS_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPackStation_:
		return (void*)soap_instantiate___ns1__GetPackStation_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPackWeigth_:
		return (void*)soap_instantiate___ns1__GetPackWeigth_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAhsMo_:
		return (void*)soap_instantiate___ns1__GetAhsMo_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfString*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfString*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAhsBarcode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAhsBarcode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAhsBarcode*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAhsBarcodeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAhsBarcodeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdAhsBarcode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdAhsBarcode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdAhsBarcode*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdAhsBarcodeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdAhsBarcodeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdAhsBarcodeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkWeightTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkWeightTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkWeightTime*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkWeightTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkWeightTimeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkWeightTimeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsSNTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsSNTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsSNTest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsSNTestResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsSNTestResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsSNTestResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SelSNTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SelSNTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SelSNTest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SelSNTestResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SelSNTestResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SelSNTestResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DelSNTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DelSNTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DelSNTest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DelSNTestResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DelSNTestResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DelSNTestResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnLinkForApple:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnLinkForApple*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnLinkForApple*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnLinkForAppleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnLinkForAppleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnLinkForAppleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doSnLinkForApple_assyDt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doSnLinkForApple_assyDt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doSnLinkForApple_assyDt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doSnLinkForApple:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doSnLinkForApple*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doSnLinkForApple*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doSnLinkForAppleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doSnLinkForAppleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doSnLinkForAppleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetObeNW:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetObeNW*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetObeNW*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetObeNWResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetObeNWResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetObeNWResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetFruitSNCheck:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetFruitSNCheck*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetFruitSNCheck*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetFruitSNCheckResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetFruitSNCheckResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetFruitSNCheckResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLotLinkCount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLotLinkCount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLotLinkCount*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLotLinkCountResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLotLinkCountResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLotLinkCountResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doLotLinkForApple_assyDt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doLotLinkForApple_assyDt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doLotLinkForApple_assyDt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doLotLinkForApple:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doLotLinkForApple*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doLotLinkForApple*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doLotLinkForAppleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doLotLinkForAppleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doLotLinkForAppleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingList*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingListResponse_GetShippingListResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingListResponse_GetShippingListResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingBerthList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingBerthList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingBerthList*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingBerthListResponse_GetShippingBerthListResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingBerthListResponse_GetShippingBerthListResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingBerthListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingBerthListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingBerthListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdShipping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdShipping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdShipping*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdShippingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdShippingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdShippingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingPalle:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingPalle*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingPalle*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingPalleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingPalleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingPalleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsShippingPalle:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsShippingPalle*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsShippingPalle*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsShippingPalleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsShippingPalleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsShippingPalleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsShippingBerth:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsShippingBerth*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsShippingBerth*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsShippingBerthResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsShippingBerthResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsShippingBerthResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingForBerth:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingForBerth*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingForBerth*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingForBerthResponse_GetShippingForBerthResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingForBerthResponse_GetShippingForBerthResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingForBerthResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingForBerthResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingForBerthResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingWeight:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingWeight*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingWeight*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingWeightResponse_GetShippingWeightResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingWeightResponse_GetShippingWeightResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetShippingWeightResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetShippingWeightResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetShippingWeightResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getStationByMoForTestPad:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getStationByMoForTestPad*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getStationByMoForTestPad*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getStationByMoForTestPadResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getStationByMoForTestPadResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getStationByMoForTestPadResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRec_dt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetFlatnessFruitRec_dt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetFlatnessFruitRec_dt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRec:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetFlatnessFruitRec*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetFlatnessFruitRec*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRecResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetFlatnessFruitRecResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetFlatnessFruitRecResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetSNForLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetSNForLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetSNForLink*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetSNForLinkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetSNForLinkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetSNForLinkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetAutoLineRec:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetAutoLineRec*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetAutoLineRec*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetAutoLineRecResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetAutoLineRecResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetAutoLineRecResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__HPSNLinkBasket:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__HPSNLinkBasket*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__HPSNLinkBasket*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__HPSNLinkBasketResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__HPSNLinkBasketResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__HPSNLinkBasketResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__BasketLinkPunch:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__BasketLinkPunch*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__BasketLinkPunch*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__BasketLinkPunchResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__BasketLinkPunchResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__BasketLinkPunchResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PunchOut:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PunchOut*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PunchOut*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PunchOutResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PunchOutResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PunchOutResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkMoSNForAOI:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkMoSNForAOI*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkMoSNForAOI*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkMoSNForAOIResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkMoSNForAOIResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkMoSNForAOIResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsAoiMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsAoiMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsAoiMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsAoiMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsAoiMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsAoiMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsCLScada:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsCLScada*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsCLScada*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsCLScadaResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsCLScadaResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsCLScadaResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetTestValueResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetTestValueResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetTestValueResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetTestValueResultResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetTestValueResultResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetTestValueResultResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetStationNumberForSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetStationNumberForSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetStationNumberForSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetStationNumberForSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetStationNumberForSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetStationNumberForSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsSNTestForFruit:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsSNTestForFruit*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsSNTestForFruit*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsSNTestForFruitResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsSNTestForFruitResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsSNTestForFruitResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SelSNTestForFruit:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SelSNTestForFruit*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SelSNTestForFruit*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SelSNTestForFruitResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SelSNTestForFruitResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SelSNTestForFruitResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SNLinkShelf:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SNLinkShelf*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SNLinkShelf*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SNLinkShelfResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SNLinkShelfResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SNLinkShelfResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SelShelfLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SelShelfLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SelShelfLink*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SelShelfLinkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SelShelfLinkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SelShelfLinkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UploadForHP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UploadForHP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UploadForHP*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UploadForHPResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UploadForHPResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UploadForHPResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetMachineForGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetMachineForGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetMachineForGroup*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetMachineForGroupResponse_GetMachineForGroupResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetMachineForGroupResponse_GetMachineForGroupResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetMachineForGroupResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetMachineForGroupResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetMachineForGroupResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetDiecastSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetDiecastSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetDiecastSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetDiecastSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetDiecastSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetDiecastSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetNgCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetNgCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetNgCode*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetNgCodeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetNgCodeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetNgCodeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoBase*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoBaseResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoBaseResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoBaseResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnLnkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnLnkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnLnkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnLnkOutSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnLnkOutSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnLnkOutSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFruitMachineChk:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFruitMachineChk*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFruitMachineChk*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFruitMachineChkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFruitMachineChkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFruitMachineChkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetFruitMachineChk:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetFruitMachineChk*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetFruitMachineChk*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetFruitMachineChkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetFruitMachineChkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetFruitMachineChkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsZjList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsZjList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsZjList*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsZjListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsZjListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsZjListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkTestData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkTestDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkTestDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkTestDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkEmpNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkEmpNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkEmpNo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkEmpNoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkEmpNoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkEmpNoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSN_USCOREStation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSN_USCOREStation*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSN_USCOREStationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSN_USCOREStationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendTestData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendTestDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendTestDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendTestDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendTestResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendTestResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendTestResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendTestResultResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendTestResultResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendTestResultResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InFruitsOrtQty:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InFruitsOrtQty*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InFruitsOrtQty*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InFruitsOrtQtyResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InFruitsOrtQtyResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InFruitsOrtQtyResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkStationTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkStationTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkStationTime*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkStationTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkStationTimeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkStationTimeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ImpMesAteTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ImpMesAteTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ImpMesAteTestData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ImpMesAteTestDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ImpMesAteTestDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ImpMesAteTestDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFlatNess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFlatNess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFlatNess*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFlatNessResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFlatNessResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFlatNessResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFlatNessForLSD:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFlatNessForLSD*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFlatNessForLSD*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFlatNessForLSDResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFlatNessForLSDResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFlatNessForLSDResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFlatNessForCL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFlatNessForCL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFlatNessForCL*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsFlatNessForCLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsFlatNessForCLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsFlatNessForCLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsWHDetection:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsWHDetection*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsWHDetection*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsWHDetectionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsWHDetectionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsWHDetectionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsThermal:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsThermal*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsThermal*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsThermalResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsThermalResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsThermalResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnLink*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnLinkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnLinkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnLinkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsThermalNew:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsThermalNew*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsThermalNew*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsThermalNewResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsThermalNewResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsThermalNewResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getInfoByMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getInfoByMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getInfoByMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getInfoByMoResponse_getInfoByMoResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getInfoByMoResponse_getInfoByMoResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getInfoByMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getInfoByMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getInfoByMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetEnergyStat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetEnergyStat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetEnergyStat*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetEnergyStatResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetEnergyStatResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetEnergyStatResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkMoStation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkMoStation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkMoStation*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkMoStationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkMoStationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkMoStationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnNextMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnNextMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnNextMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkSnNextMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkSnNextMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkSnNextMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSN_USCOREStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSN_USCOREStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSN_USCOREStationNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSN_USCOREStationNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkEmpForStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkEmpForStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkEmpForStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkEmpForStationNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkEmpForStationNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkEmpForStationNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendDataForStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendDataForStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendDataForStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendDataForStationNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendDataForStationNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendDataForStationNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendResultForStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendResultForStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendResultForStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__sendResultForStationNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__sendResultForStationNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__sendResultForStationNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__eMesNextMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__eMesNextMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__eMesNextMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__eMesNextMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__eMesNextMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__eMesNextMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnDoMapping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnDoMapping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnDoMapping*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnDoMappingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnDoMappingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnDoMappingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getStationByMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getStationByMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getStationByMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getStationByMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getStationByMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getStationByMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getStationTypeDesc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getStationTypeDesc*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getStationTypeDesc*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getStationTypeDescResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getStationTypeDescResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getStationTypeDescResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkSnMapping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkSnMapping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkSnMapping*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkSnMappingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkSnMappingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkSnMappingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoAssyList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoAssyList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoAssyList*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoAssyListResponse_getMoAssyListResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoAssyListResponse_getMoAssyListResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoAssyListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoAssyListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoAssyListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPartBomExt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPartBomExt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPartBomExt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPartBomExtResponse_getPartBomExtResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPartBomExtResponse_getPartBomExtResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPartBomExtResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPartBomExtResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPartBomExtResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsPartAssy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsPartAssy*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsPartAssy*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsPartAssyResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsPartAssyResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsPartAssyResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLinkOutSn:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLinkOutSn*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLinkOutSn*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLinkOutSnResponse_GetLinkOutSnResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLinkOutSnResponse_GetLinkOutSnResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLinkOutSnResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLinkOutSnResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLinkOutSnResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoAssyCount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoAssyCount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoAssyCount*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMoAssyCountResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMoAssyCountResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMoAssyCountResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPNbySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPNbySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPNbySN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPNbySNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPNbySNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPNbySNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkAssySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkAssySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkAssySN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkAssySNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkAssySNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkAssySNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doAssy_assyDt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doAssy_assyDt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doAssy_assyDt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doAssy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doAssy*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doAssy*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doAssyResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doAssyResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doAssyResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPmcAssyList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPmcAssyList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPmcAssyList*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPmcAssyListResponse_getPmcAssyListResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPmcAssyListResponse_getPmcAssyListResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPmcAssyListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPmcAssyListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPmcAssyListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPmcPartAssyList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPmcPartAssyList*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getPmcPartAssyListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getPmcPartAssyListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPmcSNPart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPmcSNPart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPmcSNPart*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPmcSNPartResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPmcSNPartResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPmcSNPartResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doPmcSNLink_assyDt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doPmcSNLink_assyDt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doPmcSNLink_assyDt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doPmcSNLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doPmcSNLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doPmcSNLink*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doPmcSNLinkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doPmcSNLinkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doPmcSNLinkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsZJTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsZJTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsZJTestData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsZJTestDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsZJTestDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsZJTestDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SNLinkZJ:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SNLinkZJ*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SNLinkZJ*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SNLinkZJResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SNLinkZJResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SNLinkZJResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLintOutQty:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLintOutQty*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLintOutQty*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLintOutQtyResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLintOutQtyResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLintOutQtyResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkOutSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkOutSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkOutSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkLinkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkLinkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkLinkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChkLinkOutSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChkLinkOutSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChkLinkOutSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doLinkOutSN_assyDt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doLinkOutSN_assyDt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doLinkOutSN_assyDt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doLinkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doLinkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doLinkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__doLinkOutSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__doLinkOutSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__doLinkOutSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsLinkSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsLinkSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsLinkSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsLinkSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsLinkSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsLinkSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLinkZJCount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLinkZJCount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLinkZJCount*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLinkZJCountResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLinkZJCountResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLinkZJCountResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsBoxNOTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsBoxNOTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsBoxNOTime*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsBoxNOTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsBoxNOTimeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsBoxNOTimeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkBoxNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkBoxNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkBoxNo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkBoxNoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkBoxNoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkBoxNoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InSNtoBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InSNtoBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InSNtoBox*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InSNtoBoxResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InSNtoBoxResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InSNtoBoxResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__EndSNtoBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__EndSNtoBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__EndSNtoBox*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__EndSNtoBoxResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__EndSNtoBoxResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__EndSNtoBoxResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InStationbyBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InStationbyBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InStationbyBox*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InStationbyBoxResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InStationbyBoxResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InStationbyBoxResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OutStationbyBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OutStationbyBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OutStationbyBox*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OutStationbyBoxResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OutStationbyBoxResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OutStationbyBoxResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelBoxLnk:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelBoxLnk*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelBoxLnk*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelBoxLnkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelBoxLnkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelBoxLnkResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsSNStationEmp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsSNStationEmp*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsSNStationEmp*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsSNStationEmpResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsSNStationEmpResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsSNStationEmpResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsLnkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsLnkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsLnkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsLnkOutSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsLnkOutSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsLnkOutSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsBoxInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsBoxInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsBoxInfo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsBoxInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsBoxInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsBoxInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdSnRecInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdSnRecInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdSnRecInfo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdSnRecInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdSnRecInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdSnRecInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetMoBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetMoBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetMoBase*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetMoBaseResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetMoBaseResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetMoBaseResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetTestValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetTestValue*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetTestValue*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetTestValueResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetTestValueResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetTestValueResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLnkData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLnkData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLnkData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLnkDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLnkDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLnkDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsIotMachineRec:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsIotMachineRec*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsIotMachineRec*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsIotMachineRecResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsIotMachineRecResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsIotMachineRecResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsIotTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsIotTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsIotTestData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsIotTestDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsIotTestDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsIotTestDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkDispensing:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkDispensing*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkDispensing*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkDispensingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkDispensingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkDispensingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkZJSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkZJSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkZJSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkZJSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkZJSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkZJSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LnkZJSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LnkZJSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LnkZJSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LnkZJSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LnkZJSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LnkZJSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LnkSideSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LnkSideSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LnkSideSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LnkSideSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LnkSideSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LnkSideSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__chkGrillSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__chkGrillSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__chkGrillSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LnkGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LnkGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LnkGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LnkGrillSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LnkGrillSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LnkGrillSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseGrillSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseGrillSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseGrillSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsGrillBySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsGrillBySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsGrillBySN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsGrillBySNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsGrillBySNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsGrillBySNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetGrillTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetGrillTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetGrillTime*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetGrillTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetGrillTimeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetGrillTimeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OutGrillBySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OutGrillBySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OutGrillBySN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OutGrillBySNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OutGrillBySNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OutGrillBySNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelGrillSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelGrillSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelGrillSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelLnkSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelLnkSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelLnkSN*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelLnkSNResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelLnkSNResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelLnkSNResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetWeightSet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetWeightSet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetWeightSet*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetWeightSetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetWeightSetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetWeightSetResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPackToWMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPackToWMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPackToWMS*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPackToWMSResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPackToWMSResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPackToWMSResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPallentToWMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPallentToWMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPallentToWMS*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPallentToWMSResponse_GetPallentToWMSResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPallentToWMSResponse_GetPallentToWMSResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPallentToWMSResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPallentToWMSResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPallentToWMSResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetPallentForWMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetPallentForWMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetPallentForWMS*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetPallentForWMSResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetPallentForWMSResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetPallentForWMSResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPackStation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPackStation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPackStation*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPackStationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPackStationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPackStationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPackWeigth:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPackWeigth*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPackWeigth*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPackWeigthResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPackWeigthResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPackWeigthResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAhsMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAhsMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAhsMo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAhsMoResponse_GetAhsMoResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAhsMoResponse_GetAhsMoResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAhsMoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAhsMoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAhsMoResponse*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAhsBarcode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAhsBarcode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAhsBarcode*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdAhsBarcode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdAhsBarcode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdAhsBarcode*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkWeightTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkWeightTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkWeightTime*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsSNTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsSNTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsSNTest*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SelSNTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SelSNTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SelSNTest*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__DelSNTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DelSNTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DelSNTest*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnLinkForApple:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnLinkForApple*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnLinkForApple*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doSnLinkForApple:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doSnLinkForApple*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doSnLinkForApple*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetObeNW:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetObeNW*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetObeNW*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetFruitSNCheck:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetFruitSNCheck*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetFruitSNCheck*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLotLinkCount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLotLinkCount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLotLinkCount*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doLotLinkForApple:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doLotLinkForApple*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doLotLinkForApple*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingBerthList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingBerthList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingBerthList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdShipping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdShipping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdShipping*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingPalle:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingPalle*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingPalle*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsShippingPalle:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsShippingPalle*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsShippingPalle*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsShippingBerth:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsShippingBerth*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsShippingBerth*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingForBerth:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingForBerth*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingForBerth*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingWeight:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingWeight*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingWeight*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getStationByMoForTestPad:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getStationByMoForTestPad*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getStationByMoForTestPad*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetFlatnessFruitRec:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetFlatnessFruitRec*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetFlatnessFruitRec*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetSNForLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetSNForLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetSNForLink*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetAutoLineRec:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetAutoLineRec*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetAutoLineRec*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__HPSNLinkBasket:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__HPSNLinkBasket*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__HPSNLinkBasket*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BasketLinkPunch:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BasketLinkPunch*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BasketLinkPunch*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__PunchOut:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__PunchOut*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__PunchOut*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkMoSNForAOI:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkMoSNForAOI*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkMoSNForAOI*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsAoiMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsAoiMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsAoiMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsCLScada:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsCLScada*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsCLScada*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetTestValueResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetTestValueResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetTestValueResult*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetStationNumberForSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetStationNumberForSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetStationNumberForSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsSNTestForFruit:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsSNTestForFruit*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsSNTestForFruit*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SelSNTestForFruit:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SelSNTestForFruit*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SelSNTestForFruit*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SNLinkShelf:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SNLinkShelf*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SNLinkShelf*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SelShelfLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SelShelfLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SelShelfLink*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UploadForHP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UploadForHP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UploadForHP*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetMachineForGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetMachineForGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetMachineForGroup*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetDiecastSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetDiecastSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetDiecastSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetNgCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetNgCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetNgCode*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMoBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMoBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMoBase*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SnLnkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SnLnkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SnLnkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFruitMachineChk:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFruitMachineChk*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFruitMachineChk*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetFruitMachineChk:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetFruitMachineChk*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetFruitMachineChk*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsZjList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsZjList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsZjList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkTestData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkEmpNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkEmpNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkEmpNo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkSN_USCOREStation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkSN_USCOREStation*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendTestData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendTestResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendTestResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendTestResult*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InFruitsOrtQty:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InFruitsOrtQty*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InFruitsOrtQty*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkStationTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkStationTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkStationTime*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ImpMesAteTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ImpMesAteTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ImpMesAteTestData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFlatNess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFlatNess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFlatNess*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFlatNessForLSD:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFlatNessForLSD*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFlatNessForLSD*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFlatNessForCL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFlatNessForCL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFlatNessForCL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsWHDetection:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsWHDetection*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsWHDetection*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsThermal:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsThermal*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsThermal*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnLink*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsThermalNew:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsThermalNew*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsThermalNew*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getInfoByMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getInfoByMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getInfoByMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetEnergyStat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetEnergyStat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetEnergyStat*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkMoStation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkMoStation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkMoStation*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnNextMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnNextMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnNextMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkSN_USCOREStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkSN_USCOREStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkEmpForStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkEmpForStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkEmpForStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendDataForStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendDataForStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendDataForStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendResultForStationNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendResultForStationNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendResultForStationNumber*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__eMesNextMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__eMesNextMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__eMesNextMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SnDoMapping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SnDoMapping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SnDoMapping*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getStationByMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getStationByMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getStationByMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getStationTypeDesc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getStationTypeDesc*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getStationTypeDesc*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkSnMapping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkSnMapping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkSnMapping*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMoAssyList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMoAssyList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMoAssyList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPartBomExt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPartBomExt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPartBomExt*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsPartAssy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsPartAssy*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsPartAssy*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLinkOutSn:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLinkOutSn*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLinkOutSn*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMoAssyCount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMoAssyCount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMoAssyCount*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPNbySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPNbySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPNbySN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkAssySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkAssySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkAssySN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doAssy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doAssy*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doAssy*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPmcAssyList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPmcAssyList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPmcAssyList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPmcPartAssyList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPmcPartAssyList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPmcPartAssyList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPmcSNPart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPmcSNPart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPmcSNPart*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doPmcSNLink:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doPmcSNLink*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doPmcSNLink*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsZJTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsZJTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsZJTestData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SNLinkZJ:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SNLinkZJ*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SNLinkZJ*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLintOutQty:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLintOutQty*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLintOutQty*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkLinkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkLinkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkLinkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doLinkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doLinkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doLinkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsLinkSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsLinkSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsLinkSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLinkZJCount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLinkZJCount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLinkZJCount*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsBoxNOTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsBoxNOTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsBoxNOTime*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkBoxNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkBoxNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkBoxNo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InSNtoBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InSNtoBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InSNtoBox*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__EndSNtoBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__EndSNtoBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__EndSNtoBox*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InStationbyBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InStationbyBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InStationbyBox*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OutStationbyBox:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OutStationbyBox*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OutStationbyBox*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CancelBoxLnk:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CancelBoxLnk*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CancelBoxLnk*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsSNStationEmp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsSNStationEmp*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsSNStationEmp*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsLnkOutSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsLnkOutSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsLnkOutSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsBoxInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsBoxInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsBoxInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdSnRecInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdSnRecInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdSnRecInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetMoBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetMoBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetMoBase*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetTestValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetTestValue*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetTestValue*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLnkData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLnkData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLnkData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsIotMachineRec:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsIotMachineRec*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsIotMachineRec*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsIotTestData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsIotTestData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsIotTestData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkDispensing:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkDispensing*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkDispensing*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkZJSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkZJSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkZJSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LnkZJSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LnkZJSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LnkZJSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LnkSideSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LnkSideSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LnkSideSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LnkGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LnkGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LnkGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsGrillBySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsGrillBySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsGrillBySN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetGrillTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetGrillTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetGrillTime*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OutGrillBySN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OutGrillBySN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OutGrillBySN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CancelGrillSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CancelGrillSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CancelGrillSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CancelLnkSN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CancelLnkSN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CancelLnkSN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetWeightSet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetWeightSet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetWeightSet*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPackToWMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPackToWMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPackToWMS*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPallentToWMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPallentToWMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPallentToWMS*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetPallentForWMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetPallentForWMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetPallentForWMS*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPackStation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPackStation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPackStation*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPackWeigth:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPackWeigth*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPackWeigth*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAhsMo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAhsMo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAhsMo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAhsBarcode_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAhsBarcode_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAhsBarcode_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdAhsBarcode_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdAhsBarcode_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdAhsBarcode_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkWeightTime_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkWeightTime_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkWeightTime_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsSNTest_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsSNTest_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsSNTest_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SelSNTest_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SelSNTest_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SelSNTest_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__DelSNTest_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DelSNTest_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DelSNTest_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnLinkForApple_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnLinkForApple_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnLinkForApple_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doSnLinkForApple_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doSnLinkForApple_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doSnLinkForApple_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetObeNW_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetObeNW_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetObeNW_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetFruitSNCheck_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetFruitSNCheck_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetFruitSNCheck_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLotLinkCount_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLotLinkCount_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLotLinkCount_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doLotLinkForApple_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doLotLinkForApple_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doLotLinkForApple_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingList_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingBerthList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingBerthList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingBerthList_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdShipping_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdShipping_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdShipping_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingPalle_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingPalle_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingPalle_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsShippingPalle_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsShippingPalle_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsShippingPalle_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsShippingBerth_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsShippingBerth_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsShippingBerth_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingForBerth_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingForBerth_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingForBerth_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetShippingWeight_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetShippingWeight_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetShippingWeight_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getStationByMoForTestPad_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getStationByMoForTestPad_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getStationByMoForTestPad_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetFlatnessFruitRec_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetFlatnessFruitRec_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetFlatnessFruitRec_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetSNForLink_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetSNForLink_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetSNForLink_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetAutoLineRec_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetAutoLineRec_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetAutoLineRec_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__HPSNLinkBasket_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__HPSNLinkBasket_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__HPSNLinkBasket_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BasketLinkPunch_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BasketLinkPunch_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BasketLinkPunch_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__PunchOut_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__PunchOut_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__PunchOut_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkMoSNForAOI_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkMoSNForAOI_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkMoSNForAOI_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsAoiMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsAoiMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsAoiMo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsCLScada_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsCLScada_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsCLScada_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetTestValueResult_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetTestValueResult_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetTestValueResult_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetStationNumberForSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetStationNumberForSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetStationNumberForSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsSNTestForFruit_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsSNTestForFruit_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsSNTestForFruit_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SelSNTestForFruit_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SelSNTestForFruit_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SelSNTestForFruit_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SNLinkShelf_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SNLinkShelf_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SNLinkShelf_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SelShelfLink_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SelShelfLink_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SelShelfLink_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UploadForHP_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UploadForHP_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UploadForHP_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetMachineForGroup_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetMachineForGroup_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetMachineForGroup_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetDiecastSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetDiecastSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetDiecastSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetNgCode_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetNgCode_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetNgCode_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMoBase_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMoBase_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMoBase_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SnLnkOutSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SnLnkOutSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SnLnkOutSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFruitMachineChk_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFruitMachineChk_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFruitMachineChk_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetFruitMachineChk_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetFruitMachineChk_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetFruitMachineChk_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsZjList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsZjList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsZjList_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkTestData_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkTestData_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkTestData_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkEmpNo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkEmpNo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkEmpNo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStation_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkSN_USCOREStation_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkSN_USCOREStation_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendTestData_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendTestData_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendTestData_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendTestResult_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendTestResult_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendTestResult_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InFruitsOrtQty_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InFruitsOrtQty_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InFruitsOrtQty_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkStationTime_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkStationTime_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkStationTime_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ImpMesAteTestData_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ImpMesAteTestData_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ImpMesAteTestData_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFlatNess_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFlatNess_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFlatNess_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFlatNessForLSD_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFlatNessForLSD_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFlatNessForLSD_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsFlatNessForCL_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsFlatNessForCL_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsFlatNessForCL_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsWHDetection_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsWHDetection_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsWHDetection_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsThermal_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsThermal_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsThermal_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnLink_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnLink_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnLink_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsThermalNew_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsThermalNew_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsThermalNew_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getInfoByMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getInfoByMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getInfoByMo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetEnergyStat_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetEnergyStat_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetEnergyStat_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkMoStation_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkMoStation_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkMoStation_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnMo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkSnNextMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkSnNextMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkSnNextMo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkSN_USCOREStationNumber_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkSN_USCOREStationNumber_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkEmpForStationNumber_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkEmpForStationNumber_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkEmpForStationNumber_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendDataForStationNumber_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendDataForStationNumber_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendDataForStationNumber_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__sendResultForStationNumber_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__sendResultForStationNumber_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__sendResultForStationNumber_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__eMesNextMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__eMesNextMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__eMesNextMo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SnDoMapping_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SnDoMapping_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SnDoMapping_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getStationByMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getStationByMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getStationByMo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getStationTypeDesc_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getStationTypeDesc_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getStationTypeDesc_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkSnMapping_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkSnMapping_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkSnMapping_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMoAssyList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMoAssyList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMoAssyList_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPartBomExt_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPartBomExt_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPartBomExt_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsPartAssy_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsPartAssy_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsPartAssy_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLinkOutSn_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLinkOutSn_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLinkOutSn_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMoAssyCount_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMoAssyCount_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMoAssyCount_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPNbySN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPNbySN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPNbySN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkAssySN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkAssySN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkAssySN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doAssy_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doAssy_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doAssy_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPmcAssyList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPmcAssyList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPmcAssyList_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPmcPartAssyList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPmcPartAssyList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPmcPartAssyList_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPmcSNPart_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPmcSNPart_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPmcSNPart_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doPmcSNLink_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doPmcSNLink_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doPmcSNLink_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsZJTestData_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsZJTestData_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsZJTestData_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SNLinkZJ_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SNLinkZJ_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SNLinkZJ_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLintOutQty_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLintOutQty_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLintOutQty_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkOutSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkOutSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkOutSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChkLinkOutSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChkLinkOutSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChkLinkOutSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__doLinkOutSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__doLinkOutSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__doLinkOutSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsLinkSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsLinkSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsLinkSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLinkZJCount_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLinkZJCount_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLinkZJCount_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsBoxNOTime_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsBoxNOTime_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsBoxNOTime_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkBoxNo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkBoxNo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkBoxNo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InSNtoBox_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InSNtoBox_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InSNtoBox_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__EndSNtoBox_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__EndSNtoBox_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__EndSNtoBox_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InStationbyBox_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InStationbyBox_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InStationbyBox_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OutStationbyBox_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OutStationbyBox_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OutStationbyBox_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CancelBoxLnk_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CancelBoxLnk_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CancelBoxLnk_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsSNStationEmp_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsSNStationEmp_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsSNStationEmp_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsLnkOutSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsLnkOutSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsLnkOutSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsBoxInfo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsBoxInfo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsBoxInfo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdSnRecInfo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdSnRecInfo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdSnRecInfo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetMoBase_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetMoBase_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetMoBase_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetTestValue_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetTestValue_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetTestValue_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetLnkData_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetLnkData_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetLnkData_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsIotMachineRec_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsIotMachineRec_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsIotMachineRec_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsIotTestData_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsIotTestData_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsIotTestData_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkDispensing_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkDispensing_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkDispensing_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkZJSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkZJSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkZJSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LnkZJSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LnkZJSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LnkZJSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LnkSideSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LnkSideSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LnkSideSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__chkGrillSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__chkGrillSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__chkGrillSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LnkGrillSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LnkGrillSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LnkGrillSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseGrillSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseGrillSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseGrillSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsGrillBySN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsGrillBySN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsGrillBySN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetGrillTime_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetGrillTime_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetGrillTime_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OutGrillBySN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OutGrillBySN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OutGrillBySN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CancelGrillSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CancelGrillSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CancelGrillSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CancelLnkSN_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CancelLnkSN_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CancelLnkSN_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetWeightSet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetWeightSet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetWeightSet_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPackToWMS_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPackToWMS_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPackToWMS_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPallentToWMS_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPallentToWMS_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPallentToWMS_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SetPallentForWMS_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SetPallentForWMS_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SetPallentForWMS_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPackStation_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPackStation_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPackStation_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetPackWeigth_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetPackWeigth_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetPackWeigth_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAhsMo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAhsMo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAhsMo_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<char *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<char *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfString type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
		break;
	case SOAP_TYPE__ns1__GetAhsBarcode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAhsBarcode type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAhsBarcode*)p = *(_ns1__GetAhsBarcode*)q;
		break;
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult*)p = *(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult*)q;
		break;
	case SOAP_TYPE__ns1__GetAhsBarcodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAhsBarcodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAhsBarcodeResponse*)p = *(_ns1__GetAhsBarcodeResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpdAhsBarcode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdAhsBarcode type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdAhsBarcode*)p = *(_ns1__UpdAhsBarcode*)q;
		break;
	case SOAP_TYPE__ns1__UpdAhsBarcodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdAhsBarcodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdAhsBarcodeResponse*)p = *(_ns1__UpdAhsBarcodeResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChkWeightTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkWeightTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkWeightTime*)p = *(_ns1__ChkWeightTime*)q;
		break;
	case SOAP_TYPE__ns1__ChkWeightTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkWeightTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkWeightTimeResponse*)p = *(_ns1__ChkWeightTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsSNTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsSNTest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsSNTest*)p = *(_ns1__InsSNTest*)q;
		break;
	case SOAP_TYPE__ns1__InsSNTestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsSNTestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsSNTestResponse*)p = *(_ns1__InsSNTestResponse*)q;
		break;
	case SOAP_TYPE__ns1__SelSNTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelSNTest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelSNTest*)p = *(_ns1__SelSNTest*)q;
		break;
	case SOAP_TYPE__ns1__SelSNTestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelSNTestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelSNTestResponse*)p = *(_ns1__SelSNTestResponse*)q;
		break;
	case SOAP_TYPE__ns1__DelSNTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DelSNTest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DelSNTest*)p = *(_ns1__DelSNTest*)q;
		break;
	case SOAP_TYPE__ns1__DelSNTestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DelSNTestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DelSNTestResponse*)p = *(_ns1__DelSNTestResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnLinkForApple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnLinkForApple type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnLinkForApple*)p = *(_ns1__ChkSnLinkForApple*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnLinkForAppleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnLinkForAppleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnLinkForAppleResponse*)p = *(_ns1__ChkSnLinkForAppleResponse*)q;
		break;
	case SOAP_TYPE__ns1__doSnLinkForApple_assyDt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doSnLinkForApple_assyDt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doSnLinkForApple_assyDt*)p = *(_ns1__doSnLinkForApple_assyDt*)q;
		break;
	case SOAP_TYPE__ns1__doSnLinkForApple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doSnLinkForApple type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doSnLinkForApple*)p = *(_ns1__doSnLinkForApple*)q;
		break;
	case SOAP_TYPE__ns1__doSnLinkForAppleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doSnLinkForAppleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doSnLinkForAppleResponse*)p = *(_ns1__doSnLinkForAppleResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetObeNW:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetObeNW type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetObeNW*)p = *(_ns1__GetObeNW*)q;
		break;
	case SOAP_TYPE__ns1__GetObeNWResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetObeNWResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetObeNWResponse*)p = *(_ns1__GetObeNWResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetFruitSNCheck:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFruitSNCheck type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFruitSNCheck*)p = *(_ns1__GetFruitSNCheck*)q;
		break;
	case SOAP_TYPE__ns1__GetFruitSNCheckResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFruitSNCheckResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFruitSNCheckResponse*)p = *(_ns1__GetFruitSNCheckResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetLotLinkCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLotLinkCount type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLotLinkCount*)p = *(_ns1__GetLotLinkCount*)q;
		break;
	case SOAP_TYPE__ns1__GetLotLinkCountResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLotLinkCountResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLotLinkCountResponse*)p = *(_ns1__GetLotLinkCountResponse*)q;
		break;
	case SOAP_TYPE__ns1__doLotLinkForApple_assyDt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doLotLinkForApple_assyDt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doLotLinkForApple_assyDt*)p = *(_ns1__doLotLinkForApple_assyDt*)q;
		break;
	case SOAP_TYPE__ns1__doLotLinkForApple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doLotLinkForApple type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doLotLinkForApple*)p = *(_ns1__doLotLinkForApple*)q;
		break;
	case SOAP_TYPE__ns1__doLotLinkForAppleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doLotLinkForAppleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doLotLinkForAppleResponse*)p = *(_ns1__doLotLinkForAppleResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingList*)p = *(_ns1__GetShippingList*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingListResponse_GetShippingListResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingListResponse_GetShippingListResult*)p = *(_ns1__GetShippingListResponse_GetShippingListResult*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingListResponse*)p = *(_ns1__GetShippingListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingBerthList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingBerthList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingBerthList*)p = *(_ns1__GetShippingBerthList*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingBerthListResponse_GetShippingBerthListResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult*)p = *(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingBerthListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingBerthListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingBerthListResponse*)p = *(_ns1__GetShippingBerthListResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpdShipping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdShipping type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdShipping*)p = *(_ns1__UpdShipping*)q;
		break;
	case SOAP_TYPE__ns1__UpdShippingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdShippingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdShippingResponse*)p = *(_ns1__UpdShippingResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingPalle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingPalle type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingPalle*)p = *(_ns1__GetShippingPalle*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingPalleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingPalleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingPalleResponse*)p = *(_ns1__GetShippingPalleResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsShippingPalle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsShippingPalle type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsShippingPalle*)p = *(_ns1__InsShippingPalle*)q;
		break;
	case SOAP_TYPE__ns1__InsShippingPalleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsShippingPalleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsShippingPalleResponse*)p = *(_ns1__InsShippingPalleResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsShippingBerth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsShippingBerth type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsShippingBerth*)p = *(_ns1__InsShippingBerth*)q;
		break;
	case SOAP_TYPE__ns1__InsShippingBerthResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsShippingBerthResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsShippingBerthResponse*)p = *(_ns1__InsShippingBerthResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingForBerth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingForBerth type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingForBerth*)p = *(_ns1__GetShippingForBerth*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingForBerthResponse_GetShippingForBerthResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult*)p = *(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingForBerthResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingForBerthResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingForBerthResponse*)p = *(_ns1__GetShippingForBerthResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingWeight:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingWeight type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingWeight*)p = *(_ns1__GetShippingWeight*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingWeightResponse_GetShippingWeightResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingWeightResponse_GetShippingWeightResult*)p = *(_ns1__GetShippingWeightResponse_GetShippingWeightResult*)q;
		break;
	case SOAP_TYPE__ns1__GetShippingWeightResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShippingWeightResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShippingWeightResponse*)p = *(_ns1__GetShippingWeightResponse*)q;
		break;
	case SOAP_TYPE__ns1__getStationByMoForTestPad:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getStationByMoForTestPad type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getStationByMoForTestPad*)p = *(_ns1__getStationByMoForTestPad*)q;
		break;
	case SOAP_TYPE__ns1__getStationByMoForTestPadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getStationByMoForTestPadResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getStationByMoForTestPadResponse*)p = *(_ns1__getStationByMoForTestPadResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRec_dt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetFlatnessFruitRec_dt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetFlatnessFruitRec_dt*)p = *(_ns1__SetFlatnessFruitRec_dt*)q;
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetFlatnessFruitRec type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetFlatnessFruitRec*)p = *(_ns1__SetFlatnessFruitRec*)q;
		break;
	case SOAP_TYPE__ns1__SetFlatnessFruitRecResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetFlatnessFruitRecResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetFlatnessFruitRecResponse*)p = *(_ns1__SetFlatnessFruitRecResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetSNForLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetSNForLink type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetSNForLink*)p = *(_ns1__GetSNForLink*)q;
		break;
	case SOAP_TYPE__ns1__GetSNForLinkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetSNForLinkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetSNForLinkResponse*)p = *(_ns1__GetSNForLinkResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetAutoLineRec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetAutoLineRec type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetAutoLineRec*)p = *(_ns1__SetAutoLineRec*)q;
		break;
	case SOAP_TYPE__ns1__SetAutoLineRecResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetAutoLineRecResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetAutoLineRecResponse*)p = *(_ns1__SetAutoLineRecResponse*)q;
		break;
	case SOAP_TYPE__ns1__HPSNLinkBasket:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HPSNLinkBasket type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HPSNLinkBasket*)p = *(_ns1__HPSNLinkBasket*)q;
		break;
	case SOAP_TYPE__ns1__HPSNLinkBasketResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HPSNLinkBasketResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HPSNLinkBasketResponse*)p = *(_ns1__HPSNLinkBasketResponse*)q;
		break;
	case SOAP_TYPE__ns1__BasketLinkPunch:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BasketLinkPunch type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BasketLinkPunch*)p = *(_ns1__BasketLinkPunch*)q;
		break;
	case SOAP_TYPE__ns1__BasketLinkPunchResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BasketLinkPunchResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BasketLinkPunchResponse*)p = *(_ns1__BasketLinkPunchResponse*)q;
		break;
	case SOAP_TYPE__ns1__PunchOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PunchOut type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PunchOut*)p = *(_ns1__PunchOut*)q;
		break;
	case SOAP_TYPE__ns1__PunchOutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PunchOutResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PunchOutResponse*)p = *(_ns1__PunchOutResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkMoSNForAOI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkMoSNForAOI type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkMoSNForAOI*)p = *(_ns1__chkMoSNForAOI*)q;
		break;
	case SOAP_TYPE__ns1__chkMoSNForAOIResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkMoSNForAOIResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkMoSNForAOIResponse*)p = *(_ns1__chkMoSNForAOIResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsAoiMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsAoiMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsAoiMo*)p = *(_ns1__InsAoiMo*)q;
		break;
	case SOAP_TYPE__ns1__InsAoiMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsAoiMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsAoiMoResponse*)p = *(_ns1__InsAoiMoResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsCLScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsCLScada type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsCLScada*)p = *(_ns1__InsCLScada*)q;
		break;
	case SOAP_TYPE__ns1__InsCLScadaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsCLScadaResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsCLScadaResponse*)p = *(_ns1__InsCLScadaResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetTestValueResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTestValueResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTestValueResult*)p = *(_ns1__GetTestValueResult*)q;
		break;
	case SOAP_TYPE__ns1__GetTestValueResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTestValueResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTestValueResultResponse*)p = *(_ns1__GetTestValueResultResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetStationNumberForSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetStationNumberForSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetStationNumberForSN*)p = *(_ns1__GetStationNumberForSN*)q;
		break;
	case SOAP_TYPE__ns1__GetStationNumberForSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetStationNumberForSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetStationNumberForSNResponse*)p = *(_ns1__GetStationNumberForSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsSNTestForFruit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsSNTestForFruit type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsSNTestForFruit*)p = *(_ns1__InsSNTestForFruit*)q;
		break;
	case SOAP_TYPE__ns1__InsSNTestForFruitResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsSNTestForFruitResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsSNTestForFruitResponse*)p = *(_ns1__InsSNTestForFruitResponse*)q;
		break;
	case SOAP_TYPE__ns1__SelSNTestForFruit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelSNTestForFruit type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelSNTestForFruit*)p = *(_ns1__SelSNTestForFruit*)q;
		break;
	case SOAP_TYPE__ns1__SelSNTestForFruitResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelSNTestForFruitResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelSNTestForFruitResponse*)p = *(_ns1__SelSNTestForFruitResponse*)q;
		break;
	case SOAP_TYPE__ns1__SNLinkShelf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SNLinkShelf type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SNLinkShelf*)p = *(_ns1__SNLinkShelf*)q;
		break;
	case SOAP_TYPE__ns1__SNLinkShelfResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SNLinkShelfResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SNLinkShelfResponse*)p = *(_ns1__SNLinkShelfResponse*)q;
		break;
	case SOAP_TYPE__ns1__SelShelfLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelShelfLink type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelShelfLink*)p = *(_ns1__SelShelfLink*)q;
		break;
	case SOAP_TYPE__ns1__SelShelfLinkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelShelfLinkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelShelfLinkResponse*)p = *(_ns1__SelShelfLinkResponse*)q;
		break;
	case SOAP_TYPE__ns1__UploadForHP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UploadForHP type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UploadForHP*)p = *(_ns1__UploadForHP*)q;
		break;
	case SOAP_TYPE__ns1__UploadForHPResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UploadForHPResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UploadForHPResponse*)p = *(_ns1__UploadForHPResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMachineForGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMachineForGroup type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMachineForGroup*)p = *(_ns1__GetMachineForGroup*)q;
		break;
	case SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMachineForGroupResponse_GetMachineForGroupResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult*)p = *(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult*)q;
		break;
	case SOAP_TYPE__ns1__GetMachineForGroupResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMachineForGroupResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMachineForGroupResponse*)p = *(_ns1__GetMachineForGroupResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetDiecastSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetDiecastSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetDiecastSN*)p = *(_ns1__SetDiecastSN*)q;
		break;
	case SOAP_TYPE__ns1__SetDiecastSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetDiecastSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetDiecastSNResponse*)p = *(_ns1__SetDiecastSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetNgCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetNgCode type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetNgCode*)p = *(_ns1__GetNgCode*)q;
		break;
	case SOAP_TYPE__ns1__GetNgCodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetNgCodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetNgCodeResponse*)p = *(_ns1__GetNgCodeResponse*)q;
		break;
	case SOAP_TYPE__ns1__getMoBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoBase type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoBase*)p = *(_ns1__getMoBase*)q;
		break;
	case SOAP_TYPE__ns1__getMoBaseResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoBaseResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoBaseResponse*)p = *(_ns1__getMoBaseResponse*)q;
		break;
	case SOAP_TYPE__ns1__SnLnkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnLnkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnLnkOutSN*)p = *(_ns1__SnLnkOutSN*)q;
		break;
	case SOAP_TYPE__ns1__SnLnkOutSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnLnkOutSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnLnkOutSNResponse*)p = *(_ns1__SnLnkOutSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsFruitMachineChk:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFruitMachineChk type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFruitMachineChk*)p = *(_ns1__InsFruitMachineChk*)q;
		break;
	case SOAP_TYPE__ns1__InsFruitMachineChkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFruitMachineChkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFruitMachineChkResponse*)p = *(_ns1__InsFruitMachineChkResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetFruitMachineChk:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFruitMachineChk type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFruitMachineChk*)p = *(_ns1__GetFruitMachineChk*)q;
		break;
	case SOAP_TYPE__ns1__GetFruitMachineChkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFruitMachineChkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFruitMachineChkResponse*)p = *(_ns1__GetFruitMachineChkResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsZjList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsZjList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsZjList*)p = *(_ns1__InsZjList*)q;
		break;
	case SOAP_TYPE__ns1__InsZjListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsZjListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsZjListResponse*)p = *(_ns1__InsZjListResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkTestData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkTestData*)p = *(_ns1__checkTestData*)q;
		break;
	case SOAP_TYPE__ns1__checkTestDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkTestDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkTestDataResponse*)p = *(_ns1__checkTestDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkEmpNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkEmpNo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkEmpNo*)p = *(_ns1__checkEmpNo*)q;
		break;
	case SOAP_TYPE__ns1__checkEmpNoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkEmpNoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkEmpNoResponse*)p = *(_ns1__checkEmpNoResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSN_USCOREStation type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSN_USCOREStation*)p = *(_ns1__checkSN_USCOREStation*)q;
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSN_USCOREStationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSN_USCOREStationResponse*)p = *(_ns1__checkSN_USCOREStationResponse*)q;
		break;
	case SOAP_TYPE__ns1__sendTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendTestData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendTestData*)p = *(_ns1__sendTestData*)q;
		break;
	case SOAP_TYPE__ns1__sendTestDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendTestDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendTestDataResponse*)p = *(_ns1__sendTestDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__sendTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendTestResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendTestResult*)p = *(_ns1__sendTestResult*)q;
		break;
	case SOAP_TYPE__ns1__sendTestResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendTestResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendTestResultResponse*)p = *(_ns1__sendTestResultResponse*)q;
		break;
	case SOAP_TYPE__ns1__InFruitsOrtQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InFruitsOrtQty type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InFruitsOrtQty*)p = *(_ns1__InFruitsOrtQty*)q;
		break;
	case SOAP_TYPE__ns1__InFruitsOrtQtyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InFruitsOrtQtyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InFruitsOrtQtyResponse*)p = *(_ns1__InFruitsOrtQtyResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkStationTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkStationTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkStationTime*)p = *(_ns1__chkStationTime*)q;
		break;
	case SOAP_TYPE__ns1__chkStationTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkStationTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkStationTimeResponse*)p = *(_ns1__chkStationTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__ImpMesAteTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ImpMesAteTestData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ImpMesAteTestData*)p = *(_ns1__ImpMesAteTestData*)q;
		break;
	case SOAP_TYPE__ns1__ImpMesAteTestDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ImpMesAteTestDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ImpMesAteTestDataResponse*)p = *(_ns1__ImpMesAteTestDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsFlatNess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFlatNess type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFlatNess*)p = *(_ns1__InsFlatNess*)q;
		break;
	case SOAP_TYPE__ns1__InsFlatNessResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFlatNessResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFlatNessResponse*)p = *(_ns1__InsFlatNessResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsFlatNessForLSD:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFlatNessForLSD type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFlatNessForLSD*)p = *(_ns1__InsFlatNessForLSD*)q;
		break;
	case SOAP_TYPE__ns1__InsFlatNessForLSDResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFlatNessForLSDResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFlatNessForLSDResponse*)p = *(_ns1__InsFlatNessForLSDResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsFlatNessForCL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFlatNessForCL type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFlatNessForCL*)p = *(_ns1__InsFlatNessForCL*)q;
		break;
	case SOAP_TYPE__ns1__InsFlatNessForCLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsFlatNessForCLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsFlatNessForCLResponse*)p = *(_ns1__InsFlatNessForCLResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsWHDetection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsWHDetection type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsWHDetection*)p = *(_ns1__InsWHDetection*)q;
		break;
	case SOAP_TYPE__ns1__InsWHDetectionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsWHDetectionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsWHDetectionResponse*)p = *(_ns1__InsWHDetectionResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsThermal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsThermal type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsThermal*)p = *(_ns1__InsThermal*)q;
		break;
	case SOAP_TYPE__ns1__InsThermalResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsThermalResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsThermalResponse*)p = *(_ns1__InsThermalResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnLink type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnLink*)p = *(_ns1__ChkSnLink*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnLinkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnLinkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnLinkResponse*)p = *(_ns1__ChkSnLinkResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsThermalNew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsThermalNew type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsThermalNew*)p = *(_ns1__InsThermalNew*)q;
		break;
	case SOAP_TYPE__ns1__InsThermalNewResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsThermalNewResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsThermalNewResponse*)p = *(_ns1__InsThermalNewResponse*)q;
		break;
	case SOAP_TYPE__ns1__getInfoByMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getInfoByMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getInfoByMo*)p = *(_ns1__getInfoByMo*)q;
		break;
	case SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getInfoByMoResponse_getInfoByMoResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getInfoByMoResponse_getInfoByMoResult*)p = *(_ns1__getInfoByMoResponse_getInfoByMoResult*)q;
		break;
	case SOAP_TYPE__ns1__getInfoByMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getInfoByMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getInfoByMoResponse*)p = *(_ns1__getInfoByMoResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetEnergyStat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetEnergyStat type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetEnergyStat*)p = *(_ns1__SetEnergyStat*)q;
		break;
	case SOAP_TYPE__ns1__SetEnergyStatResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetEnergyStatResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetEnergyStatResponse*)p = *(_ns1__SetEnergyStatResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkMoStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkMoStation type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkMoStation*)p = *(_ns1__chkMoStation*)q;
		break;
	case SOAP_TYPE__ns1__chkMoStationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkMoStationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkMoStationResponse*)p = *(_ns1__chkMoStationResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnMo*)p = *(_ns1__ChkSnMo*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnMoResponse*)p = *(_ns1__ChkSnMoResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnNextMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnNextMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnNextMo*)p = *(_ns1__ChkSnNextMo*)q;
		break;
	case SOAP_TYPE__ns1__ChkSnNextMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkSnNextMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkSnNextMoResponse*)p = *(_ns1__ChkSnNextMoResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSN_USCOREStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSN_USCOREStationNumber*)p = *(_ns1__checkSN_USCOREStationNumber*)q;
		break;
	case SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSN_USCOREStationNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSN_USCOREStationNumberResponse*)p = *(_ns1__checkSN_USCOREStationNumberResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkEmpForStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkEmpForStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkEmpForStationNumber*)p = *(_ns1__checkEmpForStationNumber*)q;
		break;
	case SOAP_TYPE__ns1__checkEmpForStationNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkEmpForStationNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkEmpForStationNumberResponse*)p = *(_ns1__checkEmpForStationNumberResponse*)q;
		break;
	case SOAP_TYPE__ns1__sendDataForStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendDataForStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendDataForStationNumber*)p = *(_ns1__sendDataForStationNumber*)q;
		break;
	case SOAP_TYPE__ns1__sendDataForStationNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendDataForStationNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendDataForStationNumberResponse*)p = *(_ns1__sendDataForStationNumberResponse*)q;
		break;
	case SOAP_TYPE__ns1__sendResultForStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendResultForStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendResultForStationNumber*)p = *(_ns1__sendResultForStationNumber*)q;
		break;
	case SOAP_TYPE__ns1__sendResultForStationNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__sendResultForStationNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__sendResultForStationNumberResponse*)p = *(_ns1__sendResultForStationNumberResponse*)q;
		break;
	case SOAP_TYPE__ns1__eMesNextMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__eMesNextMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__eMesNextMo*)p = *(_ns1__eMesNextMo*)q;
		break;
	case SOAP_TYPE__ns1__eMesNextMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__eMesNextMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__eMesNextMoResponse*)p = *(_ns1__eMesNextMoResponse*)q;
		break;
	case SOAP_TYPE__ns1__SnDoMapping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnDoMapping type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnDoMapping*)p = *(_ns1__SnDoMapping*)q;
		break;
	case SOAP_TYPE__ns1__SnDoMappingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnDoMappingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnDoMappingResponse*)p = *(_ns1__SnDoMappingResponse*)q;
		break;
	case SOAP_TYPE__ns1__getStationByMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getStationByMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getStationByMo*)p = *(_ns1__getStationByMo*)q;
		break;
	case SOAP_TYPE__ns1__getStationByMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getStationByMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getStationByMoResponse*)p = *(_ns1__getStationByMoResponse*)q;
		break;
	case SOAP_TYPE__ns1__getStationTypeDesc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getStationTypeDesc type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getStationTypeDesc*)p = *(_ns1__getStationTypeDesc*)q;
		break;
	case SOAP_TYPE__ns1__getStationTypeDescResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getStationTypeDescResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getStationTypeDescResponse*)p = *(_ns1__getStationTypeDescResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkSnMapping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkSnMapping type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkSnMapping*)p = *(_ns1__chkSnMapping*)q;
		break;
	case SOAP_TYPE__ns1__chkSnMappingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkSnMappingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkSnMappingResponse*)p = *(_ns1__chkSnMappingResponse*)q;
		break;
	case SOAP_TYPE__ns1__getMoAssyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoAssyList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoAssyList*)p = *(_ns1__getMoAssyList*)q;
		break;
	case SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoAssyListResponse_getMoAssyListResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoAssyListResponse_getMoAssyListResult*)p = *(_ns1__getMoAssyListResponse_getMoAssyListResult*)q;
		break;
	case SOAP_TYPE__ns1__getMoAssyListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoAssyListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoAssyListResponse*)p = *(_ns1__getMoAssyListResponse*)q;
		break;
	case SOAP_TYPE__ns1__getPartBomExt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPartBomExt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPartBomExt*)p = *(_ns1__getPartBomExt*)q;
		break;
	case SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPartBomExtResponse_getPartBomExtResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPartBomExtResponse_getPartBomExtResult*)p = *(_ns1__getPartBomExtResponse_getPartBomExtResult*)q;
		break;
	case SOAP_TYPE__ns1__getPartBomExtResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPartBomExtResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPartBomExtResponse*)p = *(_ns1__getPartBomExtResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsPartAssy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsPartAssy type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsPartAssy*)p = *(_ns1__InsPartAssy*)q;
		break;
	case SOAP_TYPE__ns1__InsPartAssyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsPartAssyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsPartAssyResponse*)p = *(_ns1__InsPartAssyResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetLinkOutSn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLinkOutSn type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLinkOutSn*)p = *(_ns1__GetLinkOutSn*)q;
		break;
	case SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLinkOutSnResponse_GetLinkOutSnResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult*)p = *(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult*)q;
		break;
	case SOAP_TYPE__ns1__GetLinkOutSnResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLinkOutSnResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLinkOutSnResponse*)p = *(_ns1__GetLinkOutSnResponse*)q;
		break;
	case SOAP_TYPE__ns1__getMoAssyCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoAssyCount type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoAssyCount*)p = *(_ns1__getMoAssyCount*)q;
		break;
	case SOAP_TYPE__ns1__getMoAssyCountResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMoAssyCountResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMoAssyCountResponse*)p = *(_ns1__getMoAssyCountResponse*)q;
		break;
	case SOAP_TYPE__ns1__getPNbySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPNbySN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPNbySN*)p = *(_ns1__getPNbySN*)q;
		break;
	case SOAP_TYPE__ns1__getPNbySNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPNbySNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPNbySNResponse*)p = *(_ns1__getPNbySNResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkAssySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkAssySN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkAssySN*)p = *(_ns1__chkAssySN*)q;
		break;
	case SOAP_TYPE__ns1__chkAssySNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkAssySNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkAssySNResponse*)p = *(_ns1__chkAssySNResponse*)q;
		break;
	case SOAP_TYPE__ns1__doAssy_assyDt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doAssy_assyDt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doAssy_assyDt*)p = *(_ns1__doAssy_assyDt*)q;
		break;
	case SOAP_TYPE__ns1__doAssy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doAssy type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doAssy*)p = *(_ns1__doAssy*)q;
		break;
	case SOAP_TYPE__ns1__doAssyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doAssyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doAssyResponse*)p = *(_ns1__doAssyResponse*)q;
		break;
	case SOAP_TYPE__ns1__getPmcAssyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPmcAssyList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPmcAssyList*)p = *(_ns1__getPmcAssyList*)q;
		break;
	case SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPmcAssyListResponse_getPmcAssyListResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPmcAssyListResponse_getPmcAssyListResult*)p = *(_ns1__getPmcAssyListResponse_getPmcAssyListResult*)q;
		break;
	case SOAP_TYPE__ns1__getPmcAssyListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPmcAssyListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPmcAssyListResponse*)p = *(_ns1__getPmcAssyListResponse*)q;
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPmcPartAssyList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPmcPartAssyList*)p = *(_ns1__getPmcPartAssyList*)q;
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult*)p = *(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult*)q;
		break;
	case SOAP_TYPE__ns1__getPmcPartAssyListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getPmcPartAssyListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getPmcPartAssyListResponse*)p = *(_ns1__getPmcPartAssyListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPmcSNPart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPmcSNPart type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPmcSNPart*)p = *(_ns1__GetPmcSNPart*)q;
		break;
	case SOAP_TYPE__ns1__GetPmcSNPartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPmcSNPartResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPmcSNPartResponse*)p = *(_ns1__GetPmcSNPartResponse*)q;
		break;
	case SOAP_TYPE__ns1__doPmcSNLink_assyDt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doPmcSNLink_assyDt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doPmcSNLink_assyDt*)p = *(_ns1__doPmcSNLink_assyDt*)q;
		break;
	case SOAP_TYPE__ns1__doPmcSNLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doPmcSNLink type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doPmcSNLink*)p = *(_ns1__doPmcSNLink*)q;
		break;
	case SOAP_TYPE__ns1__doPmcSNLinkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doPmcSNLinkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doPmcSNLinkResponse*)p = *(_ns1__doPmcSNLinkResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsZJTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsZJTestData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsZJTestData*)p = *(_ns1__InsZJTestData*)q;
		break;
	case SOAP_TYPE__ns1__InsZJTestDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsZJTestDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsZJTestDataResponse*)p = *(_ns1__InsZJTestDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__SNLinkZJ:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SNLinkZJ type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SNLinkZJ*)p = *(_ns1__SNLinkZJ*)q;
		break;
	case SOAP_TYPE__ns1__SNLinkZJResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SNLinkZJResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SNLinkZJResponse*)p = *(_ns1__SNLinkZJResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetLintOutQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLintOutQty type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLintOutQty*)p = *(_ns1__GetLintOutQty*)q;
		break;
	case SOAP_TYPE__ns1__GetLintOutQtyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLintOutQtyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLintOutQtyResponse*)p = *(_ns1__GetLintOutQtyResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkOutSN*)p = *(_ns1__chkOutSN*)q;
		break;
	case SOAP_TYPE__ns1__chkOutSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkOutSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkOutSNResponse*)p = *(_ns1__chkOutSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChkLinkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkLinkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkLinkOutSN*)p = *(_ns1__ChkLinkOutSN*)q;
		break;
	case SOAP_TYPE__ns1__ChkLinkOutSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChkLinkOutSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChkLinkOutSNResponse*)p = *(_ns1__ChkLinkOutSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__doLinkOutSN_assyDt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doLinkOutSN_assyDt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doLinkOutSN_assyDt*)p = *(_ns1__doLinkOutSN_assyDt*)q;
		break;
	case SOAP_TYPE__ns1__doLinkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doLinkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doLinkOutSN*)p = *(_ns1__doLinkOutSN*)q;
		break;
	case SOAP_TYPE__ns1__doLinkOutSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__doLinkOutSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__doLinkOutSNResponse*)p = *(_ns1__doLinkOutSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsLinkSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsLinkSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsLinkSN*)p = *(_ns1__InsLinkSN*)q;
		break;
	case SOAP_TYPE__ns1__InsLinkSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsLinkSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsLinkSNResponse*)p = *(_ns1__InsLinkSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetLinkZJCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLinkZJCount type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLinkZJCount*)p = *(_ns1__GetLinkZJCount*)q;
		break;
	case SOAP_TYPE__ns1__GetLinkZJCountResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLinkZJCountResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLinkZJCountResponse*)p = *(_ns1__GetLinkZJCountResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsBoxNOTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsBoxNOTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsBoxNOTime*)p = *(_ns1__InsBoxNOTime*)q;
		break;
	case SOAP_TYPE__ns1__InsBoxNOTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsBoxNOTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsBoxNOTimeResponse*)p = *(_ns1__InsBoxNOTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkBoxNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkBoxNo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkBoxNo*)p = *(_ns1__chkBoxNo*)q;
		break;
	case SOAP_TYPE__ns1__chkBoxNoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkBoxNoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkBoxNoResponse*)p = *(_ns1__chkBoxNoResponse*)q;
		break;
	case SOAP_TYPE__ns1__InSNtoBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InSNtoBox type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InSNtoBox*)p = *(_ns1__InSNtoBox*)q;
		break;
	case SOAP_TYPE__ns1__InSNtoBoxResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InSNtoBoxResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InSNtoBoxResponse*)p = *(_ns1__InSNtoBoxResponse*)q;
		break;
	case SOAP_TYPE__ns1__EndSNtoBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EndSNtoBox type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EndSNtoBox*)p = *(_ns1__EndSNtoBox*)q;
		break;
	case SOAP_TYPE__ns1__EndSNtoBoxResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EndSNtoBoxResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EndSNtoBoxResponse*)p = *(_ns1__EndSNtoBoxResponse*)q;
		break;
	case SOAP_TYPE__ns1__InStationbyBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InStationbyBox type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InStationbyBox*)p = *(_ns1__InStationbyBox*)q;
		break;
	case SOAP_TYPE__ns1__InStationbyBoxResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InStationbyBoxResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InStationbyBoxResponse*)p = *(_ns1__InStationbyBoxResponse*)q;
		break;
	case SOAP_TYPE__ns1__OutStationbyBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutStationbyBox type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutStationbyBox*)p = *(_ns1__OutStationbyBox*)q;
		break;
	case SOAP_TYPE__ns1__OutStationbyBoxResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutStationbyBoxResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutStationbyBoxResponse*)p = *(_ns1__OutStationbyBoxResponse*)q;
		break;
	case SOAP_TYPE__ns1__CancelBoxLnk:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelBoxLnk type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelBoxLnk*)p = *(_ns1__CancelBoxLnk*)q;
		break;
	case SOAP_TYPE__ns1__CancelBoxLnkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelBoxLnkResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelBoxLnkResponse*)p = *(_ns1__CancelBoxLnkResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsSNStationEmp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsSNStationEmp type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsSNStationEmp*)p = *(_ns1__InsSNStationEmp*)q;
		break;
	case SOAP_TYPE__ns1__InsSNStationEmpResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsSNStationEmpResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsSNStationEmpResponse*)p = *(_ns1__InsSNStationEmpResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsLnkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsLnkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsLnkOutSN*)p = *(_ns1__InsLnkOutSN*)q;
		break;
	case SOAP_TYPE__ns1__InsLnkOutSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsLnkOutSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsLnkOutSNResponse*)p = *(_ns1__InsLnkOutSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsBoxInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsBoxInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsBoxInfo*)p = *(_ns1__InsBoxInfo*)q;
		break;
	case SOAP_TYPE__ns1__InsBoxInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsBoxInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsBoxInfoResponse*)p = *(_ns1__InsBoxInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpdSnRecInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdSnRecInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdSnRecInfo*)p = *(_ns1__UpdSnRecInfo*)q;
		break;
	case SOAP_TYPE__ns1__UpdSnRecInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdSnRecInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdSnRecInfoResponse*)p = *(_ns1__UpdSnRecInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMoBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMoBase type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMoBase*)p = *(_ns1__GetMoBase*)q;
		break;
	case SOAP_TYPE__ns1__GetMoBaseResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMoBaseResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMoBaseResponse*)p = *(_ns1__GetMoBaseResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetTestValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTestValue type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTestValue*)p = *(_ns1__GetTestValue*)q;
		break;
	case SOAP_TYPE__ns1__GetTestValueResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTestValueResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTestValueResponse*)p = *(_ns1__GetTestValueResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetLnkData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLnkData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLnkData*)p = *(_ns1__GetLnkData*)q;
		break;
	case SOAP_TYPE__ns1__GetLnkDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLnkDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLnkDataResponse*)p = *(_ns1__GetLnkDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsIotMachineRec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsIotMachineRec type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsIotMachineRec*)p = *(_ns1__InsIotMachineRec*)q;
		break;
	case SOAP_TYPE__ns1__InsIotMachineRecResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsIotMachineRecResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsIotMachineRecResponse*)p = *(_ns1__InsIotMachineRecResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsIotTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsIotTestData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsIotTestData*)p = *(_ns1__InsIotTestData*)q;
		break;
	case SOAP_TYPE__ns1__InsIotTestDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsIotTestDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsIotTestDataResponse*)p = *(_ns1__InsIotTestDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkDispensing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkDispensing type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkDispensing*)p = *(_ns1__chkDispensing*)q;
		break;
	case SOAP_TYPE__ns1__chkDispensingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkDispensingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkDispensingResponse*)p = *(_ns1__chkDispensingResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkZJSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkZJSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkZJSN*)p = *(_ns1__chkZJSN*)q;
		break;
	case SOAP_TYPE__ns1__chkZJSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkZJSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkZJSNResponse*)p = *(_ns1__chkZJSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__LnkZJSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LnkZJSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LnkZJSN*)p = *(_ns1__LnkZJSN*)q;
		break;
	case SOAP_TYPE__ns1__LnkZJSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LnkZJSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LnkZJSNResponse*)p = *(_ns1__LnkZJSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__LnkSideSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LnkSideSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LnkSideSN*)p = *(_ns1__LnkSideSN*)q;
		break;
	case SOAP_TYPE__ns1__LnkSideSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LnkSideSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LnkSideSNResponse*)p = *(_ns1__LnkSideSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__chkGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkGrillSN*)p = *(_ns1__chkGrillSN*)q;
		break;
	case SOAP_TYPE__ns1__chkGrillSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__chkGrillSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__chkGrillSNResponse*)p = *(_ns1__chkGrillSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__LnkGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LnkGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LnkGrillSN*)p = *(_ns1__LnkGrillSN*)q;
		break;
	case SOAP_TYPE__ns1__LnkGrillSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LnkGrillSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LnkGrillSNResponse*)p = *(_ns1__LnkGrillSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__CloseGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseGrillSN*)p = *(_ns1__CloseGrillSN*)q;
		break;
	case SOAP_TYPE__ns1__CloseGrillSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseGrillSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseGrillSNResponse*)p = *(_ns1__CloseGrillSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsGrillBySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsGrillBySN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsGrillBySN*)p = *(_ns1__InsGrillBySN*)q;
		break;
	case SOAP_TYPE__ns1__InsGrillBySNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsGrillBySNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsGrillBySNResponse*)p = *(_ns1__InsGrillBySNResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetGrillTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetGrillTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetGrillTime*)p = *(_ns1__GetGrillTime*)q;
		break;
	case SOAP_TYPE__ns1__GetGrillTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetGrillTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetGrillTimeResponse*)p = *(_ns1__GetGrillTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__OutGrillBySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutGrillBySN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutGrillBySN*)p = *(_ns1__OutGrillBySN*)q;
		break;
	case SOAP_TYPE__ns1__OutGrillBySNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OutGrillBySNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OutGrillBySNResponse*)p = *(_ns1__OutGrillBySNResponse*)q;
		break;
	case SOAP_TYPE__ns1__CancelGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelGrillSN*)p = *(_ns1__CancelGrillSN*)q;
		break;
	case SOAP_TYPE__ns1__CancelGrillSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelGrillSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelGrillSNResponse*)p = *(_ns1__CancelGrillSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__CancelLnkSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelLnkSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelLnkSN*)p = *(_ns1__CancelLnkSN*)q;
		break;
	case SOAP_TYPE__ns1__CancelLnkSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelLnkSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelLnkSNResponse*)p = *(_ns1__CancelLnkSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetWeightSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetWeightSet type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetWeightSet*)p = *(_ns1__GetWeightSet*)q;
		break;
	case SOAP_TYPE__ns1__GetWeightSetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetWeightSetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetWeightSetResponse*)p = *(_ns1__GetWeightSetResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPackToWMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPackToWMS type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPackToWMS*)p = *(_ns1__GetPackToWMS*)q;
		break;
	case SOAP_TYPE__ns1__GetPackToWMSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPackToWMSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPackToWMSResponse*)p = *(_ns1__GetPackToWMSResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPallentToWMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPallentToWMS type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPallentToWMS*)p = *(_ns1__GetPallentToWMS*)q;
		break;
	case SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPallentToWMSResponse_GetPallentToWMSResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult*)p = *(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult*)q;
		break;
	case SOAP_TYPE__ns1__GetPallentToWMSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPallentToWMSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPallentToWMSResponse*)p = *(_ns1__GetPallentToWMSResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetPallentForWMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetPallentForWMS type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetPallentForWMS*)p = *(_ns1__SetPallentForWMS*)q;
		break;
	case SOAP_TYPE__ns1__SetPallentForWMSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetPallentForWMSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetPallentForWMSResponse*)p = *(_ns1__SetPallentForWMSResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPackStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPackStation type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPackStation*)p = *(_ns1__GetPackStation*)q;
		break;
	case SOAP_TYPE__ns1__GetPackStationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPackStationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPackStationResponse*)p = *(_ns1__GetPackStationResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPackWeigth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPackWeigth type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPackWeigth*)p = *(_ns1__GetPackWeigth*)q;
		break;
	case SOAP_TYPE__ns1__GetPackWeigthResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPackWeigthResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPackWeigthResponse*)p = *(_ns1__GetPackWeigthResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetAhsMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAhsMo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAhsMo*)p = *(_ns1__GetAhsMo*)q;
		break;
	case SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAhsMoResponse_GetAhsMoResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAhsMoResponse_GetAhsMoResult*)p = *(_ns1__GetAhsMoResponse_GetAhsMoResult*)q;
		break;
	case SOAP_TYPE__ns1__GetAhsMoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAhsMoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAhsMoResponse*)p = *(_ns1__GetAhsMoResponse*)q;
		break;
	case SOAP_TYPE___ns1__GetAhsBarcode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAhsBarcode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAhsBarcode*)p = *(struct __ns1__GetAhsBarcode*)q;
		break;
	case SOAP_TYPE___ns1__UpdAhsBarcode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdAhsBarcode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdAhsBarcode*)p = *(struct __ns1__UpdAhsBarcode*)q;
		break;
	case SOAP_TYPE___ns1__ChkWeightTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkWeightTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkWeightTime*)p = *(struct __ns1__ChkWeightTime*)q;
		break;
	case SOAP_TYPE___ns1__InsSNTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsSNTest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsSNTest*)p = *(struct __ns1__InsSNTest*)q;
		break;
	case SOAP_TYPE___ns1__SelSNTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelSNTest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelSNTest*)p = *(struct __ns1__SelSNTest*)q;
		break;
	case SOAP_TYPE___ns1__DelSNTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DelSNTest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DelSNTest*)p = *(struct __ns1__DelSNTest*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnLinkForApple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnLinkForApple type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnLinkForApple*)p = *(struct __ns1__ChkSnLinkForApple*)q;
		break;
	case SOAP_TYPE___ns1__doSnLinkForApple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doSnLinkForApple type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doSnLinkForApple*)p = *(struct __ns1__doSnLinkForApple*)q;
		break;
	case SOAP_TYPE___ns1__GetObeNW:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetObeNW type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetObeNW*)p = *(struct __ns1__GetObeNW*)q;
		break;
	case SOAP_TYPE___ns1__GetFruitSNCheck:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFruitSNCheck type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFruitSNCheck*)p = *(struct __ns1__GetFruitSNCheck*)q;
		break;
	case SOAP_TYPE___ns1__GetLotLinkCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLotLinkCount type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLotLinkCount*)p = *(struct __ns1__GetLotLinkCount*)q;
		break;
	case SOAP_TYPE___ns1__doLotLinkForApple:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doLotLinkForApple type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doLotLinkForApple*)p = *(struct __ns1__doLotLinkForApple*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingList*)p = *(struct __ns1__GetShippingList*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingBerthList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingBerthList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingBerthList*)p = *(struct __ns1__GetShippingBerthList*)q;
		break;
	case SOAP_TYPE___ns1__UpdShipping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdShipping type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdShipping*)p = *(struct __ns1__UpdShipping*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingPalle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingPalle type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingPalle*)p = *(struct __ns1__GetShippingPalle*)q;
		break;
	case SOAP_TYPE___ns1__InsShippingPalle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsShippingPalle type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsShippingPalle*)p = *(struct __ns1__InsShippingPalle*)q;
		break;
	case SOAP_TYPE___ns1__InsShippingBerth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsShippingBerth type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsShippingBerth*)p = *(struct __ns1__InsShippingBerth*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingForBerth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingForBerth type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingForBerth*)p = *(struct __ns1__GetShippingForBerth*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingWeight:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingWeight type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingWeight*)p = *(struct __ns1__GetShippingWeight*)q;
		break;
	case SOAP_TYPE___ns1__getStationByMoForTestPad:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getStationByMoForTestPad type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getStationByMoForTestPad*)p = *(struct __ns1__getStationByMoForTestPad*)q;
		break;
	case SOAP_TYPE___ns1__SetFlatnessFruitRec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetFlatnessFruitRec type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetFlatnessFruitRec*)p = *(struct __ns1__SetFlatnessFruitRec*)q;
		break;
	case SOAP_TYPE___ns1__GetSNForLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetSNForLink type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetSNForLink*)p = *(struct __ns1__GetSNForLink*)q;
		break;
	case SOAP_TYPE___ns1__SetAutoLineRec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetAutoLineRec type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetAutoLineRec*)p = *(struct __ns1__SetAutoLineRec*)q;
		break;
	case SOAP_TYPE___ns1__HPSNLinkBasket:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__HPSNLinkBasket type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__HPSNLinkBasket*)p = *(struct __ns1__HPSNLinkBasket*)q;
		break;
	case SOAP_TYPE___ns1__BasketLinkPunch:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BasketLinkPunch type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BasketLinkPunch*)p = *(struct __ns1__BasketLinkPunch*)q;
		break;
	case SOAP_TYPE___ns1__PunchOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__PunchOut type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__PunchOut*)p = *(struct __ns1__PunchOut*)q;
		break;
	case SOAP_TYPE___ns1__chkMoSNForAOI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkMoSNForAOI type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkMoSNForAOI*)p = *(struct __ns1__chkMoSNForAOI*)q;
		break;
	case SOAP_TYPE___ns1__InsAoiMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsAoiMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsAoiMo*)p = *(struct __ns1__InsAoiMo*)q;
		break;
	case SOAP_TYPE___ns1__InsCLScada:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsCLScada type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsCLScada*)p = *(struct __ns1__InsCLScada*)q;
		break;
	case SOAP_TYPE___ns1__GetTestValueResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTestValueResult type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTestValueResult*)p = *(struct __ns1__GetTestValueResult*)q;
		break;
	case SOAP_TYPE___ns1__GetStationNumberForSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetStationNumberForSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetStationNumberForSN*)p = *(struct __ns1__GetStationNumberForSN*)q;
		break;
	case SOAP_TYPE___ns1__InsSNTestForFruit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsSNTestForFruit type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsSNTestForFruit*)p = *(struct __ns1__InsSNTestForFruit*)q;
		break;
	case SOAP_TYPE___ns1__SelSNTestForFruit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelSNTestForFruit type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelSNTestForFruit*)p = *(struct __ns1__SelSNTestForFruit*)q;
		break;
	case SOAP_TYPE___ns1__SNLinkShelf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SNLinkShelf type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SNLinkShelf*)p = *(struct __ns1__SNLinkShelf*)q;
		break;
	case SOAP_TYPE___ns1__SelShelfLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelShelfLink type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelShelfLink*)p = *(struct __ns1__SelShelfLink*)q;
		break;
	case SOAP_TYPE___ns1__UploadForHP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UploadForHP type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UploadForHP*)p = *(struct __ns1__UploadForHP*)q;
		break;
	case SOAP_TYPE___ns1__GetMachineForGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMachineForGroup type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMachineForGroup*)p = *(struct __ns1__GetMachineForGroup*)q;
		break;
	case SOAP_TYPE___ns1__SetDiecastSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetDiecastSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetDiecastSN*)p = *(struct __ns1__SetDiecastSN*)q;
		break;
	case SOAP_TYPE___ns1__GetNgCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetNgCode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetNgCode*)p = *(struct __ns1__GetNgCode*)q;
		break;
	case SOAP_TYPE___ns1__getMoBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMoBase type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMoBase*)p = *(struct __ns1__getMoBase*)q;
		break;
	case SOAP_TYPE___ns1__SnLnkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SnLnkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SnLnkOutSN*)p = *(struct __ns1__SnLnkOutSN*)q;
		break;
	case SOAP_TYPE___ns1__InsFruitMachineChk:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFruitMachineChk type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFruitMachineChk*)p = *(struct __ns1__InsFruitMachineChk*)q;
		break;
	case SOAP_TYPE___ns1__GetFruitMachineChk:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFruitMachineChk type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFruitMachineChk*)p = *(struct __ns1__GetFruitMachineChk*)q;
		break;
	case SOAP_TYPE___ns1__InsZjList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsZjList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsZjList*)p = *(struct __ns1__InsZjList*)q;
		break;
	case SOAP_TYPE___ns1__checkTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkTestData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkTestData*)p = *(struct __ns1__checkTestData*)q;
		break;
	case SOAP_TYPE___ns1__checkEmpNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkEmpNo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkEmpNo*)p = *(struct __ns1__checkEmpNo*)q;
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkSN_USCOREStation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkSN_USCOREStation*)p = *(struct __ns1__checkSN_USCOREStation*)q;
		break;
	case SOAP_TYPE___ns1__sendTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendTestData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendTestData*)p = *(struct __ns1__sendTestData*)q;
		break;
	case SOAP_TYPE___ns1__sendTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendTestResult type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendTestResult*)p = *(struct __ns1__sendTestResult*)q;
		break;
	case SOAP_TYPE___ns1__InFruitsOrtQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InFruitsOrtQty type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InFruitsOrtQty*)p = *(struct __ns1__InFruitsOrtQty*)q;
		break;
	case SOAP_TYPE___ns1__chkStationTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkStationTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkStationTime*)p = *(struct __ns1__chkStationTime*)q;
		break;
	case SOAP_TYPE___ns1__ImpMesAteTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ImpMesAteTestData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ImpMesAteTestData*)p = *(struct __ns1__ImpMesAteTestData*)q;
		break;
	case SOAP_TYPE___ns1__InsFlatNess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFlatNess type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFlatNess*)p = *(struct __ns1__InsFlatNess*)q;
		break;
	case SOAP_TYPE___ns1__InsFlatNessForLSD:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFlatNessForLSD type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFlatNessForLSD*)p = *(struct __ns1__InsFlatNessForLSD*)q;
		break;
	case SOAP_TYPE___ns1__InsFlatNessForCL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFlatNessForCL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFlatNessForCL*)p = *(struct __ns1__InsFlatNessForCL*)q;
		break;
	case SOAP_TYPE___ns1__InsWHDetection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsWHDetection type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsWHDetection*)p = *(struct __ns1__InsWHDetection*)q;
		break;
	case SOAP_TYPE___ns1__InsThermal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsThermal type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsThermal*)p = *(struct __ns1__InsThermal*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnLink type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnLink*)p = *(struct __ns1__ChkSnLink*)q;
		break;
	case SOAP_TYPE___ns1__InsThermalNew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsThermalNew type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsThermalNew*)p = *(struct __ns1__InsThermalNew*)q;
		break;
	case SOAP_TYPE___ns1__getInfoByMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getInfoByMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getInfoByMo*)p = *(struct __ns1__getInfoByMo*)q;
		break;
	case SOAP_TYPE___ns1__SetEnergyStat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetEnergyStat type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetEnergyStat*)p = *(struct __ns1__SetEnergyStat*)q;
		break;
	case SOAP_TYPE___ns1__chkMoStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkMoStation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkMoStation*)p = *(struct __ns1__chkMoStation*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnMo*)p = *(struct __ns1__ChkSnMo*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnNextMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnNextMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnNextMo*)p = *(struct __ns1__ChkSnNextMo*)q;
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkSN_USCOREStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkSN_USCOREStationNumber*)p = *(struct __ns1__checkSN_USCOREStationNumber*)q;
		break;
	case SOAP_TYPE___ns1__checkEmpForStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkEmpForStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkEmpForStationNumber*)p = *(struct __ns1__checkEmpForStationNumber*)q;
		break;
	case SOAP_TYPE___ns1__sendDataForStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendDataForStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendDataForStationNumber*)p = *(struct __ns1__sendDataForStationNumber*)q;
		break;
	case SOAP_TYPE___ns1__sendResultForStationNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendResultForStationNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendResultForStationNumber*)p = *(struct __ns1__sendResultForStationNumber*)q;
		break;
	case SOAP_TYPE___ns1__eMesNextMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__eMesNextMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__eMesNextMo*)p = *(struct __ns1__eMesNextMo*)q;
		break;
	case SOAP_TYPE___ns1__SnDoMapping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SnDoMapping type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SnDoMapping*)p = *(struct __ns1__SnDoMapping*)q;
		break;
	case SOAP_TYPE___ns1__getStationByMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getStationByMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getStationByMo*)p = *(struct __ns1__getStationByMo*)q;
		break;
	case SOAP_TYPE___ns1__getStationTypeDesc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getStationTypeDesc type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getStationTypeDesc*)p = *(struct __ns1__getStationTypeDesc*)q;
		break;
	case SOAP_TYPE___ns1__chkSnMapping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkSnMapping type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkSnMapping*)p = *(struct __ns1__chkSnMapping*)q;
		break;
	case SOAP_TYPE___ns1__getMoAssyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMoAssyList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMoAssyList*)p = *(struct __ns1__getMoAssyList*)q;
		break;
	case SOAP_TYPE___ns1__getPartBomExt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPartBomExt type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPartBomExt*)p = *(struct __ns1__getPartBomExt*)q;
		break;
	case SOAP_TYPE___ns1__InsPartAssy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsPartAssy type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsPartAssy*)p = *(struct __ns1__InsPartAssy*)q;
		break;
	case SOAP_TYPE___ns1__GetLinkOutSn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLinkOutSn type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLinkOutSn*)p = *(struct __ns1__GetLinkOutSn*)q;
		break;
	case SOAP_TYPE___ns1__getMoAssyCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMoAssyCount type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMoAssyCount*)p = *(struct __ns1__getMoAssyCount*)q;
		break;
	case SOAP_TYPE___ns1__getPNbySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPNbySN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPNbySN*)p = *(struct __ns1__getPNbySN*)q;
		break;
	case SOAP_TYPE___ns1__chkAssySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkAssySN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkAssySN*)p = *(struct __ns1__chkAssySN*)q;
		break;
	case SOAP_TYPE___ns1__doAssy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doAssy type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doAssy*)p = *(struct __ns1__doAssy*)q;
		break;
	case SOAP_TYPE___ns1__getPmcAssyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPmcAssyList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPmcAssyList*)p = *(struct __ns1__getPmcAssyList*)q;
		break;
	case SOAP_TYPE___ns1__getPmcPartAssyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPmcPartAssyList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPmcPartAssyList*)p = *(struct __ns1__getPmcPartAssyList*)q;
		break;
	case SOAP_TYPE___ns1__GetPmcSNPart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPmcSNPart type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPmcSNPart*)p = *(struct __ns1__GetPmcSNPart*)q;
		break;
	case SOAP_TYPE___ns1__doPmcSNLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doPmcSNLink type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doPmcSNLink*)p = *(struct __ns1__doPmcSNLink*)q;
		break;
	case SOAP_TYPE___ns1__InsZJTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsZJTestData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsZJTestData*)p = *(struct __ns1__InsZJTestData*)q;
		break;
	case SOAP_TYPE___ns1__SNLinkZJ:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SNLinkZJ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SNLinkZJ*)p = *(struct __ns1__SNLinkZJ*)q;
		break;
	case SOAP_TYPE___ns1__GetLintOutQty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLintOutQty type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLintOutQty*)p = *(struct __ns1__GetLintOutQty*)q;
		break;
	case SOAP_TYPE___ns1__chkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkOutSN*)p = *(struct __ns1__chkOutSN*)q;
		break;
	case SOAP_TYPE___ns1__ChkLinkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkLinkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkLinkOutSN*)p = *(struct __ns1__ChkLinkOutSN*)q;
		break;
	case SOAP_TYPE___ns1__doLinkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doLinkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doLinkOutSN*)p = *(struct __ns1__doLinkOutSN*)q;
		break;
	case SOAP_TYPE___ns1__InsLinkSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsLinkSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsLinkSN*)p = *(struct __ns1__InsLinkSN*)q;
		break;
	case SOAP_TYPE___ns1__GetLinkZJCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLinkZJCount type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLinkZJCount*)p = *(struct __ns1__GetLinkZJCount*)q;
		break;
	case SOAP_TYPE___ns1__InsBoxNOTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsBoxNOTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsBoxNOTime*)p = *(struct __ns1__InsBoxNOTime*)q;
		break;
	case SOAP_TYPE___ns1__chkBoxNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkBoxNo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkBoxNo*)p = *(struct __ns1__chkBoxNo*)q;
		break;
	case SOAP_TYPE___ns1__InSNtoBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InSNtoBox type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InSNtoBox*)p = *(struct __ns1__InSNtoBox*)q;
		break;
	case SOAP_TYPE___ns1__EndSNtoBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EndSNtoBox type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EndSNtoBox*)p = *(struct __ns1__EndSNtoBox*)q;
		break;
	case SOAP_TYPE___ns1__InStationbyBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InStationbyBox type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InStationbyBox*)p = *(struct __ns1__InStationbyBox*)q;
		break;
	case SOAP_TYPE___ns1__OutStationbyBox:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutStationbyBox type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutStationbyBox*)p = *(struct __ns1__OutStationbyBox*)q;
		break;
	case SOAP_TYPE___ns1__CancelBoxLnk:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CancelBoxLnk type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CancelBoxLnk*)p = *(struct __ns1__CancelBoxLnk*)q;
		break;
	case SOAP_TYPE___ns1__InsSNStationEmp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsSNStationEmp type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsSNStationEmp*)p = *(struct __ns1__InsSNStationEmp*)q;
		break;
	case SOAP_TYPE___ns1__InsLnkOutSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsLnkOutSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsLnkOutSN*)p = *(struct __ns1__InsLnkOutSN*)q;
		break;
	case SOAP_TYPE___ns1__InsBoxInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsBoxInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsBoxInfo*)p = *(struct __ns1__InsBoxInfo*)q;
		break;
	case SOAP_TYPE___ns1__UpdSnRecInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdSnRecInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdSnRecInfo*)p = *(struct __ns1__UpdSnRecInfo*)q;
		break;
	case SOAP_TYPE___ns1__GetMoBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMoBase type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMoBase*)p = *(struct __ns1__GetMoBase*)q;
		break;
	case SOAP_TYPE___ns1__GetTestValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTestValue type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTestValue*)p = *(struct __ns1__GetTestValue*)q;
		break;
	case SOAP_TYPE___ns1__GetLnkData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLnkData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLnkData*)p = *(struct __ns1__GetLnkData*)q;
		break;
	case SOAP_TYPE___ns1__InsIotMachineRec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsIotMachineRec type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsIotMachineRec*)p = *(struct __ns1__InsIotMachineRec*)q;
		break;
	case SOAP_TYPE___ns1__InsIotTestData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsIotTestData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsIotTestData*)p = *(struct __ns1__InsIotTestData*)q;
		break;
	case SOAP_TYPE___ns1__chkDispensing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkDispensing type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkDispensing*)p = *(struct __ns1__chkDispensing*)q;
		break;
	case SOAP_TYPE___ns1__chkZJSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkZJSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkZJSN*)p = *(struct __ns1__chkZJSN*)q;
		break;
	case SOAP_TYPE___ns1__LnkZJSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LnkZJSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LnkZJSN*)p = *(struct __ns1__LnkZJSN*)q;
		break;
	case SOAP_TYPE___ns1__LnkSideSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LnkSideSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LnkSideSN*)p = *(struct __ns1__LnkSideSN*)q;
		break;
	case SOAP_TYPE___ns1__chkGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkGrillSN*)p = *(struct __ns1__chkGrillSN*)q;
		break;
	case SOAP_TYPE___ns1__LnkGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LnkGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LnkGrillSN*)p = *(struct __ns1__LnkGrillSN*)q;
		break;
	case SOAP_TYPE___ns1__CloseGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseGrillSN*)p = *(struct __ns1__CloseGrillSN*)q;
		break;
	case SOAP_TYPE___ns1__InsGrillBySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsGrillBySN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsGrillBySN*)p = *(struct __ns1__InsGrillBySN*)q;
		break;
	case SOAP_TYPE___ns1__GetGrillTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetGrillTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetGrillTime*)p = *(struct __ns1__GetGrillTime*)q;
		break;
	case SOAP_TYPE___ns1__OutGrillBySN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutGrillBySN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutGrillBySN*)p = *(struct __ns1__OutGrillBySN*)q;
		break;
	case SOAP_TYPE___ns1__CancelGrillSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CancelGrillSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CancelGrillSN*)p = *(struct __ns1__CancelGrillSN*)q;
		break;
	case SOAP_TYPE___ns1__CancelLnkSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CancelLnkSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CancelLnkSN*)p = *(struct __ns1__CancelLnkSN*)q;
		break;
	case SOAP_TYPE___ns1__GetWeightSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetWeightSet type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetWeightSet*)p = *(struct __ns1__GetWeightSet*)q;
		break;
	case SOAP_TYPE___ns1__GetPackToWMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPackToWMS type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPackToWMS*)p = *(struct __ns1__GetPackToWMS*)q;
		break;
	case SOAP_TYPE___ns1__GetPallentToWMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPallentToWMS type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPallentToWMS*)p = *(struct __ns1__GetPallentToWMS*)q;
		break;
	case SOAP_TYPE___ns1__SetPallentForWMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetPallentForWMS type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetPallentForWMS*)p = *(struct __ns1__SetPallentForWMS*)q;
		break;
	case SOAP_TYPE___ns1__GetPackStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPackStation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPackStation*)p = *(struct __ns1__GetPackStation*)q;
		break;
	case SOAP_TYPE___ns1__GetPackWeigth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPackWeigth type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPackWeigth*)p = *(struct __ns1__GetPackWeigth*)q;
		break;
	case SOAP_TYPE___ns1__GetAhsMo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAhsMo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAhsMo*)p = *(struct __ns1__GetAhsMo*)q;
		break;
	case SOAP_TYPE___ns1__GetAhsBarcode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAhsBarcode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAhsBarcode_*)p = *(struct __ns1__GetAhsBarcode_*)q;
		break;
	case SOAP_TYPE___ns1__UpdAhsBarcode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdAhsBarcode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdAhsBarcode_*)p = *(struct __ns1__UpdAhsBarcode_*)q;
		break;
	case SOAP_TYPE___ns1__ChkWeightTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkWeightTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkWeightTime_*)p = *(struct __ns1__ChkWeightTime_*)q;
		break;
	case SOAP_TYPE___ns1__InsSNTest_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsSNTest_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsSNTest_*)p = *(struct __ns1__InsSNTest_*)q;
		break;
	case SOAP_TYPE___ns1__SelSNTest_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelSNTest_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelSNTest_*)p = *(struct __ns1__SelSNTest_*)q;
		break;
	case SOAP_TYPE___ns1__DelSNTest_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DelSNTest_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DelSNTest_*)p = *(struct __ns1__DelSNTest_*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnLinkForApple_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnLinkForApple_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnLinkForApple_*)p = *(struct __ns1__ChkSnLinkForApple_*)q;
		break;
	case SOAP_TYPE___ns1__doSnLinkForApple_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doSnLinkForApple_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doSnLinkForApple_*)p = *(struct __ns1__doSnLinkForApple_*)q;
		break;
	case SOAP_TYPE___ns1__GetObeNW_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetObeNW_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetObeNW_*)p = *(struct __ns1__GetObeNW_*)q;
		break;
	case SOAP_TYPE___ns1__GetFruitSNCheck_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFruitSNCheck_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFruitSNCheck_*)p = *(struct __ns1__GetFruitSNCheck_*)q;
		break;
	case SOAP_TYPE___ns1__GetLotLinkCount_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLotLinkCount_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLotLinkCount_*)p = *(struct __ns1__GetLotLinkCount_*)q;
		break;
	case SOAP_TYPE___ns1__doLotLinkForApple_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doLotLinkForApple_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doLotLinkForApple_*)p = *(struct __ns1__doLotLinkForApple_*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingList_*)p = *(struct __ns1__GetShippingList_*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingBerthList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingBerthList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingBerthList_*)p = *(struct __ns1__GetShippingBerthList_*)q;
		break;
	case SOAP_TYPE___ns1__UpdShipping_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdShipping_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdShipping_*)p = *(struct __ns1__UpdShipping_*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingPalle_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingPalle_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingPalle_*)p = *(struct __ns1__GetShippingPalle_*)q;
		break;
	case SOAP_TYPE___ns1__InsShippingPalle_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsShippingPalle_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsShippingPalle_*)p = *(struct __ns1__InsShippingPalle_*)q;
		break;
	case SOAP_TYPE___ns1__InsShippingBerth_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsShippingBerth_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsShippingBerth_*)p = *(struct __ns1__InsShippingBerth_*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingForBerth_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingForBerth_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingForBerth_*)p = *(struct __ns1__GetShippingForBerth_*)q;
		break;
	case SOAP_TYPE___ns1__GetShippingWeight_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShippingWeight_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShippingWeight_*)p = *(struct __ns1__GetShippingWeight_*)q;
		break;
	case SOAP_TYPE___ns1__getStationByMoForTestPad_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getStationByMoForTestPad_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getStationByMoForTestPad_*)p = *(struct __ns1__getStationByMoForTestPad_*)q;
		break;
	case SOAP_TYPE___ns1__SetFlatnessFruitRec_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetFlatnessFruitRec_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetFlatnessFruitRec_*)p = *(struct __ns1__SetFlatnessFruitRec_*)q;
		break;
	case SOAP_TYPE___ns1__GetSNForLink_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetSNForLink_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetSNForLink_*)p = *(struct __ns1__GetSNForLink_*)q;
		break;
	case SOAP_TYPE___ns1__SetAutoLineRec_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetAutoLineRec_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetAutoLineRec_*)p = *(struct __ns1__SetAutoLineRec_*)q;
		break;
	case SOAP_TYPE___ns1__HPSNLinkBasket_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__HPSNLinkBasket_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__HPSNLinkBasket_*)p = *(struct __ns1__HPSNLinkBasket_*)q;
		break;
	case SOAP_TYPE___ns1__BasketLinkPunch_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BasketLinkPunch_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BasketLinkPunch_*)p = *(struct __ns1__BasketLinkPunch_*)q;
		break;
	case SOAP_TYPE___ns1__PunchOut_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__PunchOut_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__PunchOut_*)p = *(struct __ns1__PunchOut_*)q;
		break;
	case SOAP_TYPE___ns1__chkMoSNForAOI_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkMoSNForAOI_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkMoSNForAOI_*)p = *(struct __ns1__chkMoSNForAOI_*)q;
		break;
	case SOAP_TYPE___ns1__InsAoiMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsAoiMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsAoiMo_*)p = *(struct __ns1__InsAoiMo_*)q;
		break;
	case SOAP_TYPE___ns1__InsCLScada_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsCLScada_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsCLScada_*)p = *(struct __ns1__InsCLScada_*)q;
		break;
	case SOAP_TYPE___ns1__GetTestValueResult_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTestValueResult_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTestValueResult_*)p = *(struct __ns1__GetTestValueResult_*)q;
		break;
	case SOAP_TYPE___ns1__GetStationNumberForSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetStationNumberForSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetStationNumberForSN_*)p = *(struct __ns1__GetStationNumberForSN_*)q;
		break;
	case SOAP_TYPE___ns1__InsSNTestForFruit_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsSNTestForFruit_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsSNTestForFruit_*)p = *(struct __ns1__InsSNTestForFruit_*)q;
		break;
	case SOAP_TYPE___ns1__SelSNTestForFruit_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelSNTestForFruit_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelSNTestForFruit_*)p = *(struct __ns1__SelSNTestForFruit_*)q;
		break;
	case SOAP_TYPE___ns1__SNLinkShelf_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SNLinkShelf_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SNLinkShelf_*)p = *(struct __ns1__SNLinkShelf_*)q;
		break;
	case SOAP_TYPE___ns1__SelShelfLink_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelShelfLink_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelShelfLink_*)p = *(struct __ns1__SelShelfLink_*)q;
		break;
	case SOAP_TYPE___ns1__UploadForHP_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UploadForHP_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UploadForHP_*)p = *(struct __ns1__UploadForHP_*)q;
		break;
	case SOAP_TYPE___ns1__GetMachineForGroup_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMachineForGroup_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMachineForGroup_*)p = *(struct __ns1__GetMachineForGroup_*)q;
		break;
	case SOAP_TYPE___ns1__SetDiecastSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetDiecastSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetDiecastSN_*)p = *(struct __ns1__SetDiecastSN_*)q;
		break;
	case SOAP_TYPE___ns1__GetNgCode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetNgCode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetNgCode_*)p = *(struct __ns1__GetNgCode_*)q;
		break;
	case SOAP_TYPE___ns1__getMoBase_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMoBase_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMoBase_*)p = *(struct __ns1__getMoBase_*)q;
		break;
	case SOAP_TYPE___ns1__SnLnkOutSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SnLnkOutSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SnLnkOutSN_*)p = *(struct __ns1__SnLnkOutSN_*)q;
		break;
	case SOAP_TYPE___ns1__InsFruitMachineChk_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFruitMachineChk_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFruitMachineChk_*)p = *(struct __ns1__InsFruitMachineChk_*)q;
		break;
	case SOAP_TYPE___ns1__GetFruitMachineChk_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFruitMachineChk_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFruitMachineChk_*)p = *(struct __ns1__GetFruitMachineChk_*)q;
		break;
	case SOAP_TYPE___ns1__InsZjList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsZjList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsZjList_*)p = *(struct __ns1__InsZjList_*)q;
		break;
	case SOAP_TYPE___ns1__checkTestData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkTestData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkTestData_*)p = *(struct __ns1__checkTestData_*)q;
		break;
	case SOAP_TYPE___ns1__checkEmpNo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkEmpNo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkEmpNo_*)p = *(struct __ns1__checkEmpNo_*)q;
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStation_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkSN_USCOREStation_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkSN_USCOREStation_*)p = *(struct __ns1__checkSN_USCOREStation_*)q;
		break;
	case SOAP_TYPE___ns1__sendTestData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendTestData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendTestData_*)p = *(struct __ns1__sendTestData_*)q;
		break;
	case SOAP_TYPE___ns1__sendTestResult_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendTestResult_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendTestResult_*)p = *(struct __ns1__sendTestResult_*)q;
		break;
	case SOAP_TYPE___ns1__InFruitsOrtQty_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InFruitsOrtQty_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InFruitsOrtQty_*)p = *(struct __ns1__InFruitsOrtQty_*)q;
		break;
	case SOAP_TYPE___ns1__chkStationTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkStationTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkStationTime_*)p = *(struct __ns1__chkStationTime_*)q;
		break;
	case SOAP_TYPE___ns1__ImpMesAteTestData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ImpMesAteTestData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ImpMesAteTestData_*)p = *(struct __ns1__ImpMesAteTestData_*)q;
		break;
	case SOAP_TYPE___ns1__InsFlatNess_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFlatNess_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFlatNess_*)p = *(struct __ns1__InsFlatNess_*)q;
		break;
	case SOAP_TYPE___ns1__InsFlatNessForLSD_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFlatNessForLSD_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFlatNessForLSD_*)p = *(struct __ns1__InsFlatNessForLSD_*)q;
		break;
	case SOAP_TYPE___ns1__InsFlatNessForCL_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsFlatNessForCL_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsFlatNessForCL_*)p = *(struct __ns1__InsFlatNessForCL_*)q;
		break;
	case SOAP_TYPE___ns1__InsWHDetection_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsWHDetection_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsWHDetection_*)p = *(struct __ns1__InsWHDetection_*)q;
		break;
	case SOAP_TYPE___ns1__InsThermal_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsThermal_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsThermal_*)p = *(struct __ns1__InsThermal_*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnLink_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnLink_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnLink_*)p = *(struct __ns1__ChkSnLink_*)q;
		break;
	case SOAP_TYPE___ns1__InsThermalNew_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsThermalNew_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsThermalNew_*)p = *(struct __ns1__InsThermalNew_*)q;
		break;
	case SOAP_TYPE___ns1__getInfoByMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getInfoByMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getInfoByMo_*)p = *(struct __ns1__getInfoByMo_*)q;
		break;
	case SOAP_TYPE___ns1__SetEnergyStat_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetEnergyStat_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetEnergyStat_*)p = *(struct __ns1__SetEnergyStat_*)q;
		break;
	case SOAP_TYPE___ns1__chkMoStation_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkMoStation_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkMoStation_*)p = *(struct __ns1__chkMoStation_*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnMo_*)p = *(struct __ns1__ChkSnMo_*)q;
		break;
	case SOAP_TYPE___ns1__ChkSnNextMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkSnNextMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkSnNextMo_*)p = *(struct __ns1__ChkSnNextMo_*)q;
		break;
	case SOAP_TYPE___ns1__checkSN_USCOREStationNumber_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkSN_USCOREStationNumber_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkSN_USCOREStationNumber_*)p = *(struct __ns1__checkSN_USCOREStationNumber_*)q;
		break;
	case SOAP_TYPE___ns1__checkEmpForStationNumber_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkEmpForStationNumber_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkEmpForStationNumber_*)p = *(struct __ns1__checkEmpForStationNumber_*)q;
		break;
	case SOAP_TYPE___ns1__sendDataForStationNumber_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendDataForStationNumber_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendDataForStationNumber_*)p = *(struct __ns1__sendDataForStationNumber_*)q;
		break;
	case SOAP_TYPE___ns1__sendResultForStationNumber_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__sendResultForStationNumber_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__sendResultForStationNumber_*)p = *(struct __ns1__sendResultForStationNumber_*)q;
		break;
	case SOAP_TYPE___ns1__eMesNextMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__eMesNextMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__eMesNextMo_*)p = *(struct __ns1__eMesNextMo_*)q;
		break;
	case SOAP_TYPE___ns1__SnDoMapping_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SnDoMapping_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SnDoMapping_*)p = *(struct __ns1__SnDoMapping_*)q;
		break;
	case SOAP_TYPE___ns1__getStationByMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getStationByMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getStationByMo_*)p = *(struct __ns1__getStationByMo_*)q;
		break;
	case SOAP_TYPE___ns1__getStationTypeDesc_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getStationTypeDesc_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getStationTypeDesc_*)p = *(struct __ns1__getStationTypeDesc_*)q;
		break;
	case SOAP_TYPE___ns1__chkSnMapping_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkSnMapping_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkSnMapping_*)p = *(struct __ns1__chkSnMapping_*)q;
		break;
	case SOAP_TYPE___ns1__getMoAssyList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMoAssyList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMoAssyList_*)p = *(struct __ns1__getMoAssyList_*)q;
		break;
	case SOAP_TYPE___ns1__getPartBomExt_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPartBomExt_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPartBomExt_*)p = *(struct __ns1__getPartBomExt_*)q;
		break;
	case SOAP_TYPE___ns1__InsPartAssy_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsPartAssy_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsPartAssy_*)p = *(struct __ns1__InsPartAssy_*)q;
		break;
	case SOAP_TYPE___ns1__GetLinkOutSn_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLinkOutSn_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLinkOutSn_*)p = *(struct __ns1__GetLinkOutSn_*)q;
		break;
	case SOAP_TYPE___ns1__getMoAssyCount_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMoAssyCount_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMoAssyCount_*)p = *(struct __ns1__getMoAssyCount_*)q;
		break;
	case SOAP_TYPE___ns1__getPNbySN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPNbySN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPNbySN_*)p = *(struct __ns1__getPNbySN_*)q;
		break;
	case SOAP_TYPE___ns1__chkAssySN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkAssySN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkAssySN_*)p = *(struct __ns1__chkAssySN_*)q;
		break;
	case SOAP_TYPE___ns1__doAssy_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doAssy_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doAssy_*)p = *(struct __ns1__doAssy_*)q;
		break;
	case SOAP_TYPE___ns1__getPmcAssyList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPmcAssyList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPmcAssyList_*)p = *(struct __ns1__getPmcAssyList_*)q;
		break;
	case SOAP_TYPE___ns1__getPmcPartAssyList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPmcPartAssyList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPmcPartAssyList_*)p = *(struct __ns1__getPmcPartAssyList_*)q;
		break;
	case SOAP_TYPE___ns1__GetPmcSNPart_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPmcSNPart_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPmcSNPart_*)p = *(struct __ns1__GetPmcSNPart_*)q;
		break;
	case SOAP_TYPE___ns1__doPmcSNLink_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doPmcSNLink_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doPmcSNLink_*)p = *(struct __ns1__doPmcSNLink_*)q;
		break;
	case SOAP_TYPE___ns1__InsZJTestData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsZJTestData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsZJTestData_*)p = *(struct __ns1__InsZJTestData_*)q;
		break;
	case SOAP_TYPE___ns1__SNLinkZJ_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SNLinkZJ_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SNLinkZJ_*)p = *(struct __ns1__SNLinkZJ_*)q;
		break;
	case SOAP_TYPE___ns1__GetLintOutQty_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLintOutQty_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLintOutQty_*)p = *(struct __ns1__GetLintOutQty_*)q;
		break;
	case SOAP_TYPE___ns1__chkOutSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkOutSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkOutSN_*)p = *(struct __ns1__chkOutSN_*)q;
		break;
	case SOAP_TYPE___ns1__ChkLinkOutSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChkLinkOutSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChkLinkOutSN_*)p = *(struct __ns1__ChkLinkOutSN_*)q;
		break;
	case SOAP_TYPE___ns1__doLinkOutSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__doLinkOutSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__doLinkOutSN_*)p = *(struct __ns1__doLinkOutSN_*)q;
		break;
	case SOAP_TYPE___ns1__InsLinkSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsLinkSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsLinkSN_*)p = *(struct __ns1__InsLinkSN_*)q;
		break;
	case SOAP_TYPE___ns1__GetLinkZJCount_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLinkZJCount_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLinkZJCount_*)p = *(struct __ns1__GetLinkZJCount_*)q;
		break;
	case SOAP_TYPE___ns1__InsBoxNOTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsBoxNOTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsBoxNOTime_*)p = *(struct __ns1__InsBoxNOTime_*)q;
		break;
	case SOAP_TYPE___ns1__chkBoxNo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkBoxNo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkBoxNo_*)p = *(struct __ns1__chkBoxNo_*)q;
		break;
	case SOAP_TYPE___ns1__InSNtoBox_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InSNtoBox_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InSNtoBox_*)p = *(struct __ns1__InSNtoBox_*)q;
		break;
	case SOAP_TYPE___ns1__EndSNtoBox_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EndSNtoBox_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EndSNtoBox_*)p = *(struct __ns1__EndSNtoBox_*)q;
		break;
	case SOAP_TYPE___ns1__InStationbyBox_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InStationbyBox_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InStationbyBox_*)p = *(struct __ns1__InStationbyBox_*)q;
		break;
	case SOAP_TYPE___ns1__OutStationbyBox_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutStationbyBox_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutStationbyBox_*)p = *(struct __ns1__OutStationbyBox_*)q;
		break;
	case SOAP_TYPE___ns1__CancelBoxLnk_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CancelBoxLnk_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CancelBoxLnk_*)p = *(struct __ns1__CancelBoxLnk_*)q;
		break;
	case SOAP_TYPE___ns1__InsSNStationEmp_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsSNStationEmp_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsSNStationEmp_*)p = *(struct __ns1__InsSNStationEmp_*)q;
		break;
	case SOAP_TYPE___ns1__InsLnkOutSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsLnkOutSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsLnkOutSN_*)p = *(struct __ns1__InsLnkOutSN_*)q;
		break;
	case SOAP_TYPE___ns1__InsBoxInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsBoxInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsBoxInfo_*)p = *(struct __ns1__InsBoxInfo_*)q;
		break;
	case SOAP_TYPE___ns1__UpdSnRecInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdSnRecInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdSnRecInfo_*)p = *(struct __ns1__UpdSnRecInfo_*)q;
		break;
	case SOAP_TYPE___ns1__GetMoBase_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMoBase_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMoBase_*)p = *(struct __ns1__GetMoBase_*)q;
		break;
	case SOAP_TYPE___ns1__GetTestValue_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTestValue_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTestValue_*)p = *(struct __ns1__GetTestValue_*)q;
		break;
	case SOAP_TYPE___ns1__GetLnkData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLnkData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLnkData_*)p = *(struct __ns1__GetLnkData_*)q;
		break;
	case SOAP_TYPE___ns1__InsIotMachineRec_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsIotMachineRec_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsIotMachineRec_*)p = *(struct __ns1__InsIotMachineRec_*)q;
		break;
	case SOAP_TYPE___ns1__InsIotTestData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsIotTestData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsIotTestData_*)p = *(struct __ns1__InsIotTestData_*)q;
		break;
	case SOAP_TYPE___ns1__chkDispensing_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkDispensing_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkDispensing_*)p = *(struct __ns1__chkDispensing_*)q;
		break;
	case SOAP_TYPE___ns1__chkZJSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkZJSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkZJSN_*)p = *(struct __ns1__chkZJSN_*)q;
		break;
	case SOAP_TYPE___ns1__LnkZJSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LnkZJSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LnkZJSN_*)p = *(struct __ns1__LnkZJSN_*)q;
		break;
	case SOAP_TYPE___ns1__LnkSideSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LnkSideSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LnkSideSN_*)p = *(struct __ns1__LnkSideSN_*)q;
		break;
	case SOAP_TYPE___ns1__chkGrillSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__chkGrillSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__chkGrillSN_*)p = *(struct __ns1__chkGrillSN_*)q;
		break;
	case SOAP_TYPE___ns1__LnkGrillSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LnkGrillSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LnkGrillSN_*)p = *(struct __ns1__LnkGrillSN_*)q;
		break;
	case SOAP_TYPE___ns1__CloseGrillSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseGrillSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseGrillSN_*)p = *(struct __ns1__CloseGrillSN_*)q;
		break;
	case SOAP_TYPE___ns1__InsGrillBySN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsGrillBySN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsGrillBySN_*)p = *(struct __ns1__InsGrillBySN_*)q;
		break;
	case SOAP_TYPE___ns1__GetGrillTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetGrillTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetGrillTime_*)p = *(struct __ns1__GetGrillTime_*)q;
		break;
	case SOAP_TYPE___ns1__OutGrillBySN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OutGrillBySN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OutGrillBySN_*)p = *(struct __ns1__OutGrillBySN_*)q;
		break;
	case SOAP_TYPE___ns1__CancelGrillSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CancelGrillSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CancelGrillSN_*)p = *(struct __ns1__CancelGrillSN_*)q;
		break;
	case SOAP_TYPE___ns1__CancelLnkSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CancelLnkSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CancelLnkSN_*)p = *(struct __ns1__CancelLnkSN_*)q;
		break;
	case SOAP_TYPE___ns1__GetWeightSet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetWeightSet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetWeightSet_*)p = *(struct __ns1__GetWeightSet_*)q;
		break;
	case SOAP_TYPE___ns1__GetPackToWMS_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPackToWMS_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPackToWMS_*)p = *(struct __ns1__GetPackToWMS_*)q;
		break;
	case SOAP_TYPE___ns1__GetPallentToWMS_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPallentToWMS_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPallentToWMS_*)p = *(struct __ns1__GetPallentToWMS_*)q;
		break;
	case SOAP_TYPE___ns1__SetPallentForWMS_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetPallentForWMS_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetPallentForWMS_*)p = *(struct __ns1__SetPallentForWMS_*)q;
		break;
	case SOAP_TYPE___ns1__GetPackStation_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPackStation_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPackStation_*)p = *(struct __ns1__GetPackStation_*)q;
		break;
	case SOAP_TYPE___ns1__GetPackWeigth_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPackWeigth_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPackWeigth_*)p = *(struct __ns1__GetPackWeigth_*)q;
		break;
	case SOAP_TYPE___ns1__GetAhsMo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAhsMo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAhsMo_*)p = *(struct __ns1__GetAhsMo_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAhsMoResponse_GetAhsMoResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetAhsMoResponse_GetAhsMoResult::xsd__schema = NULL;
	this->_ns1__GetAhsMoResponse_GetAhsMoResult::__any = NULL;
}

void _ns1__GetAhsMoResponse_GetAhsMoResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetAhsMoResponse_GetAhsMoResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, const char *tag, int id, const _ns1__GetAhsMoResponse_GetAhsMoResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult), type))
		return soap->error;
	if (!a->_ns1__GetAhsMoResponse_GetAhsMoResult::xsd__schema)
	{	if (soap_element_empty(soap, "xsd:schema"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "xsd:schema", (char*const*)&a->_ns1__GetAhsMoResponse_GetAhsMoResult::xsd__schema, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetAhsMoResponse_GetAhsMoResult::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAhsMoResponse_GetAhsMoResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAhsMoResponse_GetAhsMoResult * SOAP_FMAC4 soap_in__ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, const char *tag, _ns1__GetAhsMoResponse_GetAhsMoResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAhsMoResponse_GetAhsMoResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult, sizeof(_ns1__GetAhsMoResponse_GetAhsMoResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAhsMoResponse_GetAhsMoResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xsd__schema1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "xsd:schema", (char**)&a->_ns1__GetAhsMoResponse_GetAhsMoResult::xsd__schema))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetAhsMoResponse_GetAhsMoResult::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetAhsMoResponse_GetAhsMoResult::xsd__schema))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetAhsMoResponse_GetAhsMoResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult, sizeof(_ns1__GetAhsMoResponse_GetAhsMoResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAhsMoResponse_GetAhsMoResult * SOAP_FMAC2 soap_instantiate__ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAhsMoResponse_GetAhsMoResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAhsMoResponse_GetAhsMoResult *p;
	size_t k = sizeof(_ns1__GetAhsMoResponse_GetAhsMoResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAhsMoResponse_GetAhsMoResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAhsMoResponse_GetAhsMoResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAhsMoResponse_GetAhsMoResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAhsMoResponse_GetAhsMoResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag ? tag : "ns1:GetAhsMoResponse-GetAhsMoResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAhsMoResponse_GetAhsMoResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAhsMoResponse_GetAhsMoResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAhsMoResponse_GetAhsMoResult * SOAP_FMAC4 soap_get__ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, _ns1__GetAhsMoResponse_GetAhsMoResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPallentToWMSResponse_GetPallentToWMSResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any);
	this->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any_ = NULL;
}

void _ns1__GetPallentToWMSResponse_GetPallentToWMSResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any);
#endif
}

int _ns1__GetPallentToWMSResponse_GetPallentToWMSResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, const char *tag, int id, const _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPallentToWMSResponse_GetPallentToWMSResult * SOAP_FMAC4 soap_in__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, const char *tag, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult, sizeof(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult, sizeof(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPallentToWMSResponse_GetPallentToWMSResult * SOAP_FMAC2 soap_instantiate__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *p;
	size_t k = sizeof(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPallentToWMSResponse_GetPallentToWMSResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPallentToWMSResponse_GetPallentToWMSResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag ? tag : "ns1:GetPallentToWMSResponse-GetPallentToWMSResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPallentToWMSResponse_GetPallentToWMSResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPallentToWMSResponse_GetPallentToWMSResult * SOAP_FMAC4 soap_get__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doLinkOutSN_assyDt::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__doLinkOutSN_assyDt::__any);
	this->_ns1__doLinkOutSN_assyDt::__any_ = NULL;
}

void _ns1__doLinkOutSN_assyDt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__doLinkOutSN_assyDt::__any);
#endif
}

int _ns1__doLinkOutSN_assyDt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doLinkOutSN_assyDt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doLinkOutSN_assyDt(struct soap *soap, const char *tag, int id, const _ns1__doLinkOutSN_assyDt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doLinkOutSN_assyDt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__doLinkOutSN_assyDt::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__doLinkOutSN_assyDt::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doLinkOutSN_assyDt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doLinkOutSN_assyDt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doLinkOutSN_assyDt * SOAP_FMAC4 soap_in__ns1__doLinkOutSN_assyDt(struct soap *soap, const char *tag, _ns1__doLinkOutSN_assyDt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doLinkOutSN_assyDt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doLinkOutSN_assyDt, sizeof(_ns1__doLinkOutSN_assyDt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doLinkOutSN_assyDt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doLinkOutSN_assyDt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__doLinkOutSN_assyDt::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__doLinkOutSN_assyDt::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doLinkOutSN_assyDt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doLinkOutSN_assyDt, SOAP_TYPE__ns1__doLinkOutSN_assyDt, sizeof(_ns1__doLinkOutSN_assyDt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doLinkOutSN_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doLinkOutSN_assyDt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doLinkOutSN_assyDt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doLinkOutSN_assyDt *p;
	size_t k = sizeof(_ns1__doLinkOutSN_assyDt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doLinkOutSN_assyDt);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doLinkOutSN_assyDt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doLinkOutSN_assyDt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doLinkOutSN_assyDt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doLinkOutSN_assyDt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doLinkOutSN_assyDt(soap, tag ? tag : "ns1:doLinkOutSN-assyDt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doLinkOutSN_assyDt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doLinkOutSN_assyDt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doLinkOutSN_assyDt * SOAP_FMAC4 soap_get__ns1__doLinkOutSN_assyDt(struct soap *soap, _ns1__doLinkOutSN_assyDt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doLinkOutSN_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doPmcSNLink_assyDt::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__doPmcSNLink_assyDt::__any);
	this->_ns1__doPmcSNLink_assyDt::__any_ = NULL;
}

void _ns1__doPmcSNLink_assyDt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__doPmcSNLink_assyDt::__any);
#endif
}

int _ns1__doPmcSNLink_assyDt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doPmcSNLink_assyDt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doPmcSNLink_assyDt(struct soap *soap, const char *tag, int id, const _ns1__doPmcSNLink_assyDt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doPmcSNLink_assyDt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__doPmcSNLink_assyDt::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__doPmcSNLink_assyDt::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doPmcSNLink_assyDt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doPmcSNLink_assyDt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doPmcSNLink_assyDt * SOAP_FMAC4 soap_in__ns1__doPmcSNLink_assyDt(struct soap *soap, const char *tag, _ns1__doPmcSNLink_assyDt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doPmcSNLink_assyDt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doPmcSNLink_assyDt, sizeof(_ns1__doPmcSNLink_assyDt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doPmcSNLink_assyDt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doPmcSNLink_assyDt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__doPmcSNLink_assyDt::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__doPmcSNLink_assyDt::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doPmcSNLink_assyDt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doPmcSNLink_assyDt, SOAP_TYPE__ns1__doPmcSNLink_assyDt, sizeof(_ns1__doPmcSNLink_assyDt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doPmcSNLink_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doPmcSNLink_assyDt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doPmcSNLink_assyDt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doPmcSNLink_assyDt *p;
	size_t k = sizeof(_ns1__doPmcSNLink_assyDt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doPmcSNLink_assyDt);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doPmcSNLink_assyDt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doPmcSNLink_assyDt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doPmcSNLink_assyDt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doPmcSNLink_assyDt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doPmcSNLink_assyDt(soap, tag ? tag : "ns1:doPmcSNLink-assyDt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doPmcSNLink_assyDt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doPmcSNLink_assyDt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doPmcSNLink_assyDt * SOAP_FMAC4 soap_get__ns1__doPmcSNLink_assyDt(struct soap *soap, _ns1__doPmcSNLink_assyDt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doPmcSNLink_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any);
	this->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any_ = NULL;
}

void _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any);
#endif
}

int _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, const char *tag, int id, const _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult * SOAP_FMAC4 soap_in__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, const char *tag, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, sizeof(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, sizeof(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult * SOAP_FMAC2 soap_instantiate__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *p;
	size_t k = sizeof(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag ? tag : "ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult * SOAP_FMAC4 soap_get__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPmcAssyListResponse_getPmcAssyListResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any);
	this->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any_ = NULL;
}

void _ns1__getPmcAssyListResponse_getPmcAssyListResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any);
#endif
}

int _ns1__getPmcAssyListResponse_getPmcAssyListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, const char *tag, int id, const _ns1__getPmcAssyListResponse_getPmcAssyListResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPmcAssyListResponse_getPmcAssyListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPmcAssyListResponse_getPmcAssyListResult * SOAP_FMAC4 soap_in__ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, const char *tag, _ns1__getPmcAssyListResponse_getPmcAssyListResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPmcAssyListResponse_getPmcAssyListResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult, sizeof(_ns1__getPmcAssyListResponse_getPmcAssyListResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPmcAssyListResponse_getPmcAssyListResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__getPmcAssyListResponse_getPmcAssyListResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPmcAssyListResponse_getPmcAssyListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult, sizeof(_ns1__getPmcAssyListResponse_getPmcAssyListResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPmcAssyListResponse_getPmcAssyListResult * SOAP_FMAC2 soap_instantiate__ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPmcAssyListResponse_getPmcAssyListResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPmcAssyListResponse_getPmcAssyListResult *p;
	size_t k = sizeof(_ns1__getPmcAssyListResponse_getPmcAssyListResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPmcAssyListResponse_getPmcAssyListResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPmcAssyListResponse_getPmcAssyListResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPmcAssyListResponse_getPmcAssyListResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPmcAssyListResponse_getPmcAssyListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag ? tag : "ns1:getPmcAssyListResponse-getPmcAssyListResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPmcAssyListResponse_getPmcAssyListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPmcAssyListResponse_getPmcAssyListResult * SOAP_FMAC4 soap_get__ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, _ns1__getPmcAssyListResponse_getPmcAssyListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doAssy_assyDt::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__doAssy_assyDt::__any);
	this->_ns1__doAssy_assyDt::__any_ = NULL;
}

void _ns1__doAssy_assyDt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__doAssy_assyDt::__any);
#endif
}

int _ns1__doAssy_assyDt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doAssy_assyDt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doAssy_assyDt(struct soap *soap, const char *tag, int id, const _ns1__doAssy_assyDt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doAssy_assyDt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__doAssy_assyDt::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__doAssy_assyDt::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doAssy_assyDt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doAssy_assyDt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doAssy_assyDt * SOAP_FMAC4 soap_in__ns1__doAssy_assyDt(struct soap *soap, const char *tag, _ns1__doAssy_assyDt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doAssy_assyDt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doAssy_assyDt, sizeof(_ns1__doAssy_assyDt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doAssy_assyDt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doAssy_assyDt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__doAssy_assyDt::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__doAssy_assyDt::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doAssy_assyDt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doAssy_assyDt, SOAP_TYPE__ns1__doAssy_assyDt, sizeof(_ns1__doAssy_assyDt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doAssy_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doAssy_assyDt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doAssy_assyDt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doAssy_assyDt *p;
	size_t k = sizeof(_ns1__doAssy_assyDt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doAssy_assyDt);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doAssy_assyDt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doAssy_assyDt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doAssy_assyDt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doAssy_assyDt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doAssy_assyDt(soap, tag ? tag : "ns1:doAssy-assyDt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doAssy_assyDt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doAssy_assyDt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doAssy_assyDt * SOAP_FMAC4 soap_get__ns1__doAssy_assyDt(struct soap *soap, _ns1__doAssy_assyDt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doAssy_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLinkOutSnResponse_GetLinkOutSnResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any);
	this->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any_ = NULL;
}

void _ns1__GetLinkOutSnResponse_GetLinkOutSnResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any);
#endif
}

int _ns1__GetLinkOutSnResponse_GetLinkOutSnResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, const char *tag, int id, const _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLinkOutSnResponse_GetLinkOutSnResult * SOAP_FMAC4 soap_in__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, const char *tag, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult, sizeof(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult, sizeof(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLinkOutSnResponse_GetLinkOutSnResult * SOAP_FMAC2 soap_instantiate__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *p;
	size_t k = sizeof(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLinkOutSnResponse_GetLinkOutSnResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLinkOutSnResponse_GetLinkOutSnResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag ? tag : "ns1:GetLinkOutSnResponse-GetLinkOutSnResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLinkOutSnResponse_GetLinkOutSnResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLinkOutSnResponse_GetLinkOutSnResult * SOAP_FMAC4 soap_get__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPartBomExtResponse_getPartBomExtResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__getPartBomExtResponse_getPartBomExtResult::__any);
	this->_ns1__getPartBomExtResponse_getPartBomExtResult::__any_ = NULL;
}

void _ns1__getPartBomExtResponse_getPartBomExtResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__getPartBomExtResponse_getPartBomExtResult::__any);
#endif
}

int _ns1__getPartBomExtResponse_getPartBomExtResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, const char *tag, int id, const _ns1__getPartBomExtResponse_getPartBomExtResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__getPartBomExtResponse_getPartBomExtResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__getPartBomExtResponse_getPartBomExtResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPartBomExtResponse_getPartBomExtResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPartBomExtResponse_getPartBomExtResult * SOAP_FMAC4 soap_in__ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, const char *tag, _ns1__getPartBomExtResponse_getPartBomExtResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPartBomExtResponse_getPartBomExtResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult, sizeof(_ns1__getPartBomExtResponse_getPartBomExtResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPartBomExtResponse_getPartBomExtResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__getPartBomExtResponse_getPartBomExtResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__getPartBomExtResponse_getPartBomExtResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPartBomExtResponse_getPartBomExtResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult, sizeof(_ns1__getPartBomExtResponse_getPartBomExtResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPartBomExtResponse_getPartBomExtResult * SOAP_FMAC2 soap_instantiate__ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPartBomExtResponse_getPartBomExtResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPartBomExtResponse_getPartBomExtResult *p;
	size_t k = sizeof(_ns1__getPartBomExtResponse_getPartBomExtResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPartBomExtResponse_getPartBomExtResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPartBomExtResponse_getPartBomExtResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPartBomExtResponse_getPartBomExtResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPartBomExtResponse_getPartBomExtResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag ? tag : "ns1:getPartBomExtResponse-getPartBomExtResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPartBomExtResponse_getPartBomExtResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPartBomExtResponse_getPartBomExtResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPartBomExtResponse_getPartBomExtResult * SOAP_FMAC4 soap_get__ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, _ns1__getPartBomExtResponse_getPartBomExtResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoAssyListResponse_getMoAssyListResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__getMoAssyListResponse_getMoAssyListResult::__any);
	this->_ns1__getMoAssyListResponse_getMoAssyListResult::__any_ = NULL;
}

void _ns1__getMoAssyListResponse_getMoAssyListResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__getMoAssyListResponse_getMoAssyListResult::__any);
#endif
}

int _ns1__getMoAssyListResponse_getMoAssyListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, const char *tag, int id, const _ns1__getMoAssyListResponse_getMoAssyListResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__getMoAssyListResponse_getMoAssyListResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__getMoAssyListResponse_getMoAssyListResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoAssyListResponse_getMoAssyListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoAssyListResponse_getMoAssyListResult * SOAP_FMAC4 soap_in__ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, const char *tag, _ns1__getMoAssyListResponse_getMoAssyListResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoAssyListResponse_getMoAssyListResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult, sizeof(_ns1__getMoAssyListResponse_getMoAssyListResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoAssyListResponse_getMoAssyListResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__getMoAssyListResponse_getMoAssyListResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__getMoAssyListResponse_getMoAssyListResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoAssyListResponse_getMoAssyListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult, sizeof(_ns1__getMoAssyListResponse_getMoAssyListResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoAssyListResponse_getMoAssyListResult * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoAssyListResponse_getMoAssyListResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoAssyListResponse_getMoAssyListResult *p;
	size_t k = sizeof(_ns1__getMoAssyListResponse_getMoAssyListResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoAssyListResponse_getMoAssyListResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoAssyListResponse_getMoAssyListResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoAssyListResponse_getMoAssyListResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoAssyListResponse_getMoAssyListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag ? tag : "ns1:getMoAssyListResponse-getMoAssyListResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoAssyListResponse_getMoAssyListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoAssyListResponse_getMoAssyListResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoAssyListResponse_getMoAssyListResult * SOAP_FMAC4 soap_get__ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, _ns1__getMoAssyListResponse_getMoAssyListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getInfoByMoResponse_getInfoByMoResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__getInfoByMoResponse_getInfoByMoResult::__any);
	this->_ns1__getInfoByMoResponse_getInfoByMoResult::__any_ = NULL;
}

void _ns1__getInfoByMoResponse_getInfoByMoResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__getInfoByMoResponse_getInfoByMoResult::__any);
#endif
}

int _ns1__getInfoByMoResponse_getInfoByMoResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, const char *tag, int id, const _ns1__getInfoByMoResponse_getInfoByMoResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__getInfoByMoResponse_getInfoByMoResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__getInfoByMoResponse_getInfoByMoResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getInfoByMoResponse_getInfoByMoResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getInfoByMoResponse_getInfoByMoResult * SOAP_FMAC4 soap_in__ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, const char *tag, _ns1__getInfoByMoResponse_getInfoByMoResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getInfoByMoResponse_getInfoByMoResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult, sizeof(_ns1__getInfoByMoResponse_getInfoByMoResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getInfoByMoResponse_getInfoByMoResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__getInfoByMoResponse_getInfoByMoResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__getInfoByMoResponse_getInfoByMoResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getInfoByMoResponse_getInfoByMoResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult, sizeof(_ns1__getInfoByMoResponse_getInfoByMoResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getInfoByMoResponse_getInfoByMoResult * SOAP_FMAC2 soap_instantiate__ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getInfoByMoResponse_getInfoByMoResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getInfoByMoResponse_getInfoByMoResult *p;
	size_t k = sizeof(_ns1__getInfoByMoResponse_getInfoByMoResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getInfoByMoResponse_getInfoByMoResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getInfoByMoResponse_getInfoByMoResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getInfoByMoResponse_getInfoByMoResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getInfoByMoResponse_getInfoByMoResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag ? tag : "ns1:getInfoByMoResponse-getInfoByMoResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getInfoByMoResponse_getInfoByMoResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getInfoByMoResponse_getInfoByMoResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getInfoByMoResponse_getInfoByMoResult * SOAP_FMAC4 soap_get__ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, _ns1__getInfoByMoResponse_getInfoByMoResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMachineForGroupResponse_GetMachineForGroupResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::xsd__schema = NULL;
	this->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::__any = NULL;
}

void _ns1__GetMachineForGroupResponse_GetMachineForGroupResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetMachineForGroupResponse_GetMachineForGroupResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, const char *tag, int id, const _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult), type))
		return soap->error;
	if (!a->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::xsd__schema)
	{	if (soap_element_empty(soap, "xsd:schema"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "xsd:schema", (char*const*)&a->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::xsd__schema, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMachineForGroupResponse_GetMachineForGroupResult * SOAP_FMAC4 soap_in__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, const char *tag, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult, sizeof(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xsd__schema1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "xsd:schema", (char**)&a->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::xsd__schema))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::xsd__schema))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult, sizeof(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMachineForGroupResponse_GetMachineForGroupResult * SOAP_FMAC2 soap_instantiate__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *p;
	size_t k = sizeof(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMachineForGroupResponse_GetMachineForGroupResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetMachineForGroupResponse_GetMachineForGroupResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag ? tag : "ns1:GetMachineForGroupResponse-GetMachineForGroupResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMachineForGroupResponse_GetMachineForGroupResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMachineForGroupResponse_GetMachineForGroupResult * SOAP_FMAC4 soap_get__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetFlatnessFruitRec_dt::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__SetFlatnessFruitRec_dt::__any);
	this->_ns1__SetFlatnessFruitRec_dt::__any_ = NULL;
}

void _ns1__SetFlatnessFruitRec_dt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__SetFlatnessFruitRec_dt::__any);
#endif
}

int _ns1__SetFlatnessFruitRec_dt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetFlatnessFruitRec_dt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetFlatnessFruitRec_dt(struct soap *soap, const char *tag, int id, const _ns1__SetFlatnessFruitRec_dt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__SetFlatnessFruitRec_dt::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__SetFlatnessFruitRec_dt::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetFlatnessFruitRec_dt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetFlatnessFruitRec_dt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec_dt * SOAP_FMAC4 soap_in__ns1__SetFlatnessFruitRec_dt(struct soap *soap, const char *tag, _ns1__SetFlatnessFruitRec_dt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetFlatnessFruitRec_dt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt, sizeof(_ns1__SetFlatnessFruitRec_dt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetFlatnessFruitRec_dt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetFlatnessFruitRec_dt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__SetFlatnessFruitRec_dt::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__SetFlatnessFruitRec_dt::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetFlatnessFruitRec_dt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt, sizeof(_ns1__SetFlatnessFruitRec_dt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetFlatnessFruitRec_dt * SOAP_FMAC2 soap_instantiate__ns1__SetFlatnessFruitRec_dt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetFlatnessFruitRec_dt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetFlatnessFruitRec_dt *p;
	size_t k = sizeof(_ns1__SetFlatnessFruitRec_dt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetFlatnessFruitRec_dt);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetFlatnessFruitRec_dt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetFlatnessFruitRec_dt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetFlatnessFruitRec_dt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetFlatnessFruitRec_dt(soap, tag ? tag : "ns1:SetFlatnessFruitRec-dt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetFlatnessFruitRec_dt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetFlatnessFruitRec_dt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec_dt * SOAP_FMAC4 soap_get__ns1__SetFlatnessFruitRec_dt(struct soap *soap, _ns1__SetFlatnessFruitRec_dt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetFlatnessFruitRec_dt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingWeightResponse_GetShippingWeightResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any);
	this->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any_ = NULL;
}

void _ns1__GetShippingWeightResponse_GetShippingWeightResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any);
#endif
}

int _ns1__GetShippingWeightResponse_GetShippingWeightResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, const char *tag, int id, const _ns1__GetShippingWeightResponse_GetShippingWeightResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingWeightResponse_GetShippingWeightResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingWeightResponse_GetShippingWeightResult * SOAP_FMAC4 soap_in__ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, const char *tag, _ns1__GetShippingWeightResponse_GetShippingWeightResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingWeightResponse_GetShippingWeightResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult, sizeof(_ns1__GetShippingWeightResponse_GetShippingWeightResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingWeightResponse_GetShippingWeightResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetShippingWeightResponse_GetShippingWeightResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingWeightResponse_GetShippingWeightResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult, sizeof(_ns1__GetShippingWeightResponse_GetShippingWeightResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingWeightResponse_GetShippingWeightResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingWeightResponse_GetShippingWeightResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingWeightResponse_GetShippingWeightResult *p;
	size_t k = sizeof(_ns1__GetShippingWeightResponse_GetShippingWeightResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingWeightResponse_GetShippingWeightResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingWeightResponse_GetShippingWeightResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingWeightResponse_GetShippingWeightResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingWeightResponse_GetShippingWeightResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag ? tag : "ns1:GetShippingWeightResponse-GetShippingWeightResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingWeightResponse_GetShippingWeightResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingWeightResponse_GetShippingWeightResult * SOAP_FMAC4 soap_get__ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, _ns1__GetShippingWeightResponse_GetShippingWeightResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingForBerthResponse_GetShippingForBerthResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any);
	this->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any_ = NULL;
}

void _ns1__GetShippingForBerthResponse_GetShippingForBerthResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any);
#endif
}

int _ns1__GetShippingForBerthResponse_GetShippingForBerthResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, const char *tag, int id, const _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingForBerthResponse_GetShippingForBerthResult * SOAP_FMAC4 soap_in__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, const char *tag, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult, sizeof(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult, sizeof(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingForBerthResponse_GetShippingForBerthResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *p;
	size_t k = sizeof(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingForBerthResponse_GetShippingForBerthResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingForBerthResponse_GetShippingForBerthResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag ? tag : "ns1:GetShippingForBerthResponse-GetShippingForBerthResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingForBerthResponse_GetShippingForBerthResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingForBerthResponse_GetShippingForBerthResult * SOAP_FMAC4 soap_get__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingBerthListResponse_GetShippingBerthListResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::xsd__schema = NULL;
	this->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::__any = NULL;
}

void _ns1__GetShippingBerthListResponse_GetShippingBerthListResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetShippingBerthListResponse_GetShippingBerthListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, const char *tag, int id, const _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult), type))
		return soap->error;
	if (!a->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::xsd__schema)
	{	if (soap_element_empty(soap, "xsd:schema"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "xsd:schema", (char*const*)&a->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::xsd__schema, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingBerthListResponse_GetShippingBerthListResult * SOAP_FMAC4 soap_in__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, const char *tag, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult, sizeof(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xsd__schema1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "xsd:schema", (char**)&a->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::xsd__schema))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::xsd__schema))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult, sizeof(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingBerthListResponse_GetShippingBerthListResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *p;
	size_t k = sizeof(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingBerthListResponse_GetShippingBerthListResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingBerthListResponse_GetShippingBerthListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag ? tag : "ns1:GetShippingBerthListResponse-GetShippingBerthListResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingBerthListResponse_GetShippingBerthListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingBerthListResponse_GetShippingBerthListResult * SOAP_FMAC4 soap_get__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingListResponse_GetShippingListResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetShippingListResponse_GetShippingListResult::xsd__schema = NULL;
	this->_ns1__GetShippingListResponse_GetShippingListResult::__any = NULL;
}

void _ns1__GetShippingListResponse_GetShippingListResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetShippingListResponse_GetShippingListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingListResponse_GetShippingListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, const char *tag, int id, const _ns1__GetShippingListResponse_GetShippingListResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult), type))
		return soap->error;
	if (!a->_ns1__GetShippingListResponse_GetShippingListResult::xsd__schema)
	{	if (soap_element_empty(soap, "xsd:schema"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "xsd:schema", (char*const*)&a->_ns1__GetShippingListResponse_GetShippingListResult::xsd__schema, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetShippingListResponse_GetShippingListResult::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingListResponse_GetShippingListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingListResponse_GetShippingListResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingListResponse_GetShippingListResult * SOAP_FMAC4 soap_in__ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, const char *tag, _ns1__GetShippingListResponse_GetShippingListResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingListResponse_GetShippingListResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult, sizeof(_ns1__GetShippingListResponse_GetShippingListResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingListResponse_GetShippingListResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xsd__schema1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "xsd:schema", (char**)&a->_ns1__GetShippingListResponse_GetShippingListResult::xsd__schema))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetShippingListResponse_GetShippingListResult::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetShippingListResponse_GetShippingListResult::xsd__schema))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetShippingListResponse_GetShippingListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult, sizeof(_ns1__GetShippingListResponse_GetShippingListResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingListResponse_GetShippingListResult * SOAP_FMAC2 soap_instantiate__ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingListResponse_GetShippingListResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingListResponse_GetShippingListResult *p;
	size_t k = sizeof(_ns1__GetShippingListResponse_GetShippingListResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingListResponse_GetShippingListResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingListResponse_GetShippingListResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingListResponse_GetShippingListResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingListResponse_GetShippingListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingListResponse_GetShippingListResult(soap, tag ? tag : "ns1:GetShippingListResponse-GetShippingListResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingListResponse_GetShippingListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingListResponse_GetShippingListResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingListResponse_GetShippingListResult * SOAP_FMAC4 soap_get__ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, _ns1__GetShippingListResponse_GetShippingListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingListResponse_GetShippingListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doLotLinkForApple_assyDt::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__doLotLinkForApple_assyDt::__any);
	this->_ns1__doLotLinkForApple_assyDt::__any_ = NULL;
}

void _ns1__doLotLinkForApple_assyDt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__doLotLinkForApple_assyDt::__any);
#endif
}

int _ns1__doLotLinkForApple_assyDt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doLotLinkForApple_assyDt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doLotLinkForApple_assyDt(struct soap *soap, const char *tag, int id, const _ns1__doLotLinkForApple_assyDt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doLotLinkForApple_assyDt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__doLotLinkForApple_assyDt::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__doLotLinkForApple_assyDt::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doLotLinkForApple_assyDt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doLotLinkForApple_assyDt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doLotLinkForApple_assyDt * SOAP_FMAC4 soap_in__ns1__doLotLinkForApple_assyDt(struct soap *soap, const char *tag, _ns1__doLotLinkForApple_assyDt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doLotLinkForApple_assyDt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doLotLinkForApple_assyDt, sizeof(_ns1__doLotLinkForApple_assyDt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doLotLinkForApple_assyDt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doLotLinkForApple_assyDt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__doLotLinkForApple_assyDt::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__doLotLinkForApple_assyDt::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doLotLinkForApple_assyDt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doLotLinkForApple_assyDt, SOAP_TYPE__ns1__doLotLinkForApple_assyDt, sizeof(_ns1__doLotLinkForApple_assyDt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doLotLinkForApple_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doLotLinkForApple_assyDt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doLotLinkForApple_assyDt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doLotLinkForApple_assyDt *p;
	size_t k = sizeof(_ns1__doLotLinkForApple_assyDt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doLotLinkForApple_assyDt);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doLotLinkForApple_assyDt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doLotLinkForApple_assyDt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doLotLinkForApple_assyDt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doLotLinkForApple_assyDt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doLotLinkForApple_assyDt(soap, tag ? tag : "ns1:doLotLinkForApple-assyDt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doLotLinkForApple_assyDt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doLotLinkForApple_assyDt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doLotLinkForApple_assyDt * SOAP_FMAC4 soap_get__ns1__doLotLinkForApple_assyDt(struct soap *soap, _ns1__doLotLinkForApple_assyDt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doLotLinkForApple_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doSnLinkForApple_assyDt::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__doSnLinkForApple_assyDt::__any);
	this->_ns1__doSnLinkForApple_assyDt::__any_ = NULL;
}

void _ns1__doSnLinkForApple_assyDt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__doSnLinkForApple_assyDt::__any);
#endif
}

int _ns1__doSnLinkForApple_assyDt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doSnLinkForApple_assyDt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doSnLinkForApple_assyDt(struct soap *soap, const char *tag, int id, const _ns1__doSnLinkForApple_assyDt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doSnLinkForApple_assyDt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__doSnLinkForApple_assyDt::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__doSnLinkForApple_assyDt::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doSnLinkForApple_assyDt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doSnLinkForApple_assyDt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doSnLinkForApple_assyDt * SOAP_FMAC4 soap_in__ns1__doSnLinkForApple_assyDt(struct soap *soap, const char *tag, _ns1__doSnLinkForApple_assyDt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doSnLinkForApple_assyDt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doSnLinkForApple_assyDt, sizeof(_ns1__doSnLinkForApple_assyDt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doSnLinkForApple_assyDt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doSnLinkForApple_assyDt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__doSnLinkForApple_assyDt::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__doSnLinkForApple_assyDt::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doSnLinkForApple_assyDt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doSnLinkForApple_assyDt, SOAP_TYPE__ns1__doSnLinkForApple_assyDt, sizeof(_ns1__doSnLinkForApple_assyDt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doSnLinkForApple_assyDt * SOAP_FMAC2 soap_instantiate__ns1__doSnLinkForApple_assyDt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doSnLinkForApple_assyDt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doSnLinkForApple_assyDt *p;
	size_t k = sizeof(_ns1__doSnLinkForApple_assyDt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doSnLinkForApple_assyDt);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doSnLinkForApple_assyDt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doSnLinkForApple_assyDt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doSnLinkForApple_assyDt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doSnLinkForApple_assyDt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doSnLinkForApple_assyDt(soap, tag ? tag : "ns1:doSnLinkForApple-assyDt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doSnLinkForApple_assyDt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doSnLinkForApple_assyDt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doSnLinkForApple_assyDt * SOAP_FMAC4 soap_get__ns1__doSnLinkForApple_assyDt(struct soap *soap, _ns1__doSnLinkForApple_assyDt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doSnLinkForApple_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::xsd__schema = NULL;
	this->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::__any = NULL;
}

void _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, const char *tag, int id, const _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult), type))
		return soap->error;
	if (!a->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::xsd__schema)
	{	if (soap_element_empty(soap, "xsd:schema"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "xsd:schema", (char*const*)&a->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::xsd__schema, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult * SOAP_FMAC4 soap_in__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, const char *tag, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, sizeof(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xsd__schema1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xsd__schema1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "xsd:schema", (char**)&a->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::xsd__schema))
				{	soap_flag_xsd__schema1--;
					continue;
				}
			}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::xsd__schema))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, sizeof(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult * SOAP_FMAC2 soap_instantiate__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *p;
	size_t k = sizeof(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag ? tag : "ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult * SOAP_FMAC4 soap_get__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAhsMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAhsMoResponse::GetAhsMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAhsMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, &this->_ns1__GetAhsMoResponse::GetAhsMoResult);
#endif
}

int _ns1__GetAhsMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAhsMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAhsMoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAhsMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAhsMoResponse), type))
		return soap->error;
	if (a->GetAhsMoResult)
		soap_element_result(soap, "ns1:GetAhsMoResult");
	if (soap_out_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, "ns1:GetAhsMoResult", -1, &a->_ns1__GetAhsMoResponse::GetAhsMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAhsMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAhsMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAhsMoResponse * SOAP_FMAC4 soap_in__ns1__GetAhsMoResponse(struct soap *soap, const char *tag, _ns1__GetAhsMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAhsMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAhsMoResponse, sizeof(_ns1__GetAhsMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAhsMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAhsMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAhsMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAhsMoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, "ns1:GetAhsMoResult", &a->_ns1__GetAhsMoResponse::GetAhsMoResult, ""))
				{	soap_flag_GetAhsMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetAhsMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAhsMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAhsMoResponse, SOAP_TYPE__ns1__GetAhsMoResponse, sizeof(_ns1__GetAhsMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAhsMoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAhsMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAhsMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAhsMoResponse *p;
	size_t k = sizeof(_ns1__GetAhsMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAhsMoResponse);
		if (p)
			((_ns1__GetAhsMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAhsMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAhsMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAhsMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAhsMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAhsMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAhsMoResponse(soap, tag ? tag : "ns1:GetAhsMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAhsMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAhsMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAhsMoResponse * SOAP_FMAC4 soap_get__ns1__GetAhsMoResponse(struct soap *soap, _ns1__GetAhsMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAhsMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAhsMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAhsMo::MoNumber = NULL;
	this->_ns1__GetAhsMo::sDate = NULL;
	this->_ns1__GetAhsMo::eDate = NULL;
	this->_ns1__GetAhsMo::PrintType = NULL;
	/* transient soap skipped */
}

void _ns1__GetAhsMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsMo::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsMo::sDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsMo::eDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsMo::PrintType);
#endif
}

int _ns1__GetAhsMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAhsMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAhsMo(struct soap *soap, const char *tag, int id, const _ns1__GetAhsMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAhsMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__GetAhsMo::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:sDate", -1, &a->_ns1__GetAhsMo::sDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:eDate", -1, &a->_ns1__GetAhsMo::eDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PrintType", -1, &a->_ns1__GetAhsMo::PrintType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAhsMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAhsMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAhsMo * SOAP_FMAC4 soap_in__ns1__GetAhsMo(struct soap *soap, const char *tag, _ns1__GetAhsMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAhsMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAhsMo, sizeof(_ns1__GetAhsMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAhsMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAhsMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_sDate1 = 1;
	size_t soap_flag_eDate1 = 1;
	size_t soap_flag_PrintType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__GetAhsMo::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_sDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:sDate", &a->_ns1__GetAhsMo::sDate, "xsd:string"))
				{	soap_flag_sDate1--;
					continue;
				}
			}
			if (soap_flag_eDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:eDate", &a->_ns1__GetAhsMo::eDate, "xsd:string"))
				{	soap_flag_eDate1--;
					continue;
				}
			}
			if (soap_flag_PrintType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PrintType", &a->_ns1__GetAhsMo::PrintType, "xsd:string"))
				{	soap_flag_PrintType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAhsMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAhsMo, SOAP_TYPE__ns1__GetAhsMo, sizeof(_ns1__GetAhsMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAhsMo * SOAP_FMAC2 soap_instantiate__ns1__GetAhsMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAhsMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAhsMo *p;
	size_t k = sizeof(_ns1__GetAhsMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAhsMo);
		if (p)
			((_ns1__GetAhsMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAhsMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAhsMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAhsMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAhsMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAhsMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAhsMo(soap, tag ? tag : "ns1:GetAhsMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAhsMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAhsMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAhsMo * SOAP_FMAC4 soap_get__ns1__GetAhsMo(struct soap *soap, _ns1__GetAhsMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAhsMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPackWeigthResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPackWeigthResponse::GetPackWeigthResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPackWeigthResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPackWeigthResponse::GetPackWeigthResult);
#endif
}

int _ns1__GetPackWeigthResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPackWeigthResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPackWeigthResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPackWeigthResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPackWeigthResponse), type))
		return soap->error;
	if (a->GetPackWeigthResult)
		soap_element_result(soap, "ns1:GetPackWeigthResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetPackWeigthResult", -1, &a->_ns1__GetPackWeigthResponse::GetPackWeigthResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPackWeigthResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPackWeigthResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPackWeigthResponse * SOAP_FMAC4 soap_in__ns1__GetPackWeigthResponse(struct soap *soap, const char *tag, _ns1__GetPackWeigthResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPackWeigthResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPackWeigthResponse, sizeof(_ns1__GetPackWeigthResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPackWeigthResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPackWeigthResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPackWeigthResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPackWeigthResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetPackWeigthResult", &a->_ns1__GetPackWeigthResponse::GetPackWeigthResult, "xsd:string"))
				{	soap_flag_GetPackWeigthResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPackWeigthResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPackWeigthResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPackWeigthResponse, SOAP_TYPE__ns1__GetPackWeigthResponse, sizeof(_ns1__GetPackWeigthResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPackWeigthResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPackWeigthResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPackWeigthResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPackWeigthResponse *p;
	size_t k = sizeof(_ns1__GetPackWeigthResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPackWeigthResponse);
		if (p)
			((_ns1__GetPackWeigthResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPackWeigthResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPackWeigthResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPackWeigthResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPackWeigthResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPackWeigthResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPackWeigthResponse(soap, tag ? tag : "ns1:GetPackWeigthResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPackWeigthResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPackWeigthResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPackWeigthResponse * SOAP_FMAC4 soap_get__ns1__GetPackWeigthResponse(struct soap *soap, _ns1__GetPackWeigthResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPackWeigthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPackWeigth::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPackWeigth::CartonNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetPackWeigth::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPackWeigth::CartonNo);
#endif
}

int _ns1__GetPackWeigth::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPackWeigth(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPackWeigth(struct soap *soap, const char *tag, int id, const _ns1__GetPackWeigth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPackWeigth), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CartonNo", -1, &a->_ns1__GetPackWeigth::CartonNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPackWeigth::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPackWeigth(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPackWeigth * SOAP_FMAC4 soap_in__ns1__GetPackWeigth(struct soap *soap, const char *tag, _ns1__GetPackWeigth *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPackWeigth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPackWeigth, sizeof(_ns1__GetPackWeigth), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPackWeigth)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPackWeigth *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CartonNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CartonNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CartonNo", &a->_ns1__GetPackWeigth::CartonNo, "xsd:string"))
				{	soap_flag_CartonNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPackWeigth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPackWeigth, SOAP_TYPE__ns1__GetPackWeigth, sizeof(_ns1__GetPackWeigth), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPackWeigth * SOAP_FMAC2 soap_instantiate__ns1__GetPackWeigth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPackWeigth(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPackWeigth *p;
	size_t k = sizeof(_ns1__GetPackWeigth);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPackWeigth);
		if (p)
			((_ns1__GetPackWeigth*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPackWeigth, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPackWeigth*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPackWeigth location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPackWeigth, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPackWeigth::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPackWeigth(soap, tag ? tag : "ns1:GetPackWeigth", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPackWeigth::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPackWeigth(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPackWeigth * SOAP_FMAC4 soap_get__ns1__GetPackWeigth(struct soap *soap, _ns1__GetPackWeigth *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPackWeigth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPackStationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPackStationResponse::GetPackStationResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPackStationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPackStationResponse::GetPackStationResult);
#endif
}

int _ns1__GetPackStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPackStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPackStationResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPackStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPackStationResponse), type))
		return soap->error;
	if (a->GetPackStationResult)
		soap_element_result(soap, "ns1:GetPackStationResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetPackStationResult", -1, &a->_ns1__GetPackStationResponse::GetPackStationResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPackStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPackStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPackStationResponse * SOAP_FMAC4 soap_in__ns1__GetPackStationResponse(struct soap *soap, const char *tag, _ns1__GetPackStationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPackStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPackStationResponse, sizeof(_ns1__GetPackStationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPackStationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPackStationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPackStationResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPackStationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetPackStationResult", &a->_ns1__GetPackStationResponse::GetPackStationResult, "xsd:string"))
				{	soap_flag_GetPackStationResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPackStationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPackStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPackStationResponse, SOAP_TYPE__ns1__GetPackStationResponse, sizeof(_ns1__GetPackStationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPackStationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPackStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPackStationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPackStationResponse *p;
	size_t k = sizeof(_ns1__GetPackStationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPackStationResponse);
		if (p)
			((_ns1__GetPackStationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPackStationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPackStationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPackStationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPackStationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPackStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPackStationResponse(soap, tag ? tag : "ns1:GetPackStationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPackStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPackStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPackStationResponse * SOAP_FMAC4 soap_get__ns1__GetPackStationResponse(struct soap *soap, _ns1__GetPackStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPackStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPackStation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPackStation::CartonNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetPackStation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPackStation::CartonNo);
#endif
}

int _ns1__GetPackStation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPackStation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPackStation(struct soap *soap, const char *tag, int id, const _ns1__GetPackStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPackStation), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CartonNo", -1, &a->_ns1__GetPackStation::CartonNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPackStation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPackStation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPackStation * SOAP_FMAC4 soap_in__ns1__GetPackStation(struct soap *soap, const char *tag, _ns1__GetPackStation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPackStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPackStation, sizeof(_ns1__GetPackStation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPackStation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPackStation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CartonNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CartonNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CartonNo", &a->_ns1__GetPackStation::CartonNo, "xsd:string"))
				{	soap_flag_CartonNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPackStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPackStation, SOAP_TYPE__ns1__GetPackStation, sizeof(_ns1__GetPackStation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPackStation * SOAP_FMAC2 soap_instantiate__ns1__GetPackStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPackStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPackStation *p;
	size_t k = sizeof(_ns1__GetPackStation);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPackStation);
		if (p)
			((_ns1__GetPackStation*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPackStation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPackStation*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPackStation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPackStation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPackStation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPackStation(soap, tag ? tag : "ns1:GetPackStation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPackStation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPackStation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPackStation * SOAP_FMAC4 soap_get__ns1__GetPackStation(struct soap *soap, _ns1__GetPackStation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPackStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetPallentForWMSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetPallentForWMSResponse::SetPallentForWMSResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetPallentForWMSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetPallentForWMSResponse::SetPallentForWMSResult);
#endif
}

int _ns1__SetPallentForWMSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPallentForWMSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPallentForWMSResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPallentForWMSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPallentForWMSResponse), type))
		return soap->error;
	if (a->SetPallentForWMSResult)
		soap_element_result(soap, "ns1:SetPallentForWMSResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SetPallentForWMSResult", -1, &a->_ns1__SetPallentForWMSResponse::SetPallentForWMSResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPallentForWMSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPallentForWMSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPallentForWMSResponse * SOAP_FMAC4 soap_in__ns1__SetPallentForWMSResponse(struct soap *soap, const char *tag, _ns1__SetPallentForWMSResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPallentForWMSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPallentForWMSResponse, sizeof(_ns1__SetPallentForWMSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetPallentForWMSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetPallentForWMSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetPallentForWMSResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetPallentForWMSResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SetPallentForWMSResult", &a->_ns1__SetPallentForWMSResponse::SetPallentForWMSResult, "xsd:string"))
				{	soap_flag_SetPallentForWMSResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetPallentForWMSResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPallentForWMSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPallentForWMSResponse, SOAP_TYPE__ns1__SetPallentForWMSResponse, sizeof(_ns1__SetPallentForWMSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetPallentForWMSResponse * SOAP_FMAC2 soap_instantiate__ns1__SetPallentForWMSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPallentForWMSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetPallentForWMSResponse *p;
	size_t k = sizeof(_ns1__SetPallentForWMSResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetPallentForWMSResponse);
		if (p)
			((_ns1__SetPallentForWMSResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetPallentForWMSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetPallentForWMSResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetPallentForWMSResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetPallentForWMSResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetPallentForWMSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetPallentForWMSResponse(soap, tag ? tag : "ns1:SetPallentForWMSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetPallentForWMSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPallentForWMSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPallentForWMSResponse * SOAP_FMAC4 soap_get__ns1__SetPallentForWMSResponse(struct soap *soap, _ns1__SetPallentForWMSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPallentForWMSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetPallentForWMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetPallentForWMS::OldPallentNo = NULL;
	this->_ns1__SetPallentForWMS::PallentNo = NULL;
	this->_ns1__SetPallentForWMS::CartonNo = NULL;
	/* transient soap skipped */
}

void _ns1__SetPallentForWMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetPallentForWMS::OldPallentNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetPallentForWMS::PallentNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetPallentForWMS::CartonNo);
#endif
}

int _ns1__SetPallentForWMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPallentForWMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPallentForWMS(struct soap *soap, const char *tag, int id, const _ns1__SetPallentForWMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPallentForWMS), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:OldPallentNo", -1, &a->_ns1__SetPallentForWMS::OldPallentNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PallentNo", -1, &a->_ns1__SetPallentForWMS::PallentNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CartonNo", -1, &a->_ns1__SetPallentForWMS::CartonNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPallentForWMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPallentForWMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPallentForWMS * SOAP_FMAC4 soap_in__ns1__SetPallentForWMS(struct soap *soap, const char *tag, _ns1__SetPallentForWMS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPallentForWMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPallentForWMS, sizeof(_ns1__SetPallentForWMS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetPallentForWMS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetPallentForWMS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OldPallentNo1 = 1;
	size_t soap_flag_PallentNo1 = 1;
	size_t soap_flag_CartonNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OldPallentNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OldPallentNo", &a->_ns1__SetPallentForWMS::OldPallentNo, "xsd:string"))
				{	soap_flag_OldPallentNo1--;
					continue;
				}
			}
			if (soap_flag_PallentNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PallentNo", &a->_ns1__SetPallentForWMS::PallentNo, "xsd:string"))
				{	soap_flag_PallentNo1--;
					continue;
				}
			}
			if (soap_flag_CartonNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CartonNo", &a->_ns1__SetPallentForWMS::CartonNo, "xsd:string"))
				{	soap_flag_CartonNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPallentForWMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPallentForWMS, SOAP_TYPE__ns1__SetPallentForWMS, sizeof(_ns1__SetPallentForWMS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetPallentForWMS * SOAP_FMAC2 soap_instantiate__ns1__SetPallentForWMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPallentForWMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetPallentForWMS *p;
	size_t k = sizeof(_ns1__SetPallentForWMS);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetPallentForWMS);
		if (p)
			((_ns1__SetPallentForWMS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetPallentForWMS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetPallentForWMS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetPallentForWMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetPallentForWMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetPallentForWMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetPallentForWMS(soap, tag ? tag : "ns1:SetPallentForWMS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetPallentForWMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPallentForWMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPallentForWMS * SOAP_FMAC4 soap_get__ns1__SetPallentForWMS(struct soap *soap, _ns1__SetPallentForWMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPallentForWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPallentToWMSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPallentToWMSResponse::GetPallentToWMSResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPallentToWMSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, &this->_ns1__GetPallentToWMSResponse::GetPallentToWMSResult);
#endif
}

int _ns1__GetPallentToWMSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPallentToWMSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPallentToWMSResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPallentToWMSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPallentToWMSResponse), type))
		return soap->error;
	if (a->GetPallentToWMSResult)
		soap_element_result(soap, "ns1:GetPallentToWMSResult");
	if (soap_out_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, "ns1:GetPallentToWMSResult", -1, &a->_ns1__GetPallentToWMSResponse::GetPallentToWMSResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPallentToWMSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPallentToWMSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPallentToWMSResponse * SOAP_FMAC4 soap_in__ns1__GetPallentToWMSResponse(struct soap *soap, const char *tag, _ns1__GetPallentToWMSResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPallentToWMSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPallentToWMSResponse, sizeof(_ns1__GetPallentToWMSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPallentToWMSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPallentToWMSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPallentToWMSResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPallentToWMSResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, "ns1:GetPallentToWMSResult", &a->_ns1__GetPallentToWMSResponse::GetPallentToWMSResult, ""))
				{	soap_flag_GetPallentToWMSResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPallentToWMSResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPallentToWMSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPallentToWMSResponse, SOAP_TYPE__ns1__GetPallentToWMSResponse, sizeof(_ns1__GetPallentToWMSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPallentToWMSResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPallentToWMSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPallentToWMSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPallentToWMSResponse *p;
	size_t k = sizeof(_ns1__GetPallentToWMSResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPallentToWMSResponse);
		if (p)
			((_ns1__GetPallentToWMSResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPallentToWMSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPallentToWMSResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPallentToWMSResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPallentToWMSResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPallentToWMSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPallentToWMSResponse(soap, tag ? tag : "ns1:GetPallentToWMSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPallentToWMSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPallentToWMSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPallentToWMSResponse * SOAP_FMAC4 soap_get__ns1__GetPallentToWMSResponse(struct soap *soap, _ns1__GetPallentToWMSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPallentToWMSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPallentToWMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPallentToWMS::PallentNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetPallentToWMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPallentToWMS::PallentNo);
#endif
}

int _ns1__GetPallentToWMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPallentToWMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPallentToWMS(struct soap *soap, const char *tag, int id, const _ns1__GetPallentToWMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPallentToWMS), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PallentNo", -1, &a->_ns1__GetPallentToWMS::PallentNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPallentToWMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPallentToWMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPallentToWMS * SOAP_FMAC4 soap_in__ns1__GetPallentToWMS(struct soap *soap, const char *tag, _ns1__GetPallentToWMS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPallentToWMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPallentToWMS, sizeof(_ns1__GetPallentToWMS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPallentToWMS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPallentToWMS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PallentNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PallentNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PallentNo", &a->_ns1__GetPallentToWMS::PallentNo, "xsd:string"))
				{	soap_flag_PallentNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPallentToWMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPallentToWMS, SOAP_TYPE__ns1__GetPallentToWMS, sizeof(_ns1__GetPallentToWMS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPallentToWMS * SOAP_FMAC2 soap_instantiate__ns1__GetPallentToWMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPallentToWMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPallentToWMS *p;
	size_t k = sizeof(_ns1__GetPallentToWMS);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPallentToWMS);
		if (p)
			((_ns1__GetPallentToWMS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPallentToWMS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPallentToWMS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPallentToWMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPallentToWMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPallentToWMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPallentToWMS(soap, tag ? tag : "ns1:GetPallentToWMS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPallentToWMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPallentToWMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPallentToWMS * SOAP_FMAC4 soap_get__ns1__GetPallentToWMS(struct soap *soap, _ns1__GetPallentToWMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPallentToWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPackToWMSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPackToWMSResponse::GetPackToWMSResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPackToWMSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPackToWMSResponse::GetPackToWMSResult);
#endif
}

int _ns1__GetPackToWMSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPackToWMSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPackToWMSResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPackToWMSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPackToWMSResponse), type))
		return soap->error;
	if (a->GetPackToWMSResult)
		soap_element_result(soap, "ns1:GetPackToWMSResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetPackToWMSResult", -1, &a->_ns1__GetPackToWMSResponse::GetPackToWMSResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPackToWMSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPackToWMSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPackToWMSResponse * SOAP_FMAC4 soap_in__ns1__GetPackToWMSResponse(struct soap *soap, const char *tag, _ns1__GetPackToWMSResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPackToWMSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPackToWMSResponse, sizeof(_ns1__GetPackToWMSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPackToWMSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPackToWMSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPackToWMSResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPackToWMSResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetPackToWMSResult", &a->_ns1__GetPackToWMSResponse::GetPackToWMSResult, "xsd:string"))
				{	soap_flag_GetPackToWMSResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPackToWMSResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPackToWMSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPackToWMSResponse, SOAP_TYPE__ns1__GetPackToWMSResponse, sizeof(_ns1__GetPackToWMSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPackToWMSResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPackToWMSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPackToWMSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPackToWMSResponse *p;
	size_t k = sizeof(_ns1__GetPackToWMSResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPackToWMSResponse);
		if (p)
			((_ns1__GetPackToWMSResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPackToWMSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPackToWMSResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPackToWMSResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPackToWMSResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPackToWMSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPackToWMSResponse(soap, tag ? tag : "ns1:GetPackToWMSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPackToWMSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPackToWMSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPackToWMSResponse * SOAP_FMAC4 soap_get__ns1__GetPackToWMSResponse(struct soap *soap, _ns1__GetPackToWMSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPackToWMSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPackToWMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPackToWMS::CartonNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetPackToWMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPackToWMS::CartonNo);
#endif
}

int _ns1__GetPackToWMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPackToWMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPackToWMS(struct soap *soap, const char *tag, int id, const _ns1__GetPackToWMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPackToWMS), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CartonNo", -1, &a->_ns1__GetPackToWMS::CartonNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPackToWMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPackToWMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPackToWMS * SOAP_FMAC4 soap_in__ns1__GetPackToWMS(struct soap *soap, const char *tag, _ns1__GetPackToWMS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPackToWMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPackToWMS, sizeof(_ns1__GetPackToWMS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPackToWMS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPackToWMS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CartonNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CartonNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CartonNo", &a->_ns1__GetPackToWMS::CartonNo, "xsd:string"))
				{	soap_flag_CartonNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPackToWMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPackToWMS, SOAP_TYPE__ns1__GetPackToWMS, sizeof(_ns1__GetPackToWMS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPackToWMS * SOAP_FMAC2 soap_instantiate__ns1__GetPackToWMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPackToWMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPackToWMS *p;
	size_t k = sizeof(_ns1__GetPackToWMS);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPackToWMS);
		if (p)
			((_ns1__GetPackToWMS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPackToWMS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPackToWMS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPackToWMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPackToWMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPackToWMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPackToWMS(soap, tag ? tag : "ns1:GetPackToWMS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPackToWMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPackToWMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPackToWMS * SOAP_FMAC4 soap_get__ns1__GetPackToWMS(struct soap *soap, _ns1__GetPackToWMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPackToWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetWeightSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetWeightSetResponse::GetWeightSetResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetWeightSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetWeightSetResponse::GetWeightSetResult);
#endif
}

int _ns1__GetWeightSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWeightSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWeightSetResponse(struct soap *soap, const char *tag, int id, const _ns1__GetWeightSetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWeightSetResponse), type))
		return soap->error;
	if (a->GetWeightSetResult)
		soap_element_result(soap, "ns1:GetWeightSetResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetWeightSetResult", -1, &a->_ns1__GetWeightSetResponse::GetWeightSetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWeightSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWeightSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWeightSetResponse * SOAP_FMAC4 soap_in__ns1__GetWeightSetResponse(struct soap *soap, const char *tag, _ns1__GetWeightSetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWeightSetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWeightSetResponse, sizeof(_ns1__GetWeightSetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetWeightSetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetWeightSetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetWeightSetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetWeightSetResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetWeightSetResult", &a->_ns1__GetWeightSetResponse::GetWeightSetResult, "xsd:string"))
				{	soap_flag_GetWeightSetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetWeightSetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWeightSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWeightSetResponse, SOAP_TYPE__ns1__GetWeightSetResponse, sizeof(_ns1__GetWeightSetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetWeightSetResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWeightSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWeightSetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetWeightSetResponse *p;
	size_t k = sizeof(_ns1__GetWeightSetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetWeightSetResponse);
		if (p)
			((_ns1__GetWeightSetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetWeightSetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetWeightSetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetWeightSetResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetWeightSetResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetWeightSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetWeightSetResponse(soap, tag ? tag : "ns1:GetWeightSetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWeightSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWeightSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWeightSetResponse * SOAP_FMAC4 soap_get__ns1__GetWeightSetResponse(struct soap *soap, _ns1__GetWeightSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWeightSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetWeightSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetWeightSet::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetWeightSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetWeightSet::SN);
#endif
}

int _ns1__GetWeightSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWeightSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWeightSet(struct soap *soap, const char *tag, int id, const _ns1__GetWeightSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWeightSet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetWeightSet::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWeightSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWeightSet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWeightSet * SOAP_FMAC4 soap_in__ns1__GetWeightSet(struct soap *soap, const char *tag, _ns1__GetWeightSet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWeightSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWeightSet, sizeof(_ns1__GetWeightSet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetWeightSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetWeightSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetWeightSet::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWeightSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWeightSet, SOAP_TYPE__ns1__GetWeightSet, sizeof(_ns1__GetWeightSet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetWeightSet * SOAP_FMAC2 soap_instantiate__ns1__GetWeightSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWeightSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetWeightSet *p;
	size_t k = sizeof(_ns1__GetWeightSet);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetWeightSet);
		if (p)
			((_ns1__GetWeightSet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetWeightSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetWeightSet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetWeightSet location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetWeightSet, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetWeightSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetWeightSet(soap, tag ? tag : "ns1:GetWeightSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWeightSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWeightSet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWeightSet * SOAP_FMAC4 soap_get__ns1__GetWeightSet(struct soap *soap, _ns1__GetWeightSet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWeightSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelLnkSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CancelLnkSNResponse::CancelLnkSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__CancelLnkSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelLnkSNResponse::CancelLnkSNResult);
#endif
}

int _ns1__CancelLnkSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelLnkSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelLnkSNResponse(struct soap *soap, const char *tag, int id, const _ns1__CancelLnkSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelLnkSNResponse), type))
		return soap->error;
	if (a->CancelLnkSNResult)
		soap_element_result(soap, "ns1:CancelLnkSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:CancelLnkSNResult", -1, &a->_ns1__CancelLnkSNResponse::CancelLnkSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelLnkSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelLnkSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelLnkSNResponse * SOAP_FMAC4 soap_in__ns1__CancelLnkSNResponse(struct soap *soap, const char *tag, _ns1__CancelLnkSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelLnkSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelLnkSNResponse, sizeof(_ns1__CancelLnkSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CancelLnkSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CancelLnkSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CancelLnkSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CancelLnkSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CancelLnkSNResult", &a->_ns1__CancelLnkSNResponse::CancelLnkSNResult, "xsd:string"))
				{	soap_flag_CancelLnkSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CancelLnkSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CancelLnkSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelLnkSNResponse, SOAP_TYPE__ns1__CancelLnkSNResponse, sizeof(_ns1__CancelLnkSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelLnkSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelLnkSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelLnkSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelLnkSNResponse *p;
	size_t k = sizeof(_ns1__CancelLnkSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelLnkSNResponse);
		if (p)
			((_ns1__CancelLnkSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelLnkSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelLnkSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelLnkSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelLnkSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelLnkSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CancelLnkSNResponse(soap, tag ? tag : "ns1:CancelLnkSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelLnkSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelLnkSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelLnkSNResponse * SOAP_FMAC4 soap_get__ns1__CancelLnkSNResponse(struct soap *soap, _ns1__CancelLnkSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelLnkSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelLnkSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CancelLnkSN::ZJSN = NULL;
	/* transient soap skipped */
}

void _ns1__CancelLnkSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelLnkSN::ZJSN);
#endif
}

int _ns1__CancelLnkSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelLnkSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelLnkSN(struct soap *soap, const char *tag, int id, const _ns1__CancelLnkSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelLnkSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__CancelLnkSN::ZJSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelLnkSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelLnkSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelLnkSN * SOAP_FMAC4 soap_in__ns1__CancelLnkSN(struct soap *soap, const char *tag, _ns1__CancelLnkSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelLnkSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelLnkSN, sizeof(_ns1__CancelLnkSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CancelLnkSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CancelLnkSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZJSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__CancelLnkSN::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CancelLnkSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelLnkSN, SOAP_TYPE__ns1__CancelLnkSN, sizeof(_ns1__CancelLnkSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelLnkSN * SOAP_FMAC2 soap_instantiate__ns1__CancelLnkSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelLnkSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelLnkSN *p;
	size_t k = sizeof(_ns1__CancelLnkSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelLnkSN);
		if (p)
			((_ns1__CancelLnkSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelLnkSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelLnkSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelLnkSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelLnkSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelLnkSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CancelLnkSN(soap, tag ? tag : "ns1:CancelLnkSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelLnkSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelLnkSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelLnkSN * SOAP_FMAC4 soap_get__ns1__CancelLnkSN(struct soap *soap, _ns1__CancelLnkSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelLnkSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelGrillSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CancelGrillSNResponse::CancelGrillSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__CancelGrillSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelGrillSNResponse::CancelGrillSNResult);
#endif
}

int _ns1__CancelGrillSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelGrillSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelGrillSNResponse(struct soap *soap, const char *tag, int id, const _ns1__CancelGrillSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelGrillSNResponse), type))
		return soap->error;
	if (a->CancelGrillSNResult)
		soap_element_result(soap, "ns1:CancelGrillSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:CancelGrillSNResult", -1, &a->_ns1__CancelGrillSNResponse::CancelGrillSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelGrillSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelGrillSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelGrillSNResponse * SOAP_FMAC4 soap_in__ns1__CancelGrillSNResponse(struct soap *soap, const char *tag, _ns1__CancelGrillSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelGrillSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelGrillSNResponse, sizeof(_ns1__CancelGrillSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CancelGrillSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CancelGrillSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CancelGrillSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CancelGrillSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CancelGrillSNResult", &a->_ns1__CancelGrillSNResponse::CancelGrillSNResult, "xsd:string"))
				{	soap_flag_CancelGrillSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CancelGrillSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CancelGrillSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelGrillSNResponse, SOAP_TYPE__ns1__CancelGrillSNResponse, sizeof(_ns1__CancelGrillSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelGrillSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelGrillSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelGrillSNResponse *p;
	size_t k = sizeof(_ns1__CancelGrillSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelGrillSNResponse);
		if (p)
			((_ns1__CancelGrillSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelGrillSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelGrillSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelGrillSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelGrillSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelGrillSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CancelGrillSNResponse(soap, tag ? tag : "ns1:CancelGrillSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelGrillSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelGrillSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelGrillSNResponse * SOAP_FMAC4 soap_get__ns1__CancelGrillSNResponse(struct soap *soap, _ns1__CancelGrillSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelGrillSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelGrillSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CancelGrillSN::GrillSN = NULL;
	/* transient soap skipped */
}

void _ns1__CancelGrillSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelGrillSN::GrillSN);
#endif
}

int _ns1__CancelGrillSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelGrillSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelGrillSN(struct soap *soap, const char *tag, int id, const _ns1__CancelGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelGrillSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GrillSN", -1, &a->_ns1__CancelGrillSN::GrillSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelGrillSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelGrillSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelGrillSN * SOAP_FMAC4 soap_in__ns1__CancelGrillSN(struct soap *soap, const char *tag, _ns1__CancelGrillSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelGrillSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelGrillSN, sizeof(_ns1__CancelGrillSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CancelGrillSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CancelGrillSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GrillSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GrillSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GrillSN", &a->_ns1__CancelGrillSN::GrillSN, "xsd:string"))
				{	soap_flag_GrillSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CancelGrillSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelGrillSN, SOAP_TYPE__ns1__CancelGrillSN, sizeof(_ns1__CancelGrillSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelGrillSN * SOAP_FMAC2 soap_instantiate__ns1__CancelGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelGrillSN *p;
	size_t k = sizeof(_ns1__CancelGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelGrillSN);
		if (p)
			((_ns1__CancelGrillSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelGrillSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelGrillSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelGrillSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CancelGrillSN(soap, tag ? tag : "ns1:CancelGrillSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelGrillSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelGrillSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelGrillSN * SOAP_FMAC4 soap_get__ns1__CancelGrillSN(struct soap *soap, _ns1__CancelGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutGrillBySNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutGrillBySNResponse::OutGrillBySNResult = NULL;
	/* transient soap skipped */
}

void _ns1__OutGrillBySNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutGrillBySNResponse::OutGrillBySNResult);
#endif
}

int _ns1__OutGrillBySNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutGrillBySNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutGrillBySNResponse(struct soap *soap, const char *tag, int id, const _ns1__OutGrillBySNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutGrillBySNResponse), type))
		return soap->error;
	if (a->OutGrillBySNResult)
		soap_element_result(soap, "ns1:OutGrillBySNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:OutGrillBySNResult", -1, &a->_ns1__OutGrillBySNResponse::OutGrillBySNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutGrillBySNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OutGrillBySNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutGrillBySNResponse * SOAP_FMAC4 soap_in__ns1__OutGrillBySNResponse(struct soap *soap, const char *tag, _ns1__OutGrillBySNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutGrillBySNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutGrillBySNResponse, sizeof(_ns1__OutGrillBySNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutGrillBySNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutGrillBySNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OutGrillBySNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutGrillBySNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OutGrillBySNResult", &a->_ns1__OutGrillBySNResponse::OutGrillBySNResult, "xsd:string"))
				{	soap_flag_OutGrillBySNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OutGrillBySNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutGrillBySNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutGrillBySNResponse, SOAP_TYPE__ns1__OutGrillBySNResponse, sizeof(_ns1__OutGrillBySNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutGrillBySNResponse * SOAP_FMAC2 soap_instantiate__ns1__OutGrillBySNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutGrillBySNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutGrillBySNResponse *p;
	size_t k = sizeof(_ns1__OutGrillBySNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OutGrillBySNResponse);
		if (p)
			((_ns1__OutGrillBySNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OutGrillBySNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OutGrillBySNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutGrillBySNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OutGrillBySNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OutGrillBySNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutGrillBySNResponse(soap, tag ? tag : "ns1:OutGrillBySNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutGrillBySNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutGrillBySNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutGrillBySNResponse * SOAP_FMAC4 soap_get__ns1__OutGrillBySNResponse(struct soap *soap, _ns1__OutGrillBySNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutGrillBySNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutGrillBySN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutGrillBySN::Emp = NULL;
	this->_ns1__OutGrillBySN::GrillSN = NULL;
	this->_ns1__OutGrillBySN::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__OutGrillBySN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutGrillBySN::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutGrillBySN::GrillSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutGrillBySN::StationNumber);
#endif
}

int _ns1__OutGrillBySN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutGrillBySN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutGrillBySN(struct soap *soap, const char *tag, int id, const _ns1__OutGrillBySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutGrillBySN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__OutGrillBySN::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GrillSN", -1, &a->_ns1__OutGrillBySN::GrillSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__OutGrillBySN::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutGrillBySN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OutGrillBySN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutGrillBySN * SOAP_FMAC4 soap_in__ns1__OutGrillBySN(struct soap *soap, const char *tag, _ns1__OutGrillBySN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutGrillBySN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutGrillBySN, sizeof(_ns1__OutGrillBySN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutGrillBySN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutGrillBySN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_GrillSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__OutGrillBySN::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_GrillSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GrillSN", &a->_ns1__OutGrillBySN::GrillSN, "xsd:string"))
				{	soap_flag_GrillSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__OutGrillBySN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutGrillBySN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutGrillBySN, SOAP_TYPE__ns1__OutGrillBySN, sizeof(_ns1__OutGrillBySN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutGrillBySN * SOAP_FMAC2 soap_instantiate__ns1__OutGrillBySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutGrillBySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutGrillBySN *p;
	size_t k = sizeof(_ns1__OutGrillBySN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OutGrillBySN);
		if (p)
			((_ns1__OutGrillBySN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OutGrillBySN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OutGrillBySN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutGrillBySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OutGrillBySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OutGrillBySN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutGrillBySN(soap, tag ? tag : "ns1:OutGrillBySN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutGrillBySN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutGrillBySN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutGrillBySN * SOAP_FMAC4 soap_get__ns1__OutGrillBySN(struct soap *soap, _ns1__OutGrillBySN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutGrillBySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetGrillTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetGrillTimeResponse::GetGrillTimeResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetGrillTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetGrillTimeResponse::GetGrillTimeResult);
#endif
}

int _ns1__GetGrillTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGrillTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGrillTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetGrillTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGrillTimeResponse), type))
		return soap->error;
	if (a->GetGrillTimeResult)
		soap_element_result(soap, "ns1:GetGrillTimeResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetGrillTimeResult", -1, &a->_ns1__GetGrillTimeResponse::GetGrillTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGrillTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGrillTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGrillTimeResponse * SOAP_FMAC4 soap_in__ns1__GetGrillTimeResponse(struct soap *soap, const char *tag, _ns1__GetGrillTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGrillTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGrillTimeResponse, sizeof(_ns1__GetGrillTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetGrillTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetGrillTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetGrillTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetGrillTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetGrillTimeResult", &a->_ns1__GetGrillTimeResponse::GetGrillTimeResult, "xsd:string"))
				{	soap_flag_GetGrillTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetGrillTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGrillTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGrillTimeResponse, SOAP_TYPE__ns1__GetGrillTimeResponse, sizeof(_ns1__GetGrillTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetGrillTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetGrillTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGrillTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetGrillTimeResponse *p;
	size_t k = sizeof(_ns1__GetGrillTimeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetGrillTimeResponse);
		if (p)
			((_ns1__GetGrillTimeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetGrillTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetGrillTimeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetGrillTimeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetGrillTimeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetGrillTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetGrillTimeResponse(soap, tag ? tag : "ns1:GetGrillTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetGrillTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGrillTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGrillTimeResponse * SOAP_FMAC4 soap_get__ns1__GetGrillTimeResponse(struct soap *soap, _ns1__GetGrillTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGrillTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetGrillTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetGrillTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetGrillTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGrillTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGrillTime(struct soap *soap, const char *tag, int id, const _ns1__GetGrillTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGrillTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGrillTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGrillTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGrillTime * SOAP_FMAC4 soap_in__ns1__GetGrillTime(struct soap *soap, const char *tag, _ns1__GetGrillTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGrillTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGrillTime, sizeof(_ns1__GetGrillTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetGrillTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetGrillTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGrillTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGrillTime, SOAP_TYPE__ns1__GetGrillTime, sizeof(_ns1__GetGrillTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetGrillTime * SOAP_FMAC2 soap_instantiate__ns1__GetGrillTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGrillTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetGrillTime *p;
	size_t k = sizeof(_ns1__GetGrillTime);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetGrillTime);
		if (p)
			((_ns1__GetGrillTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetGrillTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetGrillTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetGrillTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetGrillTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetGrillTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetGrillTime(soap, tag ? tag : "ns1:GetGrillTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetGrillTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGrillTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGrillTime * SOAP_FMAC4 soap_get__ns1__GetGrillTime(struct soap *soap, _ns1__GetGrillTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGrillTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsGrillBySNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsGrillBySNResponse::InsGrillBySNResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsGrillBySNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsGrillBySNResponse::InsGrillBySNResult);
#endif
}

int _ns1__InsGrillBySNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsGrillBySNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsGrillBySNResponse(struct soap *soap, const char *tag, int id, const _ns1__InsGrillBySNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsGrillBySNResponse), type))
		return soap->error;
	if (a->InsGrillBySNResult)
		soap_element_result(soap, "ns1:InsGrillBySNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsGrillBySNResult", -1, &a->_ns1__InsGrillBySNResponse::InsGrillBySNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsGrillBySNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsGrillBySNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsGrillBySNResponse * SOAP_FMAC4 soap_in__ns1__InsGrillBySNResponse(struct soap *soap, const char *tag, _ns1__InsGrillBySNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsGrillBySNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsGrillBySNResponse, sizeof(_ns1__InsGrillBySNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsGrillBySNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsGrillBySNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsGrillBySNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsGrillBySNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsGrillBySNResult", &a->_ns1__InsGrillBySNResponse::InsGrillBySNResult, "xsd:string"))
				{	soap_flag_InsGrillBySNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsGrillBySNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsGrillBySNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsGrillBySNResponse, SOAP_TYPE__ns1__InsGrillBySNResponse, sizeof(_ns1__InsGrillBySNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsGrillBySNResponse * SOAP_FMAC2 soap_instantiate__ns1__InsGrillBySNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsGrillBySNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsGrillBySNResponse *p;
	size_t k = sizeof(_ns1__InsGrillBySNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsGrillBySNResponse);
		if (p)
			((_ns1__InsGrillBySNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsGrillBySNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsGrillBySNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsGrillBySNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsGrillBySNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsGrillBySNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsGrillBySNResponse(soap, tag ? tag : "ns1:InsGrillBySNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsGrillBySNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsGrillBySNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsGrillBySNResponse * SOAP_FMAC4 soap_get__ns1__InsGrillBySNResponse(struct soap *soap, _ns1__InsGrillBySNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsGrillBySNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsGrillBySN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsGrillBySN::Emp = NULL;
	this->_ns1__InsGrillBySN::GrillSN = NULL;
	this->_ns1__InsGrillBySN::OvenSN = NULL;
	this->_ns1__InsGrillBySN::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__InsGrillBySN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsGrillBySN::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsGrillBySN::GrillSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsGrillBySN::OvenSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsGrillBySN::StationNumber);
#endif
}

int _ns1__InsGrillBySN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsGrillBySN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsGrillBySN(struct soap *soap, const char *tag, int id, const _ns1__InsGrillBySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsGrillBySN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__InsGrillBySN::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GrillSN", -1, &a->_ns1__InsGrillBySN::GrillSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:OvenSN", -1, &a->_ns1__InsGrillBySN::OvenSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__InsGrillBySN::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsGrillBySN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsGrillBySN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsGrillBySN * SOAP_FMAC4 soap_in__ns1__InsGrillBySN(struct soap *soap, const char *tag, _ns1__InsGrillBySN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsGrillBySN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsGrillBySN, sizeof(_ns1__InsGrillBySN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsGrillBySN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsGrillBySN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_GrillSN1 = 1;
	size_t soap_flag_OvenSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__InsGrillBySN::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_GrillSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GrillSN", &a->_ns1__InsGrillBySN::GrillSN, "xsd:string"))
				{	soap_flag_GrillSN1--;
					continue;
				}
			}
			if (soap_flag_OvenSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OvenSN", &a->_ns1__InsGrillBySN::OvenSN, "xsd:string"))
				{	soap_flag_OvenSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__InsGrillBySN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsGrillBySN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsGrillBySN, SOAP_TYPE__ns1__InsGrillBySN, sizeof(_ns1__InsGrillBySN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsGrillBySN * SOAP_FMAC2 soap_instantiate__ns1__InsGrillBySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsGrillBySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsGrillBySN *p;
	size_t k = sizeof(_ns1__InsGrillBySN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsGrillBySN);
		if (p)
			((_ns1__InsGrillBySN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsGrillBySN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsGrillBySN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsGrillBySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsGrillBySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsGrillBySN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsGrillBySN(soap, tag ? tag : "ns1:InsGrillBySN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsGrillBySN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsGrillBySN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsGrillBySN * SOAP_FMAC4 soap_get__ns1__InsGrillBySN(struct soap *soap, _ns1__InsGrillBySN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsGrillBySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseGrillSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CloseGrillSNResponse::CloseGrillSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__CloseGrillSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CloseGrillSNResponse::CloseGrillSNResult);
#endif
}

int _ns1__CloseGrillSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseGrillSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseGrillSNResponse(struct soap *soap, const char *tag, int id, const _ns1__CloseGrillSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseGrillSNResponse), type))
		return soap->error;
	if (a->CloseGrillSNResult)
		soap_element_result(soap, "ns1:CloseGrillSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:CloseGrillSNResult", -1, &a->_ns1__CloseGrillSNResponse::CloseGrillSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseGrillSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseGrillSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseGrillSNResponse * SOAP_FMAC4 soap_in__ns1__CloseGrillSNResponse(struct soap *soap, const char *tag, _ns1__CloseGrillSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseGrillSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseGrillSNResponse, sizeof(_ns1__CloseGrillSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseGrillSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseGrillSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CloseGrillSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CloseGrillSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CloseGrillSNResult", &a->_ns1__CloseGrillSNResponse::CloseGrillSNResult, "xsd:string"))
				{	soap_flag_CloseGrillSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CloseGrillSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CloseGrillSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseGrillSNResponse, SOAP_TYPE__ns1__CloseGrillSNResponse, sizeof(_ns1__CloseGrillSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseGrillSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseGrillSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseGrillSNResponse *p;
	size_t k = sizeof(_ns1__CloseGrillSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseGrillSNResponse);
		if (p)
			((_ns1__CloseGrillSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseGrillSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseGrillSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseGrillSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseGrillSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseGrillSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseGrillSNResponse(soap, tag ? tag : "ns1:CloseGrillSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseGrillSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseGrillSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseGrillSNResponse * SOAP_FMAC4 soap_get__ns1__CloseGrillSNResponse(struct soap *soap, _ns1__CloseGrillSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseGrillSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseGrillSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CloseGrillSN::Emp = NULL;
	this->_ns1__CloseGrillSN::GrillSN = NULL;
	this->_ns1__CloseGrillSN::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__CloseGrillSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CloseGrillSN::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CloseGrillSN::GrillSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CloseGrillSN::StationNumber);
#endif
}

int _ns1__CloseGrillSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseGrillSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseGrillSN(struct soap *soap, const char *tag, int id, const _ns1__CloseGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseGrillSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__CloseGrillSN::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GrillSN", -1, &a->_ns1__CloseGrillSN::GrillSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__CloseGrillSN::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseGrillSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseGrillSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseGrillSN * SOAP_FMAC4 soap_in__ns1__CloseGrillSN(struct soap *soap, const char *tag, _ns1__CloseGrillSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseGrillSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseGrillSN, sizeof(_ns1__CloseGrillSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseGrillSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseGrillSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_GrillSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__CloseGrillSN::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_GrillSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GrillSN", &a->_ns1__CloseGrillSN::GrillSN, "xsd:string"))
				{	soap_flag_GrillSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__CloseGrillSN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CloseGrillSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseGrillSN, SOAP_TYPE__ns1__CloseGrillSN, sizeof(_ns1__CloseGrillSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseGrillSN * SOAP_FMAC2 soap_instantiate__ns1__CloseGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseGrillSN *p;
	size_t k = sizeof(_ns1__CloseGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseGrillSN);
		if (p)
			((_ns1__CloseGrillSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseGrillSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseGrillSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseGrillSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseGrillSN(soap, tag ? tag : "ns1:CloseGrillSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseGrillSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseGrillSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseGrillSN * SOAP_FMAC4 soap_get__ns1__CloseGrillSN(struct soap *soap, _ns1__CloseGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LnkGrillSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LnkGrillSNResponse::LnkGrillSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__LnkGrillSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkGrillSNResponse::LnkGrillSNResult);
#endif
}

int _ns1__LnkGrillSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LnkGrillSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LnkGrillSNResponse(struct soap *soap, const char *tag, int id, const _ns1__LnkGrillSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LnkGrillSNResponse), type))
		return soap->error;
	if (a->LnkGrillSNResult)
		soap_element_result(soap, "ns1:LnkGrillSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:LnkGrillSNResult", -1, &a->_ns1__LnkGrillSNResponse::LnkGrillSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LnkGrillSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LnkGrillSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LnkGrillSNResponse * SOAP_FMAC4 soap_in__ns1__LnkGrillSNResponse(struct soap *soap, const char *tag, _ns1__LnkGrillSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LnkGrillSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LnkGrillSNResponse, sizeof(_ns1__LnkGrillSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LnkGrillSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LnkGrillSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LnkGrillSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LnkGrillSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkGrillSNResult", &a->_ns1__LnkGrillSNResponse::LnkGrillSNResult, "xsd:string"))
				{	soap_flag_LnkGrillSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:LnkGrillSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LnkGrillSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LnkGrillSNResponse, SOAP_TYPE__ns1__LnkGrillSNResponse, sizeof(_ns1__LnkGrillSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LnkGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__LnkGrillSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LnkGrillSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LnkGrillSNResponse *p;
	size_t k = sizeof(_ns1__LnkGrillSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LnkGrillSNResponse);
		if (p)
			((_ns1__LnkGrillSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LnkGrillSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LnkGrillSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LnkGrillSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LnkGrillSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LnkGrillSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LnkGrillSNResponse(soap, tag ? tag : "ns1:LnkGrillSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LnkGrillSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LnkGrillSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LnkGrillSNResponse * SOAP_FMAC4 soap_get__ns1__LnkGrillSNResponse(struct soap *soap, _ns1__LnkGrillSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LnkGrillSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LnkGrillSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LnkGrillSN::GrillSN = NULL;
	this->_ns1__LnkGrillSN::ZJSN = NULL;
	this->_ns1__LnkGrillSN::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__LnkGrillSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkGrillSN::GrillSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkGrillSN::ZJSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkGrillSN::StationNumber);
#endif
}

int _ns1__LnkGrillSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LnkGrillSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LnkGrillSN(struct soap *soap, const char *tag, int id, const _ns1__LnkGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LnkGrillSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GrillSN", -1, &a->_ns1__LnkGrillSN::GrillSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__LnkGrillSN::ZJSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__LnkGrillSN::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LnkGrillSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LnkGrillSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LnkGrillSN * SOAP_FMAC4 soap_in__ns1__LnkGrillSN(struct soap *soap, const char *tag, _ns1__LnkGrillSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LnkGrillSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LnkGrillSN, sizeof(_ns1__LnkGrillSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LnkGrillSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LnkGrillSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GrillSN1 = 1;
	size_t soap_flag_ZJSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GrillSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GrillSN", &a->_ns1__LnkGrillSN::GrillSN, "xsd:string"))
				{	soap_flag_GrillSN1--;
					continue;
				}
			}
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__LnkGrillSN::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__LnkGrillSN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LnkGrillSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LnkGrillSN, SOAP_TYPE__ns1__LnkGrillSN, sizeof(_ns1__LnkGrillSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LnkGrillSN * SOAP_FMAC2 soap_instantiate__ns1__LnkGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LnkGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LnkGrillSN *p;
	size_t k = sizeof(_ns1__LnkGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LnkGrillSN);
		if (p)
			((_ns1__LnkGrillSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LnkGrillSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LnkGrillSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LnkGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LnkGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LnkGrillSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LnkGrillSN(soap, tag ? tag : "ns1:LnkGrillSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LnkGrillSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LnkGrillSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LnkGrillSN * SOAP_FMAC4 soap_get__ns1__LnkGrillSN(struct soap *soap, _ns1__LnkGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LnkGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkGrillSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkGrillSNResponse::chkGrillSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkGrillSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkGrillSNResponse::chkGrillSNResult);
#endif
}

int _ns1__chkGrillSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkGrillSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkGrillSNResponse(struct soap *soap, const char *tag, int id, const _ns1__chkGrillSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkGrillSNResponse), type))
		return soap->error;
	if (a->chkGrillSNResult)
		soap_element_result(soap, "ns1:chkGrillSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkGrillSNResult", -1, &a->_ns1__chkGrillSNResponse::chkGrillSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkGrillSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkGrillSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkGrillSNResponse * SOAP_FMAC4 soap_in__ns1__chkGrillSNResponse(struct soap *soap, const char *tag, _ns1__chkGrillSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkGrillSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkGrillSNResponse, sizeof(_ns1__chkGrillSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkGrillSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkGrillSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkGrillSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkGrillSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkGrillSNResult", &a->_ns1__chkGrillSNResponse::chkGrillSNResult, "xsd:string"))
				{	soap_flag_chkGrillSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkGrillSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkGrillSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkGrillSNResponse, SOAP_TYPE__ns1__chkGrillSNResponse, sizeof(_ns1__chkGrillSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkGrillSNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkGrillSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkGrillSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkGrillSNResponse *p;
	size_t k = sizeof(_ns1__chkGrillSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkGrillSNResponse);
		if (p)
			((_ns1__chkGrillSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkGrillSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkGrillSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkGrillSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkGrillSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkGrillSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkGrillSNResponse(soap, tag ? tag : "ns1:chkGrillSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkGrillSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkGrillSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkGrillSNResponse * SOAP_FMAC4 soap_get__ns1__chkGrillSNResponse(struct soap *soap, _ns1__chkGrillSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkGrillSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkGrillSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkGrillSN::GrillSN = NULL;
	/* transient soap skipped */
}

void _ns1__chkGrillSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkGrillSN::GrillSN);
#endif
}

int _ns1__chkGrillSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkGrillSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkGrillSN(struct soap *soap, const char *tag, int id, const _ns1__chkGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkGrillSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GrillSN", -1, &a->_ns1__chkGrillSN::GrillSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkGrillSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkGrillSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkGrillSN * SOAP_FMAC4 soap_in__ns1__chkGrillSN(struct soap *soap, const char *tag, _ns1__chkGrillSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkGrillSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkGrillSN, sizeof(_ns1__chkGrillSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkGrillSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkGrillSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GrillSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GrillSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GrillSN", &a->_ns1__chkGrillSN::GrillSN, "xsd:string"))
				{	soap_flag_GrillSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkGrillSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkGrillSN, SOAP_TYPE__ns1__chkGrillSN, sizeof(_ns1__chkGrillSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkGrillSN * SOAP_FMAC2 soap_instantiate__ns1__chkGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkGrillSN *p;
	size_t k = sizeof(_ns1__chkGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkGrillSN);
		if (p)
			((_ns1__chkGrillSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkGrillSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkGrillSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkGrillSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkGrillSN(soap, tag ? tag : "ns1:chkGrillSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkGrillSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkGrillSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkGrillSN * SOAP_FMAC4 soap_get__ns1__chkGrillSN(struct soap *soap, _ns1__chkGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LnkSideSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LnkSideSNResponse::LnkSideSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__LnkSideSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkSideSNResponse::LnkSideSNResult);
#endif
}

int _ns1__LnkSideSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LnkSideSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LnkSideSNResponse(struct soap *soap, const char *tag, int id, const _ns1__LnkSideSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LnkSideSNResponse), type))
		return soap->error;
	if (a->LnkSideSNResult)
		soap_element_result(soap, "ns1:LnkSideSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:LnkSideSNResult", -1, &a->_ns1__LnkSideSNResponse::LnkSideSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LnkSideSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LnkSideSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LnkSideSNResponse * SOAP_FMAC4 soap_in__ns1__LnkSideSNResponse(struct soap *soap, const char *tag, _ns1__LnkSideSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LnkSideSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LnkSideSNResponse, sizeof(_ns1__LnkSideSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LnkSideSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LnkSideSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LnkSideSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LnkSideSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkSideSNResult", &a->_ns1__LnkSideSNResponse::LnkSideSNResult, "xsd:string"))
				{	soap_flag_LnkSideSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:LnkSideSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LnkSideSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LnkSideSNResponse, SOAP_TYPE__ns1__LnkSideSNResponse, sizeof(_ns1__LnkSideSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LnkSideSNResponse * SOAP_FMAC2 soap_instantiate__ns1__LnkSideSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LnkSideSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LnkSideSNResponse *p;
	size_t k = sizeof(_ns1__LnkSideSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LnkSideSNResponse);
		if (p)
			((_ns1__LnkSideSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LnkSideSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LnkSideSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LnkSideSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LnkSideSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LnkSideSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LnkSideSNResponse(soap, tag ? tag : "ns1:LnkSideSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LnkSideSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LnkSideSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LnkSideSNResponse * SOAP_FMAC4 soap_get__ns1__LnkSideSNResponse(struct soap *soap, _ns1__LnkSideSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LnkSideSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LnkSideSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LnkSideSN::Emp = NULL;
	this->_ns1__LnkSideSN::ZJSN = NULL;
	this->_ns1__LnkSideSN::LnkSN = NULL;
	this->_ns1__LnkSideSN::StationNumber = NULL;
	this->_ns1__LnkSideSN::strType = NULL;
	/* transient soap skipped */
}

void _ns1__LnkSideSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkSideSN::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkSideSN::ZJSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkSideSN::LnkSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkSideSN::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkSideSN::strType);
#endif
}

int _ns1__LnkSideSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LnkSideSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LnkSideSN(struct soap *soap, const char *tag, int id, const _ns1__LnkSideSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LnkSideSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__LnkSideSN::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__LnkSideSN::ZJSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkSN", -1, &a->_ns1__LnkSideSN::LnkSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__LnkSideSN::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strType", -1, &a->_ns1__LnkSideSN::strType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LnkSideSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LnkSideSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LnkSideSN * SOAP_FMAC4 soap_in__ns1__LnkSideSN(struct soap *soap, const char *tag, _ns1__LnkSideSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LnkSideSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LnkSideSN, sizeof(_ns1__LnkSideSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LnkSideSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LnkSideSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_ZJSN1 = 1;
	size_t soap_flag_LnkSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_strType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__LnkSideSN::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__LnkSideSN::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap_flag_LnkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkSN", &a->_ns1__LnkSideSN::LnkSN, "xsd:string"))
				{	soap_flag_LnkSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__LnkSideSN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strType", &a->_ns1__LnkSideSN::strType, "xsd:string"))
				{	soap_flag_strType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LnkSideSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LnkSideSN, SOAP_TYPE__ns1__LnkSideSN, sizeof(_ns1__LnkSideSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LnkSideSN * SOAP_FMAC2 soap_instantiate__ns1__LnkSideSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LnkSideSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LnkSideSN *p;
	size_t k = sizeof(_ns1__LnkSideSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LnkSideSN);
		if (p)
			((_ns1__LnkSideSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LnkSideSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LnkSideSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LnkSideSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LnkSideSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LnkSideSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LnkSideSN(soap, tag ? tag : "ns1:LnkSideSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LnkSideSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LnkSideSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LnkSideSN * SOAP_FMAC4 soap_get__ns1__LnkSideSN(struct soap *soap, _ns1__LnkSideSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LnkSideSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LnkZJSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LnkZJSNResponse::LnkZJSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__LnkZJSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkZJSNResponse::LnkZJSNResult);
#endif
}

int _ns1__LnkZJSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LnkZJSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LnkZJSNResponse(struct soap *soap, const char *tag, int id, const _ns1__LnkZJSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LnkZJSNResponse), type))
		return soap->error;
	if (a->LnkZJSNResult)
		soap_element_result(soap, "ns1:LnkZJSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:LnkZJSNResult", -1, &a->_ns1__LnkZJSNResponse::LnkZJSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LnkZJSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LnkZJSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LnkZJSNResponse * SOAP_FMAC4 soap_in__ns1__LnkZJSNResponse(struct soap *soap, const char *tag, _ns1__LnkZJSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LnkZJSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LnkZJSNResponse, sizeof(_ns1__LnkZJSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LnkZJSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LnkZJSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LnkZJSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LnkZJSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkZJSNResult", &a->_ns1__LnkZJSNResponse::LnkZJSNResult, "xsd:string"))
				{	soap_flag_LnkZJSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:LnkZJSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LnkZJSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LnkZJSNResponse, SOAP_TYPE__ns1__LnkZJSNResponse, sizeof(_ns1__LnkZJSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LnkZJSNResponse * SOAP_FMAC2 soap_instantiate__ns1__LnkZJSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LnkZJSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LnkZJSNResponse *p;
	size_t k = sizeof(_ns1__LnkZJSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LnkZJSNResponse);
		if (p)
			((_ns1__LnkZJSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LnkZJSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LnkZJSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LnkZJSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LnkZJSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LnkZJSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LnkZJSNResponse(soap, tag ? tag : "ns1:LnkZJSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LnkZJSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LnkZJSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LnkZJSNResponse * SOAP_FMAC4 soap_get__ns1__LnkZJSNResponse(struct soap *soap, _ns1__LnkZJSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LnkZJSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LnkZJSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LnkZJSN::Emp = NULL;
	this->_ns1__LnkZJSN::SN = NULL;
	this->_ns1__LnkZJSN::ZJSN = NULL;
	this->_ns1__LnkZJSN::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__LnkZJSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkZJSN::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkZJSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkZJSN::ZJSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__LnkZJSN::StationNumber);
#endif
}

int _ns1__LnkZJSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LnkZJSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LnkZJSN(struct soap *soap, const char *tag, int id, const _ns1__LnkZJSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LnkZJSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__LnkZJSN::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__LnkZJSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__LnkZJSN::ZJSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__LnkZJSN::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LnkZJSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LnkZJSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LnkZJSN * SOAP_FMAC4 soap_in__ns1__LnkZJSN(struct soap *soap, const char *tag, _ns1__LnkZJSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LnkZJSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LnkZJSN, sizeof(_ns1__LnkZJSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LnkZJSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LnkZJSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_ZJSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__LnkZJSN::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__LnkZJSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__LnkZJSN::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__LnkZJSN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LnkZJSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LnkZJSN, SOAP_TYPE__ns1__LnkZJSN, sizeof(_ns1__LnkZJSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LnkZJSN * SOAP_FMAC2 soap_instantiate__ns1__LnkZJSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LnkZJSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LnkZJSN *p;
	size_t k = sizeof(_ns1__LnkZJSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LnkZJSN);
		if (p)
			((_ns1__LnkZJSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LnkZJSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LnkZJSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LnkZJSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LnkZJSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LnkZJSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LnkZJSN(soap, tag ? tag : "ns1:LnkZJSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LnkZJSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LnkZJSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LnkZJSN * SOAP_FMAC4 soap_get__ns1__LnkZJSN(struct soap *soap, _ns1__LnkZJSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LnkZJSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkZJSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkZJSNResponse::chkZJSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkZJSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkZJSNResponse::chkZJSNResult);
#endif
}

int _ns1__chkZJSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkZJSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkZJSNResponse(struct soap *soap, const char *tag, int id, const _ns1__chkZJSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkZJSNResponse), type))
		return soap->error;
	if (a->chkZJSNResult)
		soap_element_result(soap, "ns1:chkZJSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkZJSNResult", -1, &a->_ns1__chkZJSNResponse::chkZJSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkZJSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkZJSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkZJSNResponse * SOAP_FMAC4 soap_in__ns1__chkZJSNResponse(struct soap *soap, const char *tag, _ns1__chkZJSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkZJSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkZJSNResponse, sizeof(_ns1__chkZJSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkZJSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkZJSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkZJSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkZJSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkZJSNResult", &a->_ns1__chkZJSNResponse::chkZJSNResult, "xsd:string"))
				{	soap_flag_chkZJSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkZJSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkZJSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkZJSNResponse, SOAP_TYPE__ns1__chkZJSNResponse, sizeof(_ns1__chkZJSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkZJSNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkZJSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkZJSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkZJSNResponse *p;
	size_t k = sizeof(_ns1__chkZJSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkZJSNResponse);
		if (p)
			((_ns1__chkZJSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkZJSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkZJSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkZJSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkZJSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkZJSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkZJSNResponse(soap, tag ? tag : "ns1:chkZJSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkZJSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkZJSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkZJSNResponse * SOAP_FMAC4 soap_get__ns1__chkZJSNResponse(struct soap *soap, _ns1__chkZJSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkZJSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkZJSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkZJSN::ZJSN = NULL;
	this->_ns1__chkZJSN::StationNumber = NULL;
	this->_ns1__chkZJSN::strType = NULL;
	/* transient soap skipped */
}

void _ns1__chkZJSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkZJSN::ZJSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkZJSN::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkZJSN::strType);
#endif
}

int _ns1__chkZJSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkZJSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkZJSN(struct soap *soap, const char *tag, int id, const _ns1__chkZJSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkZJSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__chkZJSN::ZJSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__chkZJSN::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strType", -1, &a->_ns1__chkZJSN::strType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkZJSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkZJSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkZJSN * SOAP_FMAC4 soap_in__ns1__chkZJSN(struct soap *soap, const char *tag, _ns1__chkZJSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkZJSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkZJSN, sizeof(_ns1__chkZJSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkZJSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkZJSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZJSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_strType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__chkZJSN::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__chkZJSN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strType", &a->_ns1__chkZJSN::strType, "xsd:string"))
				{	soap_flag_strType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkZJSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkZJSN, SOAP_TYPE__ns1__chkZJSN, sizeof(_ns1__chkZJSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkZJSN * SOAP_FMAC2 soap_instantiate__ns1__chkZJSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkZJSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkZJSN *p;
	size_t k = sizeof(_ns1__chkZJSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkZJSN);
		if (p)
			((_ns1__chkZJSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkZJSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkZJSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkZJSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkZJSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkZJSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkZJSN(soap, tag ? tag : "ns1:chkZJSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkZJSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkZJSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkZJSN * SOAP_FMAC4 soap_get__ns1__chkZJSN(struct soap *soap, _ns1__chkZJSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkZJSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkDispensingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkDispensingResponse::chkDispensingResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkDispensingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkDispensingResponse::chkDispensingResult);
#endif
}

int _ns1__chkDispensingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkDispensingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkDispensingResponse(struct soap *soap, const char *tag, int id, const _ns1__chkDispensingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkDispensingResponse), type))
		return soap->error;
	if (a->chkDispensingResult)
		soap_element_result(soap, "ns1:chkDispensingResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkDispensingResult", -1, &a->_ns1__chkDispensingResponse::chkDispensingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkDispensingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkDispensingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkDispensingResponse * SOAP_FMAC4 soap_in__ns1__chkDispensingResponse(struct soap *soap, const char *tag, _ns1__chkDispensingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkDispensingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkDispensingResponse, sizeof(_ns1__chkDispensingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkDispensingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkDispensingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkDispensingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkDispensingResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkDispensingResult", &a->_ns1__chkDispensingResponse::chkDispensingResult, "xsd:string"))
				{	soap_flag_chkDispensingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkDispensingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkDispensingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkDispensingResponse, SOAP_TYPE__ns1__chkDispensingResponse, sizeof(_ns1__chkDispensingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkDispensingResponse * SOAP_FMAC2 soap_instantiate__ns1__chkDispensingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkDispensingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkDispensingResponse *p;
	size_t k = sizeof(_ns1__chkDispensingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkDispensingResponse);
		if (p)
			((_ns1__chkDispensingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkDispensingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkDispensingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkDispensingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkDispensingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkDispensingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkDispensingResponse(soap, tag ? tag : "ns1:chkDispensingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkDispensingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkDispensingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkDispensingResponse * SOAP_FMAC4 soap_get__ns1__chkDispensingResponse(struct soap *soap, _ns1__chkDispensingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkDispensingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkDispensing::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkDispensing::SN = NULL;
	/* transient soap skipped */
}

void _ns1__chkDispensing::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkDispensing::SN);
#endif
}

int _ns1__chkDispensing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkDispensing(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkDispensing(struct soap *soap, const char *tag, int id, const _ns1__chkDispensing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkDispensing), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__chkDispensing::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkDispensing::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkDispensing(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkDispensing * SOAP_FMAC4 soap_in__ns1__chkDispensing(struct soap *soap, const char *tag, _ns1__chkDispensing *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkDispensing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkDispensing, sizeof(_ns1__chkDispensing), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkDispensing)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkDispensing *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__chkDispensing::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkDispensing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkDispensing, SOAP_TYPE__ns1__chkDispensing, sizeof(_ns1__chkDispensing), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkDispensing * SOAP_FMAC2 soap_instantiate__ns1__chkDispensing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkDispensing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkDispensing *p;
	size_t k = sizeof(_ns1__chkDispensing);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkDispensing);
		if (p)
			((_ns1__chkDispensing*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkDispensing, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkDispensing*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkDispensing location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkDispensing, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkDispensing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkDispensing(soap, tag ? tag : "ns1:chkDispensing", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkDispensing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkDispensing(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkDispensing * SOAP_FMAC4 soap_get__ns1__chkDispensing(struct soap *soap, _ns1__chkDispensing *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkDispensing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsIotTestDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsIotTestDataResponse::InsIotTestDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsIotTestDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestDataResponse::InsIotTestDataResult);
#endif
}

int _ns1__InsIotTestDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsIotTestDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsIotTestDataResponse(struct soap *soap, const char *tag, int id, const _ns1__InsIotTestDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsIotTestDataResponse), type))
		return soap->error;
	if (a->InsIotTestDataResult)
		soap_element_result(soap, "ns1:InsIotTestDataResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsIotTestDataResult", -1, &a->_ns1__InsIotTestDataResponse::InsIotTestDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsIotTestDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsIotTestDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsIotTestDataResponse * SOAP_FMAC4 soap_in__ns1__InsIotTestDataResponse(struct soap *soap, const char *tag, _ns1__InsIotTestDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsIotTestDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsIotTestDataResponse, sizeof(_ns1__InsIotTestDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsIotTestDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsIotTestDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsIotTestDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsIotTestDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsIotTestDataResult", &a->_ns1__InsIotTestDataResponse::InsIotTestDataResult, "xsd:string"))
				{	soap_flag_InsIotTestDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsIotTestDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsIotTestDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsIotTestDataResponse, SOAP_TYPE__ns1__InsIotTestDataResponse, sizeof(_ns1__InsIotTestDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsIotTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__InsIotTestDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsIotTestDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsIotTestDataResponse *p;
	size_t k = sizeof(_ns1__InsIotTestDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsIotTestDataResponse);
		if (p)
			((_ns1__InsIotTestDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsIotTestDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsIotTestDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsIotTestDataResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsIotTestDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsIotTestDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsIotTestDataResponse(soap, tag ? tag : "ns1:InsIotTestDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsIotTestDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsIotTestDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsIotTestDataResponse * SOAP_FMAC4 soap_get__ns1__InsIotTestDataResponse(struct soap *soap, _ns1__InsIotTestDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsIotTestDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsIotTestData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsIotTestData::MoNumber = NULL;
	this->_ns1__InsIotTestData::PartNo = NULL;
	this->_ns1__InsIotTestData::StationNumber = NULL;
	this->_ns1__InsIotTestData::Barcode = NULL;
	this->_ns1__InsIotTestData::Machine = NULL;
	this->_ns1__InsIotTestData::Hole = NULL;
	this->_ns1__InsIotTestData::TestTime = NULL;
	this->_ns1__InsIotTestData::strResult = NULL;
	this->_ns1__InsIotTestData::ErrCode = NULL;
	this->_ns1__InsIotTestData::TC1 = NULL;
	this->_ns1__InsIotTestData::TC2 = NULL;
	this->_ns1__InsIotTestData::TC3 = NULL;
	this->_ns1__InsIotTestData::TC4 = NULL;
	this->_ns1__InsIotTestData::DT1 = NULL;
	this->_ns1__InsIotTestData::DT2 = NULL;
	this->_ns1__InsIotTestData::DT3 = NULL;
	this->_ns1__InsIotTestData::DT4 = NULL;
	this->_ns1__InsIotTestData::TotalTestTime = NULL;
	this->_ns1__InsIotTestData::UserID = NULL;
	this->_ns1__InsIotTestData::Memo1 = NULL;
	this->_ns1__InsIotTestData::Memo2 = NULL;
	this->_ns1__InsIotTestData::Memo3 = NULL;
	this->_ns1__InsIotTestData::Memo4 = NULL;
	this->_ns1__InsIotTestData::Memo5 = NULL;
	this->_ns1__InsIotTestData::Memo6 = NULL;
	this->_ns1__InsIotTestData::Memo7 = NULL;
	this->_ns1__InsIotTestData::Memo8 = NULL;
	this->_ns1__InsIotTestData::Memo9 = NULL;
	this->_ns1__InsIotTestData::Memo10 = NULL;
	/* transient soap skipped */
}

void _ns1__InsIotTestData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::PartNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Barcode);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Machine);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Hole);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::TestTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::strResult);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::ErrCode);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::TC1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::TC2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::TC3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::TC4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::DT1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::DT2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::DT3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::DT4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::TotalTestTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::UserID);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo5);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo6);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo7);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo8);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo9);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotTestData::Memo10);
#endif
}

int _ns1__InsIotTestData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsIotTestData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsIotTestData(struct soap *soap, const char *tag, int id, const _ns1__InsIotTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsIotTestData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__InsIotTestData::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PartNo", -1, &a->_ns1__InsIotTestData::PartNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__InsIotTestData::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Barcode", -1, &a->_ns1__InsIotTestData::Barcode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Machine", -1, &a->_ns1__InsIotTestData::Machine, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Hole", -1, &a->_ns1__InsIotTestData::Hole, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestTime", -1, &a->_ns1__InsIotTestData::TestTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strResult", -1, &a->_ns1__InsIotTestData::strResult, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ErrCode", -1, &a->_ns1__InsIotTestData::ErrCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TC1", -1, &a->_ns1__InsIotTestData::TC1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TC2", -1, &a->_ns1__InsIotTestData::TC2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TC3", -1, &a->_ns1__InsIotTestData::TC3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TC4", -1, &a->_ns1__InsIotTestData::TC4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DT1", -1, &a->_ns1__InsIotTestData::DT1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DT2", -1, &a->_ns1__InsIotTestData::DT2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DT3", -1, &a->_ns1__InsIotTestData::DT3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DT4", -1, &a->_ns1__InsIotTestData::DT4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TotalTestTime", -1, &a->_ns1__InsIotTestData::TotalTestTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:UserID", -1, &a->_ns1__InsIotTestData::UserID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo1", -1, &a->_ns1__InsIotTestData::Memo1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo2", -1, &a->_ns1__InsIotTestData::Memo2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo3", -1, &a->_ns1__InsIotTestData::Memo3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo4", -1, &a->_ns1__InsIotTestData::Memo4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo5", -1, &a->_ns1__InsIotTestData::Memo5, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo6", -1, &a->_ns1__InsIotTestData::Memo6, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo7", -1, &a->_ns1__InsIotTestData::Memo7, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo8", -1, &a->_ns1__InsIotTestData::Memo8, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo9", -1, &a->_ns1__InsIotTestData::Memo9, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Memo10", -1, &a->_ns1__InsIotTestData::Memo10, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsIotTestData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsIotTestData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsIotTestData * SOAP_FMAC4 soap_in__ns1__InsIotTestData(struct soap *soap, const char *tag, _ns1__InsIotTestData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsIotTestData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsIotTestData, sizeof(_ns1__InsIotTestData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsIotTestData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsIotTestData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_PartNo1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_Barcode1 = 1;
	size_t soap_flag_Machine1 = 1;
	size_t soap_flag_Hole1 = 1;
	size_t soap_flag_TestTime1 = 1;
	size_t soap_flag_strResult1 = 1;
	size_t soap_flag_ErrCode1 = 1;
	size_t soap_flag_TC11 = 1;
	size_t soap_flag_TC21 = 1;
	size_t soap_flag_TC31 = 1;
	size_t soap_flag_TC41 = 1;
	size_t soap_flag_DT11 = 1;
	size_t soap_flag_DT21 = 1;
	size_t soap_flag_DT31 = 1;
	size_t soap_flag_DT41 = 1;
	size_t soap_flag_TotalTestTime1 = 1;
	size_t soap_flag_UserID1 = 1;
	size_t soap_flag_Memo11 = 1;
	size_t soap_flag_Memo21 = 1;
	size_t soap_flag_Memo31 = 1;
	size_t soap_flag_Memo41 = 1;
	size_t soap_flag_Memo51 = 1;
	size_t soap_flag_Memo61 = 1;
	size_t soap_flag_Memo71 = 1;
	size_t soap_flag_Memo81 = 1;
	size_t soap_flag_Memo91 = 1;
	size_t soap_flag_Memo101 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__InsIotTestData::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_PartNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PartNo", &a->_ns1__InsIotTestData::PartNo, "xsd:string"))
				{	soap_flag_PartNo1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__InsIotTestData::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_Barcode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Barcode", &a->_ns1__InsIotTestData::Barcode, "xsd:string"))
				{	soap_flag_Barcode1--;
					continue;
				}
			}
			if (soap_flag_Machine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Machine", &a->_ns1__InsIotTestData::Machine, "xsd:string"))
				{	soap_flag_Machine1--;
					continue;
				}
			}
			if (soap_flag_Hole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Hole", &a->_ns1__InsIotTestData::Hole, "xsd:string"))
				{	soap_flag_Hole1--;
					continue;
				}
			}
			if (soap_flag_TestTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestTime", &a->_ns1__InsIotTestData::TestTime, "xsd:string"))
				{	soap_flag_TestTime1--;
					continue;
				}
			}
			if (soap_flag_strResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strResult", &a->_ns1__InsIotTestData::strResult, "xsd:string"))
				{	soap_flag_strResult1--;
					continue;
				}
			}
			if (soap_flag_ErrCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ErrCode", &a->_ns1__InsIotTestData::ErrCode, "xsd:string"))
				{	soap_flag_ErrCode1--;
					continue;
				}
			}
			if (soap_flag_TC11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TC1", &a->_ns1__InsIotTestData::TC1, "xsd:string"))
				{	soap_flag_TC11--;
					continue;
				}
			}
			if (soap_flag_TC21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TC2", &a->_ns1__InsIotTestData::TC2, "xsd:string"))
				{	soap_flag_TC21--;
					continue;
				}
			}
			if (soap_flag_TC31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TC3", &a->_ns1__InsIotTestData::TC3, "xsd:string"))
				{	soap_flag_TC31--;
					continue;
				}
			}
			if (soap_flag_TC41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TC4", &a->_ns1__InsIotTestData::TC4, "xsd:string"))
				{	soap_flag_TC41--;
					continue;
				}
			}
			if (soap_flag_DT11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DT1", &a->_ns1__InsIotTestData::DT1, "xsd:string"))
				{	soap_flag_DT11--;
					continue;
				}
			}
			if (soap_flag_DT21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DT2", &a->_ns1__InsIotTestData::DT2, "xsd:string"))
				{	soap_flag_DT21--;
					continue;
				}
			}
			if (soap_flag_DT31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DT3", &a->_ns1__InsIotTestData::DT3, "xsd:string"))
				{	soap_flag_DT31--;
					continue;
				}
			}
			if (soap_flag_DT41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DT4", &a->_ns1__InsIotTestData::DT4, "xsd:string"))
				{	soap_flag_DT41--;
					continue;
				}
			}
			if (soap_flag_TotalTestTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TotalTestTime", &a->_ns1__InsIotTestData::TotalTestTime, "xsd:string"))
				{	soap_flag_TotalTestTime1--;
					continue;
				}
			}
			if (soap_flag_UserID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UserID", &a->_ns1__InsIotTestData::UserID, "xsd:string"))
				{	soap_flag_UserID1--;
					continue;
				}
			}
			if (soap_flag_Memo11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo1", &a->_ns1__InsIotTestData::Memo1, "xsd:string"))
				{	soap_flag_Memo11--;
					continue;
				}
			}
			if (soap_flag_Memo21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo2", &a->_ns1__InsIotTestData::Memo2, "xsd:string"))
				{	soap_flag_Memo21--;
					continue;
				}
			}
			if (soap_flag_Memo31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo3", &a->_ns1__InsIotTestData::Memo3, "xsd:string"))
				{	soap_flag_Memo31--;
					continue;
				}
			}
			if (soap_flag_Memo41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo4", &a->_ns1__InsIotTestData::Memo4, "xsd:string"))
				{	soap_flag_Memo41--;
					continue;
				}
			}
			if (soap_flag_Memo51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo5", &a->_ns1__InsIotTestData::Memo5, "xsd:string"))
				{	soap_flag_Memo51--;
					continue;
				}
			}
			if (soap_flag_Memo61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo6", &a->_ns1__InsIotTestData::Memo6, "xsd:string"))
				{	soap_flag_Memo61--;
					continue;
				}
			}
			if (soap_flag_Memo71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo7", &a->_ns1__InsIotTestData::Memo7, "xsd:string"))
				{	soap_flag_Memo71--;
					continue;
				}
			}
			if (soap_flag_Memo81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo8", &a->_ns1__InsIotTestData::Memo8, "xsd:string"))
				{	soap_flag_Memo81--;
					continue;
				}
			}
			if (soap_flag_Memo91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo9", &a->_ns1__InsIotTestData::Memo9, "xsd:string"))
				{	soap_flag_Memo91--;
					continue;
				}
			}
			if (soap_flag_Memo101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Memo10", &a->_ns1__InsIotTestData::Memo10, "xsd:string"))
				{	soap_flag_Memo101--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsIotTestData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsIotTestData, SOAP_TYPE__ns1__InsIotTestData, sizeof(_ns1__InsIotTestData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsIotTestData * SOAP_FMAC2 soap_instantiate__ns1__InsIotTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsIotTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsIotTestData *p;
	size_t k = sizeof(_ns1__InsIotTestData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsIotTestData);
		if (p)
			((_ns1__InsIotTestData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsIotTestData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsIotTestData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsIotTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsIotTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsIotTestData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsIotTestData(soap, tag ? tag : "ns1:InsIotTestData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsIotTestData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsIotTestData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsIotTestData * SOAP_FMAC4 soap_get__ns1__InsIotTestData(struct soap *soap, _ns1__InsIotTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsIotTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsIotMachineRecResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsIotMachineRecResponse::InsIotMachineRecResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsIotMachineRecResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotMachineRecResponse::InsIotMachineRecResult);
#endif
}

int _ns1__InsIotMachineRecResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsIotMachineRecResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsIotMachineRecResponse(struct soap *soap, const char *tag, int id, const _ns1__InsIotMachineRecResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsIotMachineRecResponse), type))
		return soap->error;
	if (a->InsIotMachineRecResult)
		soap_element_result(soap, "ns1:InsIotMachineRecResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsIotMachineRecResult", -1, &a->_ns1__InsIotMachineRecResponse::InsIotMachineRecResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsIotMachineRecResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsIotMachineRecResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsIotMachineRecResponse * SOAP_FMAC4 soap_in__ns1__InsIotMachineRecResponse(struct soap *soap, const char *tag, _ns1__InsIotMachineRecResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsIotMachineRecResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsIotMachineRecResponse, sizeof(_ns1__InsIotMachineRecResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsIotMachineRecResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsIotMachineRecResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsIotMachineRecResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsIotMachineRecResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsIotMachineRecResult", &a->_ns1__InsIotMachineRecResponse::InsIotMachineRecResult, "xsd:string"))
				{	soap_flag_InsIotMachineRecResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsIotMachineRecResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsIotMachineRecResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsIotMachineRecResponse, SOAP_TYPE__ns1__InsIotMachineRecResponse, sizeof(_ns1__InsIotMachineRecResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsIotMachineRecResponse * SOAP_FMAC2 soap_instantiate__ns1__InsIotMachineRecResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsIotMachineRecResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsIotMachineRecResponse *p;
	size_t k = sizeof(_ns1__InsIotMachineRecResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsIotMachineRecResponse);
		if (p)
			((_ns1__InsIotMachineRecResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsIotMachineRecResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsIotMachineRecResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsIotMachineRecResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsIotMachineRecResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsIotMachineRecResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsIotMachineRecResponse(soap, tag ? tag : "ns1:InsIotMachineRecResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsIotMachineRecResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsIotMachineRecResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsIotMachineRecResponse * SOAP_FMAC4 soap_get__ns1__InsIotMachineRecResponse(struct soap *soap, _ns1__InsIotMachineRecResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsIotMachineRecResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsIotMachineRec::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsIotMachineRec::Machine = NULL;
	this->_ns1__InsIotMachineRec::Hole = NULL;
	this->_ns1__InsIotMachineRec::MoNumber = NULL;
	this->_ns1__InsIotMachineRec::strStatus = NULL;
	this->_ns1__InsIotMachineRec::ErrCode = NULL;
	/* transient soap skipped */
}

void _ns1__InsIotMachineRec::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotMachineRec::Machine);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotMachineRec::Hole);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotMachineRec::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotMachineRec::strStatus);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsIotMachineRec::ErrCode);
#endif
}

int _ns1__InsIotMachineRec::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsIotMachineRec(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsIotMachineRec(struct soap *soap, const char *tag, int id, const _ns1__InsIotMachineRec *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsIotMachineRec), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Machine", -1, &a->_ns1__InsIotMachineRec::Machine, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Hole", -1, &a->_ns1__InsIotMachineRec::Hole, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__InsIotMachineRec::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strStatus", -1, &a->_ns1__InsIotMachineRec::strStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ErrCode", -1, &a->_ns1__InsIotMachineRec::ErrCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsIotMachineRec::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsIotMachineRec(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsIotMachineRec * SOAP_FMAC4 soap_in__ns1__InsIotMachineRec(struct soap *soap, const char *tag, _ns1__InsIotMachineRec *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsIotMachineRec *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsIotMachineRec, sizeof(_ns1__InsIotMachineRec), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsIotMachineRec)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsIotMachineRec *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Machine1 = 1;
	size_t soap_flag_Hole1 = 1;
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_strStatus1 = 1;
	size_t soap_flag_ErrCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Machine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Machine", &a->_ns1__InsIotMachineRec::Machine, "xsd:string"))
				{	soap_flag_Machine1--;
					continue;
				}
			}
			if (soap_flag_Hole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Hole", &a->_ns1__InsIotMachineRec::Hole, "xsd:string"))
				{	soap_flag_Hole1--;
					continue;
				}
			}
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__InsIotMachineRec::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_strStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strStatus", &a->_ns1__InsIotMachineRec::strStatus, "xsd:string"))
				{	soap_flag_strStatus1--;
					continue;
				}
			}
			if (soap_flag_ErrCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ErrCode", &a->_ns1__InsIotMachineRec::ErrCode, "xsd:string"))
				{	soap_flag_ErrCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsIotMachineRec *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsIotMachineRec, SOAP_TYPE__ns1__InsIotMachineRec, sizeof(_ns1__InsIotMachineRec), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsIotMachineRec * SOAP_FMAC2 soap_instantiate__ns1__InsIotMachineRec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsIotMachineRec(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsIotMachineRec *p;
	size_t k = sizeof(_ns1__InsIotMachineRec);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsIotMachineRec);
		if (p)
			((_ns1__InsIotMachineRec*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsIotMachineRec, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsIotMachineRec*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsIotMachineRec location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsIotMachineRec, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsIotMachineRec::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsIotMachineRec(soap, tag ? tag : "ns1:InsIotMachineRec", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsIotMachineRec::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsIotMachineRec(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsIotMachineRec * SOAP_FMAC4 soap_get__ns1__InsIotMachineRec(struct soap *soap, _ns1__InsIotMachineRec *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsIotMachineRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLnkDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLnkDataResponse::GetLnkDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetLnkDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLnkDataResponse::GetLnkDataResult);
#endif
}

int _ns1__GetLnkDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLnkDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLnkDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLnkDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLnkDataResponse), type))
		return soap->error;
	if (a->GetLnkDataResult)
		soap_element_result(soap, "ns1:GetLnkDataResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetLnkDataResult", -1, &a->_ns1__GetLnkDataResponse::GetLnkDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLnkDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLnkDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLnkDataResponse * SOAP_FMAC4 soap_in__ns1__GetLnkDataResponse(struct soap *soap, const char *tag, _ns1__GetLnkDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLnkDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLnkDataResponse, sizeof(_ns1__GetLnkDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLnkDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLnkDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLnkDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLnkDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetLnkDataResult", &a->_ns1__GetLnkDataResponse::GetLnkDataResult, "xsd:string"))
				{	soap_flag_GetLnkDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetLnkDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLnkDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLnkDataResponse, SOAP_TYPE__ns1__GetLnkDataResponse, sizeof(_ns1__GetLnkDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLnkDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLnkDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLnkDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLnkDataResponse *p;
	size_t k = sizeof(_ns1__GetLnkDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLnkDataResponse);
		if (p)
			((_ns1__GetLnkDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLnkDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLnkDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLnkDataResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLnkDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLnkDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLnkDataResponse(soap, tag ? tag : "ns1:GetLnkDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLnkDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLnkDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLnkDataResponse * SOAP_FMAC4 soap_get__ns1__GetLnkDataResponse(struct soap *soap, _ns1__GetLnkDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLnkDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLnkData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLnkData::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetLnkData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLnkData::SN);
#endif
}

int _ns1__GetLnkData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLnkData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLnkData(struct soap *soap, const char *tag, int id, const _ns1__GetLnkData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLnkData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetLnkData::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLnkData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLnkData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLnkData * SOAP_FMAC4 soap_in__ns1__GetLnkData(struct soap *soap, const char *tag, _ns1__GetLnkData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLnkData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLnkData, sizeof(_ns1__GetLnkData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLnkData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLnkData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetLnkData::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLnkData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLnkData, SOAP_TYPE__ns1__GetLnkData, sizeof(_ns1__GetLnkData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLnkData * SOAP_FMAC2 soap_instantiate__ns1__GetLnkData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLnkData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLnkData *p;
	size_t k = sizeof(_ns1__GetLnkData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLnkData);
		if (p)
			((_ns1__GetLnkData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLnkData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLnkData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLnkData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLnkData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLnkData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLnkData(soap, tag ? tag : "ns1:GetLnkData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLnkData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLnkData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLnkData * SOAP_FMAC4 soap_get__ns1__GetLnkData(struct soap *soap, _ns1__GetLnkData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLnkData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTestValueResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTestValueResponse::GetTestValueResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetTestValueResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetTestValueResponse::GetTestValueResult);
#endif
}

int _ns1__GetTestValueResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTestValueResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTestValueResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTestValueResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTestValueResponse), type))
		return soap->error;
	if (a->GetTestValueResult)
		soap_element_result(soap, "ns1:GetTestValueResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetTestValueResult", -1, &a->_ns1__GetTestValueResponse::GetTestValueResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTestValueResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTestValueResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTestValueResponse * SOAP_FMAC4 soap_in__ns1__GetTestValueResponse(struct soap *soap, const char *tag, _ns1__GetTestValueResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTestValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTestValueResponse, sizeof(_ns1__GetTestValueResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTestValueResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTestValueResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetTestValueResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTestValueResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetTestValueResult", &a->_ns1__GetTestValueResponse::GetTestValueResult, "xsd:string"))
				{	soap_flag_GetTestValueResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetTestValueResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTestValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTestValueResponse, SOAP_TYPE__ns1__GetTestValueResponse, sizeof(_ns1__GetTestValueResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTestValueResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTestValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTestValueResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTestValueResponse *p;
	size_t k = sizeof(_ns1__GetTestValueResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetTestValueResponse);
		if (p)
			((_ns1__GetTestValueResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetTestValueResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetTestValueResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTestValueResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetTestValueResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetTestValueResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTestValueResponse(soap, tag ? tag : "ns1:GetTestValueResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTestValueResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTestValueResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTestValueResponse * SOAP_FMAC4 soap_get__ns1__GetTestValueResponse(struct soap *soap, _ns1__GetTestValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTestValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTestValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTestValue::SPC = NULL;
	this->_ns1__GetTestValue::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetTestValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetTestValue::SPC);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetTestValue::SN);
#endif
}

int _ns1__GetTestValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTestValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTestValue(struct soap *soap, const char *tag, int id, const _ns1__GetTestValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTestValue), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SPC", -1, &a->_ns1__GetTestValue::SPC, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetTestValue::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTestValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTestValue(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTestValue * SOAP_FMAC4 soap_in__ns1__GetTestValue(struct soap *soap, const char *tag, _ns1__GetTestValue *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTestValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTestValue, sizeof(_ns1__GetTestValue), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTestValue)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTestValue *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SPC1 = 1;
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SPC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SPC", &a->_ns1__GetTestValue::SPC, "xsd:string"))
				{	soap_flag_SPC1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetTestValue::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTestValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTestValue, SOAP_TYPE__ns1__GetTestValue, sizeof(_ns1__GetTestValue), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTestValue * SOAP_FMAC2 soap_instantiate__ns1__GetTestValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTestValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTestValue *p;
	size_t k = sizeof(_ns1__GetTestValue);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetTestValue);
		if (p)
			((_ns1__GetTestValue*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetTestValue, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetTestValue*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTestValue location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetTestValue, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetTestValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTestValue(soap, tag ? tag : "ns1:GetTestValue", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTestValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTestValue(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTestValue * SOAP_FMAC4 soap_get__ns1__GetTestValue(struct soap *soap, _ns1__GetTestValue *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTestValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMoBaseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMoBaseResponse::GetMoBaseResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetMoBaseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetMoBaseResponse::GetMoBaseResult);
#endif
}

int _ns1__GetMoBaseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMoBaseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMoBaseResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMoBaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMoBaseResponse), type))
		return soap->error;
	if (a->GetMoBaseResult)
		soap_element_result(soap, "ns1:GetMoBaseResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetMoBaseResult", -1, &a->_ns1__GetMoBaseResponse::GetMoBaseResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMoBaseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMoBaseResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMoBaseResponse * SOAP_FMAC4 soap_in__ns1__GetMoBaseResponse(struct soap *soap, const char *tag, _ns1__GetMoBaseResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMoBaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMoBaseResponse, sizeof(_ns1__GetMoBaseResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMoBaseResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMoBaseResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMoBaseResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMoBaseResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetMoBaseResult", &a->_ns1__GetMoBaseResponse::GetMoBaseResult, "xsd:string"))
				{	soap_flag_GetMoBaseResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMoBaseResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMoBaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMoBaseResponse, SOAP_TYPE__ns1__GetMoBaseResponse, sizeof(_ns1__GetMoBaseResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMoBaseResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMoBaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMoBaseResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMoBaseResponse *p;
	size_t k = sizeof(_ns1__GetMoBaseResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetMoBaseResponse);
		if (p)
			((_ns1__GetMoBaseResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetMoBaseResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetMoBaseResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMoBaseResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetMoBaseResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetMoBaseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMoBaseResponse(soap, tag ? tag : "ns1:GetMoBaseResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMoBaseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMoBaseResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMoBaseResponse * SOAP_FMAC4 soap_get__ns1__GetMoBaseResponse(struct soap *soap, _ns1__GetMoBaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMoBaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMoBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMoBase::MoNumber = NULL;
	/* transient soap skipped */
}

void _ns1__GetMoBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetMoBase::MoNumber);
#endif
}

int _ns1__GetMoBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMoBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMoBase(struct soap *soap, const char *tag, int id, const _ns1__GetMoBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMoBase), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__GetMoBase::MoNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMoBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMoBase(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMoBase * SOAP_FMAC4 soap_in__ns1__GetMoBase(struct soap *soap, const char *tag, _ns1__GetMoBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMoBase, sizeof(_ns1__GetMoBase), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMoBase)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMoBase *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__GetMoBase::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMoBase, SOAP_TYPE__ns1__GetMoBase, sizeof(_ns1__GetMoBase), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMoBase * SOAP_FMAC2 soap_instantiate__ns1__GetMoBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMoBase(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMoBase *p;
	size_t k = sizeof(_ns1__GetMoBase);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetMoBase);
		if (p)
			((_ns1__GetMoBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetMoBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetMoBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMoBase location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetMoBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetMoBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMoBase(soap, tag ? tag : "ns1:GetMoBase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMoBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMoBase(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMoBase * SOAP_FMAC4 soap_get__ns1__GetMoBase(struct soap *soap, _ns1__GetMoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdSnRecInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdSnRecInfoResponse::UpdSnRecInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__UpdSnRecInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfoResponse::UpdSnRecInfoResult);
#endif
}

int _ns1__UpdSnRecInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdSnRecInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdSnRecInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdSnRecInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdSnRecInfoResponse), type))
		return soap->error;
	if (a->UpdSnRecInfoResult)
		soap_element_result(soap, "ns1:UpdSnRecInfoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:UpdSnRecInfoResult", -1, &a->_ns1__UpdSnRecInfoResponse::UpdSnRecInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdSnRecInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdSnRecInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdSnRecInfoResponse * SOAP_FMAC4 soap_in__ns1__UpdSnRecInfoResponse(struct soap *soap, const char *tag, _ns1__UpdSnRecInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdSnRecInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdSnRecInfoResponse, sizeof(_ns1__UpdSnRecInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdSnRecInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdSnRecInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpdSnRecInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdSnRecInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UpdSnRecInfoResult", &a->_ns1__UpdSnRecInfoResponse::UpdSnRecInfoResult, "xsd:string"))
				{	soap_flag_UpdSnRecInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UpdSnRecInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdSnRecInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdSnRecInfoResponse, SOAP_TYPE__ns1__UpdSnRecInfoResponse, sizeof(_ns1__UpdSnRecInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdSnRecInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdSnRecInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdSnRecInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdSnRecInfoResponse *p;
	size_t k = sizeof(_ns1__UpdSnRecInfoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdSnRecInfoResponse);
		if (p)
			((_ns1__UpdSnRecInfoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdSnRecInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdSnRecInfoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdSnRecInfoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdSnRecInfoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdSnRecInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdSnRecInfoResponse(soap, tag ? tag : "ns1:UpdSnRecInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdSnRecInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdSnRecInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdSnRecInfoResponse * SOAP_FMAC4 soap_get__ns1__UpdSnRecInfoResponse(struct soap *soap, _ns1__UpdSnRecInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdSnRecInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdSnRecInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdSnRecInfo::MO = NULL;
	this->_ns1__UpdSnRecInfo::PartNo = NULL;
	this->_ns1__UpdSnRecInfo::SN = NULL;
	this->_ns1__UpdSnRecInfo::VD = NULL;
	this->_ns1__UpdSnRecInfo::StationNo = NULL;
	this->_ns1__UpdSnRecInfo::BoxSN = NULL;
	this->_ns1__UpdSnRecInfo::PkgTime = NULL;
	/* transient soap skipped */
}

void _ns1__UpdSnRecInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::MO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::PartNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::VD);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::StationNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::BoxSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdSnRecInfo::PkgTime);
#endif
}

int _ns1__UpdSnRecInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdSnRecInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdSnRecInfo(struct soap *soap, const char *tag, int id, const _ns1__UpdSnRecInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdSnRecInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__UpdSnRecInfo::MO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PartNo", -1, &a->_ns1__UpdSnRecInfo::PartNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__UpdSnRecInfo::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VD", -1, &a->_ns1__UpdSnRecInfo::VD, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNo", -1, &a->_ns1__UpdSnRecInfo::StationNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxSN", -1, &a->_ns1__UpdSnRecInfo::BoxSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PkgTime", -1, &a->_ns1__UpdSnRecInfo::PkgTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdSnRecInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdSnRecInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdSnRecInfo * SOAP_FMAC4 soap_in__ns1__UpdSnRecInfo(struct soap *soap, const char *tag, _ns1__UpdSnRecInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdSnRecInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdSnRecInfo, sizeof(_ns1__UpdSnRecInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdSnRecInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdSnRecInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MO1 = 1;
	size_t soap_flag_PartNo1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_VD1 = 1;
	size_t soap_flag_StationNo1 = 1;
	size_t soap_flag_BoxSN1 = 1;
	size_t soap_flag_PkgTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__UpdSnRecInfo::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap_flag_PartNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PartNo", &a->_ns1__UpdSnRecInfo::PartNo, "xsd:string"))
				{	soap_flag_PartNo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__UpdSnRecInfo::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_VD1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VD", &a->_ns1__UpdSnRecInfo::VD, "xsd:string"))
				{	soap_flag_VD1--;
					continue;
				}
			}
			if (soap_flag_StationNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNo", &a->_ns1__UpdSnRecInfo::StationNo, "xsd:string"))
				{	soap_flag_StationNo1--;
					continue;
				}
			}
			if (soap_flag_BoxSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxSN", &a->_ns1__UpdSnRecInfo::BoxSN, "xsd:string"))
				{	soap_flag_BoxSN1--;
					continue;
				}
			}
			if (soap_flag_PkgTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PkgTime", &a->_ns1__UpdSnRecInfo::PkgTime, "xsd:string"))
				{	soap_flag_PkgTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdSnRecInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdSnRecInfo, SOAP_TYPE__ns1__UpdSnRecInfo, sizeof(_ns1__UpdSnRecInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdSnRecInfo * SOAP_FMAC2 soap_instantiate__ns1__UpdSnRecInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdSnRecInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdSnRecInfo *p;
	size_t k = sizeof(_ns1__UpdSnRecInfo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdSnRecInfo);
		if (p)
			((_ns1__UpdSnRecInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdSnRecInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdSnRecInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdSnRecInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdSnRecInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdSnRecInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdSnRecInfo(soap, tag ? tag : "ns1:UpdSnRecInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdSnRecInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdSnRecInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdSnRecInfo * SOAP_FMAC4 soap_get__ns1__UpdSnRecInfo(struct soap *soap, _ns1__UpdSnRecInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdSnRecInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsBoxInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsBoxInfoResponse::InsBoxInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsBoxInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfoResponse::InsBoxInfoResult);
#endif
}

int _ns1__InsBoxInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsBoxInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsBoxInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InsBoxInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsBoxInfoResponse), type))
		return soap->error;
	if (a->InsBoxInfoResult)
		soap_element_result(soap, "ns1:InsBoxInfoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsBoxInfoResult", -1, &a->_ns1__InsBoxInfoResponse::InsBoxInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsBoxInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsBoxInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsBoxInfoResponse * SOAP_FMAC4 soap_in__ns1__InsBoxInfoResponse(struct soap *soap, const char *tag, _ns1__InsBoxInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsBoxInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsBoxInfoResponse, sizeof(_ns1__InsBoxInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsBoxInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsBoxInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsBoxInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsBoxInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsBoxInfoResult", &a->_ns1__InsBoxInfoResponse::InsBoxInfoResult, "xsd:string"))
				{	soap_flag_InsBoxInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsBoxInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsBoxInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsBoxInfoResponse, SOAP_TYPE__ns1__InsBoxInfoResponse, sizeof(_ns1__InsBoxInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsBoxInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InsBoxInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsBoxInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsBoxInfoResponse *p;
	size_t k = sizeof(_ns1__InsBoxInfoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsBoxInfoResponse);
		if (p)
			((_ns1__InsBoxInfoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsBoxInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsBoxInfoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsBoxInfoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsBoxInfoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsBoxInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsBoxInfoResponse(soap, tag ? tag : "ns1:InsBoxInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsBoxInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsBoxInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsBoxInfoResponse * SOAP_FMAC4 soap_get__ns1__InsBoxInfoResponse(struct soap *soap, _ns1__InsBoxInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsBoxInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsBoxInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsBoxInfo::MO = NULL;
	this->_ns1__InsBoxInfo::PartNo = NULL;
	this->_ns1__InsBoxInfo::VD = NULL;
	this->_ns1__InsBoxInfo::StationNo = NULL;
	this->_ns1__InsBoxInfo::BoxSN = NULL;
	soap_default_int(soap, &this->_ns1__InsBoxInfo::TargetQty);
	soap_default_int(soap, &this->_ns1__InsBoxInfo::PkgQty);
	this->_ns1__InsBoxInfo::CrePkgTime = NULL;
	this->_ns1__InsBoxInfo::EndPkgTime = NULL;
	/* transient soap skipped */
}

void _ns1__InsBoxInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::MO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::PartNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::VD);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::StationNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::BoxSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::CrePkgTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxInfo::EndPkgTime);
#endif
}

int _ns1__InsBoxInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsBoxInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsBoxInfo(struct soap *soap, const char *tag, int id, const _ns1__InsBoxInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsBoxInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__InsBoxInfo::MO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PartNo", -1, &a->_ns1__InsBoxInfo::PartNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VD", -1, &a->_ns1__InsBoxInfo::VD, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNo", -1, &a->_ns1__InsBoxInfo::StationNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxSN", -1, &a->_ns1__InsBoxInfo::BoxSN, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:TargetQty", -1, &a->_ns1__InsBoxInfo::TargetQty, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PkgQty", -1, &a->_ns1__InsBoxInfo::PkgQty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CrePkgTime", -1, &a->_ns1__InsBoxInfo::CrePkgTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EndPkgTime", -1, &a->_ns1__InsBoxInfo::EndPkgTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsBoxInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsBoxInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsBoxInfo * SOAP_FMAC4 soap_in__ns1__InsBoxInfo(struct soap *soap, const char *tag, _ns1__InsBoxInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsBoxInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsBoxInfo, sizeof(_ns1__InsBoxInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsBoxInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsBoxInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MO1 = 1;
	size_t soap_flag_PartNo1 = 1;
	size_t soap_flag_VD1 = 1;
	size_t soap_flag_StationNo1 = 1;
	size_t soap_flag_BoxSN1 = 1;
	size_t soap_flag_TargetQty1 = 1;
	size_t soap_flag_PkgQty1 = 1;
	size_t soap_flag_CrePkgTime1 = 1;
	size_t soap_flag_EndPkgTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__InsBoxInfo::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap_flag_PartNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PartNo", &a->_ns1__InsBoxInfo::PartNo, "xsd:string"))
				{	soap_flag_PartNo1--;
					continue;
				}
			}
			if (soap_flag_VD1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VD", &a->_ns1__InsBoxInfo::VD, "xsd:string"))
				{	soap_flag_VD1--;
					continue;
				}
			}
			if (soap_flag_StationNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNo", &a->_ns1__InsBoxInfo::StationNo, "xsd:string"))
				{	soap_flag_StationNo1--;
					continue;
				}
			}
			if (soap_flag_BoxSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxSN", &a->_ns1__InsBoxInfo::BoxSN, "xsd:string"))
				{	soap_flag_BoxSN1--;
					continue;
				}
			}
			if (soap_flag_TargetQty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:TargetQty", &a->_ns1__InsBoxInfo::TargetQty, "xsd:int"))
				{	soap_flag_TargetQty1--;
					continue;
				}
			}
			if (soap_flag_PkgQty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:PkgQty", &a->_ns1__InsBoxInfo::PkgQty, "xsd:int"))
				{	soap_flag_PkgQty1--;
					continue;
				}
			}
			if (soap_flag_CrePkgTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CrePkgTime", &a->_ns1__InsBoxInfo::CrePkgTime, "xsd:string"))
				{	soap_flag_CrePkgTime1--;
					continue;
				}
			}
			if (soap_flag_EndPkgTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EndPkgTime", &a->_ns1__InsBoxInfo::EndPkgTime, "xsd:string"))
				{	soap_flag_EndPkgTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TargetQty1 > 0 || soap_flag_PkgQty1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InsBoxInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsBoxInfo, SOAP_TYPE__ns1__InsBoxInfo, sizeof(_ns1__InsBoxInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsBoxInfo * SOAP_FMAC2 soap_instantiate__ns1__InsBoxInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsBoxInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsBoxInfo *p;
	size_t k = sizeof(_ns1__InsBoxInfo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsBoxInfo);
		if (p)
			((_ns1__InsBoxInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsBoxInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsBoxInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsBoxInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsBoxInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsBoxInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsBoxInfo(soap, tag ? tag : "ns1:InsBoxInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsBoxInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsBoxInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsBoxInfo * SOAP_FMAC4 soap_get__ns1__InsBoxInfo(struct soap *soap, _ns1__InsBoxInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsBoxInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsLnkOutSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsLnkOutSNResponse::InsLnkOutSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsLnkOutSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLnkOutSNResponse::InsLnkOutSNResult);
#endif
}

int _ns1__InsLnkOutSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsLnkOutSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsLnkOutSNResponse(struct soap *soap, const char *tag, int id, const _ns1__InsLnkOutSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsLnkOutSNResponse), type))
		return soap->error;
	if (a->InsLnkOutSNResult)
		soap_element_result(soap, "ns1:InsLnkOutSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsLnkOutSNResult", -1, &a->_ns1__InsLnkOutSNResponse::InsLnkOutSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsLnkOutSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsLnkOutSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsLnkOutSNResponse * SOAP_FMAC4 soap_in__ns1__InsLnkOutSNResponse(struct soap *soap, const char *tag, _ns1__InsLnkOutSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsLnkOutSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsLnkOutSNResponse, sizeof(_ns1__InsLnkOutSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsLnkOutSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsLnkOutSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsLnkOutSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsLnkOutSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsLnkOutSNResult", &a->_ns1__InsLnkOutSNResponse::InsLnkOutSNResult, "xsd:string"))
				{	soap_flag_InsLnkOutSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsLnkOutSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsLnkOutSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsLnkOutSNResponse, SOAP_TYPE__ns1__InsLnkOutSNResponse, sizeof(_ns1__InsLnkOutSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsLnkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__InsLnkOutSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsLnkOutSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsLnkOutSNResponse *p;
	size_t k = sizeof(_ns1__InsLnkOutSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsLnkOutSNResponse);
		if (p)
			((_ns1__InsLnkOutSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsLnkOutSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsLnkOutSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsLnkOutSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsLnkOutSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsLnkOutSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsLnkOutSNResponse(soap, tag ? tag : "ns1:InsLnkOutSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsLnkOutSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsLnkOutSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsLnkOutSNResponse * SOAP_FMAC4 soap_get__ns1__InsLnkOutSNResponse(struct soap *soap, _ns1__InsLnkOutSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsLnkOutSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsLnkOutSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsLnkOutSN::empNO = NULL;
	this->_ns1__InsLnkOutSN::SN = NULL;
	this->_ns1__InsLnkOutSN::LnkSN = NULL;
	/* transient soap skipped */
}

void _ns1__InsLnkOutSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLnkOutSN::empNO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLnkOutSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLnkOutSN::LnkSN);
#endif
}

int _ns1__InsLnkOutSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsLnkOutSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsLnkOutSN(struct soap *soap, const char *tag, int id, const _ns1__InsLnkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsLnkOutSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:empNO", -1, &a->_ns1__InsLnkOutSN::empNO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsLnkOutSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkSN", -1, &a->_ns1__InsLnkOutSN::LnkSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsLnkOutSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsLnkOutSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsLnkOutSN * SOAP_FMAC4 soap_in__ns1__InsLnkOutSN(struct soap *soap, const char *tag, _ns1__InsLnkOutSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsLnkOutSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsLnkOutSN, sizeof(_ns1__InsLnkOutSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsLnkOutSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsLnkOutSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_empNO1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_LnkSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_empNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:empNO", &a->_ns1__InsLnkOutSN::empNO, "xsd:string"))
				{	soap_flag_empNO1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsLnkOutSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_LnkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkSN", &a->_ns1__InsLnkOutSN::LnkSN, "xsd:string"))
				{	soap_flag_LnkSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsLnkOutSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsLnkOutSN, SOAP_TYPE__ns1__InsLnkOutSN, sizeof(_ns1__InsLnkOutSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsLnkOutSN * SOAP_FMAC2 soap_instantiate__ns1__InsLnkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsLnkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsLnkOutSN *p;
	size_t k = sizeof(_ns1__InsLnkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsLnkOutSN);
		if (p)
			((_ns1__InsLnkOutSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsLnkOutSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsLnkOutSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsLnkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsLnkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsLnkOutSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsLnkOutSN(soap, tag ? tag : "ns1:InsLnkOutSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsLnkOutSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsLnkOutSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsLnkOutSN * SOAP_FMAC4 soap_get__ns1__InsLnkOutSN(struct soap *soap, _ns1__InsLnkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsLnkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsSNStationEmpResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsSNStationEmpResponse::InsSNStationEmpResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsSNStationEmpResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNStationEmpResponse::InsSNStationEmpResult);
#endif
}

int _ns1__InsSNStationEmpResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsSNStationEmpResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsSNStationEmpResponse(struct soap *soap, const char *tag, int id, const _ns1__InsSNStationEmpResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsSNStationEmpResponse), type))
		return soap->error;
	if (a->InsSNStationEmpResult)
		soap_element_result(soap, "ns1:InsSNStationEmpResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsSNStationEmpResult", -1, &a->_ns1__InsSNStationEmpResponse::InsSNStationEmpResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsSNStationEmpResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsSNStationEmpResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsSNStationEmpResponse * SOAP_FMAC4 soap_in__ns1__InsSNStationEmpResponse(struct soap *soap, const char *tag, _ns1__InsSNStationEmpResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsSNStationEmpResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsSNStationEmpResponse, sizeof(_ns1__InsSNStationEmpResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsSNStationEmpResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsSNStationEmpResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsSNStationEmpResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsSNStationEmpResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsSNStationEmpResult", &a->_ns1__InsSNStationEmpResponse::InsSNStationEmpResult, "xsd:string"))
				{	soap_flag_InsSNStationEmpResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsSNStationEmpResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsSNStationEmpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsSNStationEmpResponse, SOAP_TYPE__ns1__InsSNStationEmpResponse, sizeof(_ns1__InsSNStationEmpResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsSNStationEmpResponse * SOAP_FMAC2 soap_instantiate__ns1__InsSNStationEmpResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsSNStationEmpResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsSNStationEmpResponse *p;
	size_t k = sizeof(_ns1__InsSNStationEmpResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsSNStationEmpResponse);
		if (p)
			((_ns1__InsSNStationEmpResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsSNStationEmpResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsSNStationEmpResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsSNStationEmpResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsSNStationEmpResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsSNStationEmpResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsSNStationEmpResponse(soap, tag ? tag : "ns1:InsSNStationEmpResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsSNStationEmpResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsSNStationEmpResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsSNStationEmpResponse * SOAP_FMAC4 soap_get__ns1__InsSNStationEmpResponse(struct soap *soap, _ns1__InsSNStationEmpResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsSNStationEmpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsSNStationEmp::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsSNStationEmp::SN = NULL;
	this->_ns1__InsSNStationEmp::EmpNo = NULL;
	this->_ns1__InsSNStationEmp::Station = NULL;
	/* transient soap skipped */
}

void _ns1__InsSNStationEmp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNStationEmp::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNStationEmp::EmpNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNStationEmp::Station);
#endif
}

int _ns1__InsSNStationEmp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsSNStationEmp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsSNStationEmp(struct soap *soap, const char *tag, int id, const _ns1__InsSNStationEmp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsSNStationEmp), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsSNStationEmp::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EmpNo", -1, &a->_ns1__InsSNStationEmp::EmpNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__InsSNStationEmp::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsSNStationEmp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsSNStationEmp(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsSNStationEmp * SOAP_FMAC4 soap_in__ns1__InsSNStationEmp(struct soap *soap, const char *tag, _ns1__InsSNStationEmp *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsSNStationEmp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsSNStationEmp, sizeof(_ns1__InsSNStationEmp), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsSNStationEmp)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsSNStationEmp *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_EmpNo1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsSNStationEmp::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_EmpNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EmpNo", &a->_ns1__InsSNStationEmp::EmpNo, "xsd:string"))
				{	soap_flag_EmpNo1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__InsSNStationEmp::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsSNStationEmp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsSNStationEmp, SOAP_TYPE__ns1__InsSNStationEmp, sizeof(_ns1__InsSNStationEmp), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsSNStationEmp * SOAP_FMAC2 soap_instantiate__ns1__InsSNStationEmp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsSNStationEmp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsSNStationEmp *p;
	size_t k = sizeof(_ns1__InsSNStationEmp);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsSNStationEmp);
		if (p)
			((_ns1__InsSNStationEmp*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsSNStationEmp, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsSNStationEmp*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsSNStationEmp location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsSNStationEmp, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsSNStationEmp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsSNStationEmp(soap, tag ? tag : "ns1:InsSNStationEmp", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsSNStationEmp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsSNStationEmp(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsSNStationEmp * SOAP_FMAC4 soap_get__ns1__InsSNStationEmp(struct soap *soap, _ns1__InsSNStationEmp *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsSNStationEmp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelBoxLnkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CancelBoxLnkResponse::CancelBoxLnkResult = NULL;
	/* transient soap skipped */
}

void _ns1__CancelBoxLnkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelBoxLnkResponse::CancelBoxLnkResult);
#endif
}

int _ns1__CancelBoxLnkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelBoxLnkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelBoxLnkResponse(struct soap *soap, const char *tag, int id, const _ns1__CancelBoxLnkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelBoxLnkResponse), type))
		return soap->error;
	if (a->CancelBoxLnkResult)
		soap_element_result(soap, "ns1:CancelBoxLnkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:CancelBoxLnkResult", -1, &a->_ns1__CancelBoxLnkResponse::CancelBoxLnkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelBoxLnkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelBoxLnkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelBoxLnkResponse * SOAP_FMAC4 soap_in__ns1__CancelBoxLnkResponse(struct soap *soap, const char *tag, _ns1__CancelBoxLnkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelBoxLnkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelBoxLnkResponse, sizeof(_ns1__CancelBoxLnkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CancelBoxLnkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CancelBoxLnkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CancelBoxLnkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CancelBoxLnkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CancelBoxLnkResult", &a->_ns1__CancelBoxLnkResponse::CancelBoxLnkResult, "xsd:string"))
				{	soap_flag_CancelBoxLnkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CancelBoxLnkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CancelBoxLnkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelBoxLnkResponse, SOAP_TYPE__ns1__CancelBoxLnkResponse, sizeof(_ns1__CancelBoxLnkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelBoxLnkResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelBoxLnkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelBoxLnkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelBoxLnkResponse *p;
	size_t k = sizeof(_ns1__CancelBoxLnkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelBoxLnkResponse);
		if (p)
			((_ns1__CancelBoxLnkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelBoxLnkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelBoxLnkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelBoxLnkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelBoxLnkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelBoxLnkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CancelBoxLnkResponse(soap, tag ? tag : "ns1:CancelBoxLnkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelBoxLnkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelBoxLnkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelBoxLnkResponse * SOAP_FMAC4 soap_get__ns1__CancelBoxLnkResponse(struct soap *soap, _ns1__CancelBoxLnkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelBoxLnkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelBoxLnk::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CancelBoxLnk::EmpNo = NULL;
	this->_ns1__CancelBoxLnk::BoxNo = NULL;
	/* transient soap skipped */
}

void _ns1__CancelBoxLnk::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelBoxLnk::EmpNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CancelBoxLnk::BoxNo);
#endif
}

int _ns1__CancelBoxLnk::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelBoxLnk(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelBoxLnk(struct soap *soap, const char *tag, int id, const _ns1__CancelBoxLnk *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelBoxLnk), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EmpNo", -1, &a->_ns1__CancelBoxLnk::EmpNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__CancelBoxLnk::BoxNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelBoxLnk::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelBoxLnk(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelBoxLnk * SOAP_FMAC4 soap_in__ns1__CancelBoxLnk(struct soap *soap, const char *tag, _ns1__CancelBoxLnk *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelBoxLnk *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelBoxLnk, sizeof(_ns1__CancelBoxLnk), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CancelBoxLnk)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CancelBoxLnk *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EmpNo1 = 1;
	size_t soap_flag_BoxNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EmpNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EmpNo", &a->_ns1__CancelBoxLnk::EmpNo, "xsd:string"))
				{	soap_flag_EmpNo1--;
					continue;
				}
			}
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__CancelBoxLnk::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CancelBoxLnk *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelBoxLnk, SOAP_TYPE__ns1__CancelBoxLnk, sizeof(_ns1__CancelBoxLnk), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelBoxLnk * SOAP_FMAC2 soap_instantiate__ns1__CancelBoxLnk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelBoxLnk(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelBoxLnk *p;
	size_t k = sizeof(_ns1__CancelBoxLnk);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelBoxLnk);
		if (p)
			((_ns1__CancelBoxLnk*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelBoxLnk, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelBoxLnk*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelBoxLnk location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelBoxLnk, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelBoxLnk::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CancelBoxLnk(soap, tag ? tag : "ns1:CancelBoxLnk", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelBoxLnk::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelBoxLnk(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelBoxLnk * SOAP_FMAC4 soap_get__ns1__CancelBoxLnk(struct soap *soap, _ns1__CancelBoxLnk *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelBoxLnk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutStationbyBoxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutStationbyBoxResponse::OutStationbyBoxResult = NULL;
	/* transient soap skipped */
}

void _ns1__OutStationbyBoxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutStationbyBoxResponse::OutStationbyBoxResult);
#endif
}

int _ns1__OutStationbyBoxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutStationbyBoxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutStationbyBoxResponse(struct soap *soap, const char *tag, int id, const _ns1__OutStationbyBoxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutStationbyBoxResponse), type))
		return soap->error;
	if (a->OutStationbyBoxResult)
		soap_element_result(soap, "ns1:OutStationbyBoxResult");
	if (soap_out_PointerTostd__string(soap, "ns1:OutStationbyBoxResult", -1, &a->_ns1__OutStationbyBoxResponse::OutStationbyBoxResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutStationbyBoxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OutStationbyBoxResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutStationbyBoxResponse * SOAP_FMAC4 soap_in__ns1__OutStationbyBoxResponse(struct soap *soap, const char *tag, _ns1__OutStationbyBoxResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutStationbyBoxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutStationbyBoxResponse, sizeof(_ns1__OutStationbyBoxResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutStationbyBoxResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutStationbyBoxResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OutStationbyBoxResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutStationbyBoxResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OutStationbyBoxResult", &a->_ns1__OutStationbyBoxResponse::OutStationbyBoxResult, "xsd:string"))
				{	soap_flag_OutStationbyBoxResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OutStationbyBoxResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutStationbyBoxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutStationbyBoxResponse, SOAP_TYPE__ns1__OutStationbyBoxResponse, sizeof(_ns1__OutStationbyBoxResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutStationbyBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__OutStationbyBoxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutStationbyBoxResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutStationbyBoxResponse *p;
	size_t k = sizeof(_ns1__OutStationbyBoxResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OutStationbyBoxResponse);
		if (p)
			((_ns1__OutStationbyBoxResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OutStationbyBoxResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OutStationbyBoxResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutStationbyBoxResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OutStationbyBoxResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OutStationbyBoxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutStationbyBoxResponse(soap, tag ? tag : "ns1:OutStationbyBoxResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutStationbyBoxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutStationbyBoxResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutStationbyBoxResponse * SOAP_FMAC4 soap_get__ns1__OutStationbyBoxResponse(struct soap *soap, _ns1__OutStationbyBoxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutStationbyBoxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OutStationbyBox::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OutStationbyBox::EmpNo = NULL;
	this->_ns1__OutStationbyBox::BoxNo = NULL;
	this->_ns1__OutStationbyBox::Station = NULL;
	/* transient soap skipped */
}

void _ns1__OutStationbyBox::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutStationbyBox::EmpNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutStationbyBox::BoxNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__OutStationbyBox::Station);
#endif
}

int _ns1__OutStationbyBox::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OutStationbyBox(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OutStationbyBox(struct soap *soap, const char *tag, int id, const _ns1__OutStationbyBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OutStationbyBox), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EmpNo", -1, &a->_ns1__OutStationbyBox::EmpNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__OutStationbyBox::BoxNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__OutStationbyBox::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OutStationbyBox::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OutStationbyBox(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OutStationbyBox * SOAP_FMAC4 soap_in__ns1__OutStationbyBox(struct soap *soap, const char *tag, _ns1__OutStationbyBox *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OutStationbyBox *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OutStationbyBox, sizeof(_ns1__OutStationbyBox), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OutStationbyBox)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OutStationbyBox *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EmpNo1 = 1;
	size_t soap_flag_BoxNo1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EmpNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EmpNo", &a->_ns1__OutStationbyBox::EmpNo, "xsd:string"))
				{	soap_flag_EmpNo1--;
					continue;
				}
			}
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__OutStationbyBox::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__OutStationbyBox::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OutStationbyBox *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OutStationbyBox, SOAP_TYPE__ns1__OutStationbyBox, sizeof(_ns1__OutStationbyBox), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OutStationbyBox * SOAP_FMAC2 soap_instantiate__ns1__OutStationbyBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OutStationbyBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OutStationbyBox *p;
	size_t k = sizeof(_ns1__OutStationbyBox);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OutStationbyBox);
		if (p)
			((_ns1__OutStationbyBox*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OutStationbyBox, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OutStationbyBox*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OutStationbyBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OutStationbyBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OutStationbyBox::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OutStationbyBox(soap, tag ? tag : "ns1:OutStationbyBox", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OutStationbyBox::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OutStationbyBox(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OutStationbyBox * SOAP_FMAC4 soap_get__ns1__OutStationbyBox(struct soap *soap, _ns1__OutStationbyBox *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OutStationbyBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InStationbyBoxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InStationbyBoxResponse::InStationbyBoxResult = NULL;
	/* transient soap skipped */
}

void _ns1__InStationbyBoxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InStationbyBoxResponse::InStationbyBoxResult);
#endif
}

int _ns1__InStationbyBoxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InStationbyBoxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InStationbyBoxResponse(struct soap *soap, const char *tag, int id, const _ns1__InStationbyBoxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InStationbyBoxResponse), type))
		return soap->error;
	if (a->InStationbyBoxResult)
		soap_element_result(soap, "ns1:InStationbyBoxResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InStationbyBoxResult", -1, &a->_ns1__InStationbyBoxResponse::InStationbyBoxResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InStationbyBoxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InStationbyBoxResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InStationbyBoxResponse * SOAP_FMAC4 soap_in__ns1__InStationbyBoxResponse(struct soap *soap, const char *tag, _ns1__InStationbyBoxResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InStationbyBoxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InStationbyBoxResponse, sizeof(_ns1__InStationbyBoxResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InStationbyBoxResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InStationbyBoxResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InStationbyBoxResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InStationbyBoxResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InStationbyBoxResult", &a->_ns1__InStationbyBoxResponse::InStationbyBoxResult, "xsd:string"))
				{	soap_flag_InStationbyBoxResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InStationbyBoxResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InStationbyBoxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InStationbyBoxResponse, SOAP_TYPE__ns1__InStationbyBoxResponse, sizeof(_ns1__InStationbyBoxResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InStationbyBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__InStationbyBoxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InStationbyBoxResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InStationbyBoxResponse *p;
	size_t k = sizeof(_ns1__InStationbyBoxResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InStationbyBoxResponse);
		if (p)
			((_ns1__InStationbyBoxResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InStationbyBoxResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InStationbyBoxResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InStationbyBoxResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InStationbyBoxResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InStationbyBoxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InStationbyBoxResponse(soap, tag ? tag : "ns1:InStationbyBoxResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InStationbyBoxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InStationbyBoxResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InStationbyBoxResponse * SOAP_FMAC4 soap_get__ns1__InStationbyBoxResponse(struct soap *soap, _ns1__InStationbyBoxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InStationbyBoxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InStationbyBox::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InStationbyBox::EmpNo = NULL;
	this->_ns1__InStationbyBox::BoxNo = NULL;
	this->_ns1__InStationbyBox::Station = NULL;
	/* transient soap skipped */
}

void _ns1__InStationbyBox::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InStationbyBox::EmpNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InStationbyBox::BoxNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InStationbyBox::Station);
#endif
}

int _ns1__InStationbyBox::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InStationbyBox(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InStationbyBox(struct soap *soap, const char *tag, int id, const _ns1__InStationbyBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InStationbyBox), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EmpNo", -1, &a->_ns1__InStationbyBox::EmpNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__InStationbyBox::BoxNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__InStationbyBox::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InStationbyBox::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InStationbyBox(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InStationbyBox * SOAP_FMAC4 soap_in__ns1__InStationbyBox(struct soap *soap, const char *tag, _ns1__InStationbyBox *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InStationbyBox *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InStationbyBox, sizeof(_ns1__InStationbyBox), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InStationbyBox)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InStationbyBox *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EmpNo1 = 1;
	size_t soap_flag_BoxNo1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EmpNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EmpNo", &a->_ns1__InStationbyBox::EmpNo, "xsd:string"))
				{	soap_flag_EmpNo1--;
					continue;
				}
			}
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__InStationbyBox::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__InStationbyBox::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InStationbyBox *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InStationbyBox, SOAP_TYPE__ns1__InStationbyBox, sizeof(_ns1__InStationbyBox), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InStationbyBox * SOAP_FMAC2 soap_instantiate__ns1__InStationbyBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InStationbyBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InStationbyBox *p;
	size_t k = sizeof(_ns1__InStationbyBox);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InStationbyBox);
		if (p)
			((_ns1__InStationbyBox*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InStationbyBox, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InStationbyBox*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InStationbyBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InStationbyBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InStationbyBox::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InStationbyBox(soap, tag ? tag : "ns1:InStationbyBox", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InStationbyBox::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InStationbyBox(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InStationbyBox * SOAP_FMAC4 soap_get__ns1__InStationbyBox(struct soap *soap, _ns1__InStationbyBox *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InStationbyBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EndSNtoBoxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndSNtoBoxResponse::EndSNtoBoxResult = NULL;
	/* transient soap skipped */
}

void _ns1__EndSNtoBoxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__EndSNtoBoxResponse::EndSNtoBoxResult);
#endif
}

int _ns1__EndSNtoBoxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndSNtoBoxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndSNtoBoxResponse(struct soap *soap, const char *tag, int id, const _ns1__EndSNtoBoxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndSNtoBoxResponse), type))
		return soap->error;
	if (a->EndSNtoBoxResult)
		soap_element_result(soap, "ns1:EndSNtoBoxResult");
	if (soap_out_PointerTostd__string(soap, "ns1:EndSNtoBoxResult", -1, &a->_ns1__EndSNtoBoxResponse::EndSNtoBoxResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndSNtoBoxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndSNtoBoxResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndSNtoBoxResponse * SOAP_FMAC4 soap_in__ns1__EndSNtoBoxResponse(struct soap *soap, const char *tag, _ns1__EndSNtoBoxResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndSNtoBoxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndSNtoBoxResponse, sizeof(_ns1__EndSNtoBoxResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__EndSNtoBoxResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EndSNtoBoxResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EndSNtoBoxResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EndSNtoBoxResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EndSNtoBoxResult", &a->_ns1__EndSNtoBoxResponse::EndSNtoBoxResult, "xsd:string"))
				{	soap_flag_EndSNtoBoxResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:EndSNtoBoxResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndSNtoBoxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndSNtoBoxResponse, SOAP_TYPE__ns1__EndSNtoBoxResponse, sizeof(_ns1__EndSNtoBoxResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EndSNtoBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__EndSNtoBoxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndSNtoBoxResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EndSNtoBoxResponse *p;
	size_t k = sizeof(_ns1__EndSNtoBoxResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__EndSNtoBoxResponse);
		if (p)
			((_ns1__EndSNtoBoxResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__EndSNtoBoxResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__EndSNtoBoxResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EndSNtoBoxResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__EndSNtoBoxResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__EndSNtoBoxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EndSNtoBoxResponse(soap, tag ? tag : "ns1:EndSNtoBoxResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndSNtoBoxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndSNtoBoxResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndSNtoBoxResponse * SOAP_FMAC4 soap_get__ns1__EndSNtoBoxResponse(struct soap *soap, _ns1__EndSNtoBoxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndSNtoBoxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EndSNtoBox::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndSNtoBox::BoxNo = NULL;
	/* transient soap skipped */
}

void _ns1__EndSNtoBox::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__EndSNtoBox::BoxNo);
#endif
}

int _ns1__EndSNtoBox::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndSNtoBox(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndSNtoBox(struct soap *soap, const char *tag, int id, const _ns1__EndSNtoBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndSNtoBox), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__EndSNtoBox::BoxNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndSNtoBox::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndSNtoBox(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndSNtoBox * SOAP_FMAC4 soap_in__ns1__EndSNtoBox(struct soap *soap, const char *tag, _ns1__EndSNtoBox *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndSNtoBox *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndSNtoBox, sizeof(_ns1__EndSNtoBox), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__EndSNtoBox)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EndSNtoBox *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BoxNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__EndSNtoBox::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndSNtoBox *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndSNtoBox, SOAP_TYPE__ns1__EndSNtoBox, sizeof(_ns1__EndSNtoBox), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EndSNtoBox * SOAP_FMAC2 soap_instantiate__ns1__EndSNtoBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndSNtoBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EndSNtoBox *p;
	size_t k = sizeof(_ns1__EndSNtoBox);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__EndSNtoBox);
		if (p)
			((_ns1__EndSNtoBox*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__EndSNtoBox, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__EndSNtoBox*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EndSNtoBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__EndSNtoBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__EndSNtoBox::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EndSNtoBox(soap, tag ? tag : "ns1:EndSNtoBox", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndSNtoBox::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndSNtoBox(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndSNtoBox * SOAP_FMAC4 soap_get__ns1__EndSNtoBox(struct soap *soap, _ns1__EndSNtoBox *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndSNtoBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InSNtoBoxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InSNtoBoxResponse::InSNtoBoxResult = NULL;
	/* transient soap skipped */
}

void _ns1__InSNtoBoxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InSNtoBoxResponse::InSNtoBoxResult);
#endif
}

int _ns1__InSNtoBoxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InSNtoBoxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InSNtoBoxResponse(struct soap *soap, const char *tag, int id, const _ns1__InSNtoBoxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InSNtoBoxResponse), type))
		return soap->error;
	if (a->InSNtoBoxResult)
		soap_element_result(soap, "ns1:InSNtoBoxResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InSNtoBoxResult", -1, &a->_ns1__InSNtoBoxResponse::InSNtoBoxResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InSNtoBoxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InSNtoBoxResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InSNtoBoxResponse * SOAP_FMAC4 soap_in__ns1__InSNtoBoxResponse(struct soap *soap, const char *tag, _ns1__InSNtoBoxResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InSNtoBoxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InSNtoBoxResponse, sizeof(_ns1__InSNtoBoxResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InSNtoBoxResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InSNtoBoxResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InSNtoBoxResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InSNtoBoxResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InSNtoBoxResult", &a->_ns1__InSNtoBoxResponse::InSNtoBoxResult, "xsd:string"))
				{	soap_flag_InSNtoBoxResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InSNtoBoxResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InSNtoBoxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InSNtoBoxResponse, SOAP_TYPE__ns1__InSNtoBoxResponse, sizeof(_ns1__InSNtoBoxResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InSNtoBoxResponse * SOAP_FMAC2 soap_instantiate__ns1__InSNtoBoxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InSNtoBoxResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InSNtoBoxResponse *p;
	size_t k = sizeof(_ns1__InSNtoBoxResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InSNtoBoxResponse);
		if (p)
			((_ns1__InSNtoBoxResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InSNtoBoxResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InSNtoBoxResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InSNtoBoxResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InSNtoBoxResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InSNtoBoxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InSNtoBoxResponse(soap, tag ? tag : "ns1:InSNtoBoxResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InSNtoBoxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InSNtoBoxResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InSNtoBoxResponse * SOAP_FMAC4 soap_get__ns1__InSNtoBoxResponse(struct soap *soap, _ns1__InSNtoBoxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InSNtoBoxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InSNtoBox::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InSNtoBox::EmpNo = NULL;
	this->_ns1__InSNtoBox::BoxNo = NULL;
	this->_ns1__InSNtoBox::SN = NULL;
	/* transient soap skipped */
}

void _ns1__InSNtoBox::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InSNtoBox::EmpNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InSNtoBox::BoxNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InSNtoBox::SN);
#endif
}

int _ns1__InSNtoBox::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InSNtoBox(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InSNtoBox(struct soap *soap, const char *tag, int id, const _ns1__InSNtoBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InSNtoBox), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EmpNo", -1, &a->_ns1__InSNtoBox::EmpNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__InSNtoBox::BoxNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InSNtoBox::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InSNtoBox::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InSNtoBox(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InSNtoBox * SOAP_FMAC4 soap_in__ns1__InSNtoBox(struct soap *soap, const char *tag, _ns1__InSNtoBox *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InSNtoBox *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InSNtoBox, sizeof(_ns1__InSNtoBox), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InSNtoBox)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InSNtoBox *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EmpNo1 = 1;
	size_t soap_flag_BoxNo1 = 1;
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EmpNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EmpNo", &a->_ns1__InSNtoBox::EmpNo, "xsd:string"))
				{	soap_flag_EmpNo1--;
					continue;
				}
			}
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__InSNtoBox::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InSNtoBox::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InSNtoBox *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InSNtoBox, SOAP_TYPE__ns1__InSNtoBox, sizeof(_ns1__InSNtoBox), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InSNtoBox * SOAP_FMAC2 soap_instantiate__ns1__InSNtoBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InSNtoBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InSNtoBox *p;
	size_t k = sizeof(_ns1__InSNtoBox);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InSNtoBox);
		if (p)
			((_ns1__InSNtoBox*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InSNtoBox, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InSNtoBox*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InSNtoBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InSNtoBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InSNtoBox::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InSNtoBox(soap, tag ? tag : "ns1:InSNtoBox", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InSNtoBox::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InSNtoBox(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InSNtoBox * SOAP_FMAC4 soap_get__ns1__InSNtoBox(struct soap *soap, _ns1__InSNtoBox *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InSNtoBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkBoxNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkBoxNoResponse::chkBoxNoResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkBoxNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkBoxNoResponse::chkBoxNoResult);
#endif
}

int _ns1__chkBoxNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkBoxNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkBoxNoResponse(struct soap *soap, const char *tag, int id, const _ns1__chkBoxNoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkBoxNoResponse), type))
		return soap->error;
	if (a->chkBoxNoResult)
		soap_element_result(soap, "ns1:chkBoxNoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkBoxNoResult", -1, &a->_ns1__chkBoxNoResponse::chkBoxNoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkBoxNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkBoxNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkBoxNoResponse * SOAP_FMAC4 soap_in__ns1__chkBoxNoResponse(struct soap *soap, const char *tag, _ns1__chkBoxNoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkBoxNoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkBoxNoResponse, sizeof(_ns1__chkBoxNoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkBoxNoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkBoxNoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkBoxNoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkBoxNoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkBoxNoResult", &a->_ns1__chkBoxNoResponse::chkBoxNoResult, "xsd:string"))
				{	soap_flag_chkBoxNoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkBoxNoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkBoxNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkBoxNoResponse, SOAP_TYPE__ns1__chkBoxNoResponse, sizeof(_ns1__chkBoxNoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkBoxNoResponse * SOAP_FMAC2 soap_instantiate__ns1__chkBoxNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkBoxNoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkBoxNoResponse *p;
	size_t k = sizeof(_ns1__chkBoxNoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkBoxNoResponse);
		if (p)
			((_ns1__chkBoxNoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkBoxNoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkBoxNoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkBoxNoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkBoxNoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkBoxNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkBoxNoResponse(soap, tag ? tag : "ns1:chkBoxNoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkBoxNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkBoxNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkBoxNoResponse * SOAP_FMAC4 soap_get__ns1__chkBoxNoResponse(struct soap *soap, _ns1__chkBoxNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkBoxNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkBoxNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkBoxNo::BoxNo = NULL;
	/* transient soap skipped */
}

void _ns1__chkBoxNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkBoxNo::BoxNo);
#endif
}

int _ns1__chkBoxNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkBoxNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkBoxNo(struct soap *soap, const char *tag, int id, const _ns1__chkBoxNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkBoxNo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__chkBoxNo::BoxNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkBoxNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkBoxNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkBoxNo * SOAP_FMAC4 soap_in__ns1__chkBoxNo(struct soap *soap, const char *tag, _ns1__chkBoxNo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkBoxNo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkBoxNo, sizeof(_ns1__chkBoxNo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkBoxNo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkBoxNo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BoxNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__chkBoxNo::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkBoxNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkBoxNo, SOAP_TYPE__ns1__chkBoxNo, sizeof(_ns1__chkBoxNo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkBoxNo * SOAP_FMAC2 soap_instantiate__ns1__chkBoxNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkBoxNo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkBoxNo *p;
	size_t k = sizeof(_ns1__chkBoxNo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkBoxNo);
		if (p)
			((_ns1__chkBoxNo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkBoxNo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkBoxNo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkBoxNo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkBoxNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkBoxNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkBoxNo(soap, tag ? tag : "ns1:chkBoxNo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkBoxNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkBoxNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkBoxNo * SOAP_FMAC4 soap_get__ns1__chkBoxNo(struct soap *soap, _ns1__chkBoxNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkBoxNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsBoxNOTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsBoxNOTimeResponse::InsBoxNOTimeResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsBoxNOTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxNOTimeResponse::InsBoxNOTimeResult);
#endif
}

int _ns1__InsBoxNOTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsBoxNOTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsBoxNOTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__InsBoxNOTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsBoxNOTimeResponse), type))
		return soap->error;
	if (a->InsBoxNOTimeResult)
		soap_element_result(soap, "ns1:InsBoxNOTimeResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsBoxNOTimeResult", -1, &a->_ns1__InsBoxNOTimeResponse::InsBoxNOTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsBoxNOTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsBoxNOTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsBoxNOTimeResponse * SOAP_FMAC4 soap_in__ns1__InsBoxNOTimeResponse(struct soap *soap, const char *tag, _ns1__InsBoxNOTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsBoxNOTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsBoxNOTimeResponse, sizeof(_ns1__InsBoxNOTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsBoxNOTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsBoxNOTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsBoxNOTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsBoxNOTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsBoxNOTimeResult", &a->_ns1__InsBoxNOTimeResponse::InsBoxNOTimeResult, "xsd:string"))
				{	soap_flag_InsBoxNOTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsBoxNOTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsBoxNOTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsBoxNOTimeResponse, SOAP_TYPE__ns1__InsBoxNOTimeResponse, sizeof(_ns1__InsBoxNOTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsBoxNOTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__InsBoxNOTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsBoxNOTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsBoxNOTimeResponse *p;
	size_t k = sizeof(_ns1__InsBoxNOTimeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsBoxNOTimeResponse);
		if (p)
			((_ns1__InsBoxNOTimeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsBoxNOTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsBoxNOTimeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsBoxNOTimeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsBoxNOTimeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsBoxNOTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsBoxNOTimeResponse(soap, tag ? tag : "ns1:InsBoxNOTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsBoxNOTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsBoxNOTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsBoxNOTimeResponse * SOAP_FMAC4 soap_get__ns1__InsBoxNOTimeResponse(struct soap *soap, _ns1__InsBoxNOTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsBoxNOTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsBoxNOTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsBoxNOTime::BoxNo = NULL;
	/* transient soap skipped */
}

void _ns1__InsBoxNOTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsBoxNOTime::BoxNo);
#endif
}

int _ns1__InsBoxNOTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsBoxNOTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsBoxNOTime(struct soap *soap, const char *tag, int id, const _ns1__InsBoxNOTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsBoxNOTime), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BoxNo", -1, &a->_ns1__InsBoxNOTime::BoxNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsBoxNOTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsBoxNOTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsBoxNOTime * SOAP_FMAC4 soap_in__ns1__InsBoxNOTime(struct soap *soap, const char *tag, _ns1__InsBoxNOTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsBoxNOTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsBoxNOTime, sizeof(_ns1__InsBoxNOTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsBoxNOTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsBoxNOTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BoxNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoxNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BoxNo", &a->_ns1__InsBoxNOTime::BoxNo, "xsd:string"))
				{	soap_flag_BoxNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsBoxNOTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsBoxNOTime, SOAP_TYPE__ns1__InsBoxNOTime, sizeof(_ns1__InsBoxNOTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsBoxNOTime * SOAP_FMAC2 soap_instantiate__ns1__InsBoxNOTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsBoxNOTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsBoxNOTime *p;
	size_t k = sizeof(_ns1__InsBoxNOTime);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsBoxNOTime);
		if (p)
			((_ns1__InsBoxNOTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsBoxNOTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsBoxNOTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsBoxNOTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsBoxNOTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsBoxNOTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsBoxNOTime(soap, tag ? tag : "ns1:InsBoxNOTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsBoxNOTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsBoxNOTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsBoxNOTime * SOAP_FMAC4 soap_get__ns1__InsBoxNOTime(struct soap *soap, _ns1__InsBoxNOTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsBoxNOTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLinkZJCountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLinkZJCountResponse::GetLinkZJCountResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetLinkZJCountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLinkZJCountResponse::GetLinkZJCountResult);
#endif
}

int _ns1__GetLinkZJCountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLinkZJCountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLinkZJCountResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLinkZJCountResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLinkZJCountResponse), type))
		return soap->error;
	if (a->GetLinkZJCountResult)
		soap_element_result(soap, "ns1:GetLinkZJCountResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetLinkZJCountResult", -1, &a->_ns1__GetLinkZJCountResponse::GetLinkZJCountResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLinkZJCountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLinkZJCountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLinkZJCountResponse * SOAP_FMAC4 soap_in__ns1__GetLinkZJCountResponse(struct soap *soap, const char *tag, _ns1__GetLinkZJCountResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLinkZJCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLinkZJCountResponse, sizeof(_ns1__GetLinkZJCountResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLinkZJCountResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLinkZJCountResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLinkZJCountResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLinkZJCountResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetLinkZJCountResult", &a->_ns1__GetLinkZJCountResponse::GetLinkZJCountResult, "xsd:string"))
				{	soap_flag_GetLinkZJCountResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetLinkZJCountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLinkZJCountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLinkZJCountResponse, SOAP_TYPE__ns1__GetLinkZJCountResponse, sizeof(_ns1__GetLinkZJCountResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLinkZJCountResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLinkZJCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLinkZJCountResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLinkZJCountResponse *p;
	size_t k = sizeof(_ns1__GetLinkZJCountResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLinkZJCountResponse);
		if (p)
			((_ns1__GetLinkZJCountResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLinkZJCountResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLinkZJCountResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLinkZJCountResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLinkZJCountResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLinkZJCountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLinkZJCountResponse(soap, tag ? tag : "ns1:GetLinkZJCountResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLinkZJCountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLinkZJCountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLinkZJCountResponse * SOAP_FMAC4 soap_get__ns1__GetLinkZJCountResponse(struct soap *soap, _ns1__GetLinkZJCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLinkZJCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLinkZJCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLinkZJCount::ZJSN = NULL;
	/* transient soap skipped */
}

void _ns1__GetLinkZJCount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLinkZJCount::ZJSN);
#endif
}

int _ns1__GetLinkZJCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLinkZJCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLinkZJCount(struct soap *soap, const char *tag, int id, const _ns1__GetLinkZJCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLinkZJCount), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__GetLinkZJCount::ZJSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLinkZJCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLinkZJCount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLinkZJCount * SOAP_FMAC4 soap_in__ns1__GetLinkZJCount(struct soap *soap, const char *tag, _ns1__GetLinkZJCount *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLinkZJCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLinkZJCount, sizeof(_ns1__GetLinkZJCount), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLinkZJCount)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLinkZJCount *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZJSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__GetLinkZJCount::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLinkZJCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLinkZJCount, SOAP_TYPE__ns1__GetLinkZJCount, sizeof(_ns1__GetLinkZJCount), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLinkZJCount * SOAP_FMAC2 soap_instantiate__ns1__GetLinkZJCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLinkZJCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLinkZJCount *p;
	size_t k = sizeof(_ns1__GetLinkZJCount);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLinkZJCount);
		if (p)
			((_ns1__GetLinkZJCount*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLinkZJCount, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLinkZJCount*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLinkZJCount location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLinkZJCount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLinkZJCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLinkZJCount(soap, tag ? tag : "ns1:GetLinkZJCount", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLinkZJCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLinkZJCount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLinkZJCount * SOAP_FMAC4 soap_get__ns1__GetLinkZJCount(struct soap *soap, _ns1__GetLinkZJCount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLinkZJCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsLinkSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsLinkSNResponse::InsLinkSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsLinkSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLinkSNResponse::InsLinkSNResult);
#endif
}

int _ns1__InsLinkSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsLinkSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsLinkSNResponse(struct soap *soap, const char *tag, int id, const _ns1__InsLinkSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsLinkSNResponse), type))
		return soap->error;
	if (a->InsLinkSNResult)
		soap_element_result(soap, "ns1:InsLinkSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsLinkSNResult", -1, &a->_ns1__InsLinkSNResponse::InsLinkSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsLinkSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsLinkSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsLinkSNResponse * SOAP_FMAC4 soap_in__ns1__InsLinkSNResponse(struct soap *soap, const char *tag, _ns1__InsLinkSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsLinkSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsLinkSNResponse, sizeof(_ns1__InsLinkSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsLinkSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsLinkSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsLinkSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsLinkSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsLinkSNResult", &a->_ns1__InsLinkSNResponse::InsLinkSNResult, "xsd:string"))
				{	soap_flag_InsLinkSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsLinkSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsLinkSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsLinkSNResponse, SOAP_TYPE__ns1__InsLinkSNResponse, sizeof(_ns1__InsLinkSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsLinkSNResponse * SOAP_FMAC2 soap_instantiate__ns1__InsLinkSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsLinkSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsLinkSNResponse *p;
	size_t k = sizeof(_ns1__InsLinkSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsLinkSNResponse);
		if (p)
			((_ns1__InsLinkSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsLinkSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsLinkSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsLinkSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsLinkSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsLinkSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsLinkSNResponse(soap, tag ? tag : "ns1:InsLinkSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsLinkSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsLinkSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsLinkSNResponse * SOAP_FMAC4 soap_get__ns1__InsLinkSNResponse(struct soap *soap, _ns1__InsLinkSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsLinkSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsLinkSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsLinkSN::Emp = NULL;
	this->_ns1__InsLinkSN::SN = NULL;
	this->_ns1__InsLinkSN::LnkSN = NULL;
	this->_ns1__InsLinkSN::LnkDesc = NULL;
	/* transient soap skipped */
}

void _ns1__InsLinkSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLinkSN::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLinkSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLinkSN::LnkSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsLinkSN::LnkDesc);
#endif
}

int _ns1__InsLinkSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsLinkSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsLinkSN(struct soap *soap, const char *tag, int id, const _ns1__InsLinkSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsLinkSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__InsLinkSN::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsLinkSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkSN", -1, &a->_ns1__InsLinkSN::LnkSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkDesc", -1, &a->_ns1__InsLinkSN::LnkDesc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsLinkSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsLinkSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsLinkSN * SOAP_FMAC4 soap_in__ns1__InsLinkSN(struct soap *soap, const char *tag, _ns1__InsLinkSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsLinkSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsLinkSN, sizeof(_ns1__InsLinkSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsLinkSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsLinkSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_LnkSN1 = 1;
	size_t soap_flag_LnkDesc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__InsLinkSN::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsLinkSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_LnkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkSN", &a->_ns1__InsLinkSN::LnkSN, "xsd:string"))
				{	soap_flag_LnkSN1--;
					continue;
				}
			}
			if (soap_flag_LnkDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkDesc", &a->_ns1__InsLinkSN::LnkDesc, "xsd:string"))
				{	soap_flag_LnkDesc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsLinkSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsLinkSN, SOAP_TYPE__ns1__InsLinkSN, sizeof(_ns1__InsLinkSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsLinkSN * SOAP_FMAC2 soap_instantiate__ns1__InsLinkSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsLinkSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsLinkSN *p;
	size_t k = sizeof(_ns1__InsLinkSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsLinkSN);
		if (p)
			((_ns1__InsLinkSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsLinkSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsLinkSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsLinkSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsLinkSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsLinkSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsLinkSN(soap, tag ? tag : "ns1:InsLinkSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsLinkSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsLinkSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsLinkSN * SOAP_FMAC4 soap_get__ns1__InsLinkSN(struct soap *soap, _ns1__InsLinkSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsLinkSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doLinkOutSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doLinkOutSNResponse::doLinkOutSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__doLinkOutSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLinkOutSNResponse::doLinkOutSNResult);
#endif
}

int _ns1__doLinkOutSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doLinkOutSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doLinkOutSNResponse(struct soap *soap, const char *tag, int id, const _ns1__doLinkOutSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doLinkOutSNResponse), type))
		return soap->error;
	if (a->doLinkOutSNResult)
		soap_element_result(soap, "ns1:doLinkOutSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:doLinkOutSNResult", -1, &a->_ns1__doLinkOutSNResponse::doLinkOutSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doLinkOutSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doLinkOutSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doLinkOutSNResponse * SOAP_FMAC4 soap_in__ns1__doLinkOutSNResponse(struct soap *soap, const char *tag, _ns1__doLinkOutSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doLinkOutSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doLinkOutSNResponse, sizeof(_ns1__doLinkOutSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doLinkOutSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doLinkOutSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_doLinkOutSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_doLinkOutSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:doLinkOutSNResult", &a->_ns1__doLinkOutSNResponse::doLinkOutSNResult, "xsd:string"))
				{	soap_flag_doLinkOutSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:doLinkOutSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doLinkOutSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doLinkOutSNResponse, SOAP_TYPE__ns1__doLinkOutSNResponse, sizeof(_ns1__doLinkOutSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doLinkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__doLinkOutSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doLinkOutSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doLinkOutSNResponse *p;
	size_t k = sizeof(_ns1__doLinkOutSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doLinkOutSNResponse);
		if (p)
			((_ns1__doLinkOutSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doLinkOutSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doLinkOutSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doLinkOutSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doLinkOutSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doLinkOutSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doLinkOutSNResponse(soap, tag ? tag : "ns1:doLinkOutSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doLinkOutSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doLinkOutSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doLinkOutSNResponse * SOAP_FMAC4 soap_get__ns1__doLinkOutSNResponse(struct soap *soap, _ns1__doLinkOutSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doLinkOutSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doLinkOutSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doLinkOutSN::assyDt = NULL;
	this->_ns1__doLinkOutSN::empNO = NULL;
	this->_ns1__doLinkOutSN::SN = NULL;
	this->_ns1__doLinkOutSN::Station = NULL;
	this->_ns1__doLinkOutSN::chkRep = NULL;
	/* transient soap skipped */
}

void _ns1__doLinkOutSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doLinkOutSN_assyDt(soap, &this->_ns1__doLinkOutSN::assyDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLinkOutSN::empNO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLinkOutSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLinkOutSN::Station);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLinkOutSN::chkRep);
#endif
}

int _ns1__doLinkOutSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doLinkOutSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doLinkOutSN(struct soap *soap, const char *tag, int id, const _ns1__doLinkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doLinkOutSN), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__doLinkOutSN_assyDt(soap, "ns1:assyDt", -1, &a->_ns1__doLinkOutSN::assyDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:empNO", -1, &a->_ns1__doLinkOutSN::empNO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__doLinkOutSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__doLinkOutSN::Station, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:chkRep", -1, &a->_ns1__doLinkOutSN::chkRep, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doLinkOutSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doLinkOutSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doLinkOutSN * SOAP_FMAC4 soap_in__ns1__doLinkOutSN(struct soap *soap, const char *tag, _ns1__doLinkOutSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doLinkOutSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doLinkOutSN, sizeof(_ns1__doLinkOutSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doLinkOutSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doLinkOutSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assyDt1 = 1;
	size_t soap_flag_empNO1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	size_t soap_flag_chkRep1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assyDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doLinkOutSN_assyDt(soap, "ns1:assyDt", &a->_ns1__doLinkOutSN::assyDt, ""))
				{	soap_flag_assyDt1--;
					continue;
				}
			}
			if (soap_flag_empNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:empNO", &a->_ns1__doLinkOutSN::empNO, "xsd:string"))
				{	soap_flag_empNO1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__doLinkOutSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__doLinkOutSN::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap_flag_chkRep1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkRep", &a->_ns1__doLinkOutSN::chkRep, "xsd:string"))
				{	soap_flag_chkRep1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doLinkOutSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doLinkOutSN, SOAP_TYPE__ns1__doLinkOutSN, sizeof(_ns1__doLinkOutSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doLinkOutSN * SOAP_FMAC2 soap_instantiate__ns1__doLinkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doLinkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doLinkOutSN *p;
	size_t k = sizeof(_ns1__doLinkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doLinkOutSN);
		if (p)
			((_ns1__doLinkOutSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doLinkOutSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doLinkOutSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doLinkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doLinkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doLinkOutSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doLinkOutSN(soap, tag ? tag : "ns1:doLinkOutSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doLinkOutSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doLinkOutSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doLinkOutSN * SOAP_FMAC4 soap_get__ns1__doLinkOutSN(struct soap *soap, _ns1__doLinkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doLinkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkLinkOutSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkLinkOutSNResponse::ChkLinkOutSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__ChkLinkOutSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkLinkOutSNResponse::ChkLinkOutSNResult);
#endif
}

int _ns1__ChkLinkOutSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkLinkOutSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkLinkOutSNResponse(struct soap *soap, const char *tag, int id, const _ns1__ChkLinkOutSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkLinkOutSNResponse), type))
		return soap->error;
	if (a->ChkLinkOutSNResult)
		soap_element_result(soap, "ns1:ChkLinkOutSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ChkLinkOutSNResult", -1, &a->_ns1__ChkLinkOutSNResponse::ChkLinkOutSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkLinkOutSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkLinkOutSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkLinkOutSNResponse * SOAP_FMAC4 soap_in__ns1__ChkLinkOutSNResponse(struct soap *soap, const char *tag, _ns1__ChkLinkOutSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkLinkOutSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkLinkOutSNResponse, sizeof(_ns1__ChkLinkOutSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkLinkOutSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkLinkOutSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChkLinkOutSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChkLinkOutSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ChkLinkOutSNResult", &a->_ns1__ChkLinkOutSNResponse::ChkLinkOutSNResult, "xsd:string"))
				{	soap_flag_ChkLinkOutSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChkLinkOutSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkLinkOutSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkLinkOutSNResponse, SOAP_TYPE__ns1__ChkLinkOutSNResponse, sizeof(_ns1__ChkLinkOutSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkLinkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkLinkOutSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkLinkOutSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkLinkOutSNResponse *p;
	size_t k = sizeof(_ns1__ChkLinkOutSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkLinkOutSNResponse);
		if (p)
			((_ns1__ChkLinkOutSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkLinkOutSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkLinkOutSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkLinkOutSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkLinkOutSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkLinkOutSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkLinkOutSNResponse(soap, tag ? tag : "ns1:ChkLinkOutSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkLinkOutSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkLinkOutSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkLinkOutSNResponse * SOAP_FMAC4 soap_get__ns1__ChkLinkOutSNResponse(struct soap *soap, _ns1__ChkLinkOutSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkLinkOutSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkLinkOutSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkLinkOutSN::SN = NULL;
	/* transient soap skipped */
}

void _ns1__ChkLinkOutSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkLinkOutSN::SN);
#endif
}

int _ns1__ChkLinkOutSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkLinkOutSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkLinkOutSN(struct soap *soap, const char *tag, int id, const _ns1__ChkLinkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkLinkOutSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ChkLinkOutSN::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkLinkOutSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkLinkOutSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkLinkOutSN * SOAP_FMAC4 soap_in__ns1__ChkLinkOutSN(struct soap *soap, const char *tag, _ns1__ChkLinkOutSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkLinkOutSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkLinkOutSN, sizeof(_ns1__ChkLinkOutSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkLinkOutSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkLinkOutSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ChkLinkOutSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkLinkOutSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkLinkOutSN, SOAP_TYPE__ns1__ChkLinkOutSN, sizeof(_ns1__ChkLinkOutSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkLinkOutSN * SOAP_FMAC2 soap_instantiate__ns1__ChkLinkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkLinkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkLinkOutSN *p;
	size_t k = sizeof(_ns1__ChkLinkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkLinkOutSN);
		if (p)
			((_ns1__ChkLinkOutSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkLinkOutSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkLinkOutSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkLinkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkLinkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkLinkOutSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkLinkOutSN(soap, tag ? tag : "ns1:ChkLinkOutSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkLinkOutSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkLinkOutSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkLinkOutSN * SOAP_FMAC4 soap_get__ns1__ChkLinkOutSN(struct soap *soap, _ns1__ChkLinkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkLinkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkOutSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkOutSNResponse::chkOutSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkOutSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkOutSNResponse::chkOutSNResult);
#endif
}

int _ns1__chkOutSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkOutSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkOutSNResponse(struct soap *soap, const char *tag, int id, const _ns1__chkOutSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkOutSNResponse), type))
		return soap->error;
	if (a->chkOutSNResult)
		soap_element_result(soap, "ns1:chkOutSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkOutSNResult", -1, &a->_ns1__chkOutSNResponse::chkOutSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkOutSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkOutSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkOutSNResponse * SOAP_FMAC4 soap_in__ns1__chkOutSNResponse(struct soap *soap, const char *tag, _ns1__chkOutSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkOutSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkOutSNResponse, sizeof(_ns1__chkOutSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkOutSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkOutSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkOutSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkOutSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkOutSNResult", &a->_ns1__chkOutSNResponse::chkOutSNResult, "xsd:string"))
				{	soap_flag_chkOutSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkOutSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkOutSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkOutSNResponse, SOAP_TYPE__ns1__chkOutSNResponse, sizeof(_ns1__chkOutSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkOutSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkOutSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkOutSNResponse *p;
	size_t k = sizeof(_ns1__chkOutSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkOutSNResponse);
		if (p)
			((_ns1__chkOutSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkOutSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkOutSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkOutSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkOutSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkOutSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkOutSNResponse(soap, tag ? tag : "ns1:chkOutSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkOutSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkOutSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkOutSNResponse * SOAP_FMAC4 soap_get__ns1__chkOutSNResponse(struct soap *soap, _ns1__chkOutSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkOutSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkOutSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkOutSN::SN = NULL;
	this->_ns1__chkOutSN::OutSN = NULL;
	/* transient soap skipped */
}

void _ns1__chkOutSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkOutSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkOutSN::OutSN);
#endif
}

int _ns1__chkOutSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkOutSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkOutSN(struct soap *soap, const char *tag, int id, const _ns1__chkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkOutSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__chkOutSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:OutSN", -1, &a->_ns1__chkOutSN::OutSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkOutSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkOutSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkOutSN * SOAP_FMAC4 soap_in__ns1__chkOutSN(struct soap *soap, const char *tag, _ns1__chkOutSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkOutSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkOutSN, sizeof(_ns1__chkOutSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkOutSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkOutSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_OutSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__chkOutSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_OutSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OutSN", &a->_ns1__chkOutSN::OutSN, "xsd:string"))
				{	soap_flag_OutSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkOutSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkOutSN, SOAP_TYPE__ns1__chkOutSN, sizeof(_ns1__chkOutSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkOutSN * SOAP_FMAC2 soap_instantiate__ns1__chkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkOutSN *p;
	size_t k = sizeof(_ns1__chkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkOutSN);
		if (p)
			((_ns1__chkOutSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkOutSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkOutSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkOutSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkOutSN(soap, tag ? tag : "ns1:chkOutSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkOutSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkOutSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkOutSN * SOAP_FMAC4 soap_get__ns1__chkOutSN(struct soap *soap, _ns1__chkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLintOutQtyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLintOutQtyResponse::GetLintOutQtyResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetLintOutQtyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLintOutQtyResponse::GetLintOutQtyResult);
#endif
}

int _ns1__GetLintOutQtyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLintOutQtyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLintOutQtyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLintOutQtyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLintOutQtyResponse), type))
		return soap->error;
	if (a->GetLintOutQtyResult)
		soap_element_result(soap, "ns1:GetLintOutQtyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetLintOutQtyResult", -1, &a->_ns1__GetLintOutQtyResponse::GetLintOutQtyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLintOutQtyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLintOutQtyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLintOutQtyResponse * SOAP_FMAC4 soap_in__ns1__GetLintOutQtyResponse(struct soap *soap, const char *tag, _ns1__GetLintOutQtyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLintOutQtyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLintOutQtyResponse, sizeof(_ns1__GetLintOutQtyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLintOutQtyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLintOutQtyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLintOutQtyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLintOutQtyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetLintOutQtyResult", &a->_ns1__GetLintOutQtyResponse::GetLintOutQtyResult, "xsd:string"))
				{	soap_flag_GetLintOutQtyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetLintOutQtyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLintOutQtyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLintOutQtyResponse, SOAP_TYPE__ns1__GetLintOutQtyResponse, sizeof(_ns1__GetLintOutQtyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLintOutQtyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLintOutQtyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLintOutQtyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLintOutQtyResponse *p;
	size_t k = sizeof(_ns1__GetLintOutQtyResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLintOutQtyResponse);
		if (p)
			((_ns1__GetLintOutQtyResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLintOutQtyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLintOutQtyResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLintOutQtyResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLintOutQtyResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLintOutQtyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLintOutQtyResponse(soap, tag ? tag : "ns1:GetLintOutQtyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLintOutQtyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLintOutQtyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLintOutQtyResponse * SOAP_FMAC4 soap_get__ns1__GetLintOutQtyResponse(struct soap *soap, _ns1__GetLintOutQtyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLintOutQtyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLintOutQty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLintOutQty::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetLintOutQty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLintOutQty::SN);
#endif
}

int _ns1__GetLintOutQty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLintOutQty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLintOutQty(struct soap *soap, const char *tag, int id, const _ns1__GetLintOutQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLintOutQty), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetLintOutQty::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLintOutQty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLintOutQty(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLintOutQty * SOAP_FMAC4 soap_in__ns1__GetLintOutQty(struct soap *soap, const char *tag, _ns1__GetLintOutQty *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLintOutQty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLintOutQty, sizeof(_ns1__GetLintOutQty), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLintOutQty)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLintOutQty *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetLintOutQty::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLintOutQty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLintOutQty, SOAP_TYPE__ns1__GetLintOutQty, sizeof(_ns1__GetLintOutQty), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLintOutQty * SOAP_FMAC2 soap_instantiate__ns1__GetLintOutQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLintOutQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLintOutQty *p;
	size_t k = sizeof(_ns1__GetLintOutQty);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLintOutQty);
		if (p)
			((_ns1__GetLintOutQty*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLintOutQty, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLintOutQty*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLintOutQty location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLintOutQty, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLintOutQty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLintOutQty(soap, tag ? tag : "ns1:GetLintOutQty", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLintOutQty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLintOutQty(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLintOutQty * SOAP_FMAC4 soap_get__ns1__GetLintOutQty(struct soap *soap, _ns1__GetLintOutQty *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLintOutQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SNLinkZJResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SNLinkZJResponse::SNLinkZJResult = NULL;
	/* transient soap skipped */
}

void _ns1__SNLinkZJResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkZJResponse::SNLinkZJResult);
#endif
}

int _ns1__SNLinkZJResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SNLinkZJResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SNLinkZJResponse(struct soap *soap, const char *tag, int id, const _ns1__SNLinkZJResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SNLinkZJResponse), type))
		return soap->error;
	if (a->SNLinkZJResult)
		soap_element_result(soap, "ns1:SNLinkZJResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SNLinkZJResult", -1, &a->_ns1__SNLinkZJResponse::SNLinkZJResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SNLinkZJResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SNLinkZJResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SNLinkZJResponse * SOAP_FMAC4 soap_in__ns1__SNLinkZJResponse(struct soap *soap, const char *tag, _ns1__SNLinkZJResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SNLinkZJResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SNLinkZJResponse, sizeof(_ns1__SNLinkZJResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SNLinkZJResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SNLinkZJResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SNLinkZJResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SNLinkZJResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SNLinkZJResult", &a->_ns1__SNLinkZJResponse::SNLinkZJResult, "xsd:string"))
				{	soap_flag_SNLinkZJResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SNLinkZJResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SNLinkZJResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SNLinkZJResponse, SOAP_TYPE__ns1__SNLinkZJResponse, sizeof(_ns1__SNLinkZJResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SNLinkZJResponse * SOAP_FMAC2 soap_instantiate__ns1__SNLinkZJResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SNLinkZJResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SNLinkZJResponse *p;
	size_t k = sizeof(_ns1__SNLinkZJResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SNLinkZJResponse);
		if (p)
			((_ns1__SNLinkZJResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SNLinkZJResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SNLinkZJResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SNLinkZJResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SNLinkZJResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SNLinkZJResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SNLinkZJResponse(soap, tag ? tag : "ns1:SNLinkZJResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SNLinkZJResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SNLinkZJResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SNLinkZJResponse * SOAP_FMAC4 soap_get__ns1__SNLinkZJResponse(struct soap *soap, _ns1__SNLinkZJResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SNLinkZJResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SNLinkZJ::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SNLinkZJ::Emp = NULL;
	this->_ns1__SNLinkZJ::SN = NULL;
	this->_ns1__SNLinkZJ::Station = NULL;
	this->_ns1__SNLinkZJ::ZJSN = NULL;
	/* transient soap skipped */
}

void _ns1__SNLinkZJ::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkZJ::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkZJ::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkZJ::Station);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkZJ::ZJSN);
#endif
}

int _ns1__SNLinkZJ::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SNLinkZJ(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SNLinkZJ(struct soap *soap, const char *tag, int id, const _ns1__SNLinkZJ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SNLinkZJ), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__SNLinkZJ::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SNLinkZJ::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__SNLinkZJ::Station, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__SNLinkZJ::ZJSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SNLinkZJ::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SNLinkZJ(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SNLinkZJ * SOAP_FMAC4 soap_in__ns1__SNLinkZJ(struct soap *soap, const char *tag, _ns1__SNLinkZJ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SNLinkZJ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SNLinkZJ, sizeof(_ns1__SNLinkZJ), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SNLinkZJ)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SNLinkZJ *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	size_t soap_flag_ZJSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__SNLinkZJ::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SNLinkZJ::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__SNLinkZJ::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__SNLinkZJ::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SNLinkZJ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SNLinkZJ, SOAP_TYPE__ns1__SNLinkZJ, sizeof(_ns1__SNLinkZJ), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SNLinkZJ * SOAP_FMAC2 soap_instantiate__ns1__SNLinkZJ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SNLinkZJ(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SNLinkZJ *p;
	size_t k = sizeof(_ns1__SNLinkZJ);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SNLinkZJ);
		if (p)
			((_ns1__SNLinkZJ*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SNLinkZJ, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SNLinkZJ*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SNLinkZJ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SNLinkZJ, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SNLinkZJ::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SNLinkZJ(soap, tag ? tag : "ns1:SNLinkZJ", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SNLinkZJ::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SNLinkZJ(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SNLinkZJ * SOAP_FMAC4 soap_get__ns1__SNLinkZJ(struct soap *soap, _ns1__SNLinkZJ *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SNLinkZJ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsZJTestDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsZJTestDataResponse::InsZJTestDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsZJTestDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZJTestDataResponse::InsZJTestDataResult);
#endif
}

int _ns1__InsZJTestDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsZJTestDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsZJTestDataResponse(struct soap *soap, const char *tag, int id, const _ns1__InsZJTestDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsZJTestDataResponse), type))
		return soap->error;
	if (a->InsZJTestDataResult)
		soap_element_result(soap, "ns1:InsZJTestDataResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsZJTestDataResult", -1, &a->_ns1__InsZJTestDataResponse::InsZJTestDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsZJTestDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsZJTestDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsZJTestDataResponse * SOAP_FMAC4 soap_in__ns1__InsZJTestDataResponse(struct soap *soap, const char *tag, _ns1__InsZJTestDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsZJTestDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsZJTestDataResponse, sizeof(_ns1__InsZJTestDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsZJTestDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsZJTestDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsZJTestDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsZJTestDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsZJTestDataResult", &a->_ns1__InsZJTestDataResponse::InsZJTestDataResult, "xsd:string"))
				{	soap_flag_InsZJTestDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsZJTestDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsZJTestDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsZJTestDataResponse, SOAP_TYPE__ns1__InsZJTestDataResponse, sizeof(_ns1__InsZJTestDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsZJTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__InsZJTestDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsZJTestDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsZJTestDataResponse *p;
	size_t k = sizeof(_ns1__InsZJTestDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsZJTestDataResponse);
		if (p)
			((_ns1__InsZJTestDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsZJTestDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsZJTestDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsZJTestDataResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsZJTestDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsZJTestDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsZJTestDataResponse(soap, tag ? tag : "ns1:InsZJTestDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsZJTestDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsZJTestDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsZJTestDataResponse * SOAP_FMAC4 soap_get__ns1__InsZJTestDataResponse(struct soap *soap, _ns1__InsZJTestDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsZJTestDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsZJTestData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsZJTestData::Emp = NULL;
	this->_ns1__InsZJTestData::SN = NULL;
	this->_ns1__InsZJTestData::Station = NULL;
	this->_ns1__InsZJTestData::Result = NULL;
	/* transient soap skipped */
}

void _ns1__InsZJTestData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZJTestData::Emp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZJTestData::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZJTestData::Station);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZJTestData::Result);
#endif
}

int _ns1__InsZJTestData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsZJTestData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsZJTestData(struct soap *soap, const char *tag, int id, const _ns1__InsZJTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsZJTestData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp", -1, &a->_ns1__InsZJTestData::Emp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsZJTestData::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__InsZJTestData::Station, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Result", -1, &a->_ns1__InsZJTestData::Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsZJTestData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsZJTestData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsZJTestData * SOAP_FMAC4 soap_in__ns1__InsZJTestData(struct soap *soap, const char *tag, _ns1__InsZJTestData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsZJTestData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsZJTestData, sizeof(_ns1__InsZJTestData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsZJTestData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsZJTestData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	size_t soap_flag_Result1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp", &a->_ns1__InsZJTestData::Emp, "xsd:string"))
				{	soap_flag_Emp1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsZJTestData::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__InsZJTestData::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap_flag_Result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Result", &a->_ns1__InsZJTestData::Result, "xsd:string"))
				{	soap_flag_Result1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsZJTestData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsZJTestData, SOAP_TYPE__ns1__InsZJTestData, sizeof(_ns1__InsZJTestData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsZJTestData * SOAP_FMAC2 soap_instantiate__ns1__InsZJTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsZJTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsZJTestData *p;
	size_t k = sizeof(_ns1__InsZJTestData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsZJTestData);
		if (p)
			((_ns1__InsZJTestData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsZJTestData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsZJTestData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsZJTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsZJTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsZJTestData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsZJTestData(soap, tag ? tag : "ns1:InsZJTestData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsZJTestData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsZJTestData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsZJTestData * SOAP_FMAC4 soap_get__ns1__InsZJTestData(struct soap *soap, _ns1__InsZJTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsZJTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doPmcSNLinkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doPmcSNLinkResponse::doPmcSNLinkResult = NULL;
	/* transient soap skipped */
}

void _ns1__doPmcSNLinkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doPmcSNLinkResponse::doPmcSNLinkResult);
#endif
}

int _ns1__doPmcSNLinkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doPmcSNLinkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doPmcSNLinkResponse(struct soap *soap, const char *tag, int id, const _ns1__doPmcSNLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doPmcSNLinkResponse), type))
		return soap->error;
	if (a->doPmcSNLinkResult)
		soap_element_result(soap, "ns1:doPmcSNLinkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:doPmcSNLinkResult", -1, &a->_ns1__doPmcSNLinkResponse::doPmcSNLinkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doPmcSNLinkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doPmcSNLinkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doPmcSNLinkResponse * SOAP_FMAC4 soap_in__ns1__doPmcSNLinkResponse(struct soap *soap, const char *tag, _ns1__doPmcSNLinkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doPmcSNLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doPmcSNLinkResponse, sizeof(_ns1__doPmcSNLinkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doPmcSNLinkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doPmcSNLinkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_doPmcSNLinkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_doPmcSNLinkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:doPmcSNLinkResult", &a->_ns1__doPmcSNLinkResponse::doPmcSNLinkResult, "xsd:string"))
				{	soap_flag_doPmcSNLinkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:doPmcSNLinkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doPmcSNLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doPmcSNLinkResponse, SOAP_TYPE__ns1__doPmcSNLinkResponse, sizeof(_ns1__doPmcSNLinkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doPmcSNLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__doPmcSNLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doPmcSNLinkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doPmcSNLinkResponse *p;
	size_t k = sizeof(_ns1__doPmcSNLinkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doPmcSNLinkResponse);
		if (p)
			((_ns1__doPmcSNLinkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doPmcSNLinkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doPmcSNLinkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doPmcSNLinkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doPmcSNLinkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doPmcSNLinkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doPmcSNLinkResponse(soap, tag ? tag : "ns1:doPmcSNLinkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doPmcSNLinkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doPmcSNLinkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doPmcSNLinkResponse * SOAP_FMAC4 soap_get__ns1__doPmcSNLinkResponse(struct soap *soap, _ns1__doPmcSNLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doPmcSNLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doPmcSNLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doPmcSNLink::assyDt = NULL;
	this->_ns1__doPmcSNLink::empNO = NULL;
	this->_ns1__doPmcSNLink::SN = NULL;
	this->_ns1__doPmcSNLink::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__doPmcSNLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doPmcSNLink_assyDt(soap, &this->_ns1__doPmcSNLink::assyDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doPmcSNLink::empNO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doPmcSNLink::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doPmcSNLink::StationNumber);
#endif
}

int _ns1__doPmcSNLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doPmcSNLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doPmcSNLink(struct soap *soap, const char *tag, int id, const _ns1__doPmcSNLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doPmcSNLink), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__doPmcSNLink_assyDt(soap, "ns1:assyDt", -1, &a->_ns1__doPmcSNLink::assyDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:empNO", -1, &a->_ns1__doPmcSNLink::empNO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__doPmcSNLink::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__doPmcSNLink::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doPmcSNLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doPmcSNLink(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doPmcSNLink * SOAP_FMAC4 soap_in__ns1__doPmcSNLink(struct soap *soap, const char *tag, _ns1__doPmcSNLink *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doPmcSNLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doPmcSNLink, sizeof(_ns1__doPmcSNLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doPmcSNLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doPmcSNLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assyDt1 = 1;
	size_t soap_flag_empNO1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assyDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doPmcSNLink_assyDt(soap, "ns1:assyDt", &a->_ns1__doPmcSNLink::assyDt, ""))
				{	soap_flag_assyDt1--;
					continue;
				}
			}
			if (soap_flag_empNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:empNO", &a->_ns1__doPmcSNLink::empNO, "xsd:string"))
				{	soap_flag_empNO1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__doPmcSNLink::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__doPmcSNLink::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doPmcSNLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doPmcSNLink, SOAP_TYPE__ns1__doPmcSNLink, sizeof(_ns1__doPmcSNLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doPmcSNLink * SOAP_FMAC2 soap_instantiate__ns1__doPmcSNLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doPmcSNLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doPmcSNLink *p;
	size_t k = sizeof(_ns1__doPmcSNLink);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doPmcSNLink);
		if (p)
			((_ns1__doPmcSNLink*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doPmcSNLink, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doPmcSNLink*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doPmcSNLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doPmcSNLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doPmcSNLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doPmcSNLink(soap, tag ? tag : "ns1:doPmcSNLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doPmcSNLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doPmcSNLink(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doPmcSNLink * SOAP_FMAC4 soap_get__ns1__doPmcSNLink(struct soap *soap, _ns1__doPmcSNLink *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doPmcSNLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPmcSNPartResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPmcSNPartResponse::GetPmcSNPartResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPmcSNPartResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPmcSNPartResponse::GetPmcSNPartResult);
#endif
}

int _ns1__GetPmcSNPartResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPmcSNPartResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPmcSNPartResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPmcSNPartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPmcSNPartResponse), type))
		return soap->error;
	if (a->GetPmcSNPartResult)
		soap_element_result(soap, "ns1:GetPmcSNPartResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetPmcSNPartResult", -1, &a->_ns1__GetPmcSNPartResponse::GetPmcSNPartResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPmcSNPartResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPmcSNPartResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPmcSNPartResponse * SOAP_FMAC4 soap_in__ns1__GetPmcSNPartResponse(struct soap *soap, const char *tag, _ns1__GetPmcSNPartResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPmcSNPartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPmcSNPartResponse, sizeof(_ns1__GetPmcSNPartResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPmcSNPartResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPmcSNPartResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPmcSNPartResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPmcSNPartResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetPmcSNPartResult", &a->_ns1__GetPmcSNPartResponse::GetPmcSNPartResult, "xsd:string"))
				{	soap_flag_GetPmcSNPartResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPmcSNPartResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPmcSNPartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPmcSNPartResponse, SOAP_TYPE__ns1__GetPmcSNPartResponse, sizeof(_ns1__GetPmcSNPartResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPmcSNPartResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPmcSNPartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPmcSNPartResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPmcSNPartResponse *p;
	size_t k = sizeof(_ns1__GetPmcSNPartResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPmcSNPartResponse);
		if (p)
			((_ns1__GetPmcSNPartResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPmcSNPartResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPmcSNPartResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPmcSNPartResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPmcSNPartResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPmcSNPartResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPmcSNPartResponse(soap, tag ? tag : "ns1:GetPmcSNPartResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPmcSNPartResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPmcSNPartResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPmcSNPartResponse * SOAP_FMAC4 soap_get__ns1__GetPmcSNPartResponse(struct soap *soap, _ns1__GetPmcSNPartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPmcSNPartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPmcSNPart::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPmcSNPart::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetPmcSNPart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetPmcSNPart::SN);
#endif
}

int _ns1__GetPmcSNPart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPmcSNPart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPmcSNPart(struct soap *soap, const char *tag, int id, const _ns1__GetPmcSNPart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPmcSNPart), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetPmcSNPart::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPmcSNPart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPmcSNPart(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPmcSNPart * SOAP_FMAC4 soap_in__ns1__GetPmcSNPart(struct soap *soap, const char *tag, _ns1__GetPmcSNPart *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPmcSNPart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPmcSNPart, sizeof(_ns1__GetPmcSNPart), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPmcSNPart)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPmcSNPart *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetPmcSNPart::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPmcSNPart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPmcSNPart, SOAP_TYPE__ns1__GetPmcSNPart, sizeof(_ns1__GetPmcSNPart), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPmcSNPart * SOAP_FMAC2 soap_instantiate__ns1__GetPmcSNPart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPmcSNPart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPmcSNPart *p;
	size_t k = sizeof(_ns1__GetPmcSNPart);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPmcSNPart);
		if (p)
			((_ns1__GetPmcSNPart*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPmcSNPart, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPmcSNPart*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPmcSNPart location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPmcSNPart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPmcSNPart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPmcSNPart(soap, tag ? tag : "ns1:GetPmcSNPart", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPmcSNPart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPmcSNPart(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPmcSNPart * SOAP_FMAC4 soap_get__ns1__GetPmcSNPart(struct soap *soap, _ns1__GetPmcSNPart *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPmcSNPart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPmcPartAssyListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPmcPartAssyListResponse::getPmcPartAssyListResult = NULL;
	/* transient soap skipped */
}

void _ns1__getPmcPartAssyListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, &this->_ns1__getPmcPartAssyListResponse::getPmcPartAssyListResult);
#endif
}

int _ns1__getPmcPartAssyListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPmcPartAssyListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPmcPartAssyListResponse(struct soap *soap, const char *tag, int id, const _ns1__getPmcPartAssyListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPmcPartAssyListResponse), type))
		return soap->error;
	if (a->getPmcPartAssyListResult)
		soap_element_result(soap, "ns1:getPmcPartAssyListResult");
	if (soap_out_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, "ns1:getPmcPartAssyListResult", -1, &a->_ns1__getPmcPartAssyListResponse::getPmcPartAssyListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPmcPartAssyListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPmcPartAssyListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPmcPartAssyListResponse * SOAP_FMAC4 soap_in__ns1__getPmcPartAssyListResponse(struct soap *soap, const char *tag, _ns1__getPmcPartAssyListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPmcPartAssyListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPmcPartAssyListResponse, sizeof(_ns1__getPmcPartAssyListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPmcPartAssyListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPmcPartAssyListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getPmcPartAssyListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getPmcPartAssyListResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, "ns1:getPmcPartAssyListResult", &a->_ns1__getPmcPartAssyListResponse::getPmcPartAssyListResult, ""))
				{	soap_flag_getPmcPartAssyListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getPmcPartAssyListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPmcPartAssyListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPmcPartAssyListResponse, SOAP_TYPE__ns1__getPmcPartAssyListResponse, sizeof(_ns1__getPmcPartAssyListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPmcPartAssyListResponse * SOAP_FMAC2 soap_instantiate__ns1__getPmcPartAssyListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPmcPartAssyListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPmcPartAssyListResponse *p;
	size_t k = sizeof(_ns1__getPmcPartAssyListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPmcPartAssyListResponse);
		if (p)
			((_ns1__getPmcPartAssyListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPmcPartAssyListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPmcPartAssyListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPmcPartAssyListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPmcPartAssyListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPmcPartAssyListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPmcPartAssyListResponse(soap, tag ? tag : "ns1:getPmcPartAssyListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPmcPartAssyListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPmcPartAssyListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPmcPartAssyListResponse * SOAP_FMAC4 soap_get__ns1__getPmcPartAssyListResponse(struct soap *soap, _ns1__getPmcPartAssyListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPmcPartAssyListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPmcPartAssyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPmcPartAssyList::SN = NULL;
	this->_ns1__getPmcPartAssyList::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__getPmcPartAssyList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPmcPartAssyList::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPmcPartAssyList::StationNumber);
#endif
}

int _ns1__getPmcPartAssyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPmcPartAssyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPmcPartAssyList(struct soap *soap, const char *tag, int id, const _ns1__getPmcPartAssyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPmcPartAssyList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__getPmcPartAssyList::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__getPmcPartAssyList::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPmcPartAssyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPmcPartAssyList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPmcPartAssyList * SOAP_FMAC4 soap_in__ns1__getPmcPartAssyList(struct soap *soap, const char *tag, _ns1__getPmcPartAssyList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPmcPartAssyList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPmcPartAssyList, sizeof(_ns1__getPmcPartAssyList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPmcPartAssyList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPmcPartAssyList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__getPmcPartAssyList::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__getPmcPartAssyList::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPmcPartAssyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPmcPartAssyList, SOAP_TYPE__ns1__getPmcPartAssyList, sizeof(_ns1__getPmcPartAssyList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPmcPartAssyList * SOAP_FMAC2 soap_instantiate__ns1__getPmcPartAssyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPmcPartAssyList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPmcPartAssyList *p;
	size_t k = sizeof(_ns1__getPmcPartAssyList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPmcPartAssyList);
		if (p)
			((_ns1__getPmcPartAssyList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPmcPartAssyList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPmcPartAssyList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPmcPartAssyList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPmcPartAssyList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPmcPartAssyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPmcPartAssyList(soap, tag ? tag : "ns1:getPmcPartAssyList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPmcPartAssyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPmcPartAssyList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPmcPartAssyList * SOAP_FMAC4 soap_get__ns1__getPmcPartAssyList(struct soap *soap, _ns1__getPmcPartAssyList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPmcPartAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPmcAssyListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPmcAssyListResponse::getPmcAssyListResult = NULL;
	/* transient soap skipped */
}

void _ns1__getPmcAssyListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, &this->_ns1__getPmcAssyListResponse::getPmcAssyListResult);
#endif
}

int _ns1__getPmcAssyListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPmcAssyListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPmcAssyListResponse(struct soap *soap, const char *tag, int id, const _ns1__getPmcAssyListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPmcAssyListResponse), type))
		return soap->error;
	if (a->getPmcAssyListResult)
		soap_element_result(soap, "ns1:getPmcAssyListResult");
	if (soap_out_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, "ns1:getPmcAssyListResult", -1, &a->_ns1__getPmcAssyListResponse::getPmcAssyListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPmcAssyListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPmcAssyListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPmcAssyListResponse * SOAP_FMAC4 soap_in__ns1__getPmcAssyListResponse(struct soap *soap, const char *tag, _ns1__getPmcAssyListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPmcAssyListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPmcAssyListResponse, sizeof(_ns1__getPmcAssyListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPmcAssyListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPmcAssyListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getPmcAssyListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getPmcAssyListResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, "ns1:getPmcAssyListResult", &a->_ns1__getPmcAssyListResponse::getPmcAssyListResult, ""))
				{	soap_flag_getPmcAssyListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getPmcAssyListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPmcAssyListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPmcAssyListResponse, SOAP_TYPE__ns1__getPmcAssyListResponse, sizeof(_ns1__getPmcAssyListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPmcAssyListResponse * SOAP_FMAC2 soap_instantiate__ns1__getPmcAssyListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPmcAssyListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPmcAssyListResponse *p;
	size_t k = sizeof(_ns1__getPmcAssyListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPmcAssyListResponse);
		if (p)
			((_ns1__getPmcAssyListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPmcAssyListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPmcAssyListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPmcAssyListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPmcAssyListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPmcAssyListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPmcAssyListResponse(soap, tag ? tag : "ns1:getPmcAssyListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPmcAssyListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPmcAssyListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPmcAssyListResponse * SOAP_FMAC4 soap_get__ns1__getPmcAssyListResponse(struct soap *soap, _ns1__getPmcAssyListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPmcAssyListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPmcAssyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPmcAssyList::SN = NULL;
	this->_ns1__getPmcAssyList::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__getPmcAssyList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPmcAssyList::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPmcAssyList::StationNumber);
#endif
}

int _ns1__getPmcAssyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPmcAssyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPmcAssyList(struct soap *soap, const char *tag, int id, const _ns1__getPmcAssyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPmcAssyList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__getPmcAssyList::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__getPmcAssyList::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPmcAssyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPmcAssyList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPmcAssyList * SOAP_FMAC4 soap_in__ns1__getPmcAssyList(struct soap *soap, const char *tag, _ns1__getPmcAssyList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPmcAssyList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPmcAssyList, sizeof(_ns1__getPmcAssyList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPmcAssyList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPmcAssyList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__getPmcAssyList::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__getPmcAssyList::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPmcAssyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPmcAssyList, SOAP_TYPE__ns1__getPmcAssyList, sizeof(_ns1__getPmcAssyList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPmcAssyList * SOAP_FMAC2 soap_instantiate__ns1__getPmcAssyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPmcAssyList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPmcAssyList *p;
	size_t k = sizeof(_ns1__getPmcAssyList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPmcAssyList);
		if (p)
			((_ns1__getPmcAssyList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPmcAssyList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPmcAssyList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPmcAssyList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPmcAssyList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPmcAssyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPmcAssyList(soap, tag ? tag : "ns1:getPmcAssyList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPmcAssyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPmcAssyList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPmcAssyList * SOAP_FMAC4 soap_get__ns1__getPmcAssyList(struct soap *soap, _ns1__getPmcAssyList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPmcAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doAssyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doAssyResponse::doAssyResult = NULL;
	/* transient soap skipped */
}

void _ns1__doAssyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doAssyResponse::doAssyResult);
#endif
}

int _ns1__doAssyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doAssyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doAssyResponse(struct soap *soap, const char *tag, int id, const _ns1__doAssyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doAssyResponse), type))
		return soap->error;
	if (a->doAssyResult)
		soap_element_result(soap, "ns1:doAssyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:doAssyResult", -1, &a->_ns1__doAssyResponse::doAssyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doAssyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doAssyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doAssyResponse * SOAP_FMAC4 soap_in__ns1__doAssyResponse(struct soap *soap, const char *tag, _ns1__doAssyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doAssyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doAssyResponse, sizeof(_ns1__doAssyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doAssyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doAssyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_doAssyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_doAssyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:doAssyResult", &a->_ns1__doAssyResponse::doAssyResult, "xsd:string"))
				{	soap_flag_doAssyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:doAssyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doAssyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doAssyResponse, SOAP_TYPE__ns1__doAssyResponse, sizeof(_ns1__doAssyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doAssyResponse * SOAP_FMAC2 soap_instantiate__ns1__doAssyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doAssyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doAssyResponse *p;
	size_t k = sizeof(_ns1__doAssyResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doAssyResponse);
		if (p)
			((_ns1__doAssyResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doAssyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doAssyResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doAssyResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doAssyResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doAssyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doAssyResponse(soap, tag ? tag : "ns1:doAssyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doAssyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doAssyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doAssyResponse * SOAP_FMAC4 soap_get__ns1__doAssyResponse(struct soap *soap, _ns1__doAssyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doAssyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doAssy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doAssy::assyDt = NULL;
	this->_ns1__doAssy::empNO = NULL;
	this->_ns1__doAssy::SN = NULL;
	this->_ns1__doAssy::MO = NULL;
	this->_ns1__doAssy::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__doAssy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doAssy_assyDt(soap, &this->_ns1__doAssy::assyDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doAssy::empNO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doAssy::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doAssy::MO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doAssy::StationNumber);
#endif
}

int _ns1__doAssy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doAssy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doAssy(struct soap *soap, const char *tag, int id, const _ns1__doAssy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doAssy), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__doAssy_assyDt(soap, "ns1:assyDt", -1, &a->_ns1__doAssy::assyDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:empNO", -1, &a->_ns1__doAssy::empNO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__doAssy::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__doAssy::MO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__doAssy::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doAssy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doAssy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doAssy * SOAP_FMAC4 soap_in__ns1__doAssy(struct soap *soap, const char *tag, _ns1__doAssy *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doAssy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doAssy, sizeof(_ns1__doAssy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doAssy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doAssy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assyDt1 = 1;
	size_t soap_flag_empNO1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_MO1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assyDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doAssy_assyDt(soap, "ns1:assyDt", &a->_ns1__doAssy::assyDt, ""))
				{	soap_flag_assyDt1--;
					continue;
				}
			}
			if (soap_flag_empNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:empNO", &a->_ns1__doAssy::empNO, "xsd:string"))
				{	soap_flag_empNO1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__doAssy::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__doAssy::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__doAssy::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doAssy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doAssy, SOAP_TYPE__ns1__doAssy, sizeof(_ns1__doAssy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doAssy * SOAP_FMAC2 soap_instantiate__ns1__doAssy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doAssy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doAssy *p;
	size_t k = sizeof(_ns1__doAssy);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doAssy);
		if (p)
			((_ns1__doAssy*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doAssy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doAssy*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doAssy location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doAssy, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doAssy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doAssy(soap, tag ? tag : "ns1:doAssy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doAssy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doAssy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doAssy * SOAP_FMAC4 soap_get__ns1__doAssy(struct soap *soap, _ns1__doAssy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doAssy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkAssySNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkAssySNResponse::chkAssySNResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkAssySNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkAssySNResponse::chkAssySNResult);
#endif
}

int _ns1__chkAssySNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkAssySNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkAssySNResponse(struct soap *soap, const char *tag, int id, const _ns1__chkAssySNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkAssySNResponse), type))
		return soap->error;
	if (a->chkAssySNResult)
		soap_element_result(soap, "ns1:chkAssySNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkAssySNResult", -1, &a->_ns1__chkAssySNResponse::chkAssySNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkAssySNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkAssySNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkAssySNResponse * SOAP_FMAC4 soap_in__ns1__chkAssySNResponse(struct soap *soap, const char *tag, _ns1__chkAssySNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkAssySNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkAssySNResponse, sizeof(_ns1__chkAssySNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkAssySNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkAssySNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkAssySNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkAssySNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkAssySNResult", &a->_ns1__chkAssySNResponse::chkAssySNResult, "xsd:string"))
				{	soap_flag_chkAssySNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkAssySNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkAssySNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkAssySNResponse, SOAP_TYPE__ns1__chkAssySNResponse, sizeof(_ns1__chkAssySNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkAssySNResponse * SOAP_FMAC2 soap_instantiate__ns1__chkAssySNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkAssySNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkAssySNResponse *p;
	size_t k = sizeof(_ns1__chkAssySNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkAssySNResponse);
		if (p)
			((_ns1__chkAssySNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkAssySNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkAssySNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkAssySNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkAssySNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkAssySNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkAssySNResponse(soap, tag ? tag : "ns1:chkAssySNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkAssySNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkAssySNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkAssySNResponse * SOAP_FMAC4 soap_get__ns1__chkAssySNResponse(struct soap *soap, _ns1__chkAssySNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkAssySNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkAssySN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkAssySN::SN = NULL;
	this->_ns1__chkAssySN::KSN = NULL;
	this->_ns1__chkAssySN::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__chkAssySN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkAssySN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkAssySN::KSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkAssySN::StationNumber);
#endif
}

int _ns1__chkAssySN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkAssySN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkAssySN(struct soap *soap, const char *tag, int id, const _ns1__chkAssySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkAssySN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__chkAssySN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:KSN", -1, &a->_ns1__chkAssySN::KSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__chkAssySN::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkAssySN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkAssySN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkAssySN * SOAP_FMAC4 soap_in__ns1__chkAssySN(struct soap *soap, const char *tag, _ns1__chkAssySN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkAssySN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkAssySN, sizeof(_ns1__chkAssySN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkAssySN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkAssySN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_KSN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__chkAssySN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_KSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:KSN", &a->_ns1__chkAssySN::KSN, "xsd:string"))
				{	soap_flag_KSN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__chkAssySN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkAssySN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkAssySN, SOAP_TYPE__ns1__chkAssySN, sizeof(_ns1__chkAssySN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkAssySN * SOAP_FMAC2 soap_instantiate__ns1__chkAssySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkAssySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkAssySN *p;
	size_t k = sizeof(_ns1__chkAssySN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkAssySN);
		if (p)
			((_ns1__chkAssySN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkAssySN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkAssySN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkAssySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkAssySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkAssySN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkAssySN(soap, tag ? tag : "ns1:chkAssySN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkAssySN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkAssySN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkAssySN * SOAP_FMAC4 soap_get__ns1__chkAssySN(struct soap *soap, _ns1__chkAssySN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkAssySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPNbySNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPNbySNResponse::getPNbySNResult = NULL;
	/* transient soap skipped */
}

void _ns1__getPNbySNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPNbySNResponse::getPNbySNResult);
#endif
}

int _ns1__getPNbySNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPNbySNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPNbySNResponse(struct soap *soap, const char *tag, int id, const _ns1__getPNbySNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPNbySNResponse), type))
		return soap->error;
	if (a->getPNbySNResult)
		soap_element_result(soap, "ns1:getPNbySNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:getPNbySNResult", -1, &a->_ns1__getPNbySNResponse::getPNbySNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPNbySNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPNbySNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPNbySNResponse * SOAP_FMAC4 soap_in__ns1__getPNbySNResponse(struct soap *soap, const char *tag, _ns1__getPNbySNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPNbySNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPNbySNResponse, sizeof(_ns1__getPNbySNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPNbySNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPNbySNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getPNbySNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getPNbySNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:getPNbySNResult", &a->_ns1__getPNbySNResponse::getPNbySNResult, "xsd:string"))
				{	soap_flag_getPNbySNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getPNbySNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPNbySNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPNbySNResponse, SOAP_TYPE__ns1__getPNbySNResponse, sizeof(_ns1__getPNbySNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPNbySNResponse * SOAP_FMAC2 soap_instantiate__ns1__getPNbySNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPNbySNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPNbySNResponse *p;
	size_t k = sizeof(_ns1__getPNbySNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPNbySNResponse);
		if (p)
			((_ns1__getPNbySNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPNbySNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPNbySNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPNbySNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPNbySNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPNbySNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPNbySNResponse(soap, tag ? tag : "ns1:getPNbySNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPNbySNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPNbySNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPNbySNResponse * SOAP_FMAC4 soap_get__ns1__getPNbySNResponse(struct soap *soap, _ns1__getPNbySNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPNbySNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPNbySN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPNbySN::SN = NULL;
	/* transient soap skipped */
}

void _ns1__getPNbySN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPNbySN::SN);
#endif
}

int _ns1__getPNbySN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPNbySN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPNbySN(struct soap *soap, const char *tag, int id, const _ns1__getPNbySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPNbySN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__getPNbySN::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPNbySN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPNbySN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPNbySN * SOAP_FMAC4 soap_in__ns1__getPNbySN(struct soap *soap, const char *tag, _ns1__getPNbySN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPNbySN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPNbySN, sizeof(_ns1__getPNbySN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPNbySN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPNbySN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__getPNbySN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPNbySN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPNbySN, SOAP_TYPE__ns1__getPNbySN, sizeof(_ns1__getPNbySN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPNbySN * SOAP_FMAC2 soap_instantiate__ns1__getPNbySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPNbySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPNbySN *p;
	size_t k = sizeof(_ns1__getPNbySN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPNbySN);
		if (p)
			((_ns1__getPNbySN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPNbySN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPNbySN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPNbySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPNbySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPNbySN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPNbySN(soap, tag ? tag : "ns1:getPNbySN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPNbySN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPNbySN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPNbySN * SOAP_FMAC4 soap_get__ns1__getPNbySN(struct soap *soap, _ns1__getPNbySN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPNbySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoAssyCountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMoAssyCountResponse::getMoAssyCountResult = NULL;
	/* transient soap skipped */
}

void _ns1__getMoAssyCountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyCountResponse::getMoAssyCountResult);
#endif
}

int _ns1__getMoAssyCountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoAssyCountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoAssyCountResponse(struct soap *soap, const char *tag, int id, const _ns1__getMoAssyCountResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoAssyCountResponse), type))
		return soap->error;
	if (a->getMoAssyCountResult)
		soap_element_result(soap, "ns1:getMoAssyCountResult");
	if (soap_out_PointerTostd__string(soap, "ns1:getMoAssyCountResult", -1, &a->_ns1__getMoAssyCountResponse::getMoAssyCountResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoAssyCountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoAssyCountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoAssyCountResponse * SOAP_FMAC4 soap_in__ns1__getMoAssyCountResponse(struct soap *soap, const char *tag, _ns1__getMoAssyCountResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoAssyCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoAssyCountResponse, sizeof(_ns1__getMoAssyCountResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoAssyCountResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoAssyCountResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getMoAssyCountResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getMoAssyCountResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:getMoAssyCountResult", &a->_ns1__getMoAssyCountResponse::getMoAssyCountResult, "xsd:string"))
				{	soap_flag_getMoAssyCountResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getMoAssyCountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoAssyCountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoAssyCountResponse, SOAP_TYPE__ns1__getMoAssyCountResponse, sizeof(_ns1__getMoAssyCountResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoAssyCountResponse * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoAssyCountResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoAssyCountResponse *p;
	size_t k = sizeof(_ns1__getMoAssyCountResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoAssyCountResponse);
		if (p)
			((_ns1__getMoAssyCountResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoAssyCountResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMoAssyCountResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoAssyCountResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoAssyCountResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoAssyCountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoAssyCountResponse(soap, tag ? tag : "ns1:getMoAssyCountResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoAssyCountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoAssyCountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoAssyCountResponse * SOAP_FMAC4 soap_get__ns1__getMoAssyCountResponse(struct soap *soap, _ns1__getMoAssyCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoAssyCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoAssyCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMoAssyCount::MoNumber = NULL;
	this->_ns1__getMoAssyCount::StationNumber = NULL;
	this->_ns1__getMoAssyCount::StationType = NULL;
	/* transient soap skipped */
}

void _ns1__getMoAssyCount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyCount::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyCount::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyCount::StationType);
#endif
}

int _ns1__getMoAssyCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoAssyCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoAssyCount(struct soap *soap, const char *tag, int id, const _ns1__getMoAssyCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoAssyCount), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__getMoAssyCount::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__getMoAssyCount::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationType", -1, &a->_ns1__getMoAssyCount::StationType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoAssyCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoAssyCount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoAssyCount * SOAP_FMAC4 soap_in__ns1__getMoAssyCount(struct soap *soap, const char *tag, _ns1__getMoAssyCount *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoAssyCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoAssyCount, sizeof(_ns1__getMoAssyCount), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoAssyCount)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoAssyCount *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_StationType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__getMoAssyCount::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__getMoAssyCount::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_StationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationType", &a->_ns1__getMoAssyCount::StationType, "xsd:string"))
				{	soap_flag_StationType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoAssyCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoAssyCount, SOAP_TYPE__ns1__getMoAssyCount, sizeof(_ns1__getMoAssyCount), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoAssyCount * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoAssyCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoAssyCount *p;
	size_t k = sizeof(_ns1__getMoAssyCount);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoAssyCount);
		if (p)
			((_ns1__getMoAssyCount*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoAssyCount, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMoAssyCount*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoAssyCount location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoAssyCount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoAssyCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoAssyCount(soap, tag ? tag : "ns1:getMoAssyCount", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoAssyCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoAssyCount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoAssyCount * SOAP_FMAC4 soap_get__ns1__getMoAssyCount(struct soap *soap, _ns1__getMoAssyCount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoAssyCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLinkOutSnResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLinkOutSnResponse::GetLinkOutSnResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetLinkOutSnResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, &this->_ns1__GetLinkOutSnResponse::GetLinkOutSnResult);
#endif
}

int _ns1__GetLinkOutSnResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLinkOutSnResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLinkOutSnResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLinkOutSnResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLinkOutSnResponse), type))
		return soap->error;
	if (a->GetLinkOutSnResult)
		soap_element_result(soap, "ns1:GetLinkOutSnResult");
	if (soap_out_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, "ns1:GetLinkOutSnResult", -1, &a->_ns1__GetLinkOutSnResponse::GetLinkOutSnResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLinkOutSnResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLinkOutSnResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLinkOutSnResponse * SOAP_FMAC4 soap_in__ns1__GetLinkOutSnResponse(struct soap *soap, const char *tag, _ns1__GetLinkOutSnResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLinkOutSnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLinkOutSnResponse, sizeof(_ns1__GetLinkOutSnResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLinkOutSnResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLinkOutSnResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLinkOutSnResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLinkOutSnResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, "ns1:GetLinkOutSnResult", &a->_ns1__GetLinkOutSnResponse::GetLinkOutSnResult, ""))
				{	soap_flag_GetLinkOutSnResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetLinkOutSnResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLinkOutSnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLinkOutSnResponse, SOAP_TYPE__ns1__GetLinkOutSnResponse, sizeof(_ns1__GetLinkOutSnResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLinkOutSnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLinkOutSnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLinkOutSnResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLinkOutSnResponse *p;
	size_t k = sizeof(_ns1__GetLinkOutSnResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLinkOutSnResponse);
		if (p)
			((_ns1__GetLinkOutSnResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLinkOutSnResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLinkOutSnResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLinkOutSnResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLinkOutSnResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLinkOutSnResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLinkOutSnResponse(soap, tag ? tag : "ns1:GetLinkOutSnResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLinkOutSnResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLinkOutSnResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLinkOutSnResponse * SOAP_FMAC4 soap_get__ns1__GetLinkOutSnResponse(struct soap *soap, _ns1__GetLinkOutSnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLinkOutSnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLinkOutSn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLinkOutSn::Mo = NULL;
	this->_ns1__GetLinkOutSn::Part = NULL;
	this->_ns1__GetLinkOutSn::OutPart = NULL;
	/* transient soap skipped */
}

void _ns1__GetLinkOutSn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLinkOutSn::Mo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLinkOutSn::Part);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLinkOutSn::OutPart);
#endif
}

int _ns1__GetLinkOutSn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLinkOutSn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLinkOutSn(struct soap *soap, const char *tag, int id, const _ns1__GetLinkOutSn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLinkOutSn), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Mo", -1, &a->_ns1__GetLinkOutSn::Mo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Part", -1, &a->_ns1__GetLinkOutSn::Part, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:OutPart", -1, &a->_ns1__GetLinkOutSn::OutPart, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLinkOutSn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLinkOutSn(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLinkOutSn * SOAP_FMAC4 soap_in__ns1__GetLinkOutSn(struct soap *soap, const char *tag, _ns1__GetLinkOutSn *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLinkOutSn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLinkOutSn, sizeof(_ns1__GetLinkOutSn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLinkOutSn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLinkOutSn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mo1 = 1;
	size_t soap_flag_Part1 = 1;
	size_t soap_flag_OutPart1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Mo", &a->_ns1__GetLinkOutSn::Mo, "xsd:string"))
				{	soap_flag_Mo1--;
					continue;
				}
			}
			if (soap_flag_Part1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Part", &a->_ns1__GetLinkOutSn::Part, "xsd:string"))
				{	soap_flag_Part1--;
					continue;
				}
			}
			if (soap_flag_OutPart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OutPart", &a->_ns1__GetLinkOutSn::OutPart, "xsd:string"))
				{	soap_flag_OutPart1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLinkOutSn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLinkOutSn, SOAP_TYPE__ns1__GetLinkOutSn, sizeof(_ns1__GetLinkOutSn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLinkOutSn * SOAP_FMAC2 soap_instantiate__ns1__GetLinkOutSn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLinkOutSn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLinkOutSn *p;
	size_t k = sizeof(_ns1__GetLinkOutSn);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLinkOutSn);
		if (p)
			((_ns1__GetLinkOutSn*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLinkOutSn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLinkOutSn*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLinkOutSn location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLinkOutSn, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLinkOutSn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLinkOutSn(soap, tag ? tag : "ns1:GetLinkOutSn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLinkOutSn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLinkOutSn(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLinkOutSn * SOAP_FMAC4 soap_get__ns1__GetLinkOutSn(struct soap *soap, _ns1__GetLinkOutSn *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLinkOutSn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsPartAssyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsPartAssyResponse::InsPartAssyResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsPartAssyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsPartAssyResponse::InsPartAssyResult);
#endif
}

int _ns1__InsPartAssyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsPartAssyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsPartAssyResponse(struct soap *soap, const char *tag, int id, const _ns1__InsPartAssyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsPartAssyResponse), type))
		return soap->error;
	if (a->InsPartAssyResult)
		soap_element_result(soap, "ns1:InsPartAssyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsPartAssyResult", -1, &a->_ns1__InsPartAssyResponse::InsPartAssyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsPartAssyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsPartAssyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsPartAssyResponse * SOAP_FMAC4 soap_in__ns1__InsPartAssyResponse(struct soap *soap, const char *tag, _ns1__InsPartAssyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsPartAssyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsPartAssyResponse, sizeof(_ns1__InsPartAssyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsPartAssyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsPartAssyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsPartAssyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsPartAssyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsPartAssyResult", &a->_ns1__InsPartAssyResponse::InsPartAssyResult, "xsd:string"))
				{	soap_flag_InsPartAssyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsPartAssyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsPartAssyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsPartAssyResponse, SOAP_TYPE__ns1__InsPartAssyResponse, sizeof(_ns1__InsPartAssyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsPartAssyResponse * SOAP_FMAC2 soap_instantiate__ns1__InsPartAssyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsPartAssyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsPartAssyResponse *p;
	size_t k = sizeof(_ns1__InsPartAssyResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsPartAssyResponse);
		if (p)
			((_ns1__InsPartAssyResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsPartAssyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsPartAssyResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsPartAssyResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsPartAssyResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsPartAssyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsPartAssyResponse(soap, tag ? tag : "ns1:InsPartAssyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsPartAssyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsPartAssyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsPartAssyResponse * SOAP_FMAC4 soap_get__ns1__InsPartAssyResponse(struct soap *soap, _ns1__InsPartAssyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsPartAssyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsPartAssy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsPartAssy::Mo = NULL;
	this->_ns1__InsPartAssy::Part = NULL;
	this->_ns1__InsPartAssy::StationNo = NULL;
	this->_ns1__InsPartAssy::SN = NULL;
	this->_ns1__InsPartAssy::SubSn = NULL;
	this->_ns1__InsPartAssy::Desc = NULL;
	/* transient soap skipped */
}

void _ns1__InsPartAssy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsPartAssy::Mo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsPartAssy::Part);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsPartAssy::StationNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsPartAssy::SN);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsPartAssy::SubSn);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsPartAssy::Desc);
#endif
}

int _ns1__InsPartAssy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsPartAssy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsPartAssy(struct soap *soap, const char *tag, int id, const _ns1__InsPartAssy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsPartAssy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Mo", -1, &a->_ns1__InsPartAssy::Mo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Part", -1, &a->_ns1__InsPartAssy::Part, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNo", -1, &a->_ns1__InsPartAssy::StationNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsPartAssy::SN, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:SubSn", -1, &a->_ns1__InsPartAssy::SubSn, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Desc", -1, &a->_ns1__InsPartAssy::Desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsPartAssy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsPartAssy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsPartAssy * SOAP_FMAC4 soap_in__ns1__InsPartAssy(struct soap *soap, const char *tag, _ns1__InsPartAssy *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsPartAssy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsPartAssy, sizeof(_ns1__InsPartAssy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsPartAssy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsPartAssy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mo1 = 1;
	size_t soap_flag_Part1 = 1;
	size_t soap_flag_StationNo1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_SubSn1 = 1;
	size_t soap_flag_Desc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Mo", &a->_ns1__InsPartAssy::Mo, "xsd:string"))
				{	soap_flag_Mo1--;
					continue;
				}
			}
			if (soap_flag_Part1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Part", &a->_ns1__InsPartAssy::Part, "xsd:string"))
				{	soap_flag_Part1--;
					continue;
				}
			}
			if (soap_flag_StationNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNo", &a->_ns1__InsPartAssy::StationNo, "xsd:string"))
				{	soap_flag_StationNo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsPartAssy::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_SubSn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:SubSn", &a->_ns1__InsPartAssy::SubSn, "ns1:ArrayOfString"))
				{	soap_flag_SubSn1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Desc", &a->_ns1__InsPartAssy::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsPartAssy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsPartAssy, SOAP_TYPE__ns1__InsPartAssy, sizeof(_ns1__InsPartAssy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsPartAssy * SOAP_FMAC2 soap_instantiate__ns1__InsPartAssy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsPartAssy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsPartAssy *p;
	size_t k = sizeof(_ns1__InsPartAssy);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsPartAssy);
		if (p)
			((_ns1__InsPartAssy*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsPartAssy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsPartAssy*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsPartAssy location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsPartAssy, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsPartAssy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsPartAssy(soap, tag ? tag : "ns1:InsPartAssy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsPartAssy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsPartAssy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsPartAssy * SOAP_FMAC4 soap_get__ns1__InsPartAssy(struct soap *soap, _ns1__InsPartAssy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsPartAssy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPartBomExtResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPartBomExtResponse::getPartBomExtResult = NULL;
	/* transient soap skipped */
}

void _ns1__getPartBomExtResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, &this->_ns1__getPartBomExtResponse::getPartBomExtResult);
#endif
}

int _ns1__getPartBomExtResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPartBomExtResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPartBomExtResponse(struct soap *soap, const char *tag, int id, const _ns1__getPartBomExtResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPartBomExtResponse), type))
		return soap->error;
	if (a->getPartBomExtResult)
		soap_element_result(soap, "ns1:getPartBomExtResult");
	if (soap_out_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, "ns1:getPartBomExtResult", -1, &a->_ns1__getPartBomExtResponse::getPartBomExtResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPartBomExtResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPartBomExtResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPartBomExtResponse * SOAP_FMAC4 soap_in__ns1__getPartBomExtResponse(struct soap *soap, const char *tag, _ns1__getPartBomExtResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPartBomExtResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPartBomExtResponse, sizeof(_ns1__getPartBomExtResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPartBomExtResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPartBomExtResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getPartBomExtResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getPartBomExtResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, "ns1:getPartBomExtResult", &a->_ns1__getPartBomExtResponse::getPartBomExtResult, ""))
				{	soap_flag_getPartBomExtResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getPartBomExtResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPartBomExtResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPartBomExtResponse, SOAP_TYPE__ns1__getPartBomExtResponse, sizeof(_ns1__getPartBomExtResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPartBomExtResponse * SOAP_FMAC2 soap_instantiate__ns1__getPartBomExtResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPartBomExtResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPartBomExtResponse *p;
	size_t k = sizeof(_ns1__getPartBomExtResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPartBomExtResponse);
		if (p)
			((_ns1__getPartBomExtResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPartBomExtResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPartBomExtResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPartBomExtResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPartBomExtResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPartBomExtResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPartBomExtResponse(soap, tag ? tag : "ns1:getPartBomExtResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPartBomExtResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPartBomExtResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPartBomExtResponse * SOAP_FMAC4 soap_get__ns1__getPartBomExtResponse(struct soap *soap, _ns1__getPartBomExtResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPartBomExtResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getPartBomExt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPartBomExt::PartNo = NULL;
	this->_ns1__getPartBomExt::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__getPartBomExt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPartBomExt::PartNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getPartBomExt::StationNumber);
#endif
}

int _ns1__getPartBomExt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPartBomExt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPartBomExt(struct soap *soap, const char *tag, int id, const _ns1__getPartBomExt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPartBomExt), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PartNo", -1, &a->_ns1__getPartBomExt::PartNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__getPartBomExt::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPartBomExt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPartBomExt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPartBomExt * SOAP_FMAC4 soap_in__ns1__getPartBomExt(struct soap *soap, const char *tag, _ns1__getPartBomExt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPartBomExt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPartBomExt, sizeof(_ns1__getPartBomExt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getPartBomExt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getPartBomExt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PartNo1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PartNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PartNo", &a->_ns1__getPartBomExt::PartNo, "xsd:string"))
				{	soap_flag_PartNo1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__getPartBomExt::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPartBomExt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPartBomExt, SOAP_TYPE__ns1__getPartBomExt, sizeof(_ns1__getPartBomExt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getPartBomExt * SOAP_FMAC2 soap_instantiate__ns1__getPartBomExt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPartBomExt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getPartBomExt *p;
	size_t k = sizeof(_ns1__getPartBomExt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getPartBomExt);
		if (p)
			((_ns1__getPartBomExt*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getPartBomExt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getPartBomExt*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getPartBomExt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getPartBomExt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getPartBomExt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getPartBomExt(soap, tag ? tag : "ns1:getPartBomExt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPartBomExt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPartBomExt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPartBomExt * SOAP_FMAC4 soap_get__ns1__getPartBomExt(struct soap *soap, _ns1__getPartBomExt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPartBomExt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoAssyListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMoAssyListResponse::getMoAssyListResult = NULL;
	/* transient soap skipped */
}

void _ns1__getMoAssyListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, &this->_ns1__getMoAssyListResponse::getMoAssyListResult);
#endif
}

int _ns1__getMoAssyListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoAssyListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoAssyListResponse(struct soap *soap, const char *tag, int id, const _ns1__getMoAssyListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoAssyListResponse), type))
		return soap->error;
	if (a->getMoAssyListResult)
		soap_element_result(soap, "ns1:getMoAssyListResult");
	if (soap_out_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, "ns1:getMoAssyListResult", -1, &a->_ns1__getMoAssyListResponse::getMoAssyListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoAssyListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoAssyListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoAssyListResponse * SOAP_FMAC4 soap_in__ns1__getMoAssyListResponse(struct soap *soap, const char *tag, _ns1__getMoAssyListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoAssyListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoAssyListResponse, sizeof(_ns1__getMoAssyListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoAssyListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoAssyListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getMoAssyListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getMoAssyListResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, "ns1:getMoAssyListResult", &a->_ns1__getMoAssyListResponse::getMoAssyListResult, ""))
				{	soap_flag_getMoAssyListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getMoAssyListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoAssyListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoAssyListResponse, SOAP_TYPE__ns1__getMoAssyListResponse, sizeof(_ns1__getMoAssyListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoAssyListResponse * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoAssyListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoAssyListResponse *p;
	size_t k = sizeof(_ns1__getMoAssyListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoAssyListResponse);
		if (p)
			((_ns1__getMoAssyListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoAssyListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMoAssyListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoAssyListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoAssyListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoAssyListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoAssyListResponse(soap, tag ? tag : "ns1:getMoAssyListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoAssyListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoAssyListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoAssyListResponse * SOAP_FMAC4 soap_get__ns1__getMoAssyListResponse(struct soap *soap, _ns1__getMoAssyListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoAssyListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoAssyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMoAssyList::MoNumber = NULL;
	this->_ns1__getMoAssyList::StationNumber = NULL;
	this->_ns1__getMoAssyList::StationType = NULL;
	/* transient soap skipped */
}

void _ns1__getMoAssyList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyList::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyList::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoAssyList::StationType);
#endif
}

int _ns1__getMoAssyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoAssyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoAssyList(struct soap *soap, const char *tag, int id, const _ns1__getMoAssyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoAssyList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__getMoAssyList::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__getMoAssyList::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationType", -1, &a->_ns1__getMoAssyList::StationType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoAssyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoAssyList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoAssyList * SOAP_FMAC4 soap_in__ns1__getMoAssyList(struct soap *soap, const char *tag, _ns1__getMoAssyList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoAssyList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoAssyList, sizeof(_ns1__getMoAssyList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoAssyList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoAssyList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_StationType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__getMoAssyList::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__getMoAssyList::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_StationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationType", &a->_ns1__getMoAssyList::StationType, "xsd:string"))
				{	soap_flag_StationType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoAssyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoAssyList, SOAP_TYPE__ns1__getMoAssyList, sizeof(_ns1__getMoAssyList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoAssyList * SOAP_FMAC2 soap_instantiate__ns1__getMoAssyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoAssyList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoAssyList *p;
	size_t k = sizeof(_ns1__getMoAssyList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoAssyList);
		if (p)
			((_ns1__getMoAssyList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoAssyList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMoAssyList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoAssyList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoAssyList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoAssyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoAssyList(soap, tag ? tag : "ns1:getMoAssyList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoAssyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoAssyList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoAssyList * SOAP_FMAC4 soap_get__ns1__getMoAssyList(struct soap *soap, _ns1__getMoAssyList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkSnMappingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkSnMappingResponse::chkSnMappingResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkSnMappingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkSnMappingResponse::chkSnMappingResult);
#endif
}

int _ns1__chkSnMappingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkSnMappingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkSnMappingResponse(struct soap *soap, const char *tag, int id, const _ns1__chkSnMappingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkSnMappingResponse), type))
		return soap->error;
	if (a->chkSnMappingResult)
		soap_element_result(soap, "ns1:chkSnMappingResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkSnMappingResult", -1, &a->_ns1__chkSnMappingResponse::chkSnMappingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkSnMappingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkSnMappingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkSnMappingResponse * SOAP_FMAC4 soap_in__ns1__chkSnMappingResponse(struct soap *soap, const char *tag, _ns1__chkSnMappingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkSnMappingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkSnMappingResponse, sizeof(_ns1__chkSnMappingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkSnMappingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkSnMappingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkSnMappingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkSnMappingResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkSnMappingResult", &a->_ns1__chkSnMappingResponse::chkSnMappingResult, "xsd:string"))
				{	soap_flag_chkSnMappingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkSnMappingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkSnMappingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkSnMappingResponse, SOAP_TYPE__ns1__chkSnMappingResponse, sizeof(_ns1__chkSnMappingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkSnMappingResponse * SOAP_FMAC2 soap_instantiate__ns1__chkSnMappingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkSnMappingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkSnMappingResponse *p;
	size_t k = sizeof(_ns1__chkSnMappingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkSnMappingResponse);
		if (p)
			((_ns1__chkSnMappingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkSnMappingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkSnMappingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkSnMappingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkSnMappingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkSnMappingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkSnMappingResponse(soap, tag ? tag : "ns1:chkSnMappingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkSnMappingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkSnMappingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkSnMappingResponse * SOAP_FMAC4 soap_get__ns1__chkSnMappingResponse(struct soap *soap, _ns1__chkSnMappingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkSnMappingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkSnMapping::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkSnMapping::SN = NULL;
	this->_ns1__chkSnMapping::CustSN = NULL;
	this->_ns1__chkSnMapping::MO = NULL;
	/* transient soap skipped */
}

void _ns1__chkSnMapping::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkSnMapping::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkSnMapping::CustSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkSnMapping::MO);
#endif
}

int _ns1__chkSnMapping::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkSnMapping(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkSnMapping(struct soap *soap, const char *tag, int id, const _ns1__chkSnMapping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkSnMapping), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__chkSnMapping::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CustSN", -1, &a->_ns1__chkSnMapping::CustSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__chkSnMapping::MO, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkSnMapping::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkSnMapping(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkSnMapping * SOAP_FMAC4 soap_in__ns1__chkSnMapping(struct soap *soap, const char *tag, _ns1__chkSnMapping *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkSnMapping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkSnMapping, sizeof(_ns1__chkSnMapping), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkSnMapping)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkSnMapping *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_CustSN1 = 1;
	size_t soap_flag_MO1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__chkSnMapping::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_CustSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CustSN", &a->_ns1__chkSnMapping::CustSN, "xsd:string"))
				{	soap_flag_CustSN1--;
					continue;
				}
			}
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__chkSnMapping::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkSnMapping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkSnMapping, SOAP_TYPE__ns1__chkSnMapping, sizeof(_ns1__chkSnMapping), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkSnMapping * SOAP_FMAC2 soap_instantiate__ns1__chkSnMapping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkSnMapping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkSnMapping *p;
	size_t k = sizeof(_ns1__chkSnMapping);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkSnMapping);
		if (p)
			((_ns1__chkSnMapping*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkSnMapping, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkSnMapping*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkSnMapping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkSnMapping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkSnMapping::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkSnMapping(soap, tag ? tag : "ns1:chkSnMapping", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkSnMapping::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkSnMapping(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkSnMapping * SOAP_FMAC4 soap_get__ns1__chkSnMapping(struct soap *soap, _ns1__chkSnMapping *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkSnMapping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getStationTypeDescResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getStationTypeDescResponse::getStationTypeDescResult = NULL;
	/* transient soap skipped */
}

void _ns1__getStationTypeDescResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationTypeDescResponse::getStationTypeDescResult);
#endif
}

int _ns1__getStationTypeDescResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getStationTypeDescResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getStationTypeDescResponse(struct soap *soap, const char *tag, int id, const _ns1__getStationTypeDescResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getStationTypeDescResponse), type))
		return soap->error;
	if (a->getStationTypeDescResult)
		soap_element_result(soap, "ns1:getStationTypeDescResult");
	if (soap_out_PointerTostd__string(soap, "ns1:getStationTypeDescResult", -1, &a->_ns1__getStationTypeDescResponse::getStationTypeDescResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getStationTypeDescResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getStationTypeDescResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getStationTypeDescResponse * SOAP_FMAC4 soap_in__ns1__getStationTypeDescResponse(struct soap *soap, const char *tag, _ns1__getStationTypeDescResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getStationTypeDescResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getStationTypeDescResponse, sizeof(_ns1__getStationTypeDescResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getStationTypeDescResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getStationTypeDescResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getStationTypeDescResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getStationTypeDescResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:getStationTypeDescResult", &a->_ns1__getStationTypeDescResponse::getStationTypeDescResult, "xsd:string"))
				{	soap_flag_getStationTypeDescResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getStationTypeDescResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getStationTypeDescResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getStationTypeDescResponse, SOAP_TYPE__ns1__getStationTypeDescResponse, sizeof(_ns1__getStationTypeDescResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getStationTypeDescResponse * SOAP_FMAC2 soap_instantiate__ns1__getStationTypeDescResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getStationTypeDescResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getStationTypeDescResponse *p;
	size_t k = sizeof(_ns1__getStationTypeDescResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getStationTypeDescResponse);
		if (p)
			((_ns1__getStationTypeDescResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getStationTypeDescResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getStationTypeDescResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getStationTypeDescResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getStationTypeDescResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getStationTypeDescResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getStationTypeDescResponse(soap, tag ? tag : "ns1:getStationTypeDescResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getStationTypeDescResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getStationTypeDescResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getStationTypeDescResponse * SOAP_FMAC4 soap_get__ns1__getStationTypeDescResponse(struct soap *soap, _ns1__getStationTypeDescResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getStationTypeDescResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getStationTypeDesc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getStationTypeDesc::typeID = NULL;
	/* transient soap skipped */
}

void _ns1__getStationTypeDesc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationTypeDesc::typeID);
#endif
}

int _ns1__getStationTypeDesc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getStationTypeDesc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getStationTypeDesc(struct soap *soap, const char *tag, int id, const _ns1__getStationTypeDesc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getStationTypeDesc), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:typeID", -1, &a->_ns1__getStationTypeDesc::typeID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getStationTypeDesc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getStationTypeDesc(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getStationTypeDesc * SOAP_FMAC4 soap_in__ns1__getStationTypeDesc(struct soap *soap, const char *tag, _ns1__getStationTypeDesc *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getStationTypeDesc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getStationTypeDesc, sizeof(_ns1__getStationTypeDesc), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getStationTypeDesc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getStationTypeDesc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_typeID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_typeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:typeID", &a->_ns1__getStationTypeDesc::typeID, "xsd:string"))
				{	soap_flag_typeID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getStationTypeDesc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getStationTypeDesc, SOAP_TYPE__ns1__getStationTypeDesc, sizeof(_ns1__getStationTypeDesc), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getStationTypeDesc * SOAP_FMAC2 soap_instantiate__ns1__getStationTypeDesc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getStationTypeDesc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getStationTypeDesc *p;
	size_t k = sizeof(_ns1__getStationTypeDesc);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getStationTypeDesc);
		if (p)
			((_ns1__getStationTypeDesc*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getStationTypeDesc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getStationTypeDesc*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getStationTypeDesc location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getStationTypeDesc, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getStationTypeDesc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getStationTypeDesc(soap, tag ? tag : "ns1:getStationTypeDesc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getStationTypeDesc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getStationTypeDesc(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getStationTypeDesc * SOAP_FMAC4 soap_get__ns1__getStationTypeDesc(struct soap *soap, _ns1__getStationTypeDesc *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getStationTypeDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getStationByMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getStationByMoResponse::getStationByMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__getStationByMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationByMoResponse::getStationByMoResult);
#endif
}

int _ns1__getStationByMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getStationByMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getStationByMoResponse(struct soap *soap, const char *tag, int id, const _ns1__getStationByMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getStationByMoResponse), type))
		return soap->error;
	if (a->getStationByMoResult)
		soap_element_result(soap, "ns1:getStationByMoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:getStationByMoResult", -1, &a->_ns1__getStationByMoResponse::getStationByMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getStationByMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getStationByMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getStationByMoResponse * SOAP_FMAC4 soap_in__ns1__getStationByMoResponse(struct soap *soap, const char *tag, _ns1__getStationByMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getStationByMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getStationByMoResponse, sizeof(_ns1__getStationByMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getStationByMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getStationByMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getStationByMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getStationByMoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:getStationByMoResult", &a->_ns1__getStationByMoResponse::getStationByMoResult, "xsd:string"))
				{	soap_flag_getStationByMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getStationByMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getStationByMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getStationByMoResponse, SOAP_TYPE__ns1__getStationByMoResponse, sizeof(_ns1__getStationByMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getStationByMoResponse * SOAP_FMAC2 soap_instantiate__ns1__getStationByMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getStationByMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getStationByMoResponse *p;
	size_t k = sizeof(_ns1__getStationByMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getStationByMoResponse);
		if (p)
			((_ns1__getStationByMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getStationByMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getStationByMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getStationByMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getStationByMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getStationByMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getStationByMoResponse(soap, tag ? tag : "ns1:getStationByMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getStationByMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getStationByMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getStationByMoResponse * SOAP_FMAC4 soap_get__ns1__getStationByMoResponse(struct soap *soap, _ns1__getStationByMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getStationByMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getStationByMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getStationByMo::MoNumber = NULL;
	/* transient soap skipped */
}

void _ns1__getStationByMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationByMo::MoNumber);
#endif
}

int _ns1__getStationByMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getStationByMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getStationByMo(struct soap *soap, const char *tag, int id, const _ns1__getStationByMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getStationByMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__getStationByMo::MoNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getStationByMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getStationByMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getStationByMo * SOAP_FMAC4 soap_in__ns1__getStationByMo(struct soap *soap, const char *tag, _ns1__getStationByMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getStationByMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getStationByMo, sizeof(_ns1__getStationByMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getStationByMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getStationByMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__getStationByMo::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getStationByMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getStationByMo, SOAP_TYPE__ns1__getStationByMo, sizeof(_ns1__getStationByMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getStationByMo * SOAP_FMAC2 soap_instantiate__ns1__getStationByMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getStationByMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getStationByMo *p;
	size_t k = sizeof(_ns1__getStationByMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getStationByMo);
		if (p)
			((_ns1__getStationByMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getStationByMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getStationByMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getStationByMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getStationByMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getStationByMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getStationByMo(soap, tag ? tag : "ns1:getStationByMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getStationByMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getStationByMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getStationByMo * SOAP_FMAC4 soap_get__ns1__getStationByMo(struct soap *soap, _ns1__getStationByMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getStationByMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnDoMappingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnDoMappingResponse::SnDoMappingResult = NULL;
	/* transient soap skipped */
}

void _ns1__SnDoMappingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnDoMappingResponse::SnDoMappingResult);
#endif
}

int _ns1__SnDoMappingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnDoMappingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnDoMappingResponse(struct soap *soap, const char *tag, int id, const _ns1__SnDoMappingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnDoMappingResponse), type))
		return soap->error;
	if (a->SnDoMappingResult)
		soap_element_result(soap, "ns1:SnDoMappingResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SnDoMappingResult", -1, &a->_ns1__SnDoMappingResponse::SnDoMappingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnDoMappingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnDoMappingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnDoMappingResponse * SOAP_FMAC4 soap_in__ns1__SnDoMappingResponse(struct soap *soap, const char *tag, _ns1__SnDoMappingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnDoMappingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnDoMappingResponse, sizeof(_ns1__SnDoMappingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnDoMappingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnDoMappingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SnDoMappingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SnDoMappingResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SnDoMappingResult", &a->_ns1__SnDoMappingResponse::SnDoMappingResult, "xsd:string"))
				{	soap_flag_SnDoMappingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SnDoMappingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SnDoMappingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnDoMappingResponse, SOAP_TYPE__ns1__SnDoMappingResponse, sizeof(_ns1__SnDoMappingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnDoMappingResponse * SOAP_FMAC2 soap_instantiate__ns1__SnDoMappingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnDoMappingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnDoMappingResponse *p;
	size_t k = sizeof(_ns1__SnDoMappingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnDoMappingResponse);
		if (p)
			((_ns1__SnDoMappingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnDoMappingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnDoMappingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnDoMappingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnDoMappingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnDoMappingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SnDoMappingResponse(soap, tag ? tag : "ns1:SnDoMappingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnDoMappingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnDoMappingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnDoMappingResponse * SOAP_FMAC4 soap_get__ns1__SnDoMappingResponse(struct soap *soap, _ns1__SnDoMappingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnDoMappingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnDoMapping::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnDoMapping::SN = NULL;
	this->_ns1__SnDoMapping::CustSN = NULL;
	this->_ns1__SnDoMapping::Emp_USCORENo = NULL;
	this->_ns1__SnDoMapping::Station_USCORENumber = NULL;
	this->_ns1__SnDoMapping::LnkType = NULL;
	/* transient soap skipped */
}

void _ns1__SnDoMapping::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnDoMapping::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnDoMapping::CustSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnDoMapping::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnDoMapping::Station_USCORENumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnDoMapping::LnkType);
#endif
}

int _ns1__SnDoMapping::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnDoMapping(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnDoMapping(struct soap *soap, const char *tag, int id, const _ns1__SnDoMapping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnDoMapping), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SnDoMapping::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CustSN", -1, &a->_ns1__SnDoMapping::CustSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__SnDoMapping::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Number", -1, &a->_ns1__SnDoMapping::Station_USCORENumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkType", -1, &a->_ns1__SnDoMapping::LnkType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnDoMapping::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnDoMapping(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnDoMapping * SOAP_FMAC4 soap_in__ns1__SnDoMapping(struct soap *soap, const char *tag, _ns1__SnDoMapping *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnDoMapping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnDoMapping, sizeof(_ns1__SnDoMapping), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnDoMapping)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnDoMapping *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_CustSN1 = 1;
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_Station_USCORENumber1 = 1;
	size_t soap_flag_LnkType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SnDoMapping::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_CustSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CustSN", &a->_ns1__SnDoMapping::CustSN, "xsd:string"))
				{	soap_flag_CustSN1--;
					continue;
				}
			}
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__SnDoMapping::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_Station_USCORENumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Number", &a->_ns1__SnDoMapping::Station_USCORENumber, "xsd:string"))
				{	soap_flag_Station_USCORENumber1--;
					continue;
				}
			}
			if (soap_flag_LnkType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkType", &a->_ns1__SnDoMapping::LnkType, "xsd:string"))
				{	soap_flag_LnkType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SnDoMapping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnDoMapping, SOAP_TYPE__ns1__SnDoMapping, sizeof(_ns1__SnDoMapping), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnDoMapping * SOAP_FMAC2 soap_instantiate__ns1__SnDoMapping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnDoMapping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnDoMapping *p;
	size_t k = sizeof(_ns1__SnDoMapping);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnDoMapping);
		if (p)
			((_ns1__SnDoMapping*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnDoMapping, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnDoMapping*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnDoMapping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnDoMapping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnDoMapping::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SnDoMapping(soap, tag ? tag : "ns1:SnDoMapping", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnDoMapping::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnDoMapping(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnDoMapping * SOAP_FMAC4 soap_get__ns1__SnDoMapping(struct soap *soap, _ns1__SnDoMapping *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnDoMapping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__eMesNextMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__eMesNextMoResponse::eMesNextMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__eMesNextMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__eMesNextMoResponse::eMesNextMoResult);
#endif
}

int _ns1__eMesNextMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__eMesNextMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__eMesNextMoResponse(struct soap *soap, const char *tag, int id, const _ns1__eMesNextMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__eMesNextMoResponse), type))
		return soap->error;
	if (a->eMesNextMoResult)
		soap_element_result(soap, "ns1:eMesNextMoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:eMesNextMoResult", -1, &a->_ns1__eMesNextMoResponse::eMesNextMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__eMesNextMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__eMesNextMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__eMesNextMoResponse * SOAP_FMAC4 soap_in__ns1__eMesNextMoResponse(struct soap *soap, const char *tag, _ns1__eMesNextMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__eMesNextMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__eMesNextMoResponse, sizeof(_ns1__eMesNextMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__eMesNextMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__eMesNextMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_eMesNextMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eMesNextMoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:eMesNextMoResult", &a->_ns1__eMesNextMoResponse::eMesNextMoResult, "xsd:string"))
				{	soap_flag_eMesNextMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:eMesNextMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__eMesNextMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__eMesNextMoResponse, SOAP_TYPE__ns1__eMesNextMoResponse, sizeof(_ns1__eMesNextMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__eMesNextMoResponse * SOAP_FMAC2 soap_instantiate__ns1__eMesNextMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__eMesNextMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__eMesNextMoResponse *p;
	size_t k = sizeof(_ns1__eMesNextMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__eMesNextMoResponse);
		if (p)
			((_ns1__eMesNextMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__eMesNextMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__eMesNextMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__eMesNextMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__eMesNextMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__eMesNextMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__eMesNextMoResponse(soap, tag ? tag : "ns1:eMesNextMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__eMesNextMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__eMesNextMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__eMesNextMoResponse * SOAP_FMAC4 soap_get__ns1__eMesNextMoResponse(struct soap *soap, _ns1__eMesNextMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__eMesNextMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__eMesNextMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__eMesNextMo::SN = NULL;
	this->_ns1__eMesNextMo::STATION_USCORENUMBER = NULL;
	this->_ns1__eMesNextMo::USER_USCORENO = NULL;
	this->_ns1__eMesNextMo::MO = NULL;
	/* transient soap skipped */
}

void _ns1__eMesNextMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__eMesNextMo::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__eMesNextMo::STATION_USCORENUMBER);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__eMesNextMo::USER_USCORENO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__eMesNextMo::MO);
#endif
}

int _ns1__eMesNextMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__eMesNextMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__eMesNextMo(struct soap *soap, const char *tag, int id, const _ns1__eMesNextMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__eMesNextMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__eMesNextMo::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:STATION_NUMBER", -1, &a->_ns1__eMesNextMo::STATION_USCORENUMBER, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:USER_NO", -1, &a->_ns1__eMesNextMo::USER_USCORENO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__eMesNextMo::MO, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__eMesNextMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__eMesNextMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__eMesNextMo * SOAP_FMAC4 soap_in__ns1__eMesNextMo(struct soap *soap, const char *tag, _ns1__eMesNextMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__eMesNextMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__eMesNextMo, sizeof(_ns1__eMesNextMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__eMesNextMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__eMesNextMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_STATION_USCORENUMBER1 = 1;
	size_t soap_flag_USER_USCORENO1 = 1;
	size_t soap_flag_MO1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__eMesNextMo::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_STATION_USCORENUMBER1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:STATION_NUMBER", &a->_ns1__eMesNextMo::STATION_USCORENUMBER, "xsd:string"))
				{	soap_flag_STATION_USCORENUMBER1--;
					continue;
				}
			}
			if (soap_flag_USER_USCORENO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:USER_NO", &a->_ns1__eMesNextMo::USER_USCORENO, "xsd:string"))
				{	soap_flag_USER_USCORENO1--;
					continue;
				}
			}
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__eMesNextMo::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__eMesNextMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__eMesNextMo, SOAP_TYPE__ns1__eMesNextMo, sizeof(_ns1__eMesNextMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__eMesNextMo * SOAP_FMAC2 soap_instantiate__ns1__eMesNextMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__eMesNextMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__eMesNextMo *p;
	size_t k = sizeof(_ns1__eMesNextMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__eMesNextMo);
		if (p)
			((_ns1__eMesNextMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__eMesNextMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__eMesNextMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__eMesNextMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__eMesNextMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__eMesNextMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__eMesNextMo(soap, tag ? tag : "ns1:eMesNextMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__eMesNextMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__eMesNextMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__eMesNextMo * SOAP_FMAC4 soap_get__ns1__eMesNextMo(struct soap *soap, _ns1__eMesNextMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__eMesNextMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendResultForStationNumberResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendResultForStationNumberResponse::sendResultForStationNumberResult = NULL;
	/* transient soap skipped */
}

void _ns1__sendResultForStationNumberResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendResultForStationNumberResponse::sendResultForStationNumberResult);
#endif
}

int _ns1__sendResultForStationNumberResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendResultForStationNumberResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendResultForStationNumberResponse(struct soap *soap, const char *tag, int id, const _ns1__sendResultForStationNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendResultForStationNumberResponse), type))
		return soap->error;
	if (a->sendResultForStationNumberResult)
		soap_element_result(soap, "ns1:sendResultForStationNumberResult");
	if (soap_out_PointerTostd__string(soap, "ns1:sendResultForStationNumberResult", -1, &a->_ns1__sendResultForStationNumberResponse::sendResultForStationNumberResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendResultForStationNumberResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendResultForStationNumberResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendResultForStationNumberResponse * SOAP_FMAC4 soap_in__ns1__sendResultForStationNumberResponse(struct soap *soap, const char *tag, _ns1__sendResultForStationNumberResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendResultForStationNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendResultForStationNumberResponse, sizeof(_ns1__sendResultForStationNumberResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendResultForStationNumberResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendResultForStationNumberResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sendResultForStationNumberResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sendResultForStationNumberResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:sendResultForStationNumberResult", &a->_ns1__sendResultForStationNumberResponse::sendResultForStationNumberResult, "xsd:string"))
				{	soap_flag_sendResultForStationNumberResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:sendResultForStationNumberResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendResultForStationNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendResultForStationNumberResponse, SOAP_TYPE__ns1__sendResultForStationNumberResponse, sizeof(_ns1__sendResultForStationNumberResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendResultForStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__sendResultForStationNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendResultForStationNumberResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendResultForStationNumberResponse *p;
	size_t k = sizeof(_ns1__sendResultForStationNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendResultForStationNumberResponse);
		if (p)
			((_ns1__sendResultForStationNumberResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendResultForStationNumberResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendResultForStationNumberResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendResultForStationNumberResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendResultForStationNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendResultForStationNumberResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendResultForStationNumberResponse(soap, tag ? tag : "ns1:sendResultForStationNumberResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendResultForStationNumberResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendResultForStationNumberResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendResultForStationNumberResponse * SOAP_FMAC4 soap_get__ns1__sendResultForStationNumberResponse(struct soap *soap, _ns1__sendResultForStationNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendResultForStationNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendResultForStationNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendResultForStationNumber::Emp_USCORENo = NULL;
	this->_ns1__sendResultForStationNumber::SN = NULL;
	this->_ns1__sendResultForStationNumber::Station_USCORENumber = NULL;
	this->_ns1__sendResultForStationNumber::TestResult = NULL;
	/* transient soap skipped */
}

void _ns1__sendResultForStationNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendResultForStationNumber::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendResultForStationNumber::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendResultForStationNumber::Station_USCORENumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendResultForStationNumber::TestResult);
#endif
}

int _ns1__sendResultForStationNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendResultForStationNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendResultForStationNumber(struct soap *soap, const char *tag, int id, const _ns1__sendResultForStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendResultForStationNumber), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__sendResultForStationNumber::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__sendResultForStationNumber::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Number", -1, &a->_ns1__sendResultForStationNumber::Station_USCORENumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestResult", -1, &a->_ns1__sendResultForStationNumber::TestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendResultForStationNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendResultForStationNumber(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendResultForStationNumber * SOAP_FMAC4 soap_in__ns1__sendResultForStationNumber(struct soap *soap, const char *tag, _ns1__sendResultForStationNumber *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendResultForStationNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendResultForStationNumber, sizeof(_ns1__sendResultForStationNumber), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendResultForStationNumber)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendResultForStationNumber *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station_USCORENumber1 = 1;
	size_t soap_flag_TestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__sendResultForStationNumber::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__sendResultForStationNumber::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station_USCORENumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Number", &a->_ns1__sendResultForStationNumber::Station_USCORENumber, "xsd:string"))
				{	soap_flag_Station_USCORENumber1--;
					continue;
				}
			}
			if (soap_flag_TestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestResult", &a->_ns1__sendResultForStationNumber::TestResult, "xsd:string"))
				{	soap_flag_TestResult1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendResultForStationNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendResultForStationNumber, SOAP_TYPE__ns1__sendResultForStationNumber, sizeof(_ns1__sendResultForStationNumber), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendResultForStationNumber * SOAP_FMAC2 soap_instantiate__ns1__sendResultForStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendResultForStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendResultForStationNumber *p;
	size_t k = sizeof(_ns1__sendResultForStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendResultForStationNumber);
		if (p)
			((_ns1__sendResultForStationNumber*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendResultForStationNumber, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendResultForStationNumber*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendResultForStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendResultForStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendResultForStationNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendResultForStationNumber(soap, tag ? tag : "ns1:sendResultForStationNumber", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendResultForStationNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendResultForStationNumber(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendResultForStationNumber * SOAP_FMAC4 soap_get__ns1__sendResultForStationNumber(struct soap *soap, _ns1__sendResultForStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendResultForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendDataForStationNumberResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendDataForStationNumberResponse::sendDataForStationNumberResult = NULL;
	/* transient soap skipped */
}

void _ns1__sendDataForStationNumberResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendDataForStationNumberResponse::sendDataForStationNumberResult);
#endif
}

int _ns1__sendDataForStationNumberResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendDataForStationNumberResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendDataForStationNumberResponse(struct soap *soap, const char *tag, int id, const _ns1__sendDataForStationNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendDataForStationNumberResponse), type))
		return soap->error;
	if (a->sendDataForStationNumberResult)
		soap_element_result(soap, "ns1:sendDataForStationNumberResult");
	if (soap_out_PointerTostd__string(soap, "ns1:sendDataForStationNumberResult", -1, &a->_ns1__sendDataForStationNumberResponse::sendDataForStationNumberResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendDataForStationNumberResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendDataForStationNumberResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendDataForStationNumberResponse * SOAP_FMAC4 soap_in__ns1__sendDataForStationNumberResponse(struct soap *soap, const char *tag, _ns1__sendDataForStationNumberResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendDataForStationNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendDataForStationNumberResponse, sizeof(_ns1__sendDataForStationNumberResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendDataForStationNumberResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendDataForStationNumberResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sendDataForStationNumberResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sendDataForStationNumberResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:sendDataForStationNumberResult", &a->_ns1__sendDataForStationNumberResponse::sendDataForStationNumberResult, "xsd:string"))
				{	soap_flag_sendDataForStationNumberResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:sendDataForStationNumberResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendDataForStationNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendDataForStationNumberResponse, SOAP_TYPE__ns1__sendDataForStationNumberResponse, sizeof(_ns1__sendDataForStationNumberResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendDataForStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__sendDataForStationNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendDataForStationNumberResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendDataForStationNumberResponse *p;
	size_t k = sizeof(_ns1__sendDataForStationNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendDataForStationNumberResponse);
		if (p)
			((_ns1__sendDataForStationNumberResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendDataForStationNumberResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendDataForStationNumberResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendDataForStationNumberResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendDataForStationNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendDataForStationNumberResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendDataForStationNumberResponse(soap, tag ? tag : "ns1:sendDataForStationNumberResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendDataForStationNumberResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendDataForStationNumberResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendDataForStationNumberResponse * SOAP_FMAC4 soap_get__ns1__sendDataForStationNumberResponse(struct soap *soap, _ns1__sendDataForStationNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendDataForStationNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendDataForStationNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendDataForStationNumber::Emp_USCORENo = NULL;
	this->_ns1__sendDataForStationNumber::SN = NULL;
	this->_ns1__sendDataForStationNumber::Station_USCORENumber = NULL;
	this->_ns1__sendDataForStationNumber::TestData = NULL;
	/* transient soap skipped */
}

void _ns1__sendDataForStationNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendDataForStationNumber::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendDataForStationNumber::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendDataForStationNumber::Station_USCORENumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendDataForStationNumber::TestData);
#endif
}

int _ns1__sendDataForStationNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendDataForStationNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendDataForStationNumber(struct soap *soap, const char *tag, int id, const _ns1__sendDataForStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendDataForStationNumber), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__sendDataForStationNumber::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__sendDataForStationNumber::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Number", -1, &a->_ns1__sendDataForStationNumber::Station_USCORENumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestData", -1, &a->_ns1__sendDataForStationNumber::TestData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendDataForStationNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendDataForStationNumber(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendDataForStationNumber * SOAP_FMAC4 soap_in__ns1__sendDataForStationNumber(struct soap *soap, const char *tag, _ns1__sendDataForStationNumber *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendDataForStationNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendDataForStationNumber, sizeof(_ns1__sendDataForStationNumber), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendDataForStationNumber)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendDataForStationNumber *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station_USCORENumber1 = 1;
	size_t soap_flag_TestData1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__sendDataForStationNumber::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__sendDataForStationNumber::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station_USCORENumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Number", &a->_ns1__sendDataForStationNumber::Station_USCORENumber, "xsd:string"))
				{	soap_flag_Station_USCORENumber1--;
					continue;
				}
			}
			if (soap_flag_TestData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestData", &a->_ns1__sendDataForStationNumber::TestData, "xsd:string"))
				{	soap_flag_TestData1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendDataForStationNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendDataForStationNumber, SOAP_TYPE__ns1__sendDataForStationNumber, sizeof(_ns1__sendDataForStationNumber), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendDataForStationNumber * SOAP_FMAC2 soap_instantiate__ns1__sendDataForStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendDataForStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendDataForStationNumber *p;
	size_t k = sizeof(_ns1__sendDataForStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendDataForStationNumber);
		if (p)
			((_ns1__sendDataForStationNumber*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendDataForStationNumber, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendDataForStationNumber*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendDataForStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendDataForStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendDataForStationNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendDataForStationNumber(soap, tag ? tag : "ns1:sendDataForStationNumber", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendDataForStationNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendDataForStationNumber(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendDataForStationNumber * SOAP_FMAC4 soap_get__ns1__sendDataForStationNumber(struct soap *soap, _ns1__sendDataForStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendDataForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkEmpForStationNumberResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkEmpForStationNumberResponse::checkEmpForStationNumberResult = NULL;
	/* transient soap skipped */
}

void _ns1__checkEmpForStationNumberResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkEmpForStationNumberResponse::checkEmpForStationNumberResult);
#endif
}

int _ns1__checkEmpForStationNumberResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkEmpForStationNumberResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkEmpForStationNumberResponse(struct soap *soap, const char *tag, int id, const _ns1__checkEmpForStationNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkEmpForStationNumberResponse), type))
		return soap->error;
	if (a->checkEmpForStationNumberResult)
		soap_element_result(soap, "ns1:checkEmpForStationNumberResult");
	if (soap_out_PointerTostd__string(soap, "ns1:checkEmpForStationNumberResult", -1, &a->_ns1__checkEmpForStationNumberResponse::checkEmpForStationNumberResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkEmpForStationNumberResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkEmpForStationNumberResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkEmpForStationNumberResponse * SOAP_FMAC4 soap_in__ns1__checkEmpForStationNumberResponse(struct soap *soap, const char *tag, _ns1__checkEmpForStationNumberResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkEmpForStationNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkEmpForStationNumberResponse, sizeof(_ns1__checkEmpForStationNumberResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkEmpForStationNumberResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkEmpForStationNumberResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_checkEmpForStationNumberResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkEmpForStationNumberResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:checkEmpForStationNumberResult", &a->_ns1__checkEmpForStationNumberResponse::checkEmpForStationNumberResult, "xsd:string"))
				{	soap_flag_checkEmpForStationNumberResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:checkEmpForStationNumberResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkEmpForStationNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkEmpForStationNumberResponse, SOAP_TYPE__ns1__checkEmpForStationNumberResponse, sizeof(_ns1__checkEmpForStationNumberResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkEmpForStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__checkEmpForStationNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkEmpForStationNumberResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkEmpForStationNumberResponse *p;
	size_t k = sizeof(_ns1__checkEmpForStationNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkEmpForStationNumberResponse);
		if (p)
			((_ns1__checkEmpForStationNumberResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkEmpForStationNumberResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkEmpForStationNumberResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkEmpForStationNumberResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkEmpForStationNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkEmpForStationNumberResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkEmpForStationNumberResponse(soap, tag ? tag : "ns1:checkEmpForStationNumberResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkEmpForStationNumberResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkEmpForStationNumberResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkEmpForStationNumberResponse * SOAP_FMAC4 soap_get__ns1__checkEmpForStationNumberResponse(struct soap *soap, _ns1__checkEmpForStationNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkEmpForStationNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkEmpForStationNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkEmpForStationNumber::Emp_USCORENo = NULL;
	this->_ns1__checkEmpForStationNumber::Station_USCORENumber = NULL;
	/* transient soap skipped */
}

void _ns1__checkEmpForStationNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkEmpForStationNumber::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkEmpForStationNumber::Station_USCORENumber);
#endif
}

int _ns1__checkEmpForStationNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkEmpForStationNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkEmpForStationNumber(struct soap *soap, const char *tag, int id, const _ns1__checkEmpForStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkEmpForStationNumber), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__checkEmpForStationNumber::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Number", -1, &a->_ns1__checkEmpForStationNumber::Station_USCORENumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkEmpForStationNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkEmpForStationNumber(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkEmpForStationNumber * SOAP_FMAC4 soap_in__ns1__checkEmpForStationNumber(struct soap *soap, const char *tag, _ns1__checkEmpForStationNumber *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkEmpForStationNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkEmpForStationNumber, sizeof(_ns1__checkEmpForStationNumber), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkEmpForStationNumber)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkEmpForStationNumber *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_Station_USCORENumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__checkEmpForStationNumber::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_Station_USCORENumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Number", &a->_ns1__checkEmpForStationNumber::Station_USCORENumber, "xsd:string"))
				{	soap_flag_Station_USCORENumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkEmpForStationNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkEmpForStationNumber, SOAP_TYPE__ns1__checkEmpForStationNumber, sizeof(_ns1__checkEmpForStationNumber), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkEmpForStationNumber * SOAP_FMAC2 soap_instantiate__ns1__checkEmpForStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkEmpForStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkEmpForStationNumber *p;
	size_t k = sizeof(_ns1__checkEmpForStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkEmpForStationNumber);
		if (p)
			((_ns1__checkEmpForStationNumber*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkEmpForStationNumber, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkEmpForStationNumber*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkEmpForStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkEmpForStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkEmpForStationNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkEmpForStationNumber(soap, tag ? tag : "ns1:checkEmpForStationNumber", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkEmpForStationNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkEmpForStationNumber(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkEmpForStationNumber * SOAP_FMAC4 soap_get__ns1__checkEmpForStationNumber(struct soap *soap, _ns1__checkEmpForStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkEmpForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSN_USCOREStationNumberResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSN_USCOREStationNumberResponse::checkSN_USCOREStationNumberResult = NULL;
	/* transient soap skipped */
}

void _ns1__checkSN_USCOREStationNumberResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSN_USCOREStationNumberResponse::checkSN_USCOREStationNumberResult);
#endif
}

int _ns1__checkSN_USCOREStationNumberResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSN_USCOREStationNumberResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSN_USCOREStationNumberResponse(struct soap *soap, const char *tag, int id, const _ns1__checkSN_USCOREStationNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse), type))
		return soap->error;
	if (a->checkSN_USCOREStationNumberResult)
		soap_element_result(soap, "ns1:checkSN_StationNumberResult");
	if (soap_out_PointerTostd__string(soap, "ns1:checkSN_StationNumberResult", -1, &a->_ns1__checkSN_USCOREStationNumberResponse::checkSN_USCOREStationNumberResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSN_USCOREStationNumberResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSN_USCOREStationNumberResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationNumberResponse * SOAP_FMAC4 soap_in__ns1__checkSN_USCOREStationNumberResponse(struct soap *soap, const char *tag, _ns1__checkSN_USCOREStationNumberResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSN_USCOREStationNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse, sizeof(_ns1__checkSN_USCOREStationNumberResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSN_USCOREStationNumberResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_checkSN_USCOREStationNumberResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkSN_USCOREStationNumberResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:checkSN_StationNumberResult", &a->_ns1__checkSN_USCOREStationNumberResponse::checkSN_USCOREStationNumberResult, "xsd:string"))
				{	soap_flag_checkSN_USCOREStationNumberResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:checkSN_StationNumberResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkSN_USCOREStationNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse, SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse, sizeof(_ns1__checkSN_USCOREStationNumberResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSN_USCOREStationNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStationNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSN_USCOREStationNumberResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSN_USCOREStationNumberResponse *p;
	size_t k = sizeof(_ns1__checkSN_USCOREStationNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSN_USCOREStationNumberResponse);
		if (p)
			((_ns1__checkSN_USCOREStationNumberResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSN_USCOREStationNumberResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSN_USCOREStationNumberResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSN_USCOREStationNumberResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSN_USCOREStationNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSN_USCOREStationNumberResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkSN_USCOREStationNumberResponse(soap, tag ? tag : "ns1:checkSN_StationNumberResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSN_USCOREStationNumberResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSN_USCOREStationNumberResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationNumberResponse * SOAP_FMAC4 soap_get__ns1__checkSN_USCOREStationNumberResponse(struct soap *soap, _ns1__checkSN_USCOREStationNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSN_USCOREStationNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSN_USCOREStationNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSN_USCOREStationNumber::SN = NULL;
	this->_ns1__checkSN_USCOREStationNumber::Station_USCORENumber = NULL;
	/* transient soap skipped */
}

void _ns1__checkSN_USCOREStationNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSN_USCOREStationNumber::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSN_USCOREStationNumber::Station_USCORENumber);
#endif
}

int _ns1__checkSN_USCOREStationNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSN_USCOREStationNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *tag, int id, const _ns1__checkSN_USCOREStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSN_USCOREStationNumber), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__checkSN_USCOREStationNumber::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Number", -1, &a->_ns1__checkSN_USCOREStationNumber::Station_USCORENumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSN_USCOREStationNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSN_USCOREStationNumber(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationNumber * SOAP_FMAC4 soap_in__ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *tag, _ns1__checkSN_USCOREStationNumber *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSN_USCOREStationNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSN_USCOREStationNumber, sizeof(_ns1__checkSN_USCOREStationNumber), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSN_USCOREStationNumber)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSN_USCOREStationNumber *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station_USCORENumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__checkSN_USCOREStationNumber::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station_USCORENumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Number", &a->_ns1__checkSN_USCOREStationNumber::Station_USCORENumber, "xsd:string"))
				{	soap_flag_Station_USCORENumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkSN_USCOREStationNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSN_USCOREStationNumber, SOAP_TYPE__ns1__checkSN_USCOREStationNumber, sizeof(_ns1__checkSN_USCOREStationNumber), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSN_USCOREStationNumber * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSN_USCOREStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSN_USCOREStationNumber *p;
	size_t k = sizeof(_ns1__checkSN_USCOREStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSN_USCOREStationNumber);
		if (p)
			((_ns1__checkSN_USCOREStationNumber*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSN_USCOREStationNumber, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSN_USCOREStationNumber*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSN_USCOREStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSN_USCOREStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSN_USCOREStationNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkSN_USCOREStationNumber(soap, tag ? tag : "ns1:checkSN_StationNumber", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSN_USCOREStationNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSN_USCOREStationNumber(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationNumber * SOAP_FMAC4 soap_get__ns1__checkSN_USCOREStationNumber(struct soap *soap, _ns1__checkSN_USCOREStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSN_USCOREStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnNextMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnNextMoResponse::ChkSnNextMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnNextMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnNextMoResponse::ChkSnNextMoResult);
#endif
}

int _ns1__ChkSnNextMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnNextMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnNextMoResponse(struct soap *soap, const char *tag, int id, const _ns1__ChkSnNextMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnNextMoResponse), type))
		return soap->error;
	if (a->ChkSnNextMoResult)
		soap_element_result(soap, "ns1:ChkSnNextMoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ChkSnNextMoResult", -1, &a->_ns1__ChkSnNextMoResponse::ChkSnNextMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnNextMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnNextMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnNextMoResponse * SOAP_FMAC4 soap_in__ns1__ChkSnNextMoResponse(struct soap *soap, const char *tag, _ns1__ChkSnNextMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnNextMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnNextMoResponse, sizeof(_ns1__ChkSnNextMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnNextMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnNextMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChkSnNextMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChkSnNextMoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ChkSnNextMoResult", &a->_ns1__ChkSnNextMoResponse::ChkSnNextMoResult, "xsd:string"))
				{	soap_flag_ChkSnNextMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChkSnNextMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnNextMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnNextMoResponse, SOAP_TYPE__ns1__ChkSnNextMoResponse, sizeof(_ns1__ChkSnNextMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnNextMoResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnNextMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnNextMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnNextMoResponse *p;
	size_t k = sizeof(_ns1__ChkSnNextMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnNextMoResponse);
		if (p)
			((_ns1__ChkSnNextMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnNextMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnNextMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnNextMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnNextMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnNextMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnNextMoResponse(soap, tag ? tag : "ns1:ChkSnNextMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnNextMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnNextMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnNextMoResponse * SOAP_FMAC4 soap_get__ns1__ChkSnNextMoResponse(struct soap *soap, _ns1__ChkSnNextMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnNextMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnNextMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnNextMo::SN = NULL;
	this->_ns1__ChkSnNextMo::MO = NULL;
	this->_ns1__ChkSnNextMo::STATION_USCORENUMBER = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnNextMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnNextMo::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnNextMo::MO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnNextMo::STATION_USCORENUMBER);
#endif
}

int _ns1__ChkSnNextMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnNextMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnNextMo(struct soap *soap, const char *tag, int id, const _ns1__ChkSnNextMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnNextMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ChkSnNextMo::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__ChkSnNextMo::MO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:STATION_NUMBER", -1, &a->_ns1__ChkSnNextMo::STATION_USCORENUMBER, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnNextMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnNextMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnNextMo * SOAP_FMAC4 soap_in__ns1__ChkSnNextMo(struct soap *soap, const char *tag, _ns1__ChkSnNextMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnNextMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnNextMo, sizeof(_ns1__ChkSnNextMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnNextMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnNextMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_MO1 = 1;
	size_t soap_flag_STATION_USCORENUMBER1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ChkSnNextMo::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__ChkSnNextMo::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap_flag_STATION_USCORENUMBER1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:STATION_NUMBER", &a->_ns1__ChkSnNextMo::STATION_USCORENUMBER, "xsd:string"))
				{	soap_flag_STATION_USCORENUMBER1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnNextMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnNextMo, SOAP_TYPE__ns1__ChkSnNextMo, sizeof(_ns1__ChkSnNextMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnNextMo * SOAP_FMAC2 soap_instantiate__ns1__ChkSnNextMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnNextMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnNextMo *p;
	size_t k = sizeof(_ns1__ChkSnNextMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnNextMo);
		if (p)
			((_ns1__ChkSnNextMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnNextMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnNextMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnNextMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnNextMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnNextMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnNextMo(soap, tag ? tag : "ns1:ChkSnNextMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnNextMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnNextMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnNextMo * SOAP_FMAC4 soap_get__ns1__ChkSnNextMo(struct soap *soap, _ns1__ChkSnNextMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnNextMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnMoResponse::ChkSnMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnMoResponse::ChkSnMoResult);
#endif
}

int _ns1__ChkSnMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnMoResponse(struct soap *soap, const char *tag, int id, const _ns1__ChkSnMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnMoResponse), type))
		return soap->error;
	if (a->ChkSnMoResult)
		soap_element_result(soap, "ns1:ChkSnMoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ChkSnMoResult", -1, &a->_ns1__ChkSnMoResponse::ChkSnMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnMoResponse * SOAP_FMAC4 soap_in__ns1__ChkSnMoResponse(struct soap *soap, const char *tag, _ns1__ChkSnMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnMoResponse, sizeof(_ns1__ChkSnMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChkSnMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChkSnMoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ChkSnMoResult", &a->_ns1__ChkSnMoResponse::ChkSnMoResult, "xsd:string"))
				{	soap_flag_ChkSnMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChkSnMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnMoResponse, SOAP_TYPE__ns1__ChkSnMoResponse, sizeof(_ns1__ChkSnMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnMoResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnMoResponse *p;
	size_t k = sizeof(_ns1__ChkSnMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnMoResponse);
		if (p)
			((_ns1__ChkSnMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnMoResponse(soap, tag ? tag : "ns1:ChkSnMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnMoResponse * SOAP_FMAC4 soap_get__ns1__ChkSnMoResponse(struct soap *soap, _ns1__ChkSnMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnMo::SN = NULL;
	this->_ns1__ChkSnMo::MO = NULL;
	this->_ns1__ChkSnMo::STATION_USCORENUMBER = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnMo::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnMo::MO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnMo::STATION_USCORENUMBER);
#endif
}

int _ns1__ChkSnMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnMo(struct soap *soap, const char *tag, int id, const _ns1__ChkSnMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ChkSnMo::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__ChkSnMo::MO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:STATION_NUMBER", -1, &a->_ns1__ChkSnMo::STATION_USCORENUMBER, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnMo * SOAP_FMAC4 soap_in__ns1__ChkSnMo(struct soap *soap, const char *tag, _ns1__ChkSnMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnMo, sizeof(_ns1__ChkSnMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_MO1 = 1;
	size_t soap_flag_STATION_USCORENUMBER1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ChkSnMo::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__ChkSnMo::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap_flag_STATION_USCORENUMBER1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:STATION_NUMBER", &a->_ns1__ChkSnMo::STATION_USCORENUMBER, "xsd:string"))
				{	soap_flag_STATION_USCORENUMBER1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnMo, SOAP_TYPE__ns1__ChkSnMo, sizeof(_ns1__ChkSnMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnMo * SOAP_FMAC2 soap_instantiate__ns1__ChkSnMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnMo *p;
	size_t k = sizeof(_ns1__ChkSnMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnMo);
		if (p)
			((_ns1__ChkSnMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnMo(soap, tag ? tag : "ns1:ChkSnMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnMo * SOAP_FMAC4 soap_get__ns1__ChkSnMo(struct soap *soap, _ns1__ChkSnMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkMoStationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkMoStationResponse::chkMoStationResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkMoStationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkMoStationResponse::chkMoStationResult);
#endif
}

int _ns1__chkMoStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkMoStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkMoStationResponse(struct soap *soap, const char *tag, int id, const _ns1__chkMoStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkMoStationResponse), type))
		return soap->error;
	if (a->chkMoStationResult)
		soap_element_result(soap, "ns1:chkMoStationResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkMoStationResult", -1, &a->_ns1__chkMoStationResponse::chkMoStationResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkMoStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkMoStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkMoStationResponse * SOAP_FMAC4 soap_in__ns1__chkMoStationResponse(struct soap *soap, const char *tag, _ns1__chkMoStationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkMoStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkMoStationResponse, sizeof(_ns1__chkMoStationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkMoStationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkMoStationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkMoStationResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkMoStationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkMoStationResult", &a->_ns1__chkMoStationResponse::chkMoStationResult, "xsd:string"))
				{	soap_flag_chkMoStationResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkMoStationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkMoStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkMoStationResponse, SOAP_TYPE__ns1__chkMoStationResponse, sizeof(_ns1__chkMoStationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkMoStationResponse * SOAP_FMAC2 soap_instantiate__ns1__chkMoStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkMoStationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkMoStationResponse *p;
	size_t k = sizeof(_ns1__chkMoStationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkMoStationResponse);
		if (p)
			((_ns1__chkMoStationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkMoStationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkMoStationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkMoStationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkMoStationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkMoStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkMoStationResponse(soap, tag ? tag : "ns1:chkMoStationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkMoStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkMoStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkMoStationResponse * SOAP_FMAC4 soap_get__ns1__chkMoStationResponse(struct soap *soap, _ns1__chkMoStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkMoStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkMoStation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkMoStation::MO = NULL;
	this->_ns1__chkMoStation::StationNumber = NULL;
	/* transient soap skipped */
}

void _ns1__chkMoStation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkMoStation::MO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkMoStation::StationNumber);
#endif
}

int _ns1__chkMoStation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkMoStation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkMoStation(struct soap *soap, const char *tag, int id, const _ns1__chkMoStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkMoStation), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MO", -1, &a->_ns1__chkMoStation::MO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__chkMoStation::StationNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkMoStation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkMoStation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkMoStation * SOAP_FMAC4 soap_in__ns1__chkMoStation(struct soap *soap, const char *tag, _ns1__chkMoStation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkMoStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkMoStation, sizeof(_ns1__chkMoStation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkMoStation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkMoStation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MO1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MO", &a->_ns1__chkMoStation::MO, "xsd:string"))
				{	soap_flag_MO1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__chkMoStation::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkMoStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkMoStation, SOAP_TYPE__ns1__chkMoStation, sizeof(_ns1__chkMoStation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkMoStation * SOAP_FMAC2 soap_instantiate__ns1__chkMoStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkMoStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkMoStation *p;
	size_t k = sizeof(_ns1__chkMoStation);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkMoStation);
		if (p)
			((_ns1__chkMoStation*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkMoStation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkMoStation*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkMoStation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkMoStation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkMoStation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkMoStation(soap, tag ? tag : "ns1:chkMoStation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkMoStation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkMoStation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkMoStation * SOAP_FMAC4 soap_get__ns1__chkMoStation(struct soap *soap, _ns1__chkMoStation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkMoStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetEnergyStatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetEnergyStatResponse::SetEnergyStatResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetEnergyStatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetEnergyStatResponse::SetEnergyStatResult);
#endif
}

int _ns1__SetEnergyStatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetEnergyStatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetEnergyStatResponse(struct soap *soap, const char *tag, int id, const _ns1__SetEnergyStatResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetEnergyStatResponse), type))
		return soap->error;
	if (a->SetEnergyStatResult)
		soap_element_result(soap, "ns1:SetEnergyStatResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SetEnergyStatResult", -1, &a->_ns1__SetEnergyStatResponse::SetEnergyStatResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetEnergyStatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetEnergyStatResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetEnergyStatResponse * SOAP_FMAC4 soap_in__ns1__SetEnergyStatResponse(struct soap *soap, const char *tag, _ns1__SetEnergyStatResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetEnergyStatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetEnergyStatResponse, sizeof(_ns1__SetEnergyStatResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetEnergyStatResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetEnergyStatResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetEnergyStatResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetEnergyStatResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SetEnergyStatResult", &a->_ns1__SetEnergyStatResponse::SetEnergyStatResult, "xsd:string"))
				{	soap_flag_SetEnergyStatResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetEnergyStatResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetEnergyStatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetEnergyStatResponse, SOAP_TYPE__ns1__SetEnergyStatResponse, sizeof(_ns1__SetEnergyStatResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetEnergyStatResponse * SOAP_FMAC2 soap_instantiate__ns1__SetEnergyStatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetEnergyStatResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetEnergyStatResponse *p;
	size_t k = sizeof(_ns1__SetEnergyStatResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetEnergyStatResponse);
		if (p)
			((_ns1__SetEnergyStatResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetEnergyStatResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetEnergyStatResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetEnergyStatResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetEnergyStatResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetEnergyStatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetEnergyStatResponse(soap, tag ? tag : "ns1:SetEnergyStatResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetEnergyStatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetEnergyStatResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetEnergyStatResponse * SOAP_FMAC4 soap_get__ns1__SetEnergyStatResponse(struct soap *soap, _ns1__SetEnergyStatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetEnergyStatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetEnergyStat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetEnergyStat::DateKey = NULL;
	this->_ns1__SetEnergyStat::strPower = NULL;
	this->_ns1__SetEnergyStat::strEnergy = NULL;
	/* transient soap skipped */
}

void _ns1__SetEnergyStat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetEnergyStat::DateKey);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__SetEnergyStat::strPower);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__SetEnergyStat::strEnergy);
#endif
}

int _ns1__SetEnergyStat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetEnergyStat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetEnergyStat(struct soap *soap, const char *tag, int id, const _ns1__SetEnergyStat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetEnergyStat), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DateKey", -1, &a->_ns1__SetEnergyStat::DateKey, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strPower", -1, &a->_ns1__SetEnergyStat::strPower, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strEnergy", -1, &a->_ns1__SetEnergyStat::strEnergy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetEnergyStat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetEnergyStat(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetEnergyStat * SOAP_FMAC4 soap_in__ns1__SetEnergyStat(struct soap *soap, const char *tag, _ns1__SetEnergyStat *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetEnergyStat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetEnergyStat, sizeof(_ns1__SetEnergyStat), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetEnergyStat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetEnergyStat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DateKey1 = 1;
	size_t soap_flag_strPower1 = 1;
	size_t soap_flag_strEnergy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DateKey", &a->_ns1__SetEnergyStat::DateKey, "xsd:string"))
				{	soap_flag_DateKey1--;
					continue;
				}
			}
			if (soap_flag_strPower1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strPower", &a->_ns1__SetEnergyStat::strPower, "ns1:ArrayOfString"))
				{	soap_flag_strPower1--;
					continue;
				}
			}
			if (soap_flag_strEnergy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strEnergy", &a->_ns1__SetEnergyStat::strEnergy, "ns1:ArrayOfString"))
				{	soap_flag_strEnergy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetEnergyStat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetEnergyStat, SOAP_TYPE__ns1__SetEnergyStat, sizeof(_ns1__SetEnergyStat), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetEnergyStat * SOAP_FMAC2 soap_instantiate__ns1__SetEnergyStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetEnergyStat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetEnergyStat *p;
	size_t k = sizeof(_ns1__SetEnergyStat);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetEnergyStat);
		if (p)
			((_ns1__SetEnergyStat*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetEnergyStat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetEnergyStat*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetEnergyStat location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetEnergyStat, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetEnergyStat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetEnergyStat(soap, tag ? tag : "ns1:SetEnergyStat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetEnergyStat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetEnergyStat(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetEnergyStat * SOAP_FMAC4 soap_get__ns1__SetEnergyStat(struct soap *soap, _ns1__SetEnergyStat *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetEnergyStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getInfoByMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getInfoByMoResponse::getInfoByMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__getInfoByMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, &this->_ns1__getInfoByMoResponse::getInfoByMoResult);
#endif
}

int _ns1__getInfoByMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getInfoByMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getInfoByMoResponse(struct soap *soap, const char *tag, int id, const _ns1__getInfoByMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getInfoByMoResponse), type))
		return soap->error;
	if (a->getInfoByMoResult)
		soap_element_result(soap, "ns1:getInfoByMoResult");
	if (soap_out_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, "ns1:getInfoByMoResult", -1, &a->_ns1__getInfoByMoResponse::getInfoByMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getInfoByMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getInfoByMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getInfoByMoResponse * SOAP_FMAC4 soap_in__ns1__getInfoByMoResponse(struct soap *soap, const char *tag, _ns1__getInfoByMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getInfoByMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getInfoByMoResponse, sizeof(_ns1__getInfoByMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getInfoByMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getInfoByMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getInfoByMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getInfoByMoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, "ns1:getInfoByMoResult", &a->_ns1__getInfoByMoResponse::getInfoByMoResult, ""))
				{	soap_flag_getInfoByMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getInfoByMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getInfoByMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getInfoByMoResponse, SOAP_TYPE__ns1__getInfoByMoResponse, sizeof(_ns1__getInfoByMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getInfoByMoResponse * SOAP_FMAC2 soap_instantiate__ns1__getInfoByMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getInfoByMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getInfoByMoResponse *p;
	size_t k = sizeof(_ns1__getInfoByMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getInfoByMoResponse);
		if (p)
			((_ns1__getInfoByMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getInfoByMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getInfoByMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getInfoByMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getInfoByMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getInfoByMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getInfoByMoResponse(soap, tag ? tag : "ns1:getInfoByMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getInfoByMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getInfoByMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getInfoByMoResponse * SOAP_FMAC4 soap_get__ns1__getInfoByMoResponse(struct soap *soap, _ns1__getInfoByMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getInfoByMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getInfoByMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getInfoByMo::MoNumber = NULL;
	/* transient soap skipped */
}

void _ns1__getInfoByMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getInfoByMo::MoNumber);
#endif
}

int _ns1__getInfoByMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getInfoByMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getInfoByMo(struct soap *soap, const char *tag, int id, const _ns1__getInfoByMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getInfoByMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__getInfoByMo::MoNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getInfoByMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getInfoByMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getInfoByMo * SOAP_FMAC4 soap_in__ns1__getInfoByMo(struct soap *soap, const char *tag, _ns1__getInfoByMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getInfoByMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getInfoByMo, sizeof(_ns1__getInfoByMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getInfoByMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getInfoByMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__getInfoByMo::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getInfoByMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getInfoByMo, SOAP_TYPE__ns1__getInfoByMo, sizeof(_ns1__getInfoByMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getInfoByMo * SOAP_FMAC2 soap_instantiate__ns1__getInfoByMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getInfoByMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getInfoByMo *p;
	size_t k = sizeof(_ns1__getInfoByMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getInfoByMo);
		if (p)
			((_ns1__getInfoByMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getInfoByMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getInfoByMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getInfoByMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getInfoByMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getInfoByMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getInfoByMo(soap, tag ? tag : "ns1:getInfoByMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getInfoByMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getInfoByMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getInfoByMo * SOAP_FMAC4 soap_get__ns1__getInfoByMo(struct soap *soap, _ns1__getInfoByMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getInfoByMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsThermalNewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsThermalNewResponse::InsThermalNewResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsThermalNewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNewResponse::InsThermalNewResult);
#endif
}

int _ns1__InsThermalNewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsThermalNewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsThermalNewResponse(struct soap *soap, const char *tag, int id, const _ns1__InsThermalNewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsThermalNewResponse), type))
		return soap->error;
	if (a->InsThermalNewResult)
		soap_element_result(soap, "ns1:InsThermalNewResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsThermalNewResult", -1, &a->_ns1__InsThermalNewResponse::InsThermalNewResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsThermalNewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsThermalNewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsThermalNewResponse * SOAP_FMAC4 soap_in__ns1__InsThermalNewResponse(struct soap *soap, const char *tag, _ns1__InsThermalNewResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsThermalNewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsThermalNewResponse, sizeof(_ns1__InsThermalNewResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsThermalNewResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsThermalNewResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsThermalNewResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsThermalNewResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsThermalNewResult", &a->_ns1__InsThermalNewResponse::InsThermalNewResult, "xsd:string"))
				{	soap_flag_InsThermalNewResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsThermalNewResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsThermalNewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsThermalNewResponse, SOAP_TYPE__ns1__InsThermalNewResponse, sizeof(_ns1__InsThermalNewResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsThermalNewResponse * SOAP_FMAC2 soap_instantiate__ns1__InsThermalNewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsThermalNewResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsThermalNewResponse *p;
	size_t k = sizeof(_ns1__InsThermalNewResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsThermalNewResponse);
		if (p)
			((_ns1__InsThermalNewResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsThermalNewResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsThermalNewResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsThermalNewResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsThermalNewResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsThermalNewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsThermalNewResponse(soap, tag ? tag : "ns1:InsThermalNewResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsThermalNewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsThermalNewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsThermalNewResponse * SOAP_FMAC4 soap_get__ns1__InsThermalNewResponse(struct soap *soap, _ns1__InsThermalNewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsThermalNewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsThermalNew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsThermalNew::SN = NULL;
	this->_ns1__InsThermalNew::LinkSN = NULL;
	this->_ns1__InsThermalNew::TestDt = NULL;
	this->_ns1__InsThermalNew::Hole = NULL;
	this->_ns1__InsThermalNew::User = NULL;
	this->_ns1__InsThermalNew::Result = NULL;
	this->_ns1__InsThermalNew::strTemp = NULL;
	this->_ns1__InsThermalNew::strErature = NULL;
	this->_ns1__InsThermalNew::strResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsThermalNew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNew::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNew::LinkSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNew::TestDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNew::Hole);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNew::User);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalNew::Result);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsThermalNew::strTemp);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsThermalNew::strErature);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsThermalNew::strResult);
#endif
}

int _ns1__InsThermalNew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsThermalNew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsThermalNew(struct soap *soap, const char *tag, int id, const _ns1__InsThermalNew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsThermalNew), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsThermalNew::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LinkSN", -1, &a->_ns1__InsThermalNew::LinkSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestDt", -1, &a->_ns1__InsThermalNew::TestDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Hole", -1, &a->_ns1__InsThermalNew::Hole, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:User", -1, &a->_ns1__InsThermalNew::User, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Result", -1, &a->_ns1__InsThermalNew::Result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strTemp", -1, &a->_ns1__InsThermalNew::strTemp, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strErature", -1, &a->_ns1__InsThermalNew::strErature, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strResult", -1, &a->_ns1__InsThermalNew::strResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsThermalNew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsThermalNew(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsThermalNew * SOAP_FMAC4 soap_in__ns1__InsThermalNew(struct soap *soap, const char *tag, _ns1__InsThermalNew *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsThermalNew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsThermalNew, sizeof(_ns1__InsThermalNew), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsThermalNew)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsThermalNew *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_LinkSN1 = 1;
	size_t soap_flag_TestDt1 = 1;
	size_t soap_flag_Hole1 = 1;
	size_t soap_flag_User1 = 1;
	size_t soap_flag_Result1 = 1;
	size_t soap_flag_strTemp1 = 1;
	size_t soap_flag_strErature1 = 1;
	size_t soap_flag_strResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsThermalNew::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_LinkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LinkSN", &a->_ns1__InsThermalNew::LinkSN, "xsd:string"))
				{	soap_flag_LinkSN1--;
					continue;
				}
			}
			if (soap_flag_TestDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestDt", &a->_ns1__InsThermalNew::TestDt, "xsd:string"))
				{	soap_flag_TestDt1--;
					continue;
				}
			}
			if (soap_flag_Hole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Hole", &a->_ns1__InsThermalNew::Hole, "xsd:string"))
				{	soap_flag_Hole1--;
					continue;
				}
			}
			if (soap_flag_User1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:User", &a->_ns1__InsThermalNew::User, "xsd:string"))
				{	soap_flag_User1--;
					continue;
				}
			}
			if (soap_flag_Result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Result", &a->_ns1__InsThermalNew::Result, "xsd:string"))
				{	soap_flag_Result1--;
					continue;
				}
			}
			if (soap_flag_strTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strTemp", &a->_ns1__InsThermalNew::strTemp, "ns1:ArrayOfString"))
				{	soap_flag_strTemp1--;
					continue;
				}
			}
			if (soap_flag_strErature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strErature", &a->_ns1__InsThermalNew::strErature, "ns1:ArrayOfString"))
				{	soap_flag_strErature1--;
					continue;
				}
			}
			if (soap_flag_strResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strResult", &a->_ns1__InsThermalNew::strResult, "ns1:ArrayOfString"))
				{	soap_flag_strResult1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsThermalNew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsThermalNew, SOAP_TYPE__ns1__InsThermalNew, sizeof(_ns1__InsThermalNew), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsThermalNew * SOAP_FMAC2 soap_instantiate__ns1__InsThermalNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsThermalNew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsThermalNew *p;
	size_t k = sizeof(_ns1__InsThermalNew);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsThermalNew);
		if (p)
			((_ns1__InsThermalNew*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsThermalNew, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsThermalNew*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsThermalNew location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsThermalNew, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsThermalNew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsThermalNew(soap, tag ? tag : "ns1:InsThermalNew", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsThermalNew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsThermalNew(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsThermalNew * SOAP_FMAC4 soap_get__ns1__InsThermalNew(struct soap *soap, _ns1__InsThermalNew *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsThermalNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnLinkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnLinkResponse::ChkSnLinkResult = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnLinkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnLinkResponse::ChkSnLinkResult);
#endif
}

int _ns1__ChkSnLinkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnLinkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnLinkResponse(struct soap *soap, const char *tag, int id, const _ns1__ChkSnLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnLinkResponse), type))
		return soap->error;
	if (a->ChkSnLinkResult)
		soap_element_result(soap, "ns1:ChkSnLinkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ChkSnLinkResult", -1, &a->_ns1__ChkSnLinkResponse::ChkSnLinkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnLinkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnLinkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnLinkResponse * SOAP_FMAC4 soap_in__ns1__ChkSnLinkResponse(struct soap *soap, const char *tag, _ns1__ChkSnLinkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnLinkResponse, sizeof(_ns1__ChkSnLinkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnLinkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnLinkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChkSnLinkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChkSnLinkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ChkSnLinkResult", &a->_ns1__ChkSnLinkResponse::ChkSnLinkResult, "xsd:string"))
				{	soap_flag_ChkSnLinkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChkSnLinkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnLinkResponse, SOAP_TYPE__ns1__ChkSnLinkResponse, sizeof(_ns1__ChkSnLinkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnLinkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnLinkResponse *p;
	size_t k = sizeof(_ns1__ChkSnLinkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnLinkResponse);
		if (p)
			((_ns1__ChkSnLinkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnLinkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnLinkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnLinkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnLinkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnLinkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnLinkResponse(soap, tag ? tag : "ns1:ChkSnLinkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnLinkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnLinkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnLinkResponse * SOAP_FMAC4 soap_get__ns1__ChkSnLinkResponse(struct soap *soap, _ns1__ChkSnLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnLink::SN = NULL;
	this->_ns1__ChkSnLink::LinkSN = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnLink::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnLink::LinkSN);
#endif
}

int _ns1__ChkSnLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnLink(struct soap *soap, const char *tag, int id, const _ns1__ChkSnLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnLink), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ChkSnLink::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LinkSN", -1, &a->_ns1__ChkSnLink::LinkSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnLink(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnLink * SOAP_FMAC4 soap_in__ns1__ChkSnLink(struct soap *soap, const char *tag, _ns1__ChkSnLink *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnLink, sizeof(_ns1__ChkSnLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_LinkSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ChkSnLink::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_LinkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LinkSN", &a->_ns1__ChkSnLink::LinkSN, "xsd:string"))
				{	soap_flag_LinkSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnLink, SOAP_TYPE__ns1__ChkSnLink, sizeof(_ns1__ChkSnLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnLink * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnLink *p;
	size_t k = sizeof(_ns1__ChkSnLink);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnLink);
		if (p)
			((_ns1__ChkSnLink*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnLink, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnLink*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnLink(soap, tag ? tag : "ns1:ChkSnLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnLink(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnLink * SOAP_FMAC4 soap_get__ns1__ChkSnLink(struct soap *soap, _ns1__ChkSnLink *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsThermalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsThermalResponse::InsThermalResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsThermalResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermalResponse::InsThermalResult);
#endif
}

int _ns1__InsThermalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsThermalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsThermalResponse(struct soap *soap, const char *tag, int id, const _ns1__InsThermalResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsThermalResponse), type))
		return soap->error;
	if (a->InsThermalResult)
		soap_element_result(soap, "ns1:InsThermalResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsThermalResult", -1, &a->_ns1__InsThermalResponse::InsThermalResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsThermalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsThermalResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsThermalResponse * SOAP_FMAC4 soap_in__ns1__InsThermalResponse(struct soap *soap, const char *tag, _ns1__InsThermalResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsThermalResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsThermalResponse, sizeof(_ns1__InsThermalResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsThermalResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsThermalResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsThermalResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsThermalResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsThermalResult", &a->_ns1__InsThermalResponse::InsThermalResult, "xsd:string"))
				{	soap_flag_InsThermalResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsThermalResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsThermalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsThermalResponse, SOAP_TYPE__ns1__InsThermalResponse, sizeof(_ns1__InsThermalResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsThermalResponse * SOAP_FMAC2 soap_instantiate__ns1__InsThermalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsThermalResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsThermalResponse *p;
	size_t k = sizeof(_ns1__InsThermalResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsThermalResponse);
		if (p)
			((_ns1__InsThermalResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsThermalResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsThermalResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsThermalResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsThermalResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsThermalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsThermalResponse(soap, tag ? tag : "ns1:InsThermalResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsThermalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsThermalResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsThermalResponse * SOAP_FMAC4 soap_get__ns1__InsThermalResponse(struct soap *soap, _ns1__InsThermalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsThermalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsThermal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsThermal::SN = NULL;
	this->_ns1__InsThermal::TestDt = NULL;
	this->_ns1__InsThermal::Hole = NULL;
	this->_ns1__InsThermal::User = NULL;
	this->_ns1__InsThermal::Result = NULL;
	this->_ns1__InsThermal::strTemp = NULL;
	this->_ns1__InsThermal::strErature = NULL;
	this->_ns1__InsThermal::strResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsThermal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermal::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermal::TestDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermal::Hole);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermal::User);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsThermal::Result);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsThermal::strTemp);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsThermal::strErature);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsThermal::strResult);
#endif
}

int _ns1__InsThermal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsThermal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsThermal(struct soap *soap, const char *tag, int id, const _ns1__InsThermal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsThermal), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsThermal::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestDt", -1, &a->_ns1__InsThermal::TestDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Hole", -1, &a->_ns1__InsThermal::Hole, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:User", -1, &a->_ns1__InsThermal::User, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Result", -1, &a->_ns1__InsThermal::Result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strTemp", -1, &a->_ns1__InsThermal::strTemp, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strErature", -1, &a->_ns1__InsThermal::strErature, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strResult", -1, &a->_ns1__InsThermal::strResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsThermal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsThermal(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsThermal * SOAP_FMAC4 soap_in__ns1__InsThermal(struct soap *soap, const char *tag, _ns1__InsThermal *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsThermal *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsThermal, sizeof(_ns1__InsThermal), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsThermal)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsThermal *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_TestDt1 = 1;
	size_t soap_flag_Hole1 = 1;
	size_t soap_flag_User1 = 1;
	size_t soap_flag_Result1 = 1;
	size_t soap_flag_strTemp1 = 1;
	size_t soap_flag_strErature1 = 1;
	size_t soap_flag_strResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsThermal::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_TestDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestDt", &a->_ns1__InsThermal::TestDt, "xsd:string"))
				{	soap_flag_TestDt1--;
					continue;
				}
			}
			if (soap_flag_Hole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Hole", &a->_ns1__InsThermal::Hole, "xsd:string"))
				{	soap_flag_Hole1--;
					continue;
				}
			}
			if (soap_flag_User1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:User", &a->_ns1__InsThermal::User, "xsd:string"))
				{	soap_flag_User1--;
					continue;
				}
			}
			if (soap_flag_Result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Result", &a->_ns1__InsThermal::Result, "xsd:string"))
				{	soap_flag_Result1--;
					continue;
				}
			}
			if (soap_flag_strTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strTemp", &a->_ns1__InsThermal::strTemp, "ns1:ArrayOfString"))
				{	soap_flag_strTemp1--;
					continue;
				}
			}
			if (soap_flag_strErature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strErature", &a->_ns1__InsThermal::strErature, "ns1:ArrayOfString"))
				{	soap_flag_strErature1--;
					continue;
				}
			}
			if (soap_flag_strResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strResult", &a->_ns1__InsThermal::strResult, "ns1:ArrayOfString"))
				{	soap_flag_strResult1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsThermal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsThermal, SOAP_TYPE__ns1__InsThermal, sizeof(_ns1__InsThermal), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsThermal * SOAP_FMAC2 soap_instantiate__ns1__InsThermal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsThermal(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsThermal *p;
	size_t k = sizeof(_ns1__InsThermal);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsThermal);
		if (p)
			((_ns1__InsThermal*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsThermal, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsThermal*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsThermal location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsThermal, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsThermal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsThermal(soap, tag ? tag : "ns1:InsThermal", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsThermal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsThermal(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsThermal * SOAP_FMAC4 soap_get__ns1__InsThermal(struct soap *soap, _ns1__InsThermal *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsThermal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsWHDetectionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsWHDetectionResponse::InsWHDetectionResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsWHDetectionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsWHDetectionResponse::InsWHDetectionResult);
#endif
}

int _ns1__InsWHDetectionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsWHDetectionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsWHDetectionResponse(struct soap *soap, const char *tag, int id, const _ns1__InsWHDetectionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsWHDetectionResponse), type))
		return soap->error;
	if (a->InsWHDetectionResult)
		soap_element_result(soap, "ns1:InsWHDetectionResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsWHDetectionResult", -1, &a->_ns1__InsWHDetectionResponse::InsWHDetectionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsWHDetectionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsWHDetectionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsWHDetectionResponse * SOAP_FMAC4 soap_in__ns1__InsWHDetectionResponse(struct soap *soap, const char *tag, _ns1__InsWHDetectionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsWHDetectionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsWHDetectionResponse, sizeof(_ns1__InsWHDetectionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsWHDetectionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsWHDetectionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsWHDetectionResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsWHDetectionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsWHDetectionResult", &a->_ns1__InsWHDetectionResponse::InsWHDetectionResult, "xsd:string"))
				{	soap_flag_InsWHDetectionResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsWHDetectionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsWHDetectionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsWHDetectionResponse, SOAP_TYPE__ns1__InsWHDetectionResponse, sizeof(_ns1__InsWHDetectionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsWHDetectionResponse * SOAP_FMAC2 soap_instantiate__ns1__InsWHDetectionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsWHDetectionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsWHDetectionResponse *p;
	size_t k = sizeof(_ns1__InsWHDetectionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsWHDetectionResponse);
		if (p)
			((_ns1__InsWHDetectionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsWHDetectionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsWHDetectionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsWHDetectionResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsWHDetectionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsWHDetectionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsWHDetectionResponse(soap, tag ? tag : "ns1:InsWHDetectionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsWHDetectionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsWHDetectionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsWHDetectionResponse * SOAP_FMAC4 soap_get__ns1__InsWHDetectionResponse(struct soap *soap, _ns1__InsWHDetectionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsWHDetectionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsWHDetection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsWHDetection::Wh = NULL;
	this->_ns1__InsWHDetection::Hole = NULL;
	this->_ns1__InsWHDetection::DateTime = NULL;
	this->_ns1__InsWHDetection::Temp = NULL;
	this->_ns1__InsWHDetection::Humidity = NULL;
	/* transient soap skipped */
}

void _ns1__InsWHDetection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsWHDetection::Wh);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsWHDetection::Hole);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsWHDetection::DateTime);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsWHDetection::Temp);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsWHDetection::Humidity);
#endif
}

int _ns1__InsWHDetection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsWHDetection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsWHDetection(struct soap *soap, const char *tag, int id, const _ns1__InsWHDetection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsWHDetection), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Wh", -1, &a->_ns1__InsWHDetection::Wh, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Hole", -1, &a->_ns1__InsWHDetection::Hole, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:DateTime", -1, &a->_ns1__InsWHDetection::DateTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Temp", -1, &a->_ns1__InsWHDetection::Temp, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Humidity", -1, &a->_ns1__InsWHDetection::Humidity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsWHDetection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsWHDetection(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsWHDetection * SOAP_FMAC4 soap_in__ns1__InsWHDetection(struct soap *soap, const char *tag, _ns1__InsWHDetection *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsWHDetection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsWHDetection, sizeof(_ns1__InsWHDetection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsWHDetection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsWHDetection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Wh1 = 1;
	size_t soap_flag_Hole1 = 1;
	size_t soap_flag_DateTime1 = 1;
	size_t soap_flag_Temp1 = 1;
	size_t soap_flag_Humidity1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Wh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Wh", &a->_ns1__InsWHDetection::Wh, "xsd:string"))
				{	soap_flag_Wh1--;
					continue;
				}
			}
			if (soap_flag_Hole1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Hole", &a->_ns1__InsWHDetection::Hole, "ns1:ArrayOfString"))
				{	soap_flag_Hole1--;
					continue;
				}
			}
			if (soap_flag_DateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:DateTime", &a->_ns1__InsWHDetection::DateTime, "ns1:ArrayOfString"))
				{	soap_flag_DateTime1--;
					continue;
				}
			}
			if (soap_flag_Temp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Temp", &a->_ns1__InsWHDetection::Temp, "ns1:ArrayOfString"))
				{	soap_flag_Temp1--;
					continue;
				}
			}
			if (soap_flag_Humidity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Humidity", &a->_ns1__InsWHDetection::Humidity, "ns1:ArrayOfString"))
				{	soap_flag_Humidity1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsWHDetection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsWHDetection, SOAP_TYPE__ns1__InsWHDetection, sizeof(_ns1__InsWHDetection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsWHDetection * SOAP_FMAC2 soap_instantiate__ns1__InsWHDetection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsWHDetection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsWHDetection *p;
	size_t k = sizeof(_ns1__InsWHDetection);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsWHDetection);
		if (p)
			((_ns1__InsWHDetection*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsWHDetection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsWHDetection*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsWHDetection location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsWHDetection, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsWHDetection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsWHDetection(soap, tag ? tag : "ns1:InsWHDetection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsWHDetection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsWHDetection(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsWHDetection * SOAP_FMAC4 soap_get__ns1__InsWHDetection(struct soap *soap, _ns1__InsWHDetection *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsWHDetection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFlatNessForCLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFlatNessForCLResponse::InsFlatNessForCLResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsFlatNessForCLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFlatNessForCLResponse::InsFlatNessForCLResult);
#endif
}

int _ns1__InsFlatNessForCLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFlatNessForCLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFlatNessForCLResponse(struct soap *soap, const char *tag, int id, const _ns1__InsFlatNessForCLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFlatNessForCLResponse), type))
		return soap->error;
	if (a->InsFlatNessForCLResult)
		soap_element_result(soap, "ns1:InsFlatNessForCLResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsFlatNessForCLResult", -1, &a->_ns1__InsFlatNessForCLResponse::InsFlatNessForCLResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFlatNessForCLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFlatNessForCLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForCLResponse * SOAP_FMAC4 soap_in__ns1__InsFlatNessForCLResponse(struct soap *soap, const char *tag, _ns1__InsFlatNessForCLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFlatNessForCLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFlatNessForCLResponse, sizeof(_ns1__InsFlatNessForCLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFlatNessForCLResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFlatNessForCLResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsFlatNessForCLResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsFlatNessForCLResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsFlatNessForCLResult", &a->_ns1__InsFlatNessForCLResponse::InsFlatNessForCLResult, "xsd:string"))
				{	soap_flag_InsFlatNessForCLResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsFlatNessForCLResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFlatNessForCLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFlatNessForCLResponse, SOAP_TYPE__ns1__InsFlatNessForCLResponse, sizeof(_ns1__InsFlatNessForCLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFlatNessForCLResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForCLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFlatNessForCLResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFlatNessForCLResponse *p;
	size_t k = sizeof(_ns1__InsFlatNessForCLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFlatNessForCLResponse);
		if (p)
			((_ns1__InsFlatNessForCLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFlatNessForCLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFlatNessForCLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFlatNessForCLResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFlatNessForCLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFlatNessForCLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFlatNessForCLResponse(soap, tag ? tag : "ns1:InsFlatNessForCLResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFlatNessForCLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFlatNessForCLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForCLResponse * SOAP_FMAC4 soap_get__ns1__InsFlatNessForCLResponse(struct soap *soap, _ns1__InsFlatNessForCLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFlatNessForCLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFlatNessForCL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFlatNessForCL::strList = NULL;
	this->_ns1__InsFlatNessForCL::AxisX = NULL;
	this->_ns1__InsFlatNessForCL::AxisY = NULL;
	this->_ns1__InsFlatNessForCL::AxisZ = NULL;
	this->_ns1__InsFlatNessForCL::Ftype = NULL;
	this->_ns1__InsFlatNessForCL::Flat = NULL;
	this->_ns1__InsFlatNessForCL::Dsign = NULL;
	this->_ns1__InsFlatNessForCL::FlatX = NULL;
	this->_ns1__InsFlatNessForCL::FlatY = NULL;
	this->_ns1__InsFlatNessForCL::PiontX = NULL;
	this->_ns1__InsFlatNessForCL::PiontY = NULL;
	/* transient soap skipped */
}

void _ns1__InsFlatNessForCL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::strList);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::AxisX);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::AxisY);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::AxisZ);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::Ftype);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::Flat);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::Dsign);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::FlatX);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::FlatY);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::PiontX);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForCL::PiontY);
#endif
}

int _ns1__InsFlatNessForCL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFlatNessForCL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFlatNessForCL(struct soap *soap, const char *tag, int id, const _ns1__InsFlatNessForCL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFlatNessForCL), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strList", -1, &a->_ns1__InsFlatNessForCL::strList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisX", -1, &a->_ns1__InsFlatNessForCL::AxisX, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisY", -1, &a->_ns1__InsFlatNessForCL::AxisY, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisZ", -1, &a->_ns1__InsFlatNessForCL::AxisZ, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Ftype", -1, &a->_ns1__InsFlatNessForCL::Ftype, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Flat", -1, &a->_ns1__InsFlatNessForCL::Flat, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Dsign", -1, &a->_ns1__InsFlatNessForCL::Dsign, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:FlatX", -1, &a->_ns1__InsFlatNessForCL::FlatX, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:FlatY", -1, &a->_ns1__InsFlatNessForCL::FlatY, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:PiontX", -1, &a->_ns1__InsFlatNessForCL::PiontX, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:PiontY", -1, &a->_ns1__InsFlatNessForCL::PiontY, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFlatNessForCL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFlatNessForCL(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForCL * SOAP_FMAC4 soap_in__ns1__InsFlatNessForCL(struct soap *soap, const char *tag, _ns1__InsFlatNessForCL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFlatNessForCL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFlatNessForCL, sizeof(_ns1__InsFlatNessForCL), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFlatNessForCL)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFlatNessForCL *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strList1 = 1;
	size_t soap_flag_AxisX1 = 1;
	size_t soap_flag_AxisY1 = 1;
	size_t soap_flag_AxisZ1 = 1;
	size_t soap_flag_Ftype1 = 1;
	size_t soap_flag_Flat1 = 1;
	size_t soap_flag_Dsign1 = 1;
	size_t soap_flag_FlatX1 = 1;
	size_t soap_flag_FlatY1 = 1;
	size_t soap_flag_PiontX1 = 1;
	size_t soap_flag_PiontY1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strList", &a->_ns1__InsFlatNessForCL::strList, "ns1:ArrayOfString"))
				{	soap_flag_strList1--;
					continue;
				}
			}
			if (soap_flag_AxisX1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisX", &a->_ns1__InsFlatNessForCL::AxisX, "ns1:ArrayOfString"))
				{	soap_flag_AxisX1--;
					continue;
				}
			}
			if (soap_flag_AxisY1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisY", &a->_ns1__InsFlatNessForCL::AxisY, "ns1:ArrayOfString"))
				{	soap_flag_AxisY1--;
					continue;
				}
			}
			if (soap_flag_AxisZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisZ", &a->_ns1__InsFlatNessForCL::AxisZ, "ns1:ArrayOfString"))
				{	soap_flag_AxisZ1--;
					continue;
				}
			}
			if (soap_flag_Ftype1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Ftype", &a->_ns1__InsFlatNessForCL::Ftype, "ns1:ArrayOfString"))
				{	soap_flag_Ftype1--;
					continue;
				}
			}
			if (soap_flag_Flat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Flat", &a->_ns1__InsFlatNessForCL::Flat, "ns1:ArrayOfString"))
				{	soap_flag_Flat1--;
					continue;
				}
			}
			if (soap_flag_Dsign1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Dsign", &a->_ns1__InsFlatNessForCL::Dsign, "ns1:ArrayOfString"))
				{	soap_flag_Dsign1--;
					continue;
				}
			}
			if (soap_flag_FlatX1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:FlatX", &a->_ns1__InsFlatNessForCL::FlatX, "ns1:ArrayOfString"))
				{	soap_flag_FlatX1--;
					continue;
				}
			}
			if (soap_flag_FlatY1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:FlatY", &a->_ns1__InsFlatNessForCL::FlatY, "ns1:ArrayOfString"))
				{	soap_flag_FlatY1--;
					continue;
				}
			}
			if (soap_flag_PiontX1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:PiontX", &a->_ns1__InsFlatNessForCL::PiontX, "ns1:ArrayOfString"))
				{	soap_flag_PiontX1--;
					continue;
				}
			}
			if (soap_flag_PiontY1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:PiontY", &a->_ns1__InsFlatNessForCL::PiontY, "ns1:ArrayOfString"))
				{	soap_flag_PiontY1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFlatNessForCL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFlatNessForCL, SOAP_TYPE__ns1__InsFlatNessForCL, sizeof(_ns1__InsFlatNessForCL), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFlatNessForCL * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForCL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFlatNessForCL(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFlatNessForCL *p;
	size_t k = sizeof(_ns1__InsFlatNessForCL);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFlatNessForCL);
		if (p)
			((_ns1__InsFlatNessForCL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFlatNessForCL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFlatNessForCL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFlatNessForCL location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFlatNessForCL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFlatNessForCL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFlatNessForCL(soap, tag ? tag : "ns1:InsFlatNessForCL", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFlatNessForCL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFlatNessForCL(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForCL * SOAP_FMAC4 soap_get__ns1__InsFlatNessForCL(struct soap *soap, _ns1__InsFlatNessForCL *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFlatNessForCL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFlatNessForLSDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFlatNessForLSDResponse::InsFlatNessForLSDResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsFlatNessForLSDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFlatNessForLSDResponse::InsFlatNessForLSDResult);
#endif
}

int _ns1__InsFlatNessForLSDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFlatNessForLSDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFlatNessForLSDResponse(struct soap *soap, const char *tag, int id, const _ns1__InsFlatNessForLSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFlatNessForLSDResponse), type))
		return soap->error;
	if (a->InsFlatNessForLSDResult)
		soap_element_result(soap, "ns1:InsFlatNessForLSDResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsFlatNessForLSDResult", -1, &a->_ns1__InsFlatNessForLSDResponse::InsFlatNessForLSDResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFlatNessForLSDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFlatNessForLSDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForLSDResponse * SOAP_FMAC4 soap_in__ns1__InsFlatNessForLSDResponse(struct soap *soap, const char *tag, _ns1__InsFlatNessForLSDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFlatNessForLSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFlatNessForLSDResponse, sizeof(_ns1__InsFlatNessForLSDResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFlatNessForLSDResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFlatNessForLSDResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsFlatNessForLSDResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsFlatNessForLSDResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsFlatNessForLSDResult", &a->_ns1__InsFlatNessForLSDResponse::InsFlatNessForLSDResult, "xsd:string"))
				{	soap_flag_InsFlatNessForLSDResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsFlatNessForLSDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFlatNessForLSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFlatNessForLSDResponse, SOAP_TYPE__ns1__InsFlatNessForLSDResponse, sizeof(_ns1__InsFlatNessForLSDResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFlatNessForLSDResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForLSDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFlatNessForLSDResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFlatNessForLSDResponse *p;
	size_t k = sizeof(_ns1__InsFlatNessForLSDResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFlatNessForLSDResponse);
		if (p)
			((_ns1__InsFlatNessForLSDResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFlatNessForLSDResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFlatNessForLSDResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFlatNessForLSDResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFlatNessForLSDResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFlatNessForLSDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFlatNessForLSDResponse(soap, tag ? tag : "ns1:InsFlatNessForLSDResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFlatNessForLSDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFlatNessForLSDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForLSDResponse * SOAP_FMAC4 soap_get__ns1__InsFlatNessForLSDResponse(struct soap *soap, _ns1__InsFlatNessForLSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFlatNessForLSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFlatNessForLSD::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFlatNessForLSD::strList = NULL;
	this->_ns1__InsFlatNessForLSD::AxisX = NULL;
	this->_ns1__InsFlatNessForLSD::AxisY = NULL;
	this->_ns1__InsFlatNessForLSD::AxisZ = NULL;
	this->_ns1__InsFlatNessForLSD::Ftype = NULL;
	this->_ns1__InsFlatNessForLSD::Flat = NULL;
	this->_ns1__InsFlatNessForLSD::Dsign = NULL;
	/* transient soap skipped */
}

void _ns1__InsFlatNessForLSD::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::strList);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::AxisX);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::AxisY);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::AxisZ);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::Ftype);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::Flat);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNessForLSD::Dsign);
#endif
}

int _ns1__InsFlatNessForLSD::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFlatNessForLSD(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFlatNessForLSD(struct soap *soap, const char *tag, int id, const _ns1__InsFlatNessForLSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFlatNessForLSD), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strList", -1, &a->_ns1__InsFlatNessForLSD::strList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisX", -1, &a->_ns1__InsFlatNessForLSD::AxisX, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisY", -1, &a->_ns1__InsFlatNessForLSD::AxisY, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisZ", -1, &a->_ns1__InsFlatNessForLSD::AxisZ, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Ftype", -1, &a->_ns1__InsFlatNessForLSD::Ftype, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Flat", -1, &a->_ns1__InsFlatNessForLSD::Flat, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Dsign", -1, &a->_ns1__InsFlatNessForLSD::Dsign, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFlatNessForLSD::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFlatNessForLSD(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForLSD * SOAP_FMAC4 soap_in__ns1__InsFlatNessForLSD(struct soap *soap, const char *tag, _ns1__InsFlatNessForLSD *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFlatNessForLSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFlatNessForLSD, sizeof(_ns1__InsFlatNessForLSD), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFlatNessForLSD)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFlatNessForLSD *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strList1 = 1;
	size_t soap_flag_AxisX1 = 1;
	size_t soap_flag_AxisY1 = 1;
	size_t soap_flag_AxisZ1 = 1;
	size_t soap_flag_Ftype1 = 1;
	size_t soap_flag_Flat1 = 1;
	size_t soap_flag_Dsign1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strList", &a->_ns1__InsFlatNessForLSD::strList, "ns1:ArrayOfString"))
				{	soap_flag_strList1--;
					continue;
				}
			}
			if (soap_flag_AxisX1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisX", &a->_ns1__InsFlatNessForLSD::AxisX, "ns1:ArrayOfString"))
				{	soap_flag_AxisX1--;
					continue;
				}
			}
			if (soap_flag_AxisY1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisY", &a->_ns1__InsFlatNessForLSD::AxisY, "ns1:ArrayOfString"))
				{	soap_flag_AxisY1--;
					continue;
				}
			}
			if (soap_flag_AxisZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisZ", &a->_ns1__InsFlatNessForLSD::AxisZ, "ns1:ArrayOfString"))
				{	soap_flag_AxisZ1--;
					continue;
				}
			}
			if (soap_flag_Ftype1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Ftype", &a->_ns1__InsFlatNessForLSD::Ftype, "ns1:ArrayOfString"))
				{	soap_flag_Ftype1--;
					continue;
				}
			}
			if (soap_flag_Flat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Flat", &a->_ns1__InsFlatNessForLSD::Flat, "ns1:ArrayOfString"))
				{	soap_flag_Flat1--;
					continue;
				}
			}
			if (soap_flag_Dsign1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Dsign", &a->_ns1__InsFlatNessForLSD::Dsign, "ns1:ArrayOfString"))
				{	soap_flag_Dsign1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFlatNessForLSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFlatNessForLSD, SOAP_TYPE__ns1__InsFlatNessForLSD, sizeof(_ns1__InsFlatNessForLSD), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFlatNessForLSD * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessForLSD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFlatNessForLSD(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFlatNessForLSD *p;
	size_t k = sizeof(_ns1__InsFlatNessForLSD);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFlatNessForLSD);
		if (p)
			((_ns1__InsFlatNessForLSD*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFlatNessForLSD, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFlatNessForLSD*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFlatNessForLSD location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFlatNessForLSD, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFlatNessForLSD::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFlatNessForLSD(soap, tag ? tag : "ns1:InsFlatNessForLSD", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFlatNessForLSD::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFlatNessForLSD(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFlatNessForLSD * SOAP_FMAC4 soap_get__ns1__InsFlatNessForLSD(struct soap *soap, _ns1__InsFlatNessForLSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFlatNessForLSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFlatNessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFlatNessResponse::InsFlatNessResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsFlatNessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFlatNessResponse::InsFlatNessResult);
#endif
}

int _ns1__InsFlatNessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFlatNessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFlatNessResponse(struct soap *soap, const char *tag, int id, const _ns1__InsFlatNessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFlatNessResponse), type))
		return soap->error;
	if (a->InsFlatNessResult)
		soap_element_result(soap, "ns1:InsFlatNessResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsFlatNessResult", -1, &a->_ns1__InsFlatNessResponse::InsFlatNessResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFlatNessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFlatNessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFlatNessResponse * SOAP_FMAC4 soap_in__ns1__InsFlatNessResponse(struct soap *soap, const char *tag, _ns1__InsFlatNessResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFlatNessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFlatNessResponse, sizeof(_ns1__InsFlatNessResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFlatNessResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFlatNessResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsFlatNessResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsFlatNessResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsFlatNessResult", &a->_ns1__InsFlatNessResponse::InsFlatNessResult, "xsd:string"))
				{	soap_flag_InsFlatNessResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsFlatNessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFlatNessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFlatNessResponse, SOAP_TYPE__ns1__InsFlatNessResponse, sizeof(_ns1__InsFlatNessResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFlatNessResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFlatNessResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFlatNessResponse *p;
	size_t k = sizeof(_ns1__InsFlatNessResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFlatNessResponse);
		if (p)
			((_ns1__InsFlatNessResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFlatNessResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFlatNessResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFlatNessResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFlatNessResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFlatNessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFlatNessResponse(soap, tag ? tag : "ns1:InsFlatNessResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFlatNessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFlatNessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFlatNessResponse * SOAP_FMAC4 soap_get__ns1__InsFlatNessResponse(struct soap *soap, _ns1__InsFlatNessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFlatNessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFlatNess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFlatNess::strList = NULL;
	this->_ns1__InsFlatNess::AxisX = NULL;
	this->_ns1__InsFlatNess::AxisY = NULL;
	this->_ns1__InsFlatNess::AxisZ = NULL;
	this->_ns1__InsFlatNess::Ftype = NULL;
	this->_ns1__InsFlatNess::Flat = NULL;
	/* transient soap skipped */
}

void _ns1__InsFlatNess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNess::strList);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNess::AxisX);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNess::AxisY);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNess::AxisZ);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNess::Ftype);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__InsFlatNess::Flat);
#endif
}

int _ns1__InsFlatNess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFlatNess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFlatNess(struct soap *soap, const char *tag, int id, const _ns1__InsFlatNess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFlatNess), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:strList", -1, &a->_ns1__InsFlatNess::strList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisX", -1, &a->_ns1__InsFlatNess::AxisX, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisY", -1, &a->_ns1__InsFlatNess::AxisY, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:AxisZ", -1, &a->_ns1__InsFlatNess::AxisZ, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Ftype", -1, &a->_ns1__InsFlatNess::Ftype, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:Flat", -1, &a->_ns1__InsFlatNess::Flat, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFlatNess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFlatNess(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFlatNess * SOAP_FMAC4 soap_in__ns1__InsFlatNess(struct soap *soap, const char *tag, _ns1__InsFlatNess *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFlatNess *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFlatNess, sizeof(_ns1__InsFlatNess), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFlatNess)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFlatNess *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strList1 = 1;
	size_t soap_flag_AxisX1 = 1;
	size_t soap_flag_AxisY1 = 1;
	size_t soap_flag_AxisZ1 = 1;
	size_t soap_flag_Ftype1 = 1;
	size_t soap_flag_Flat1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:strList", &a->_ns1__InsFlatNess::strList, "ns1:ArrayOfString"))
				{	soap_flag_strList1--;
					continue;
				}
			}
			if (soap_flag_AxisX1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisX", &a->_ns1__InsFlatNess::AxisX, "ns1:ArrayOfString"))
				{	soap_flag_AxisX1--;
					continue;
				}
			}
			if (soap_flag_AxisY1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisY", &a->_ns1__InsFlatNess::AxisY, "ns1:ArrayOfString"))
				{	soap_flag_AxisY1--;
					continue;
				}
			}
			if (soap_flag_AxisZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:AxisZ", &a->_ns1__InsFlatNess::AxisZ, "ns1:ArrayOfString"))
				{	soap_flag_AxisZ1--;
					continue;
				}
			}
			if (soap_flag_Ftype1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Ftype", &a->_ns1__InsFlatNess::Ftype, "ns1:ArrayOfString"))
				{	soap_flag_Ftype1--;
					continue;
				}
			}
			if (soap_flag_Flat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:Flat", &a->_ns1__InsFlatNess::Flat, "ns1:ArrayOfString"))
				{	soap_flag_Flat1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFlatNess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFlatNess, SOAP_TYPE__ns1__InsFlatNess, sizeof(_ns1__InsFlatNess), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFlatNess * SOAP_FMAC2 soap_instantiate__ns1__InsFlatNess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFlatNess(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFlatNess *p;
	size_t k = sizeof(_ns1__InsFlatNess);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFlatNess);
		if (p)
			((_ns1__InsFlatNess*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFlatNess, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFlatNess*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFlatNess location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFlatNess, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFlatNess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFlatNess(soap, tag ? tag : "ns1:InsFlatNess", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFlatNess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFlatNess(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFlatNess * SOAP_FMAC4 soap_get__ns1__InsFlatNess(struct soap *soap, _ns1__InsFlatNess *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFlatNess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ImpMesAteTestDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ImpMesAteTestDataResponse::ImpMesAteTestDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__ImpMesAteTestDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ImpMesAteTestDataResponse::ImpMesAteTestDataResult);
#endif
}

int _ns1__ImpMesAteTestDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ImpMesAteTestDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ImpMesAteTestDataResponse(struct soap *soap, const char *tag, int id, const _ns1__ImpMesAteTestDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ImpMesAteTestDataResponse), type))
		return soap->error;
	if (a->ImpMesAteTestDataResult)
		soap_element_result(soap, "ns1:ImpMesAteTestDataResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ImpMesAteTestDataResult", -1, &a->_ns1__ImpMesAteTestDataResponse::ImpMesAteTestDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ImpMesAteTestDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ImpMesAteTestDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ImpMesAteTestDataResponse * SOAP_FMAC4 soap_in__ns1__ImpMesAteTestDataResponse(struct soap *soap, const char *tag, _ns1__ImpMesAteTestDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ImpMesAteTestDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ImpMesAteTestDataResponse, sizeof(_ns1__ImpMesAteTestDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ImpMesAteTestDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ImpMesAteTestDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ImpMesAteTestDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImpMesAteTestDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ImpMesAteTestDataResult", &a->_ns1__ImpMesAteTestDataResponse::ImpMesAteTestDataResult, "xsd:string"))
				{	soap_flag_ImpMesAteTestDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ImpMesAteTestDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ImpMesAteTestDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ImpMesAteTestDataResponse, SOAP_TYPE__ns1__ImpMesAteTestDataResponse, sizeof(_ns1__ImpMesAteTestDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ImpMesAteTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__ImpMesAteTestDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ImpMesAteTestDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ImpMesAteTestDataResponse *p;
	size_t k = sizeof(_ns1__ImpMesAteTestDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ImpMesAteTestDataResponse);
		if (p)
			((_ns1__ImpMesAteTestDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ImpMesAteTestDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ImpMesAteTestDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ImpMesAteTestDataResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ImpMesAteTestDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ImpMesAteTestDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ImpMesAteTestDataResponse(soap, tag ? tag : "ns1:ImpMesAteTestDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ImpMesAteTestDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ImpMesAteTestDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ImpMesAteTestDataResponse * SOAP_FMAC4 soap_get__ns1__ImpMesAteTestDataResponse(struct soap *soap, _ns1__ImpMesAteTestDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ImpMesAteTestDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ImpMesAteTestData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ImpMesAteTestData::Emp_USCORENo = NULL;
	this->_ns1__ImpMesAteTestData::Station_USCOREName = NULL;
	this->_ns1__ImpMesAteTestData::SN = NULL;
	this->_ns1__ImpMesAteTestData::TestData = NULL;
	/* transient soap skipped */
}

void _ns1__ImpMesAteTestData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ImpMesAteTestData::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ImpMesAteTestData::Station_USCOREName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ImpMesAteTestData::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ImpMesAteTestData::TestData);
#endif
}

int _ns1__ImpMesAteTestData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ImpMesAteTestData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ImpMesAteTestData(struct soap *soap, const char *tag, int id, const _ns1__ImpMesAteTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ImpMesAteTestData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__ImpMesAteTestData::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Name", -1, &a->_ns1__ImpMesAteTestData::Station_USCOREName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ImpMesAteTestData::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestData", -1, &a->_ns1__ImpMesAteTestData::TestData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ImpMesAteTestData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ImpMesAteTestData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ImpMesAteTestData * SOAP_FMAC4 soap_in__ns1__ImpMesAteTestData(struct soap *soap, const char *tag, _ns1__ImpMesAteTestData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ImpMesAteTestData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ImpMesAteTestData, sizeof(_ns1__ImpMesAteTestData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ImpMesAteTestData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ImpMesAteTestData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_Station_USCOREName1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_TestData1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__ImpMesAteTestData::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_Station_USCOREName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Name", &a->_ns1__ImpMesAteTestData::Station_USCOREName, "xsd:string"))
				{	soap_flag_Station_USCOREName1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ImpMesAteTestData::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_TestData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestData", &a->_ns1__ImpMesAteTestData::TestData, "xsd:string"))
				{	soap_flag_TestData1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ImpMesAteTestData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ImpMesAteTestData, SOAP_TYPE__ns1__ImpMesAteTestData, sizeof(_ns1__ImpMesAteTestData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ImpMesAteTestData * SOAP_FMAC2 soap_instantiate__ns1__ImpMesAteTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ImpMesAteTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ImpMesAteTestData *p;
	size_t k = sizeof(_ns1__ImpMesAteTestData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ImpMesAteTestData);
		if (p)
			((_ns1__ImpMesAteTestData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ImpMesAteTestData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ImpMesAteTestData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ImpMesAteTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ImpMesAteTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ImpMesAteTestData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ImpMesAteTestData(soap, tag ? tag : "ns1:ImpMesAteTestData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ImpMesAteTestData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ImpMesAteTestData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ImpMesAteTestData * SOAP_FMAC4 soap_get__ns1__ImpMesAteTestData(struct soap *soap, _ns1__ImpMesAteTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ImpMesAteTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkStationTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkStationTimeResponse::chkStationTimeResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkStationTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkStationTimeResponse::chkStationTimeResult);
#endif
}

int _ns1__chkStationTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkStationTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkStationTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__chkStationTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkStationTimeResponse), type))
		return soap->error;
	if (a->chkStationTimeResult)
		soap_element_result(soap, "ns1:chkStationTimeResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkStationTimeResult", -1, &a->_ns1__chkStationTimeResponse::chkStationTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkStationTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkStationTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkStationTimeResponse * SOAP_FMAC4 soap_in__ns1__chkStationTimeResponse(struct soap *soap, const char *tag, _ns1__chkStationTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkStationTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkStationTimeResponse, sizeof(_ns1__chkStationTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkStationTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkStationTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkStationTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkStationTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkStationTimeResult", &a->_ns1__chkStationTimeResponse::chkStationTimeResult, "xsd:string"))
				{	soap_flag_chkStationTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkStationTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkStationTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkStationTimeResponse, SOAP_TYPE__ns1__chkStationTimeResponse, sizeof(_ns1__chkStationTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkStationTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__chkStationTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkStationTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkStationTimeResponse *p;
	size_t k = sizeof(_ns1__chkStationTimeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkStationTimeResponse);
		if (p)
			((_ns1__chkStationTimeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkStationTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkStationTimeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkStationTimeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkStationTimeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkStationTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkStationTimeResponse(soap, tag ? tag : "ns1:chkStationTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkStationTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkStationTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkStationTimeResponse * SOAP_FMAC4 soap_get__ns1__chkStationTimeResponse(struct soap *soap, _ns1__chkStationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkStationTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkStationTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkStationTime::SN = NULL;
	this->_ns1__chkStationTime::Station = NULL;
	/* transient soap skipped */
}

void _ns1__chkStationTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkStationTime::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkStationTime::Station);
#endif
}

int _ns1__chkStationTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkStationTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkStationTime(struct soap *soap, const char *tag, int id, const _ns1__chkStationTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkStationTime), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__chkStationTime::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__chkStationTime::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkStationTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkStationTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkStationTime * SOAP_FMAC4 soap_in__ns1__chkStationTime(struct soap *soap, const char *tag, _ns1__chkStationTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkStationTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkStationTime, sizeof(_ns1__chkStationTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkStationTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkStationTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__chkStationTime::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__chkStationTime::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkStationTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkStationTime, SOAP_TYPE__ns1__chkStationTime, sizeof(_ns1__chkStationTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkStationTime * SOAP_FMAC2 soap_instantiate__ns1__chkStationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkStationTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkStationTime *p;
	size_t k = sizeof(_ns1__chkStationTime);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkStationTime);
		if (p)
			((_ns1__chkStationTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkStationTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkStationTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkStationTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkStationTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkStationTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkStationTime(soap, tag ? tag : "ns1:chkStationTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkStationTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkStationTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkStationTime * SOAP_FMAC4 soap_get__ns1__chkStationTime(struct soap *soap, _ns1__chkStationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkStationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InFruitsOrtQtyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InFruitsOrtQtyResponse::InFruitsOrtQtyResult = NULL;
	/* transient soap skipped */
}

void _ns1__InFruitsOrtQtyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InFruitsOrtQtyResponse::InFruitsOrtQtyResult);
#endif
}

int _ns1__InFruitsOrtQtyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InFruitsOrtQtyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InFruitsOrtQtyResponse(struct soap *soap, const char *tag, int id, const _ns1__InFruitsOrtQtyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InFruitsOrtQtyResponse), type))
		return soap->error;
	if (a->InFruitsOrtQtyResult)
		soap_element_result(soap, "ns1:InFruitsOrtQtyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InFruitsOrtQtyResult", -1, &a->_ns1__InFruitsOrtQtyResponse::InFruitsOrtQtyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InFruitsOrtQtyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InFruitsOrtQtyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InFruitsOrtQtyResponse * SOAP_FMAC4 soap_in__ns1__InFruitsOrtQtyResponse(struct soap *soap, const char *tag, _ns1__InFruitsOrtQtyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InFruitsOrtQtyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InFruitsOrtQtyResponse, sizeof(_ns1__InFruitsOrtQtyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InFruitsOrtQtyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InFruitsOrtQtyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InFruitsOrtQtyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InFruitsOrtQtyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InFruitsOrtQtyResult", &a->_ns1__InFruitsOrtQtyResponse::InFruitsOrtQtyResult, "xsd:string"))
				{	soap_flag_InFruitsOrtQtyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InFruitsOrtQtyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InFruitsOrtQtyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InFruitsOrtQtyResponse, SOAP_TYPE__ns1__InFruitsOrtQtyResponse, sizeof(_ns1__InFruitsOrtQtyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InFruitsOrtQtyResponse * SOAP_FMAC2 soap_instantiate__ns1__InFruitsOrtQtyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InFruitsOrtQtyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InFruitsOrtQtyResponse *p;
	size_t k = sizeof(_ns1__InFruitsOrtQtyResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InFruitsOrtQtyResponse);
		if (p)
			((_ns1__InFruitsOrtQtyResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InFruitsOrtQtyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InFruitsOrtQtyResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InFruitsOrtQtyResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InFruitsOrtQtyResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InFruitsOrtQtyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InFruitsOrtQtyResponse(soap, tag ? tag : "ns1:InFruitsOrtQtyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InFruitsOrtQtyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InFruitsOrtQtyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InFruitsOrtQtyResponse * SOAP_FMAC4 soap_get__ns1__InFruitsOrtQtyResponse(struct soap *soap, _ns1__InFruitsOrtQtyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InFruitsOrtQtyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InFruitsOrtQty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InFruitsOrtQty::SN = NULL;
	this->_ns1__InFruitsOrtQty::Station = NULL;
	/* transient soap skipped */
}

void _ns1__InFruitsOrtQty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InFruitsOrtQty::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InFruitsOrtQty::Station);
#endif
}

int _ns1__InFruitsOrtQty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InFruitsOrtQty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InFruitsOrtQty(struct soap *soap, const char *tag, int id, const _ns1__InFruitsOrtQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InFruitsOrtQty), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InFruitsOrtQty::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__InFruitsOrtQty::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InFruitsOrtQty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InFruitsOrtQty(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InFruitsOrtQty * SOAP_FMAC4 soap_in__ns1__InFruitsOrtQty(struct soap *soap, const char *tag, _ns1__InFruitsOrtQty *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InFruitsOrtQty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InFruitsOrtQty, sizeof(_ns1__InFruitsOrtQty), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InFruitsOrtQty)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InFruitsOrtQty *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InFruitsOrtQty::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__InFruitsOrtQty::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InFruitsOrtQty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InFruitsOrtQty, SOAP_TYPE__ns1__InFruitsOrtQty, sizeof(_ns1__InFruitsOrtQty), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InFruitsOrtQty * SOAP_FMAC2 soap_instantiate__ns1__InFruitsOrtQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InFruitsOrtQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InFruitsOrtQty *p;
	size_t k = sizeof(_ns1__InFruitsOrtQty);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InFruitsOrtQty);
		if (p)
			((_ns1__InFruitsOrtQty*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InFruitsOrtQty, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InFruitsOrtQty*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InFruitsOrtQty location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InFruitsOrtQty, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InFruitsOrtQty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InFruitsOrtQty(soap, tag ? tag : "ns1:InFruitsOrtQty", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InFruitsOrtQty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InFruitsOrtQty(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InFruitsOrtQty * SOAP_FMAC4 soap_get__ns1__InFruitsOrtQty(struct soap *soap, _ns1__InFruitsOrtQty *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InFruitsOrtQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendTestResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendTestResultResponse::sendTestResultResult = NULL;
	/* transient soap skipped */
}

void _ns1__sendTestResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestResultResponse::sendTestResultResult);
#endif
}

int _ns1__sendTestResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendTestResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendTestResultResponse(struct soap *soap, const char *tag, int id, const _ns1__sendTestResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendTestResultResponse), type))
		return soap->error;
	if (a->sendTestResultResult)
		soap_element_result(soap, "ns1:sendTestResultResult");
	if (soap_out_PointerTostd__string(soap, "ns1:sendTestResultResult", -1, &a->_ns1__sendTestResultResponse::sendTestResultResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendTestResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendTestResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendTestResultResponse * SOAP_FMAC4 soap_in__ns1__sendTestResultResponse(struct soap *soap, const char *tag, _ns1__sendTestResultResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendTestResultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendTestResultResponse, sizeof(_ns1__sendTestResultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendTestResultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendTestResultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sendTestResultResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sendTestResultResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:sendTestResultResult", &a->_ns1__sendTestResultResponse::sendTestResultResult, "xsd:string"))
				{	soap_flag_sendTestResultResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:sendTestResultResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendTestResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendTestResultResponse, SOAP_TYPE__ns1__sendTestResultResponse, sizeof(_ns1__sendTestResultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendTestResultResponse * SOAP_FMAC2 soap_instantiate__ns1__sendTestResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendTestResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendTestResultResponse *p;
	size_t k = sizeof(_ns1__sendTestResultResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendTestResultResponse);
		if (p)
			((_ns1__sendTestResultResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendTestResultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendTestResultResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendTestResultResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendTestResultResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendTestResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendTestResultResponse(soap, tag ? tag : "ns1:sendTestResultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendTestResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendTestResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendTestResultResponse * SOAP_FMAC4 soap_get__ns1__sendTestResultResponse(struct soap *soap, _ns1__sendTestResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendTestResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendTestResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendTestResult::Emp_USCORENo = NULL;
	this->_ns1__sendTestResult::SN = NULL;
	this->_ns1__sendTestResult::Station = NULL;
	this->_ns1__sendTestResult::TestResult = NULL;
	/* transient soap skipped */
}

void _ns1__sendTestResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestResult::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestResult::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestResult::Station);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestResult::TestResult);
#endif
}

int _ns1__sendTestResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendTestResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendTestResult(struct soap *soap, const char *tag, int id, const _ns1__sendTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendTestResult), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__sendTestResult::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__sendTestResult::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__sendTestResult::Station, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestResult", -1, &a->_ns1__sendTestResult::TestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendTestResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendTestResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendTestResult * SOAP_FMAC4 soap_in__ns1__sendTestResult(struct soap *soap, const char *tag, _ns1__sendTestResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendTestResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendTestResult, sizeof(_ns1__sendTestResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendTestResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendTestResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	size_t soap_flag_TestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__sendTestResult::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__sendTestResult::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__sendTestResult::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap_flag_TestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestResult", &a->_ns1__sendTestResult::TestResult, "xsd:string"))
				{	soap_flag_TestResult1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendTestResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendTestResult, SOAP_TYPE__ns1__sendTestResult, sizeof(_ns1__sendTestResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendTestResult * SOAP_FMAC2 soap_instantiate__ns1__sendTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendTestResult *p;
	size_t k = sizeof(_ns1__sendTestResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendTestResult);
		if (p)
			((_ns1__sendTestResult*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendTestResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendTestResult*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendTestResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendTestResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendTestResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendTestResult(soap, tag ? tag : "ns1:sendTestResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendTestResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendTestResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendTestResult * SOAP_FMAC4 soap_get__ns1__sendTestResult(struct soap *soap, _ns1__sendTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendTestDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendTestDataResponse::sendTestDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__sendTestDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestDataResponse::sendTestDataResult);
#endif
}

int _ns1__sendTestDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendTestDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendTestDataResponse(struct soap *soap, const char *tag, int id, const _ns1__sendTestDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendTestDataResponse), type))
		return soap->error;
	if (a->sendTestDataResult)
		soap_element_result(soap, "ns1:sendTestDataResult");
	if (soap_out_PointerTostd__string(soap, "ns1:sendTestDataResult", -1, &a->_ns1__sendTestDataResponse::sendTestDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendTestDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendTestDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendTestDataResponse * SOAP_FMAC4 soap_in__ns1__sendTestDataResponse(struct soap *soap, const char *tag, _ns1__sendTestDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendTestDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendTestDataResponse, sizeof(_ns1__sendTestDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendTestDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendTestDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sendTestDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sendTestDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:sendTestDataResult", &a->_ns1__sendTestDataResponse::sendTestDataResult, "xsd:string"))
				{	soap_flag_sendTestDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:sendTestDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendTestDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendTestDataResponse, SOAP_TYPE__ns1__sendTestDataResponse, sizeof(_ns1__sendTestDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__sendTestDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendTestDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendTestDataResponse *p;
	size_t k = sizeof(_ns1__sendTestDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendTestDataResponse);
		if (p)
			((_ns1__sendTestDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendTestDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendTestDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendTestDataResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendTestDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendTestDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendTestDataResponse(soap, tag ? tag : "ns1:sendTestDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendTestDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendTestDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendTestDataResponse * SOAP_FMAC4 soap_get__ns1__sendTestDataResponse(struct soap *soap, _ns1__sendTestDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendTestDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__sendTestData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__sendTestData::Emp_USCORENo = NULL;
	this->_ns1__sendTestData::SN = NULL;
	this->_ns1__sendTestData::Station = NULL;
	this->_ns1__sendTestData::TestData = NULL;
	/* transient soap skipped */
}

void _ns1__sendTestData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestData::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestData::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestData::Station);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__sendTestData::TestData);
#endif
}

int _ns1__sendTestData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendTestData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendTestData(struct soap *soap, const char *tag, int id, const _ns1__sendTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendTestData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__sendTestData::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__sendTestData::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__sendTestData::Station, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestData", -1, &a->_ns1__sendTestData::TestData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__sendTestData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendTestData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendTestData * SOAP_FMAC4 soap_in__ns1__sendTestData(struct soap *soap, const char *tag, _ns1__sendTestData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__sendTestData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendTestData, sizeof(_ns1__sendTestData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__sendTestData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__sendTestData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	size_t soap_flag_TestData1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__sendTestData::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__sendTestData::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__sendTestData::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap_flag_TestData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestData", &a->_ns1__sendTestData::TestData, "xsd:string"))
				{	soap_flag_TestData1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__sendTestData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sendTestData, SOAP_TYPE__ns1__sendTestData, sizeof(_ns1__sendTestData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__sendTestData * SOAP_FMAC2 soap_instantiate__ns1__sendTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__sendTestData *p;
	size_t k = sizeof(_ns1__sendTestData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__sendTestData);
		if (p)
			((_ns1__sendTestData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__sendTestData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__sendTestData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__sendTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__sendTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__sendTestData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__sendTestData(soap, tag ? tag : "ns1:sendTestData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__sendTestData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendTestData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendTestData * SOAP_FMAC4 soap_get__ns1__sendTestData(struct soap *soap, _ns1__sendTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSN_USCOREStationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSN_USCOREStationResponse::checkSN_USCOREStationResult = NULL;
	/* transient soap skipped */
}

void _ns1__checkSN_USCOREStationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSN_USCOREStationResponse::checkSN_USCOREStationResult);
#endif
}

int _ns1__checkSN_USCOREStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSN_USCOREStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSN_USCOREStationResponse(struct soap *soap, const char *tag, int id, const _ns1__checkSN_USCOREStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSN_USCOREStationResponse), type))
		return soap->error;
	if (a->checkSN_USCOREStationResult)
		soap_element_result(soap, "ns1:checkSN_StationResult");
	if (soap_out_PointerTostd__string(soap, "ns1:checkSN_StationResult", -1, &a->_ns1__checkSN_USCOREStationResponse::checkSN_USCOREStationResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSN_USCOREStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSN_USCOREStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationResponse * SOAP_FMAC4 soap_in__ns1__checkSN_USCOREStationResponse(struct soap *soap, const char *tag, _ns1__checkSN_USCOREStationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSN_USCOREStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSN_USCOREStationResponse, sizeof(_ns1__checkSN_USCOREStationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSN_USCOREStationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSN_USCOREStationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_checkSN_USCOREStationResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkSN_USCOREStationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:checkSN_StationResult", &a->_ns1__checkSN_USCOREStationResponse::checkSN_USCOREStationResult, "xsd:string"))
				{	soap_flag_checkSN_USCOREStationResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:checkSN_StationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkSN_USCOREStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSN_USCOREStationResponse, SOAP_TYPE__ns1__checkSN_USCOREStationResponse, sizeof(_ns1__checkSN_USCOREStationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSN_USCOREStationResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSN_USCOREStationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSN_USCOREStationResponse *p;
	size_t k = sizeof(_ns1__checkSN_USCOREStationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSN_USCOREStationResponse);
		if (p)
			((_ns1__checkSN_USCOREStationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSN_USCOREStationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSN_USCOREStationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSN_USCOREStationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSN_USCOREStationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSN_USCOREStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkSN_USCOREStationResponse(soap, tag ? tag : "ns1:checkSN_StationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSN_USCOREStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSN_USCOREStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationResponse * SOAP_FMAC4 soap_get__ns1__checkSN_USCOREStationResponse(struct soap *soap, _ns1__checkSN_USCOREStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSN_USCOREStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSN_USCOREStation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSN_USCOREStation::SN = NULL;
	this->_ns1__checkSN_USCOREStation::Station_USCOREName = NULL;
	/* transient soap skipped */
}

void _ns1__checkSN_USCOREStation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSN_USCOREStation::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSN_USCOREStation::Station_USCOREName);
#endif
}

int _ns1__checkSN_USCOREStation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSN_USCOREStation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSN_USCOREStation(struct soap *soap, const char *tag, int id, const _ns1__checkSN_USCOREStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSN_USCOREStation), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__checkSN_USCOREStation::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Name", -1, &a->_ns1__checkSN_USCOREStation::Station_USCOREName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSN_USCOREStation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSN_USCOREStation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStation * SOAP_FMAC4 soap_in__ns1__checkSN_USCOREStation(struct soap *soap, const char *tag, _ns1__checkSN_USCOREStation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSN_USCOREStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSN_USCOREStation, sizeof(_ns1__checkSN_USCOREStation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSN_USCOREStation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSN_USCOREStation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station_USCOREName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__checkSN_USCOREStation::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station_USCOREName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Name", &a->_ns1__checkSN_USCOREStation::Station_USCOREName, "xsd:string"))
				{	soap_flag_Station_USCOREName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkSN_USCOREStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSN_USCOREStation, SOAP_TYPE__ns1__checkSN_USCOREStation, sizeof(_ns1__checkSN_USCOREStation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSN_USCOREStation * SOAP_FMAC2 soap_instantiate__ns1__checkSN_USCOREStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSN_USCOREStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSN_USCOREStation *p;
	size_t k = sizeof(_ns1__checkSN_USCOREStation);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSN_USCOREStation);
		if (p)
			((_ns1__checkSN_USCOREStation*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSN_USCOREStation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSN_USCOREStation*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSN_USCOREStation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSN_USCOREStation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSN_USCOREStation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkSN_USCOREStation(soap, tag ? tag : "ns1:checkSN_Station", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSN_USCOREStation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSN_USCOREStation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStation * SOAP_FMAC4 soap_get__ns1__checkSN_USCOREStation(struct soap *soap, _ns1__checkSN_USCOREStation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSN_USCOREStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkEmpNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkEmpNoResponse::checkEmpNoResult = NULL;
	/* transient soap skipped */
}

void _ns1__checkEmpNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkEmpNoResponse::checkEmpNoResult);
#endif
}

int _ns1__checkEmpNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkEmpNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkEmpNoResponse(struct soap *soap, const char *tag, int id, const _ns1__checkEmpNoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkEmpNoResponse), type))
		return soap->error;
	if (a->checkEmpNoResult)
		soap_element_result(soap, "ns1:checkEmpNoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:checkEmpNoResult", -1, &a->_ns1__checkEmpNoResponse::checkEmpNoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkEmpNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkEmpNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkEmpNoResponse * SOAP_FMAC4 soap_in__ns1__checkEmpNoResponse(struct soap *soap, const char *tag, _ns1__checkEmpNoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkEmpNoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkEmpNoResponse, sizeof(_ns1__checkEmpNoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkEmpNoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkEmpNoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_checkEmpNoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkEmpNoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:checkEmpNoResult", &a->_ns1__checkEmpNoResponse::checkEmpNoResult, "xsd:string"))
				{	soap_flag_checkEmpNoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:checkEmpNoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkEmpNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkEmpNoResponse, SOAP_TYPE__ns1__checkEmpNoResponse, sizeof(_ns1__checkEmpNoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkEmpNoResponse * SOAP_FMAC2 soap_instantiate__ns1__checkEmpNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkEmpNoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkEmpNoResponse *p;
	size_t k = sizeof(_ns1__checkEmpNoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkEmpNoResponse);
		if (p)
			((_ns1__checkEmpNoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkEmpNoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkEmpNoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkEmpNoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkEmpNoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkEmpNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkEmpNoResponse(soap, tag ? tag : "ns1:checkEmpNoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkEmpNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkEmpNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkEmpNoResponse * SOAP_FMAC4 soap_get__ns1__checkEmpNoResponse(struct soap *soap, _ns1__checkEmpNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkEmpNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkEmpNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkEmpNo::Emp_USCORENo = NULL;
	this->_ns1__checkEmpNo::Station_USCOREName = NULL;
	/* transient soap skipped */
}

void _ns1__checkEmpNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkEmpNo::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkEmpNo::Station_USCOREName);
#endif
}

int _ns1__checkEmpNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkEmpNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkEmpNo(struct soap *soap, const char *tag, int id, const _ns1__checkEmpNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkEmpNo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__checkEmpNo::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Name", -1, &a->_ns1__checkEmpNo::Station_USCOREName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkEmpNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkEmpNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkEmpNo * SOAP_FMAC4 soap_in__ns1__checkEmpNo(struct soap *soap, const char *tag, _ns1__checkEmpNo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkEmpNo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkEmpNo, sizeof(_ns1__checkEmpNo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkEmpNo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkEmpNo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_Station_USCOREName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__checkEmpNo::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_Station_USCOREName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Name", &a->_ns1__checkEmpNo::Station_USCOREName, "xsd:string"))
				{	soap_flag_Station_USCOREName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkEmpNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkEmpNo, SOAP_TYPE__ns1__checkEmpNo, sizeof(_ns1__checkEmpNo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkEmpNo * SOAP_FMAC2 soap_instantiate__ns1__checkEmpNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkEmpNo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkEmpNo *p;
	size_t k = sizeof(_ns1__checkEmpNo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkEmpNo);
		if (p)
			((_ns1__checkEmpNo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkEmpNo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkEmpNo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkEmpNo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkEmpNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkEmpNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkEmpNo(soap, tag ? tag : "ns1:checkEmpNo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkEmpNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkEmpNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkEmpNo * SOAP_FMAC4 soap_get__ns1__checkEmpNo(struct soap *soap, _ns1__checkEmpNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkEmpNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkTestDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkTestDataResponse::checkTestDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__checkTestDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkTestDataResponse::checkTestDataResult);
#endif
}

int _ns1__checkTestDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkTestDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkTestDataResponse(struct soap *soap, const char *tag, int id, const _ns1__checkTestDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkTestDataResponse), type))
		return soap->error;
	if (a->checkTestDataResult)
		soap_element_result(soap, "ns1:checkTestDataResult");
	if (soap_out_PointerTostd__string(soap, "ns1:checkTestDataResult", -1, &a->_ns1__checkTestDataResponse::checkTestDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkTestDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkTestDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkTestDataResponse * SOAP_FMAC4 soap_in__ns1__checkTestDataResponse(struct soap *soap, const char *tag, _ns1__checkTestDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkTestDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkTestDataResponse, sizeof(_ns1__checkTestDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkTestDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkTestDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_checkTestDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkTestDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:checkTestDataResult", &a->_ns1__checkTestDataResponse::checkTestDataResult, "xsd:string"))
				{	soap_flag_checkTestDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:checkTestDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkTestDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkTestDataResponse, SOAP_TYPE__ns1__checkTestDataResponse, sizeof(_ns1__checkTestDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__checkTestDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkTestDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkTestDataResponse *p;
	size_t k = sizeof(_ns1__checkTestDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkTestDataResponse);
		if (p)
			((_ns1__checkTestDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkTestDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkTestDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkTestDataResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkTestDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkTestDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkTestDataResponse(soap, tag ? tag : "ns1:checkTestDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkTestDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkTestDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkTestDataResponse * SOAP_FMAC4 soap_get__ns1__checkTestDataResponse(struct soap *soap, _ns1__checkTestDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkTestDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkTestData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkTestData::SN = NULL;
	this->_ns1__checkTestData::TB = NULL;
	/* transient soap skipped */
}

void _ns1__checkTestData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkTestData::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkTestData::TB);
#endif
}

int _ns1__checkTestData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkTestData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkTestData(struct soap *soap, const char *tag, int id, const _ns1__checkTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkTestData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__checkTestData::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TB", -1, &a->_ns1__checkTestData::TB, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkTestData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkTestData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkTestData * SOAP_FMAC4 soap_in__ns1__checkTestData(struct soap *soap, const char *tag, _ns1__checkTestData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkTestData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkTestData, sizeof(_ns1__checkTestData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkTestData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkTestData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_TB1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__checkTestData::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_TB1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TB", &a->_ns1__checkTestData::TB, "xsd:string"))
				{	soap_flag_TB1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__checkTestData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkTestData, SOAP_TYPE__ns1__checkTestData, sizeof(_ns1__checkTestData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkTestData * SOAP_FMAC2 soap_instantiate__ns1__checkTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkTestData *p;
	size_t k = sizeof(_ns1__checkTestData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkTestData);
		if (p)
			((_ns1__checkTestData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkTestData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkTestData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkTestData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__checkTestData(soap, tag ? tag : "ns1:checkTestData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkTestData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkTestData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkTestData * SOAP_FMAC4 soap_get__ns1__checkTestData(struct soap *soap, _ns1__checkTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsZjListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsZjListResponse::InsZjListResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsZjListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjListResponse::InsZjListResult);
#endif
}

int _ns1__InsZjListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsZjListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsZjListResponse(struct soap *soap, const char *tag, int id, const _ns1__InsZjListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsZjListResponse), type))
		return soap->error;
	if (a->InsZjListResult)
		soap_element_result(soap, "ns1:InsZjListResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsZjListResult", -1, &a->_ns1__InsZjListResponse::InsZjListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsZjListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsZjListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsZjListResponse * SOAP_FMAC4 soap_in__ns1__InsZjListResponse(struct soap *soap, const char *tag, _ns1__InsZjListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsZjListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsZjListResponse, sizeof(_ns1__InsZjListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsZjListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsZjListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsZjListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsZjListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsZjListResult", &a->_ns1__InsZjListResponse::InsZjListResult, "xsd:string"))
				{	soap_flag_InsZjListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsZjListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsZjListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsZjListResponse, SOAP_TYPE__ns1__InsZjListResponse, sizeof(_ns1__InsZjListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsZjListResponse * SOAP_FMAC2 soap_instantiate__ns1__InsZjListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsZjListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsZjListResponse *p;
	size_t k = sizeof(_ns1__InsZjListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsZjListResponse);
		if (p)
			((_ns1__InsZjListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsZjListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsZjListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsZjListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsZjListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsZjListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsZjListResponse(soap, tag ? tag : "ns1:InsZjListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsZjListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsZjListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsZjListResponse * SOAP_FMAC4 soap_get__ns1__InsZjListResponse(struct soap *soap, _ns1__InsZjListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsZjListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsZjList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsZjList::ZJSN = NULL;
	this->_ns1__InsZjList::Qty = NULL;
	this->_ns1__InsZjList::ZJQty = NULL;
	this->_ns1__InsZjList::ZJDate = NULL;
	this->_ns1__InsZjList::Mo = NULL;
	this->_ns1__InsZjList::Part = NULL;
	this->_ns1__InsZjList::Line = NULL;
	/* transient soap skipped */
}

void _ns1__InsZjList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::ZJSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::Qty);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::ZJQty);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::ZJDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::Mo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::Part);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsZjList::Line);
#endif
}

int _ns1__InsZjList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsZjList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsZjList(struct soap *soap, const char *tag, int id, const _ns1__InsZjList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsZjList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJSN", -1, &a->_ns1__InsZjList::ZJSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Qty", -1, &a->_ns1__InsZjList::Qty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJQty", -1, &a->_ns1__InsZjList::ZJQty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ZJDate", -1, &a->_ns1__InsZjList::ZJDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Mo", -1, &a->_ns1__InsZjList::Mo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Part", -1, &a->_ns1__InsZjList::Part, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Line", -1, &a->_ns1__InsZjList::Line, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsZjList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsZjList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsZjList * SOAP_FMAC4 soap_in__ns1__InsZjList(struct soap *soap, const char *tag, _ns1__InsZjList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsZjList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsZjList, sizeof(_ns1__InsZjList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsZjList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsZjList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZJSN1 = 1;
	size_t soap_flag_Qty1 = 1;
	size_t soap_flag_ZJQty1 = 1;
	size_t soap_flag_ZJDate1 = 1;
	size_t soap_flag_Mo1 = 1;
	size_t soap_flag_Part1 = 1;
	size_t soap_flag_Line1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZJSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJSN", &a->_ns1__InsZjList::ZJSN, "xsd:string"))
				{	soap_flag_ZJSN1--;
					continue;
				}
			}
			if (soap_flag_Qty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Qty", &a->_ns1__InsZjList::Qty, "xsd:string"))
				{	soap_flag_Qty1--;
					continue;
				}
			}
			if (soap_flag_ZJQty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJQty", &a->_ns1__InsZjList::ZJQty, "xsd:string"))
				{	soap_flag_ZJQty1--;
					continue;
				}
			}
			if (soap_flag_ZJDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ZJDate", &a->_ns1__InsZjList::ZJDate, "xsd:string"))
				{	soap_flag_ZJDate1--;
					continue;
				}
			}
			if (soap_flag_Mo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Mo", &a->_ns1__InsZjList::Mo, "xsd:string"))
				{	soap_flag_Mo1--;
					continue;
				}
			}
			if (soap_flag_Part1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Part", &a->_ns1__InsZjList::Part, "xsd:string"))
				{	soap_flag_Part1--;
					continue;
				}
			}
			if (soap_flag_Line1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Line", &a->_ns1__InsZjList::Line, "xsd:string"))
				{	soap_flag_Line1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsZjList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsZjList, SOAP_TYPE__ns1__InsZjList, sizeof(_ns1__InsZjList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsZjList * SOAP_FMAC2 soap_instantiate__ns1__InsZjList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsZjList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsZjList *p;
	size_t k = sizeof(_ns1__InsZjList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsZjList);
		if (p)
			((_ns1__InsZjList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsZjList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsZjList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsZjList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsZjList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsZjList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsZjList(soap, tag ? tag : "ns1:InsZjList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsZjList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsZjList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsZjList * SOAP_FMAC4 soap_get__ns1__InsZjList(struct soap *soap, _ns1__InsZjList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsZjList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFruitMachineChkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFruitMachineChkResponse::GetFruitMachineChkResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetFruitMachineChkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitMachineChkResponse::GetFruitMachineChkResult);
#endif
}

int _ns1__GetFruitMachineChkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFruitMachineChkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFruitMachineChkResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFruitMachineChkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFruitMachineChkResponse), type))
		return soap->error;
	if (a->GetFruitMachineChkResult)
		soap_element_result(soap, "ns1:GetFruitMachineChkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetFruitMachineChkResult", -1, &a->_ns1__GetFruitMachineChkResponse::GetFruitMachineChkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFruitMachineChkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFruitMachineChkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFruitMachineChkResponse * SOAP_FMAC4 soap_in__ns1__GetFruitMachineChkResponse(struct soap *soap, const char *tag, _ns1__GetFruitMachineChkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFruitMachineChkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFruitMachineChkResponse, sizeof(_ns1__GetFruitMachineChkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFruitMachineChkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFruitMachineChkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetFruitMachineChkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFruitMachineChkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetFruitMachineChkResult", &a->_ns1__GetFruitMachineChkResponse::GetFruitMachineChkResult, "xsd:string"))
				{	soap_flag_GetFruitMachineChkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetFruitMachineChkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFruitMachineChkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFruitMachineChkResponse, SOAP_TYPE__ns1__GetFruitMachineChkResponse, sizeof(_ns1__GetFruitMachineChkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFruitMachineChkResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFruitMachineChkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFruitMachineChkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFruitMachineChkResponse *p;
	size_t k = sizeof(_ns1__GetFruitMachineChkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetFruitMachineChkResponse);
		if (p)
			((_ns1__GetFruitMachineChkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetFruitMachineChkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetFruitMachineChkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFruitMachineChkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetFruitMachineChkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetFruitMachineChkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFruitMachineChkResponse(soap, tag ? tag : "ns1:GetFruitMachineChkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFruitMachineChkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFruitMachineChkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFruitMachineChkResponse * SOAP_FMAC4 soap_get__ns1__GetFruitMachineChkResponse(struct soap *soap, _ns1__GetFruitMachineChkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFruitMachineChkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFruitMachineChk::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFruitMachineChk::Sn = NULL;
	this->_ns1__GetFruitMachineChk::Machine = NULL;
	this->_ns1__GetFruitMachineChk::TestItem = NULL;
	/* transient soap skipped */
}

void _ns1__GetFruitMachineChk::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitMachineChk::Sn);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitMachineChk::Machine);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitMachineChk::TestItem);
#endif
}

int _ns1__GetFruitMachineChk::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFruitMachineChk(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFruitMachineChk(struct soap *soap, const char *tag, int id, const _ns1__GetFruitMachineChk *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFruitMachineChk), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Sn", -1, &a->_ns1__GetFruitMachineChk::Sn, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Machine", -1, &a->_ns1__GetFruitMachineChk::Machine, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestItem", -1, &a->_ns1__GetFruitMachineChk::TestItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFruitMachineChk::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFruitMachineChk(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFruitMachineChk * SOAP_FMAC4 soap_in__ns1__GetFruitMachineChk(struct soap *soap, const char *tag, _ns1__GetFruitMachineChk *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFruitMachineChk *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFruitMachineChk, sizeof(_ns1__GetFruitMachineChk), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFruitMachineChk)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFruitMachineChk *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Sn1 = 1;
	size_t soap_flag_Machine1 = 1;
	size_t soap_flag_TestItem1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Sn", &a->_ns1__GetFruitMachineChk::Sn, "xsd:string"))
				{	soap_flag_Sn1--;
					continue;
				}
			}
			if (soap_flag_Machine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Machine", &a->_ns1__GetFruitMachineChk::Machine, "xsd:string"))
				{	soap_flag_Machine1--;
					continue;
				}
			}
			if (soap_flag_TestItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestItem", &a->_ns1__GetFruitMachineChk::TestItem, "xsd:string"))
				{	soap_flag_TestItem1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFruitMachineChk *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFruitMachineChk, SOAP_TYPE__ns1__GetFruitMachineChk, sizeof(_ns1__GetFruitMachineChk), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFruitMachineChk * SOAP_FMAC2 soap_instantiate__ns1__GetFruitMachineChk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFruitMachineChk(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFruitMachineChk *p;
	size_t k = sizeof(_ns1__GetFruitMachineChk);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetFruitMachineChk);
		if (p)
			((_ns1__GetFruitMachineChk*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetFruitMachineChk, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetFruitMachineChk*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFruitMachineChk location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetFruitMachineChk, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetFruitMachineChk::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFruitMachineChk(soap, tag ? tag : "ns1:GetFruitMachineChk", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFruitMachineChk::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFruitMachineChk(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFruitMachineChk * SOAP_FMAC4 soap_get__ns1__GetFruitMachineChk(struct soap *soap, _ns1__GetFruitMachineChk *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFruitMachineChk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFruitMachineChkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFruitMachineChkResponse::InsFruitMachineChkResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsFruitMachineChkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChkResponse::InsFruitMachineChkResult);
#endif
}

int _ns1__InsFruitMachineChkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFruitMachineChkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFruitMachineChkResponse(struct soap *soap, const char *tag, int id, const _ns1__InsFruitMachineChkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFruitMachineChkResponse), type))
		return soap->error;
	if (a->InsFruitMachineChkResult)
		soap_element_result(soap, "ns1:InsFruitMachineChkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsFruitMachineChkResult", -1, &a->_ns1__InsFruitMachineChkResponse::InsFruitMachineChkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFruitMachineChkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFruitMachineChkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFruitMachineChkResponse * SOAP_FMAC4 soap_in__ns1__InsFruitMachineChkResponse(struct soap *soap, const char *tag, _ns1__InsFruitMachineChkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFruitMachineChkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFruitMachineChkResponse, sizeof(_ns1__InsFruitMachineChkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFruitMachineChkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFruitMachineChkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsFruitMachineChkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsFruitMachineChkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsFruitMachineChkResult", &a->_ns1__InsFruitMachineChkResponse::InsFruitMachineChkResult, "xsd:string"))
				{	soap_flag_InsFruitMachineChkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsFruitMachineChkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFruitMachineChkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFruitMachineChkResponse, SOAP_TYPE__ns1__InsFruitMachineChkResponse, sizeof(_ns1__InsFruitMachineChkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFruitMachineChkResponse * SOAP_FMAC2 soap_instantiate__ns1__InsFruitMachineChkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFruitMachineChkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFruitMachineChkResponse *p;
	size_t k = sizeof(_ns1__InsFruitMachineChkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFruitMachineChkResponse);
		if (p)
			((_ns1__InsFruitMachineChkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFruitMachineChkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFruitMachineChkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFruitMachineChkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFruitMachineChkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFruitMachineChkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFruitMachineChkResponse(soap, tag ? tag : "ns1:InsFruitMachineChkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFruitMachineChkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFruitMachineChkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFruitMachineChkResponse * SOAP_FMAC4 soap_get__ns1__InsFruitMachineChkResponse(struct soap *soap, _ns1__InsFruitMachineChkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFruitMachineChkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsFruitMachineChk::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsFruitMachineChk::Sn = NULL;
	this->_ns1__InsFruitMachineChk::Machine = NULL;
	this->_ns1__InsFruitMachineChk::TestItem = NULL;
	this->_ns1__InsFruitMachineChk::TestUpper = NULL;
	this->_ns1__InsFruitMachineChk::TestLower = NULL;
	this->_ns1__InsFruitMachineChk::TestValue = NULL;
	this->_ns1__InsFruitMachineChk::TestResult = NULL;
	this->_ns1__InsFruitMachineChk::TestTime = NULL;
	this->_ns1__InsFruitMachineChk::EndTime = NULL;
	/* transient soap skipped */
}

void _ns1__InsFruitMachineChk::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::Sn);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::Machine);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::TestItem);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::TestUpper);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::TestLower);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::TestValue);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::TestResult);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::TestTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsFruitMachineChk::EndTime);
#endif
}

int _ns1__InsFruitMachineChk::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsFruitMachineChk(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsFruitMachineChk(struct soap *soap, const char *tag, int id, const _ns1__InsFruitMachineChk *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsFruitMachineChk), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Sn", -1, &a->_ns1__InsFruitMachineChk::Sn, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Machine", -1, &a->_ns1__InsFruitMachineChk::Machine, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestItem", -1, &a->_ns1__InsFruitMachineChk::TestItem, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestUpper", -1, &a->_ns1__InsFruitMachineChk::TestUpper, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestLower", -1, &a->_ns1__InsFruitMachineChk::TestLower, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestValue", -1, &a->_ns1__InsFruitMachineChk::TestValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestResult", -1, &a->_ns1__InsFruitMachineChk::TestResult, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestTime", -1, &a->_ns1__InsFruitMachineChk::TestTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EndTime", -1, &a->_ns1__InsFruitMachineChk::EndTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsFruitMachineChk::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsFruitMachineChk(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsFruitMachineChk * SOAP_FMAC4 soap_in__ns1__InsFruitMachineChk(struct soap *soap, const char *tag, _ns1__InsFruitMachineChk *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsFruitMachineChk *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsFruitMachineChk, sizeof(_ns1__InsFruitMachineChk), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsFruitMachineChk)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsFruitMachineChk *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Sn1 = 1;
	size_t soap_flag_Machine1 = 1;
	size_t soap_flag_TestItem1 = 1;
	size_t soap_flag_TestUpper1 = 1;
	size_t soap_flag_TestLower1 = 1;
	size_t soap_flag_TestValue1 = 1;
	size_t soap_flag_TestResult1 = 1;
	size_t soap_flag_TestTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Sn", &a->_ns1__InsFruitMachineChk::Sn, "xsd:string"))
				{	soap_flag_Sn1--;
					continue;
				}
			}
			if (soap_flag_Machine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Machine", &a->_ns1__InsFruitMachineChk::Machine, "xsd:string"))
				{	soap_flag_Machine1--;
					continue;
				}
			}
			if (soap_flag_TestItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestItem", &a->_ns1__InsFruitMachineChk::TestItem, "xsd:string"))
				{	soap_flag_TestItem1--;
					continue;
				}
			}
			if (soap_flag_TestUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestUpper", &a->_ns1__InsFruitMachineChk::TestUpper, "xsd:string"))
				{	soap_flag_TestUpper1--;
					continue;
				}
			}
			if (soap_flag_TestLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestLower", &a->_ns1__InsFruitMachineChk::TestLower, "xsd:string"))
				{	soap_flag_TestLower1--;
					continue;
				}
			}
			if (soap_flag_TestValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestValue", &a->_ns1__InsFruitMachineChk::TestValue, "xsd:string"))
				{	soap_flag_TestValue1--;
					continue;
				}
			}
			if (soap_flag_TestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestResult", &a->_ns1__InsFruitMachineChk::TestResult, "xsd:string"))
				{	soap_flag_TestResult1--;
					continue;
				}
			}
			if (soap_flag_TestTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestTime", &a->_ns1__InsFruitMachineChk::TestTime, "xsd:string"))
				{	soap_flag_TestTime1--;
					continue;
				}
			}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EndTime", &a->_ns1__InsFruitMachineChk::EndTime, "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsFruitMachineChk *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsFruitMachineChk, SOAP_TYPE__ns1__InsFruitMachineChk, sizeof(_ns1__InsFruitMachineChk), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsFruitMachineChk * SOAP_FMAC2 soap_instantiate__ns1__InsFruitMachineChk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsFruitMachineChk(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsFruitMachineChk *p;
	size_t k = sizeof(_ns1__InsFruitMachineChk);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsFruitMachineChk);
		if (p)
			((_ns1__InsFruitMachineChk*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsFruitMachineChk, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsFruitMachineChk*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsFruitMachineChk location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsFruitMachineChk, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsFruitMachineChk::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsFruitMachineChk(soap, tag ? tag : "ns1:InsFruitMachineChk", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsFruitMachineChk::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsFruitMachineChk(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsFruitMachineChk * SOAP_FMAC4 soap_get__ns1__InsFruitMachineChk(struct soap *soap, _ns1__InsFruitMachineChk *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsFruitMachineChk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnLnkOutSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnLnkOutSNResponse::SnLnkOutSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__SnLnkOutSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnLnkOutSNResponse::SnLnkOutSNResult);
#endif
}

int _ns1__SnLnkOutSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnLnkOutSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnLnkOutSNResponse(struct soap *soap, const char *tag, int id, const _ns1__SnLnkOutSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnLnkOutSNResponse), type))
		return soap->error;
	if (a->SnLnkOutSNResult)
		soap_element_result(soap, "ns1:SnLnkOutSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SnLnkOutSNResult", -1, &a->_ns1__SnLnkOutSNResponse::SnLnkOutSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnLnkOutSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnLnkOutSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnLnkOutSNResponse * SOAP_FMAC4 soap_in__ns1__SnLnkOutSNResponse(struct soap *soap, const char *tag, _ns1__SnLnkOutSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnLnkOutSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnLnkOutSNResponse, sizeof(_ns1__SnLnkOutSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnLnkOutSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnLnkOutSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SnLnkOutSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SnLnkOutSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SnLnkOutSNResult", &a->_ns1__SnLnkOutSNResponse::SnLnkOutSNResult, "xsd:string"))
				{	soap_flag_SnLnkOutSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SnLnkOutSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SnLnkOutSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnLnkOutSNResponse, SOAP_TYPE__ns1__SnLnkOutSNResponse, sizeof(_ns1__SnLnkOutSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnLnkOutSNResponse * SOAP_FMAC2 soap_instantiate__ns1__SnLnkOutSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnLnkOutSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnLnkOutSNResponse *p;
	size_t k = sizeof(_ns1__SnLnkOutSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnLnkOutSNResponse);
		if (p)
			((_ns1__SnLnkOutSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnLnkOutSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnLnkOutSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnLnkOutSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnLnkOutSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnLnkOutSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SnLnkOutSNResponse(soap, tag ? tag : "ns1:SnLnkOutSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnLnkOutSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnLnkOutSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnLnkOutSNResponse * SOAP_FMAC4 soap_get__ns1__SnLnkOutSNResponse(struct soap *soap, _ns1__SnLnkOutSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnLnkOutSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnLnkOutSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnLnkOutSN::SN = NULL;
	this->_ns1__SnLnkOutSN::LnkSN = NULL;
	this->_ns1__SnLnkOutSN::Emp_USCORENo = NULL;
	this->_ns1__SnLnkOutSN::Station_USCORENumber = NULL;
	this->_ns1__SnLnkOutSN::LnkType = NULL;
	/* transient soap skipped */
}

void _ns1__SnLnkOutSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnLnkOutSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnLnkOutSN::LnkSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnLnkOutSN::Emp_USCORENo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnLnkOutSN::Station_USCORENumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnLnkOutSN::LnkType);
#endif
}

int _ns1__SnLnkOutSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnLnkOutSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnLnkOutSN(struct soap *soap, const char *tag, int id, const _ns1__SnLnkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnLnkOutSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SnLnkOutSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkSN", -1, &a->_ns1__SnLnkOutSN::LnkSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Emp_No", -1, &a->_ns1__SnLnkOutSN::Emp_USCORENo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station_Number", -1, &a->_ns1__SnLnkOutSN::Station_USCORENumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LnkType", -1, &a->_ns1__SnLnkOutSN::LnkType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnLnkOutSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnLnkOutSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnLnkOutSN * SOAP_FMAC4 soap_in__ns1__SnLnkOutSN(struct soap *soap, const char *tag, _ns1__SnLnkOutSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnLnkOutSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnLnkOutSN, sizeof(_ns1__SnLnkOutSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnLnkOutSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnLnkOutSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_LnkSN1 = 1;
	size_t soap_flag_Emp_USCORENo1 = 1;
	size_t soap_flag_Station_USCORENumber1 = 1;
	size_t soap_flag_LnkType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SnLnkOutSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_LnkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkSN", &a->_ns1__SnLnkOutSN::LnkSN, "xsd:string"))
				{	soap_flag_LnkSN1--;
					continue;
				}
			}
			if (soap_flag_Emp_USCORENo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Emp_No", &a->_ns1__SnLnkOutSN::Emp_USCORENo, "xsd:string"))
				{	soap_flag_Emp_USCORENo1--;
					continue;
				}
			}
			if (soap_flag_Station_USCORENumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station_Number", &a->_ns1__SnLnkOutSN::Station_USCORENumber, "xsd:string"))
				{	soap_flag_Station_USCORENumber1--;
					continue;
				}
			}
			if (soap_flag_LnkType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LnkType", &a->_ns1__SnLnkOutSN::LnkType, "xsd:string"))
				{	soap_flag_LnkType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SnLnkOutSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnLnkOutSN, SOAP_TYPE__ns1__SnLnkOutSN, sizeof(_ns1__SnLnkOutSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnLnkOutSN * SOAP_FMAC2 soap_instantiate__ns1__SnLnkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnLnkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnLnkOutSN *p;
	size_t k = sizeof(_ns1__SnLnkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnLnkOutSN);
		if (p)
			((_ns1__SnLnkOutSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnLnkOutSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnLnkOutSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnLnkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnLnkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnLnkOutSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SnLnkOutSN(soap, tag ? tag : "ns1:SnLnkOutSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnLnkOutSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnLnkOutSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnLnkOutSN * SOAP_FMAC4 soap_get__ns1__SnLnkOutSN(struct soap *soap, _ns1__SnLnkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnLnkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoBaseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMoBaseResponse::getMoBaseResult = NULL;
	/* transient soap skipped */
}

void _ns1__getMoBaseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoBaseResponse::getMoBaseResult);
#endif
}

int _ns1__getMoBaseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoBaseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoBaseResponse(struct soap *soap, const char *tag, int id, const _ns1__getMoBaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoBaseResponse), type))
		return soap->error;
	if (a->getMoBaseResult)
		soap_element_result(soap, "ns1:getMoBaseResult");
	if (soap_out_PointerTostd__string(soap, "ns1:getMoBaseResult", -1, &a->_ns1__getMoBaseResponse::getMoBaseResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoBaseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoBaseResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoBaseResponse * SOAP_FMAC4 soap_in__ns1__getMoBaseResponse(struct soap *soap, const char *tag, _ns1__getMoBaseResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoBaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoBaseResponse, sizeof(_ns1__getMoBaseResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoBaseResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoBaseResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getMoBaseResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getMoBaseResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:getMoBaseResult", &a->_ns1__getMoBaseResponse::getMoBaseResult, "xsd:string"))
				{	soap_flag_getMoBaseResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getMoBaseResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoBaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoBaseResponse, SOAP_TYPE__ns1__getMoBaseResponse, sizeof(_ns1__getMoBaseResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoBaseResponse * SOAP_FMAC2 soap_instantiate__ns1__getMoBaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoBaseResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoBaseResponse *p;
	size_t k = sizeof(_ns1__getMoBaseResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoBaseResponse);
		if (p)
			((_ns1__getMoBaseResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoBaseResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMoBaseResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoBaseResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoBaseResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoBaseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoBaseResponse(soap, tag ? tag : "ns1:getMoBaseResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoBaseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoBaseResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoBaseResponse * SOAP_FMAC4 soap_get__ns1__getMoBaseResponse(struct soap *soap, _ns1__getMoBaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoBaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMoBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMoBase::MoNumber = NULL;
	/* transient soap skipped */
}

void _ns1__getMoBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMoBase::MoNumber);
#endif
}

int _ns1__getMoBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMoBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMoBase(struct soap *soap, const char *tag, int id, const _ns1__getMoBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMoBase), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__getMoBase::MoNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMoBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMoBase(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMoBase * SOAP_FMAC4 soap_in__ns1__getMoBase(struct soap *soap, const char *tag, _ns1__getMoBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMoBase, sizeof(_ns1__getMoBase), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMoBase)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMoBase *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__getMoBase::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getMoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMoBase, SOAP_TYPE__ns1__getMoBase, sizeof(_ns1__getMoBase), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMoBase * SOAP_FMAC2 soap_instantiate__ns1__getMoBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMoBase(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMoBase *p;
	size_t k = sizeof(_ns1__getMoBase);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMoBase);
		if (p)
			((_ns1__getMoBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMoBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMoBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMoBase location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMoBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMoBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getMoBase(soap, tag ? tag : "ns1:getMoBase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMoBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMoBase(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMoBase * SOAP_FMAC4 soap_get__ns1__getMoBase(struct soap *soap, _ns1__getMoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetNgCodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetNgCodeResponse::GetNgCodeResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetNgCodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetNgCodeResponse::GetNgCodeResult);
#endif
}

int _ns1__GetNgCodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNgCodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNgCodeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetNgCodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNgCodeResponse), type))
		return soap->error;
	if (a->GetNgCodeResult)
		soap_element_result(soap, "ns1:GetNgCodeResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetNgCodeResult", -1, &a->_ns1__GetNgCodeResponse::GetNgCodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNgCodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNgCodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNgCodeResponse * SOAP_FMAC4 soap_in__ns1__GetNgCodeResponse(struct soap *soap, const char *tag, _ns1__GetNgCodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNgCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNgCodeResponse, sizeof(_ns1__GetNgCodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetNgCodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetNgCodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNgCodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNgCodeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetNgCodeResult", &a->_ns1__GetNgCodeResponse::GetNgCodeResult, "xsd:string"))
				{	soap_flag_GetNgCodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetNgCodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNgCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNgCodeResponse, SOAP_TYPE__ns1__GetNgCodeResponse, sizeof(_ns1__GetNgCodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetNgCodeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNgCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNgCodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetNgCodeResponse *p;
	size_t k = sizeof(_ns1__GetNgCodeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetNgCodeResponse);
		if (p)
			((_ns1__GetNgCodeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetNgCodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetNgCodeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetNgCodeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetNgCodeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetNgCodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetNgCodeResponse(soap, tag ? tag : "ns1:GetNgCodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNgCodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNgCodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNgCodeResponse * SOAP_FMAC4 soap_get__ns1__GetNgCodeResponse(struct soap *soap, _ns1__GetNgCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNgCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetNgCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetNgCode::NgCode = NULL;
	/* transient soap skipped */
}

void _ns1__GetNgCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetNgCode::NgCode);
#endif
}

int _ns1__GetNgCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNgCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNgCode(struct soap *soap, const char *tag, int id, const _ns1__GetNgCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNgCode), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:NgCode", -1, &a->_ns1__GetNgCode::NgCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNgCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNgCode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNgCode * SOAP_FMAC4 soap_in__ns1__GetNgCode(struct soap *soap, const char *tag, _ns1__GetNgCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNgCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNgCode, sizeof(_ns1__GetNgCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetNgCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetNgCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NgCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NgCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:NgCode", &a->_ns1__GetNgCode::NgCode, "xsd:string"))
				{	soap_flag_NgCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNgCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNgCode, SOAP_TYPE__ns1__GetNgCode, sizeof(_ns1__GetNgCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetNgCode * SOAP_FMAC2 soap_instantiate__ns1__GetNgCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNgCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetNgCode *p;
	size_t k = sizeof(_ns1__GetNgCode);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetNgCode);
		if (p)
			((_ns1__GetNgCode*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetNgCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetNgCode*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetNgCode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetNgCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetNgCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetNgCode(soap, tag ? tag : "ns1:GetNgCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNgCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNgCode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNgCode * SOAP_FMAC4 soap_get__ns1__GetNgCode(struct soap *soap, _ns1__GetNgCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNgCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetDiecastSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetDiecastSNResponse::SetDiecastSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetDiecastSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetDiecastSNResponse::SetDiecastSNResult);
#endif
}

int _ns1__SetDiecastSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetDiecastSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetDiecastSNResponse(struct soap *soap, const char *tag, int id, const _ns1__SetDiecastSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetDiecastSNResponse), type))
		return soap->error;
	if (a->SetDiecastSNResult)
		soap_element_result(soap, "ns1:SetDiecastSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SetDiecastSNResult", -1, &a->_ns1__SetDiecastSNResponse::SetDiecastSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetDiecastSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetDiecastSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetDiecastSNResponse * SOAP_FMAC4 soap_in__ns1__SetDiecastSNResponse(struct soap *soap, const char *tag, _ns1__SetDiecastSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetDiecastSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetDiecastSNResponse, sizeof(_ns1__SetDiecastSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetDiecastSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetDiecastSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetDiecastSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetDiecastSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SetDiecastSNResult", &a->_ns1__SetDiecastSNResponse::SetDiecastSNResult, "xsd:string"))
				{	soap_flag_SetDiecastSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetDiecastSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetDiecastSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetDiecastSNResponse, SOAP_TYPE__ns1__SetDiecastSNResponse, sizeof(_ns1__SetDiecastSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetDiecastSNResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDiecastSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetDiecastSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetDiecastSNResponse *p;
	size_t k = sizeof(_ns1__SetDiecastSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetDiecastSNResponse);
		if (p)
			((_ns1__SetDiecastSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetDiecastSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetDiecastSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetDiecastSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetDiecastSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetDiecastSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetDiecastSNResponse(soap, tag ? tag : "ns1:SetDiecastSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetDiecastSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetDiecastSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetDiecastSNResponse * SOAP_FMAC4 soap_get__ns1__SetDiecastSNResponse(struct soap *soap, _ns1__SetDiecastSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetDiecastSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetDiecastSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetDiecastSN::SN = NULL;
	this->_ns1__SetDiecastSN::StationNumber = NULL;
	this->_ns1__SetDiecastSN::strType = NULL;
	/* transient soap skipped */
}

void _ns1__SetDiecastSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetDiecastSN::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetDiecastSN::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetDiecastSN::strType);
#endif
}

int _ns1__SetDiecastSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetDiecastSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetDiecastSN(struct soap *soap, const char *tag, int id, const _ns1__SetDiecastSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetDiecastSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SetDiecastSN::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__SetDiecastSN::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strType", -1, &a->_ns1__SetDiecastSN::strType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetDiecastSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetDiecastSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetDiecastSN * SOAP_FMAC4 soap_in__ns1__SetDiecastSN(struct soap *soap, const char *tag, _ns1__SetDiecastSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetDiecastSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetDiecastSN, sizeof(_ns1__SetDiecastSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetDiecastSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetDiecastSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_strType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SetDiecastSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__SetDiecastSN::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strType", &a->_ns1__SetDiecastSN::strType, "xsd:string"))
				{	soap_flag_strType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetDiecastSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetDiecastSN, SOAP_TYPE__ns1__SetDiecastSN, sizeof(_ns1__SetDiecastSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetDiecastSN * SOAP_FMAC2 soap_instantiate__ns1__SetDiecastSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetDiecastSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetDiecastSN *p;
	size_t k = sizeof(_ns1__SetDiecastSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetDiecastSN);
		if (p)
			((_ns1__SetDiecastSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetDiecastSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetDiecastSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetDiecastSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetDiecastSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetDiecastSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetDiecastSN(soap, tag ? tag : "ns1:SetDiecastSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetDiecastSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetDiecastSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetDiecastSN * SOAP_FMAC4 soap_get__ns1__SetDiecastSN(struct soap *soap, _ns1__SetDiecastSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetDiecastSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMachineForGroupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMachineForGroupResponse::GetMachineForGroupResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetMachineForGroupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, &this->_ns1__GetMachineForGroupResponse::GetMachineForGroupResult);
#endif
}

int _ns1__GetMachineForGroupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMachineForGroupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMachineForGroupResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMachineForGroupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMachineForGroupResponse), type))
		return soap->error;
	if (a->GetMachineForGroupResult)
		soap_element_result(soap, "ns1:GetMachineForGroupResult");
	if (soap_out_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, "ns1:GetMachineForGroupResult", -1, &a->_ns1__GetMachineForGroupResponse::GetMachineForGroupResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMachineForGroupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMachineForGroupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMachineForGroupResponse * SOAP_FMAC4 soap_in__ns1__GetMachineForGroupResponse(struct soap *soap, const char *tag, _ns1__GetMachineForGroupResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMachineForGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMachineForGroupResponse, sizeof(_ns1__GetMachineForGroupResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMachineForGroupResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMachineForGroupResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMachineForGroupResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMachineForGroupResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, "ns1:GetMachineForGroupResult", &a->_ns1__GetMachineForGroupResponse::GetMachineForGroupResult, ""))
				{	soap_flag_GetMachineForGroupResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMachineForGroupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMachineForGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMachineForGroupResponse, SOAP_TYPE__ns1__GetMachineForGroupResponse, sizeof(_ns1__GetMachineForGroupResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMachineForGroupResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMachineForGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMachineForGroupResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMachineForGroupResponse *p;
	size_t k = sizeof(_ns1__GetMachineForGroupResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetMachineForGroupResponse);
		if (p)
			((_ns1__GetMachineForGroupResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetMachineForGroupResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetMachineForGroupResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMachineForGroupResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetMachineForGroupResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetMachineForGroupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMachineForGroupResponse(soap, tag ? tag : "ns1:GetMachineForGroupResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMachineForGroupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMachineForGroupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMachineForGroupResponse * SOAP_FMAC4 soap_get__ns1__GetMachineForGroupResponse(struct soap *soap, _ns1__GetMachineForGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMachineForGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMachineForGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMachineForGroup::StationNumber = NULL;
	this->_ns1__GetMachineForGroup::PmcNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetMachineForGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetMachineForGroup::StationNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetMachineForGroup::PmcNo);
#endif
}

int _ns1__GetMachineForGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMachineForGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMachineForGroup(struct soap *soap, const char *tag, int id, const _ns1__GetMachineForGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMachineForGroup), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StationNumber", -1, &a->_ns1__GetMachineForGroup::StationNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PmcNo", -1, &a->_ns1__GetMachineForGroup::PmcNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMachineForGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMachineForGroup(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMachineForGroup * SOAP_FMAC4 soap_in__ns1__GetMachineForGroup(struct soap *soap, const char *tag, _ns1__GetMachineForGroup *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMachineForGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMachineForGroup, sizeof(_ns1__GetMachineForGroup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMachineForGroup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMachineForGroup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StationNumber1 = 1;
	size_t soap_flag_PmcNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StationNumber", &a->_ns1__GetMachineForGroup::StationNumber, "xsd:string"))
				{	soap_flag_StationNumber1--;
					continue;
				}
			}
			if (soap_flag_PmcNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PmcNo", &a->_ns1__GetMachineForGroup::PmcNo, "xsd:string"))
				{	soap_flag_PmcNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMachineForGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMachineForGroup, SOAP_TYPE__ns1__GetMachineForGroup, sizeof(_ns1__GetMachineForGroup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMachineForGroup * SOAP_FMAC2 soap_instantiate__ns1__GetMachineForGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMachineForGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMachineForGroup *p;
	size_t k = sizeof(_ns1__GetMachineForGroup);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetMachineForGroup);
		if (p)
			((_ns1__GetMachineForGroup*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetMachineForGroup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetMachineForGroup*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMachineForGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetMachineForGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetMachineForGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMachineForGroup(soap, tag ? tag : "ns1:GetMachineForGroup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMachineForGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMachineForGroup(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMachineForGroup * SOAP_FMAC4 soap_get__ns1__GetMachineForGroup(struct soap *soap, _ns1__GetMachineForGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMachineForGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UploadForHPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadForHPResponse::UploadForHPResult = NULL;
	/* transient soap skipped */
}

void _ns1__UploadForHPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHPResponse::UploadForHPResult);
#endif
}

int _ns1__UploadForHPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadForHPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadForHPResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadForHPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadForHPResponse), type))
		return soap->error;
	if (a->UploadForHPResult)
		soap_element_result(soap, "ns1:UploadForHPResult");
	if (soap_out_PointerTostd__string(soap, "ns1:UploadForHPResult", -1, &a->_ns1__UploadForHPResponse::UploadForHPResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadForHPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadForHPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadForHPResponse * SOAP_FMAC4 soap_in__ns1__UploadForHPResponse(struct soap *soap, const char *tag, _ns1__UploadForHPResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadForHPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadForHPResponse, sizeof(_ns1__UploadForHPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UploadForHPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UploadForHPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadForHPResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadForHPResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UploadForHPResult", &a->_ns1__UploadForHPResponse::UploadForHPResult, "xsd:string"))
				{	soap_flag_UploadForHPResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UploadForHPResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadForHPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadForHPResponse, SOAP_TYPE__ns1__UploadForHPResponse, sizeof(_ns1__UploadForHPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UploadForHPResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadForHPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadForHPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UploadForHPResponse *p;
	size_t k = sizeof(_ns1__UploadForHPResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UploadForHPResponse);
		if (p)
			((_ns1__UploadForHPResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UploadForHPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UploadForHPResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UploadForHPResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UploadForHPResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UploadForHPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UploadForHPResponse(soap, tag ? tag : "ns1:UploadForHPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadForHPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadForHPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadForHPResponse * SOAP_FMAC4 soap_get__ns1__UploadForHPResponse(struct soap *soap, _ns1__UploadForHPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadForHPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UploadForHP::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadForHP::DT = NULL;
	this->_ns1__UploadForHP::ItemNo = NULL;
	this->_ns1__UploadForHP::PartNo = NULL;
	this->_ns1__UploadForHP::Qty = NULL;
	this->_ns1__UploadForHP::NgQty = NULL;
	this->_ns1__UploadForHP::StopDT = NULL;
	this->_ns1__UploadForHP::NgDesc = NULL;
	/* transient soap skipped */
}

void _ns1__UploadForHP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::DT);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::ItemNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::PartNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::Qty);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::NgQty);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::StopDT);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadForHP::NgDesc);
#endif
}

int _ns1__UploadForHP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadForHP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadForHP(struct soap *soap, const char *tag, int id, const _ns1__UploadForHP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadForHP), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DT", -1, &a->_ns1__UploadForHP::DT, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ItemNo", -1, &a->_ns1__UploadForHP::ItemNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PartNo", -1, &a->_ns1__UploadForHP::PartNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Qty", -1, &a->_ns1__UploadForHP::Qty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:NgQty", -1, &a->_ns1__UploadForHP::NgQty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StopDT", -1, &a->_ns1__UploadForHP::StopDT, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:NgDesc", -1, &a->_ns1__UploadForHP::NgDesc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadForHP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadForHP(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadForHP * SOAP_FMAC4 soap_in__ns1__UploadForHP(struct soap *soap, const char *tag, _ns1__UploadForHP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadForHP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadForHP, sizeof(_ns1__UploadForHP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UploadForHP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UploadForHP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DT1 = 1;
	size_t soap_flag_ItemNo1 = 1;
	size_t soap_flag_PartNo1 = 1;
	size_t soap_flag_Qty1 = 1;
	size_t soap_flag_NgQty1 = 1;
	size_t soap_flag_StopDT1 = 1;
	size_t soap_flag_NgDesc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DT1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DT", &a->_ns1__UploadForHP::DT, "xsd:string"))
				{	soap_flag_DT1--;
					continue;
				}
			}
			if (soap_flag_ItemNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ItemNo", &a->_ns1__UploadForHP::ItemNo, "xsd:string"))
				{	soap_flag_ItemNo1--;
					continue;
				}
			}
			if (soap_flag_PartNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PartNo", &a->_ns1__UploadForHP::PartNo, "xsd:string"))
				{	soap_flag_PartNo1--;
					continue;
				}
			}
			if (soap_flag_Qty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Qty", &a->_ns1__UploadForHP::Qty, "xsd:string"))
				{	soap_flag_Qty1--;
					continue;
				}
			}
			if (soap_flag_NgQty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:NgQty", &a->_ns1__UploadForHP::NgQty, "xsd:string"))
				{	soap_flag_NgQty1--;
					continue;
				}
			}
			if (soap_flag_StopDT1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StopDT", &a->_ns1__UploadForHP::StopDT, "xsd:string"))
				{	soap_flag_StopDT1--;
					continue;
				}
			}
			if (soap_flag_NgDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:NgDesc", &a->_ns1__UploadForHP::NgDesc, "xsd:string"))
				{	soap_flag_NgDesc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadForHP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadForHP, SOAP_TYPE__ns1__UploadForHP, sizeof(_ns1__UploadForHP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UploadForHP * SOAP_FMAC2 soap_instantiate__ns1__UploadForHP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadForHP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UploadForHP *p;
	size_t k = sizeof(_ns1__UploadForHP);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UploadForHP);
		if (p)
			((_ns1__UploadForHP*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UploadForHP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UploadForHP*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UploadForHP location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UploadForHP, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UploadForHP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UploadForHP(soap, tag ? tag : "ns1:UploadForHP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadForHP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadForHP(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadForHP * SOAP_FMAC4 soap_get__ns1__UploadForHP(struct soap *soap, _ns1__UploadForHP *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadForHP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelShelfLinkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SelShelfLinkResponse::SelShelfLinkResult = NULL;
	/* transient soap skipped */
}

void _ns1__SelShelfLinkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SelShelfLinkResponse::SelShelfLinkResult);
#endif
}

int _ns1__SelShelfLinkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelShelfLinkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelShelfLinkResponse(struct soap *soap, const char *tag, int id, const _ns1__SelShelfLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelShelfLinkResponse), type))
		return soap->error;
	if (a->SelShelfLinkResult)
		soap_element_result(soap, "ns1:SelShelfLinkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SelShelfLinkResult", -1, &a->_ns1__SelShelfLinkResponse::SelShelfLinkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelShelfLinkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelShelfLinkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelShelfLinkResponse * SOAP_FMAC4 soap_in__ns1__SelShelfLinkResponse(struct soap *soap, const char *tag, _ns1__SelShelfLinkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelShelfLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelShelfLinkResponse, sizeof(_ns1__SelShelfLinkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelShelfLinkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelShelfLinkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelShelfLinkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelShelfLinkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SelShelfLinkResult", &a->_ns1__SelShelfLinkResponse::SelShelfLinkResult, "xsd:string"))
				{	soap_flag_SelShelfLinkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SelShelfLinkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelShelfLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelShelfLinkResponse, SOAP_TYPE__ns1__SelShelfLinkResponse, sizeof(_ns1__SelShelfLinkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelShelfLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__SelShelfLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelShelfLinkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelShelfLinkResponse *p;
	size_t k = sizeof(_ns1__SelShelfLinkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SelShelfLinkResponse);
		if (p)
			((_ns1__SelShelfLinkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SelShelfLinkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SelShelfLinkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelShelfLinkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SelShelfLinkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SelShelfLinkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelShelfLinkResponse(soap, tag ? tag : "ns1:SelShelfLinkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelShelfLinkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelShelfLinkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelShelfLinkResponse * SOAP_FMAC4 soap_get__ns1__SelShelfLinkResponse(struct soap *soap, _ns1__SelShelfLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelShelfLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelShelfLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SelShelfLink::ShelfSN = NULL;
	/* transient soap skipped */
}

void _ns1__SelShelfLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SelShelfLink::ShelfSN);
#endif
}

int _ns1__SelShelfLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelShelfLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelShelfLink(struct soap *soap, const char *tag, int id, const _ns1__SelShelfLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelShelfLink), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ShelfSN", -1, &a->_ns1__SelShelfLink::ShelfSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelShelfLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelShelfLink(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelShelfLink * SOAP_FMAC4 soap_in__ns1__SelShelfLink(struct soap *soap, const char *tag, _ns1__SelShelfLink *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelShelfLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelShelfLink, sizeof(_ns1__SelShelfLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelShelfLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelShelfLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ShelfSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShelfSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ShelfSN", &a->_ns1__SelShelfLink::ShelfSN, "xsd:string"))
				{	soap_flag_ShelfSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelShelfLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelShelfLink, SOAP_TYPE__ns1__SelShelfLink, sizeof(_ns1__SelShelfLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelShelfLink * SOAP_FMAC2 soap_instantiate__ns1__SelShelfLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelShelfLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelShelfLink *p;
	size_t k = sizeof(_ns1__SelShelfLink);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SelShelfLink);
		if (p)
			((_ns1__SelShelfLink*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SelShelfLink, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SelShelfLink*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelShelfLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SelShelfLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SelShelfLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelShelfLink(soap, tag ? tag : "ns1:SelShelfLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelShelfLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelShelfLink(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelShelfLink * SOAP_FMAC4 soap_get__ns1__SelShelfLink(struct soap *soap, _ns1__SelShelfLink *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelShelfLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SNLinkShelfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SNLinkShelfResponse::SNLinkShelfResult = NULL;
	/* transient soap skipped */
}

void _ns1__SNLinkShelfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkShelfResponse::SNLinkShelfResult);
#endif
}

int _ns1__SNLinkShelfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SNLinkShelfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SNLinkShelfResponse(struct soap *soap, const char *tag, int id, const _ns1__SNLinkShelfResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SNLinkShelfResponse), type))
		return soap->error;
	if (a->SNLinkShelfResult)
		soap_element_result(soap, "ns1:SNLinkShelfResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SNLinkShelfResult", -1, &a->_ns1__SNLinkShelfResponse::SNLinkShelfResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SNLinkShelfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SNLinkShelfResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SNLinkShelfResponse * SOAP_FMAC4 soap_in__ns1__SNLinkShelfResponse(struct soap *soap, const char *tag, _ns1__SNLinkShelfResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SNLinkShelfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SNLinkShelfResponse, sizeof(_ns1__SNLinkShelfResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SNLinkShelfResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SNLinkShelfResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SNLinkShelfResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SNLinkShelfResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SNLinkShelfResult", &a->_ns1__SNLinkShelfResponse::SNLinkShelfResult, "xsd:string"))
				{	soap_flag_SNLinkShelfResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SNLinkShelfResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SNLinkShelfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SNLinkShelfResponse, SOAP_TYPE__ns1__SNLinkShelfResponse, sizeof(_ns1__SNLinkShelfResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SNLinkShelfResponse * SOAP_FMAC2 soap_instantiate__ns1__SNLinkShelfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SNLinkShelfResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SNLinkShelfResponse *p;
	size_t k = sizeof(_ns1__SNLinkShelfResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SNLinkShelfResponse);
		if (p)
			((_ns1__SNLinkShelfResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SNLinkShelfResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SNLinkShelfResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SNLinkShelfResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SNLinkShelfResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SNLinkShelfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SNLinkShelfResponse(soap, tag ? tag : "ns1:SNLinkShelfResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SNLinkShelfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SNLinkShelfResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SNLinkShelfResponse * SOAP_FMAC4 soap_get__ns1__SNLinkShelfResponse(struct soap *soap, _ns1__SNLinkShelfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SNLinkShelfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SNLinkShelf::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SNLinkShelf::SN = NULL;
	this->_ns1__SNLinkShelf::ShelfSN = NULL;
	this->_ns1__SNLinkShelf::strUser = NULL;
	/* transient soap skipped */
}

void _ns1__SNLinkShelf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkShelf::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkShelf::ShelfSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SNLinkShelf::strUser);
#endif
}

int _ns1__SNLinkShelf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SNLinkShelf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SNLinkShelf(struct soap *soap, const char *tag, int id, const _ns1__SNLinkShelf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SNLinkShelf), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SNLinkShelf::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ShelfSN", -1, &a->_ns1__SNLinkShelf::ShelfSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__SNLinkShelf::strUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SNLinkShelf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SNLinkShelf(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SNLinkShelf * SOAP_FMAC4 soap_in__ns1__SNLinkShelf(struct soap *soap, const char *tag, _ns1__SNLinkShelf *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SNLinkShelf *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SNLinkShelf, sizeof(_ns1__SNLinkShelf), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SNLinkShelf)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SNLinkShelf *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_ShelfSN1 = 1;
	size_t soap_flag_strUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SNLinkShelf::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_ShelfSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ShelfSN", &a->_ns1__SNLinkShelf::ShelfSN, "xsd:string"))
				{	soap_flag_ShelfSN1--;
					continue;
				}
			}
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__SNLinkShelf::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SNLinkShelf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SNLinkShelf, SOAP_TYPE__ns1__SNLinkShelf, sizeof(_ns1__SNLinkShelf), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SNLinkShelf * SOAP_FMAC2 soap_instantiate__ns1__SNLinkShelf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SNLinkShelf(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SNLinkShelf *p;
	size_t k = sizeof(_ns1__SNLinkShelf);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SNLinkShelf);
		if (p)
			((_ns1__SNLinkShelf*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SNLinkShelf, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SNLinkShelf*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SNLinkShelf location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SNLinkShelf, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SNLinkShelf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SNLinkShelf(soap, tag ? tag : "ns1:SNLinkShelf", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SNLinkShelf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SNLinkShelf(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SNLinkShelf * SOAP_FMAC4 soap_get__ns1__SNLinkShelf(struct soap *soap, _ns1__SNLinkShelf *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SNLinkShelf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelSNTestForFruitResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SelSNTestForFruitResponse::SelSNTestForFruitResult = NULL;
	/* transient soap skipped */
}

void _ns1__SelSNTestForFruitResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SelSNTestForFruitResponse::SelSNTestForFruitResult);
#endif
}

int _ns1__SelSNTestForFruitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelSNTestForFruitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelSNTestForFruitResponse(struct soap *soap, const char *tag, int id, const _ns1__SelSNTestForFruitResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelSNTestForFruitResponse), type))
		return soap->error;
	if (a->SelSNTestForFruitResult)
		soap_element_result(soap, "ns1:SelSNTestForFruitResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SelSNTestForFruitResult", -1, &a->_ns1__SelSNTestForFruitResponse::SelSNTestForFruitResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelSNTestForFruitResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelSNTestForFruitResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelSNTestForFruitResponse * SOAP_FMAC4 soap_in__ns1__SelSNTestForFruitResponse(struct soap *soap, const char *tag, _ns1__SelSNTestForFruitResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelSNTestForFruitResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelSNTestForFruitResponse, sizeof(_ns1__SelSNTestForFruitResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelSNTestForFruitResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelSNTestForFruitResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelSNTestForFruitResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelSNTestForFruitResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SelSNTestForFruitResult", &a->_ns1__SelSNTestForFruitResponse::SelSNTestForFruitResult, "xsd:string"))
				{	soap_flag_SelSNTestForFruitResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SelSNTestForFruitResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelSNTestForFruitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelSNTestForFruitResponse, SOAP_TYPE__ns1__SelSNTestForFruitResponse, sizeof(_ns1__SelSNTestForFruitResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelSNTestForFruitResponse * SOAP_FMAC2 soap_instantiate__ns1__SelSNTestForFruitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelSNTestForFruitResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelSNTestForFruitResponse *p;
	size_t k = sizeof(_ns1__SelSNTestForFruitResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SelSNTestForFruitResponse);
		if (p)
			((_ns1__SelSNTestForFruitResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SelSNTestForFruitResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SelSNTestForFruitResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelSNTestForFruitResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SelSNTestForFruitResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SelSNTestForFruitResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelSNTestForFruitResponse(soap, tag ? tag : "ns1:SelSNTestForFruitResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelSNTestForFruitResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelSNTestForFruitResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelSNTestForFruitResponse * SOAP_FMAC4 soap_get__ns1__SelSNTestForFruitResponse(struct soap *soap, _ns1__SelSNTestForFruitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelSNTestForFruitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelSNTestForFruit::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SelSNTestForFruit::SN = NULL;
	/* transient soap skipped */
}

void _ns1__SelSNTestForFruit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SelSNTestForFruit::SN);
#endif
}

int _ns1__SelSNTestForFruit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelSNTestForFruit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelSNTestForFruit(struct soap *soap, const char *tag, int id, const _ns1__SelSNTestForFruit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelSNTestForFruit), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SelSNTestForFruit::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelSNTestForFruit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelSNTestForFruit(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelSNTestForFruit * SOAP_FMAC4 soap_in__ns1__SelSNTestForFruit(struct soap *soap, const char *tag, _ns1__SelSNTestForFruit *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelSNTestForFruit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelSNTestForFruit, sizeof(_ns1__SelSNTestForFruit), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelSNTestForFruit)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelSNTestForFruit *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SelSNTestForFruit::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelSNTestForFruit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelSNTestForFruit, SOAP_TYPE__ns1__SelSNTestForFruit, sizeof(_ns1__SelSNTestForFruit), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelSNTestForFruit * SOAP_FMAC2 soap_instantiate__ns1__SelSNTestForFruit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelSNTestForFruit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelSNTestForFruit *p;
	size_t k = sizeof(_ns1__SelSNTestForFruit);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SelSNTestForFruit);
		if (p)
			((_ns1__SelSNTestForFruit*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SelSNTestForFruit, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SelSNTestForFruit*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelSNTestForFruit location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SelSNTestForFruit, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SelSNTestForFruit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelSNTestForFruit(soap, tag ? tag : "ns1:SelSNTestForFruit", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelSNTestForFruit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelSNTestForFruit(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelSNTestForFruit * SOAP_FMAC4 soap_get__ns1__SelSNTestForFruit(struct soap *soap, _ns1__SelSNTestForFruit *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelSNTestForFruit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsSNTestForFruitResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsSNTestForFruitResponse::InsSNTestForFruitResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsSNTestForFruitResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTestForFruitResponse::InsSNTestForFruitResult);
#endif
}

int _ns1__InsSNTestForFruitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsSNTestForFruitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsSNTestForFruitResponse(struct soap *soap, const char *tag, int id, const _ns1__InsSNTestForFruitResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsSNTestForFruitResponse), type))
		return soap->error;
	if (a->InsSNTestForFruitResult)
		soap_element_result(soap, "ns1:InsSNTestForFruitResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsSNTestForFruitResult", -1, &a->_ns1__InsSNTestForFruitResponse::InsSNTestForFruitResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsSNTestForFruitResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsSNTestForFruitResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsSNTestForFruitResponse * SOAP_FMAC4 soap_in__ns1__InsSNTestForFruitResponse(struct soap *soap, const char *tag, _ns1__InsSNTestForFruitResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsSNTestForFruitResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsSNTestForFruitResponse, sizeof(_ns1__InsSNTestForFruitResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsSNTestForFruitResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsSNTestForFruitResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsSNTestForFruitResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsSNTestForFruitResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsSNTestForFruitResult", &a->_ns1__InsSNTestForFruitResponse::InsSNTestForFruitResult, "xsd:string"))
				{	soap_flag_InsSNTestForFruitResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsSNTestForFruitResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsSNTestForFruitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsSNTestForFruitResponse, SOAP_TYPE__ns1__InsSNTestForFruitResponse, sizeof(_ns1__InsSNTestForFruitResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsSNTestForFruitResponse * SOAP_FMAC2 soap_instantiate__ns1__InsSNTestForFruitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsSNTestForFruitResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsSNTestForFruitResponse *p;
	size_t k = sizeof(_ns1__InsSNTestForFruitResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsSNTestForFruitResponse);
		if (p)
			((_ns1__InsSNTestForFruitResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsSNTestForFruitResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsSNTestForFruitResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsSNTestForFruitResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsSNTestForFruitResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsSNTestForFruitResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsSNTestForFruitResponse(soap, tag ? tag : "ns1:InsSNTestForFruitResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsSNTestForFruitResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsSNTestForFruitResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsSNTestForFruitResponse * SOAP_FMAC4 soap_get__ns1__InsSNTestForFruitResponse(struct soap *soap, _ns1__InsSNTestForFruitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsSNTestForFruitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsSNTestForFruit::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsSNTestForFruit::SN = NULL;
	this->_ns1__InsSNTestForFruit::Machine = NULL;
	this->_ns1__InsSNTestForFruit::SiteId = NULL;
	this->_ns1__InsSNTestForFruit::TestResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsSNTestForFruit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTestForFruit::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTestForFruit::Machine);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTestForFruit::SiteId);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTestForFruit::TestResult);
#endif
}

int _ns1__InsSNTestForFruit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsSNTestForFruit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsSNTestForFruit(struct soap *soap, const char *tag, int id, const _ns1__InsSNTestForFruit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsSNTestForFruit), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsSNTestForFruit::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Machine", -1, &a->_ns1__InsSNTestForFruit::Machine, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SiteId", -1, &a->_ns1__InsSNTestForFruit::SiteId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestResult", -1, &a->_ns1__InsSNTestForFruit::TestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsSNTestForFruit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsSNTestForFruit(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsSNTestForFruit * SOAP_FMAC4 soap_in__ns1__InsSNTestForFruit(struct soap *soap, const char *tag, _ns1__InsSNTestForFruit *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsSNTestForFruit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsSNTestForFruit, sizeof(_ns1__InsSNTestForFruit), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsSNTestForFruit)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsSNTestForFruit *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Machine1 = 1;
	size_t soap_flag_SiteId1 = 1;
	size_t soap_flag_TestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsSNTestForFruit::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Machine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Machine", &a->_ns1__InsSNTestForFruit::Machine, "xsd:string"))
				{	soap_flag_Machine1--;
					continue;
				}
			}
			if (soap_flag_SiteId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SiteId", &a->_ns1__InsSNTestForFruit::SiteId, "xsd:string"))
				{	soap_flag_SiteId1--;
					continue;
				}
			}
			if (soap_flag_TestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestResult", &a->_ns1__InsSNTestForFruit::TestResult, "xsd:string"))
				{	soap_flag_TestResult1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsSNTestForFruit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsSNTestForFruit, SOAP_TYPE__ns1__InsSNTestForFruit, sizeof(_ns1__InsSNTestForFruit), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsSNTestForFruit * SOAP_FMAC2 soap_instantiate__ns1__InsSNTestForFruit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsSNTestForFruit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsSNTestForFruit *p;
	size_t k = sizeof(_ns1__InsSNTestForFruit);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsSNTestForFruit);
		if (p)
			((_ns1__InsSNTestForFruit*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsSNTestForFruit, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsSNTestForFruit*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsSNTestForFruit location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsSNTestForFruit, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsSNTestForFruit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsSNTestForFruit(soap, tag ? tag : "ns1:InsSNTestForFruit", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsSNTestForFruit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsSNTestForFruit(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsSNTestForFruit * SOAP_FMAC4 soap_get__ns1__InsSNTestForFruit(struct soap *soap, _ns1__InsSNTestForFruit *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsSNTestForFruit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStationNumberForSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStationNumberForSNResponse::GetStationNumberForSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetStationNumberForSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetStationNumberForSNResponse::GetStationNumberForSNResult);
#endif
}

int _ns1__GetStationNumberForSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStationNumberForSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStationNumberForSNResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStationNumberForSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStationNumberForSNResponse), type))
		return soap->error;
	if (a->GetStationNumberForSNResult)
		soap_element_result(soap, "ns1:GetStationNumberForSNResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetStationNumberForSNResult", -1, &a->_ns1__GetStationNumberForSNResponse::GetStationNumberForSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStationNumberForSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStationNumberForSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStationNumberForSNResponse * SOAP_FMAC4 soap_in__ns1__GetStationNumberForSNResponse(struct soap *soap, const char *tag, _ns1__GetStationNumberForSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStationNumberForSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStationNumberForSNResponse, sizeof(_ns1__GetStationNumberForSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetStationNumberForSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetStationNumberForSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetStationNumberForSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStationNumberForSNResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetStationNumberForSNResult", &a->_ns1__GetStationNumberForSNResponse::GetStationNumberForSNResult, "xsd:string"))
				{	soap_flag_GetStationNumberForSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetStationNumberForSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStationNumberForSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStationNumberForSNResponse, SOAP_TYPE__ns1__GetStationNumberForSNResponse, sizeof(_ns1__GetStationNumberForSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetStationNumberForSNResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStationNumberForSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStationNumberForSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetStationNumberForSNResponse *p;
	size_t k = sizeof(_ns1__GetStationNumberForSNResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetStationNumberForSNResponse);
		if (p)
			((_ns1__GetStationNumberForSNResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetStationNumberForSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetStationNumberForSNResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetStationNumberForSNResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetStationNumberForSNResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetStationNumberForSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetStationNumberForSNResponse(soap, tag ? tag : "ns1:GetStationNumberForSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStationNumberForSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStationNumberForSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStationNumberForSNResponse * SOAP_FMAC4 soap_get__ns1__GetStationNumberForSNResponse(struct soap *soap, _ns1__GetStationNumberForSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStationNumberForSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStationNumberForSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStationNumberForSN::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetStationNumberForSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetStationNumberForSN::SN);
#endif
}

int _ns1__GetStationNumberForSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStationNumberForSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStationNumberForSN(struct soap *soap, const char *tag, int id, const _ns1__GetStationNumberForSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStationNumberForSN), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetStationNumberForSN::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStationNumberForSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStationNumberForSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStationNumberForSN * SOAP_FMAC4 soap_in__ns1__GetStationNumberForSN(struct soap *soap, const char *tag, _ns1__GetStationNumberForSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStationNumberForSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStationNumberForSN, sizeof(_ns1__GetStationNumberForSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetStationNumberForSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetStationNumberForSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetStationNumberForSN::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStationNumberForSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStationNumberForSN, SOAP_TYPE__ns1__GetStationNumberForSN, sizeof(_ns1__GetStationNumberForSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetStationNumberForSN * SOAP_FMAC2 soap_instantiate__ns1__GetStationNumberForSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStationNumberForSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetStationNumberForSN *p;
	size_t k = sizeof(_ns1__GetStationNumberForSN);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetStationNumberForSN);
		if (p)
			((_ns1__GetStationNumberForSN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetStationNumberForSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetStationNumberForSN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetStationNumberForSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetStationNumberForSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetStationNumberForSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetStationNumberForSN(soap, tag ? tag : "ns1:GetStationNumberForSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStationNumberForSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStationNumberForSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStationNumberForSN * SOAP_FMAC4 soap_get__ns1__GetStationNumberForSN(struct soap *soap, _ns1__GetStationNumberForSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStationNumberForSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTestValueResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTestValueResultResponse::GetTestValueResultResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetTestValueResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetTestValueResultResponse::GetTestValueResultResult);
#endif
}

int _ns1__GetTestValueResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTestValueResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTestValueResultResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTestValueResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTestValueResultResponse), type))
		return soap->error;
	if (a->GetTestValueResultResult)
		soap_element_result(soap, "ns1:GetTestValueResultResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetTestValueResultResult", -1, &a->_ns1__GetTestValueResultResponse::GetTestValueResultResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTestValueResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTestValueResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTestValueResultResponse * SOAP_FMAC4 soap_in__ns1__GetTestValueResultResponse(struct soap *soap, const char *tag, _ns1__GetTestValueResultResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTestValueResultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTestValueResultResponse, sizeof(_ns1__GetTestValueResultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTestValueResultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTestValueResultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetTestValueResultResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTestValueResultResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetTestValueResultResult", &a->_ns1__GetTestValueResultResponse::GetTestValueResultResult, "xsd:string"))
				{	soap_flag_GetTestValueResultResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetTestValueResultResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTestValueResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTestValueResultResponse, SOAP_TYPE__ns1__GetTestValueResultResponse, sizeof(_ns1__GetTestValueResultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTestValueResultResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTestValueResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTestValueResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTestValueResultResponse *p;
	size_t k = sizeof(_ns1__GetTestValueResultResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetTestValueResultResponse);
		if (p)
			((_ns1__GetTestValueResultResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetTestValueResultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetTestValueResultResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTestValueResultResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetTestValueResultResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetTestValueResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTestValueResultResponse(soap, tag ? tag : "ns1:GetTestValueResultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTestValueResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTestValueResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTestValueResultResponse * SOAP_FMAC4 soap_get__ns1__GetTestValueResultResponse(struct soap *soap, _ns1__GetTestValueResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTestValueResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTestValueResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTestValueResult::SPC = NULL;
	this->_ns1__GetTestValueResult::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetTestValueResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetTestValueResult::SPC);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetTestValueResult::SN);
#endif
}

int _ns1__GetTestValueResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTestValueResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTestValueResult(struct soap *soap, const char *tag, int id, const _ns1__GetTestValueResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTestValueResult), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SPC", -1, &a->_ns1__GetTestValueResult::SPC, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetTestValueResult::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTestValueResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTestValueResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTestValueResult * SOAP_FMAC4 soap_in__ns1__GetTestValueResult(struct soap *soap, const char *tag, _ns1__GetTestValueResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTestValueResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTestValueResult, sizeof(_ns1__GetTestValueResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTestValueResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTestValueResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SPC1 = 1;
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SPC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SPC", &a->_ns1__GetTestValueResult::SPC, "xsd:string"))
				{	soap_flag_SPC1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetTestValueResult::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTestValueResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTestValueResult, SOAP_TYPE__ns1__GetTestValueResult, sizeof(_ns1__GetTestValueResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTestValueResult * SOAP_FMAC2 soap_instantiate__ns1__GetTestValueResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTestValueResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTestValueResult *p;
	size_t k = sizeof(_ns1__GetTestValueResult);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetTestValueResult);
		if (p)
			((_ns1__GetTestValueResult*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetTestValueResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetTestValueResult*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTestValueResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetTestValueResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetTestValueResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTestValueResult(soap, tag ? tag : "ns1:GetTestValueResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTestValueResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTestValueResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTestValueResult * SOAP_FMAC4 soap_get__ns1__GetTestValueResult(struct soap *soap, _ns1__GetTestValueResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTestValueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsCLScadaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsCLScadaResponse::InsCLScadaResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsCLScadaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScadaResponse::InsCLScadaResult);
#endif
}

int _ns1__InsCLScadaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsCLScadaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsCLScadaResponse(struct soap *soap, const char *tag, int id, const _ns1__InsCLScadaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsCLScadaResponse), type))
		return soap->error;
	if (a->InsCLScadaResult)
		soap_element_result(soap, "ns1:InsCLScadaResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsCLScadaResult", -1, &a->_ns1__InsCLScadaResponse::InsCLScadaResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsCLScadaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsCLScadaResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsCLScadaResponse * SOAP_FMAC4 soap_in__ns1__InsCLScadaResponse(struct soap *soap, const char *tag, _ns1__InsCLScadaResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsCLScadaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsCLScadaResponse, sizeof(_ns1__InsCLScadaResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsCLScadaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsCLScadaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsCLScadaResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsCLScadaResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsCLScadaResult", &a->_ns1__InsCLScadaResponse::InsCLScadaResult, "xsd:string"))
				{	soap_flag_InsCLScadaResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsCLScadaResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsCLScadaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsCLScadaResponse, SOAP_TYPE__ns1__InsCLScadaResponse, sizeof(_ns1__InsCLScadaResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsCLScadaResponse * SOAP_FMAC2 soap_instantiate__ns1__InsCLScadaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsCLScadaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsCLScadaResponse *p;
	size_t k = sizeof(_ns1__InsCLScadaResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsCLScadaResponse);
		if (p)
			((_ns1__InsCLScadaResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsCLScadaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsCLScadaResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsCLScadaResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsCLScadaResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsCLScadaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsCLScadaResponse(soap, tag ? tag : "ns1:InsCLScadaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsCLScadaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsCLScadaResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsCLScadaResponse * SOAP_FMAC4 soap_get__ns1__InsCLScadaResponse(struct soap *soap, _ns1__InsCLScadaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsCLScadaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsCLScada::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsCLScada::MachineNo = NULL;
	this->_ns1__InsCLScada::MachineStatus = NULL;
	this->_ns1__InsCLScada::MachineErr = NULL;
	this->_ns1__InsCLScada::VacuumBound = NULL;
	this->_ns1__InsCLScada::VacuumValue = NULL;
	this->_ns1__InsCLScada::TempBound = NULL;
	this->_ns1__InsCLScada::TempValue = NULL;
	this->_ns1__InsCLScada::PartSN = NULL;
	this->_ns1__InsCLScada::ShelfNo = NULL;
	this->_ns1__InsCLScada::ShelfSN = NULL;
	this->_ns1__InsCLScada::StartTime = NULL;
	this->_ns1__InsCLScada::EndTime = NULL;
	this->_ns1__InsCLScada::AgeTime = NULL;
	this->_ns1__InsCLScada::WaveBound = NULL;
	this->_ns1__InsCLScada::WaveValue = NULL;
	this->_ns1__InsCLScada::VoltBound = NULL;
	this->_ns1__InsCLScada::VoltValue = NULL;
	this->_ns1__InsCLScada::Ch1Value = NULL;
	this->_ns1__InsCLScada::Ch2Value = NULL;
	this->_ns1__InsCLScada::Ch3Value = NULL;
	this->_ns1__InsCLScada::Ch4Value = NULL;
	/* transient soap skipped */
}

void _ns1__InsCLScada::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::MachineNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::MachineStatus);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::MachineErr);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::VacuumBound);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::VacuumValue);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::TempBound);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::TempValue);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::PartSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::ShelfNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::ShelfSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::StartTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::EndTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::AgeTime);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::WaveBound);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::WaveValue);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::VoltBound);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::VoltValue);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::Ch1Value);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::Ch2Value);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::Ch3Value);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsCLScada::Ch4Value);
#endif
}

int _ns1__InsCLScada::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsCLScada(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsCLScada(struct soap *soap, const char *tag, int id, const _ns1__InsCLScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsCLScada), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MachineNo", -1, &a->_ns1__InsCLScada::MachineNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MachineStatus", -1, &a->_ns1__InsCLScada::MachineStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MachineErr", -1, &a->_ns1__InsCLScada::MachineErr, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VacuumBound", -1, &a->_ns1__InsCLScada::VacuumBound, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VacuumValue", -1, &a->_ns1__InsCLScada::VacuumValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TempBound", -1, &a->_ns1__InsCLScada::TempBound, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TempValue", -1, &a->_ns1__InsCLScada::TempValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PartSN", -1, &a->_ns1__InsCLScada::PartSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ShelfNo", -1, &a->_ns1__InsCLScada::ShelfNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ShelfSN", -1, &a->_ns1__InsCLScada::ShelfSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StartTime", -1, &a->_ns1__InsCLScada::StartTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EndTime", -1, &a->_ns1__InsCLScada::EndTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgeTime", -1, &a->_ns1__InsCLScada::AgeTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:WaveBound", -1, &a->_ns1__InsCLScada::WaveBound, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:WaveValue", -1, &a->_ns1__InsCLScada::WaveValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VoltBound", -1, &a->_ns1__InsCLScada::VoltBound, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VoltValue", -1, &a->_ns1__InsCLScada::VoltValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Ch1Value", -1, &a->_ns1__InsCLScada::Ch1Value, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Ch2Value", -1, &a->_ns1__InsCLScada::Ch2Value, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Ch3Value", -1, &a->_ns1__InsCLScada::Ch3Value, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Ch4Value", -1, &a->_ns1__InsCLScada::Ch4Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsCLScada::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsCLScada(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsCLScada * SOAP_FMAC4 soap_in__ns1__InsCLScada(struct soap *soap, const char *tag, _ns1__InsCLScada *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsCLScada *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsCLScada, sizeof(_ns1__InsCLScada), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsCLScada)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsCLScada *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MachineNo1 = 1;
	size_t soap_flag_MachineStatus1 = 1;
	size_t soap_flag_MachineErr1 = 1;
	size_t soap_flag_VacuumBound1 = 1;
	size_t soap_flag_VacuumValue1 = 1;
	size_t soap_flag_TempBound1 = 1;
	size_t soap_flag_TempValue1 = 1;
	size_t soap_flag_PartSN1 = 1;
	size_t soap_flag_ShelfNo1 = 1;
	size_t soap_flag_ShelfSN1 = 1;
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	size_t soap_flag_AgeTime1 = 1;
	size_t soap_flag_WaveBound1 = 1;
	size_t soap_flag_WaveValue1 = 1;
	size_t soap_flag_VoltBound1 = 1;
	size_t soap_flag_VoltValue1 = 1;
	size_t soap_flag_Ch1Value1 = 1;
	size_t soap_flag_Ch2Value1 = 1;
	size_t soap_flag_Ch3Value1 = 1;
	size_t soap_flag_Ch4Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MachineNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MachineNo", &a->_ns1__InsCLScada::MachineNo, "xsd:string"))
				{	soap_flag_MachineNo1--;
					continue;
				}
			}
			if (soap_flag_MachineStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MachineStatus", &a->_ns1__InsCLScada::MachineStatus, "xsd:string"))
				{	soap_flag_MachineStatus1--;
					continue;
				}
			}
			if (soap_flag_MachineErr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MachineErr", &a->_ns1__InsCLScada::MachineErr, "xsd:string"))
				{	soap_flag_MachineErr1--;
					continue;
				}
			}
			if (soap_flag_VacuumBound1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VacuumBound", &a->_ns1__InsCLScada::VacuumBound, "xsd:string"))
				{	soap_flag_VacuumBound1--;
					continue;
				}
			}
			if (soap_flag_VacuumValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VacuumValue", &a->_ns1__InsCLScada::VacuumValue, "xsd:string"))
				{	soap_flag_VacuumValue1--;
					continue;
				}
			}
			if (soap_flag_TempBound1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TempBound", &a->_ns1__InsCLScada::TempBound, "xsd:string"))
				{	soap_flag_TempBound1--;
					continue;
				}
			}
			if (soap_flag_TempValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TempValue", &a->_ns1__InsCLScada::TempValue, "xsd:string"))
				{	soap_flag_TempValue1--;
					continue;
				}
			}
			if (soap_flag_PartSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PartSN", &a->_ns1__InsCLScada::PartSN, "xsd:string"))
				{	soap_flag_PartSN1--;
					continue;
				}
			}
			if (soap_flag_ShelfNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ShelfNo", &a->_ns1__InsCLScada::ShelfNo, "xsd:string"))
				{	soap_flag_ShelfNo1--;
					continue;
				}
			}
			if (soap_flag_ShelfSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ShelfSN", &a->_ns1__InsCLScada::ShelfSN, "xsd:string"))
				{	soap_flag_ShelfSN1--;
					continue;
				}
			}
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:StartTime", &a->_ns1__InsCLScada::StartTime, "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EndTime", &a->_ns1__InsCLScada::EndTime, "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			}
			if (soap_flag_AgeTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:AgeTime", &a->_ns1__InsCLScada::AgeTime, "xsd:string"))
				{	soap_flag_AgeTime1--;
					continue;
				}
			}
			if (soap_flag_WaveBound1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:WaveBound", &a->_ns1__InsCLScada::WaveBound, "xsd:string"))
				{	soap_flag_WaveBound1--;
					continue;
				}
			}
			if (soap_flag_WaveValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:WaveValue", &a->_ns1__InsCLScada::WaveValue, "xsd:string"))
				{	soap_flag_WaveValue1--;
					continue;
				}
			}
			if (soap_flag_VoltBound1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VoltBound", &a->_ns1__InsCLScada::VoltBound, "xsd:string"))
				{	soap_flag_VoltBound1--;
					continue;
				}
			}
			if (soap_flag_VoltValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VoltValue", &a->_ns1__InsCLScada::VoltValue, "xsd:string"))
				{	soap_flag_VoltValue1--;
					continue;
				}
			}
			if (soap_flag_Ch1Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Ch1Value", &a->_ns1__InsCLScada::Ch1Value, "xsd:string"))
				{	soap_flag_Ch1Value1--;
					continue;
				}
			}
			if (soap_flag_Ch2Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Ch2Value", &a->_ns1__InsCLScada::Ch2Value, "xsd:string"))
				{	soap_flag_Ch2Value1--;
					continue;
				}
			}
			if (soap_flag_Ch3Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Ch3Value", &a->_ns1__InsCLScada::Ch3Value, "xsd:string"))
				{	soap_flag_Ch3Value1--;
					continue;
				}
			}
			if (soap_flag_Ch4Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Ch4Value", &a->_ns1__InsCLScada::Ch4Value, "xsd:string"))
				{	soap_flag_Ch4Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsCLScada *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsCLScada, SOAP_TYPE__ns1__InsCLScada, sizeof(_ns1__InsCLScada), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsCLScada * SOAP_FMAC2 soap_instantiate__ns1__InsCLScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsCLScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsCLScada *p;
	size_t k = sizeof(_ns1__InsCLScada);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsCLScada);
		if (p)
			((_ns1__InsCLScada*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsCLScada, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsCLScada*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsCLScada location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsCLScada, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsCLScada::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsCLScada(soap, tag ? tag : "ns1:InsCLScada", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsCLScada::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsCLScada(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsCLScada * SOAP_FMAC4 soap_get__ns1__InsCLScada(struct soap *soap, _ns1__InsCLScada *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsCLScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsAoiMoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsAoiMoResponse::InsAoiMoResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsAoiMoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsAoiMoResponse::InsAoiMoResult);
#endif
}

int _ns1__InsAoiMoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsAoiMoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsAoiMoResponse(struct soap *soap, const char *tag, int id, const _ns1__InsAoiMoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsAoiMoResponse), type))
		return soap->error;
	if (a->InsAoiMoResult)
		soap_element_result(soap, "ns1:InsAoiMoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsAoiMoResult", -1, &a->_ns1__InsAoiMoResponse::InsAoiMoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsAoiMoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsAoiMoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsAoiMoResponse * SOAP_FMAC4 soap_in__ns1__InsAoiMoResponse(struct soap *soap, const char *tag, _ns1__InsAoiMoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsAoiMoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsAoiMoResponse, sizeof(_ns1__InsAoiMoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsAoiMoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsAoiMoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsAoiMoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsAoiMoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsAoiMoResult", &a->_ns1__InsAoiMoResponse::InsAoiMoResult, "xsd:string"))
				{	soap_flag_InsAoiMoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsAoiMoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsAoiMoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsAoiMoResponse, SOAP_TYPE__ns1__InsAoiMoResponse, sizeof(_ns1__InsAoiMoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsAoiMoResponse * SOAP_FMAC2 soap_instantiate__ns1__InsAoiMoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsAoiMoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsAoiMoResponse *p;
	size_t k = sizeof(_ns1__InsAoiMoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsAoiMoResponse);
		if (p)
			((_ns1__InsAoiMoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsAoiMoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsAoiMoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsAoiMoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsAoiMoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsAoiMoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsAoiMoResponse(soap, tag ? tag : "ns1:InsAoiMoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsAoiMoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsAoiMoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsAoiMoResponse * SOAP_FMAC4 soap_get__ns1__InsAoiMoResponse(struct soap *soap, _ns1__InsAoiMoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsAoiMoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsAoiMo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsAoiMo::MoNumber = NULL;
	this->_ns1__InsAoiMo::SN = NULL;
	this->_ns1__InsAoiMo::Station = NULL;
	/* transient soap skipped */
}

void _ns1__InsAoiMo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsAoiMo::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsAoiMo::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsAoiMo::Station);
#endif
}

int _ns1__InsAoiMo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsAoiMo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsAoiMo(struct soap *soap, const char *tag, int id, const _ns1__InsAoiMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsAoiMo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__InsAoiMo::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsAoiMo::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__InsAoiMo::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsAoiMo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsAoiMo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsAoiMo * SOAP_FMAC4 soap_in__ns1__InsAoiMo(struct soap *soap, const char *tag, _ns1__InsAoiMo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsAoiMo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsAoiMo, sizeof(_ns1__InsAoiMo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsAoiMo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsAoiMo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__InsAoiMo::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsAoiMo::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__InsAoiMo::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsAoiMo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsAoiMo, SOAP_TYPE__ns1__InsAoiMo, sizeof(_ns1__InsAoiMo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsAoiMo * SOAP_FMAC2 soap_instantiate__ns1__InsAoiMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsAoiMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsAoiMo *p;
	size_t k = sizeof(_ns1__InsAoiMo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsAoiMo);
		if (p)
			((_ns1__InsAoiMo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsAoiMo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsAoiMo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsAoiMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsAoiMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsAoiMo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsAoiMo(soap, tag ? tag : "ns1:InsAoiMo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsAoiMo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsAoiMo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsAoiMo * SOAP_FMAC4 soap_get__ns1__InsAoiMo(struct soap *soap, _ns1__InsAoiMo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsAoiMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkMoSNForAOIResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkMoSNForAOIResponse::chkMoSNForAOIResult = NULL;
	/* transient soap skipped */
}

void _ns1__chkMoSNForAOIResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkMoSNForAOIResponse::chkMoSNForAOIResult);
#endif
}

int _ns1__chkMoSNForAOIResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkMoSNForAOIResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkMoSNForAOIResponse(struct soap *soap, const char *tag, int id, const _ns1__chkMoSNForAOIResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkMoSNForAOIResponse), type))
		return soap->error;
	if (a->chkMoSNForAOIResult)
		soap_element_result(soap, "ns1:chkMoSNForAOIResult");
	if (soap_out_PointerTostd__string(soap, "ns1:chkMoSNForAOIResult", -1, &a->_ns1__chkMoSNForAOIResponse::chkMoSNForAOIResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkMoSNForAOIResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkMoSNForAOIResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkMoSNForAOIResponse * SOAP_FMAC4 soap_in__ns1__chkMoSNForAOIResponse(struct soap *soap, const char *tag, _ns1__chkMoSNForAOIResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkMoSNForAOIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkMoSNForAOIResponse, sizeof(_ns1__chkMoSNForAOIResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkMoSNForAOIResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkMoSNForAOIResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_chkMoSNForAOIResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chkMoSNForAOIResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:chkMoSNForAOIResult", &a->_ns1__chkMoSNForAOIResponse::chkMoSNForAOIResult, "xsd:string"))
				{	soap_flag_chkMoSNForAOIResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:chkMoSNForAOIResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkMoSNForAOIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkMoSNForAOIResponse, SOAP_TYPE__ns1__chkMoSNForAOIResponse, sizeof(_ns1__chkMoSNForAOIResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkMoSNForAOIResponse * SOAP_FMAC2 soap_instantiate__ns1__chkMoSNForAOIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkMoSNForAOIResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkMoSNForAOIResponse *p;
	size_t k = sizeof(_ns1__chkMoSNForAOIResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkMoSNForAOIResponse);
		if (p)
			((_ns1__chkMoSNForAOIResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkMoSNForAOIResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkMoSNForAOIResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkMoSNForAOIResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkMoSNForAOIResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkMoSNForAOIResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkMoSNForAOIResponse(soap, tag ? tag : "ns1:chkMoSNForAOIResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkMoSNForAOIResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkMoSNForAOIResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkMoSNForAOIResponse * SOAP_FMAC4 soap_get__ns1__chkMoSNForAOIResponse(struct soap *soap, _ns1__chkMoSNForAOIResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkMoSNForAOIResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__chkMoSNForAOI::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__chkMoSNForAOI::MoNumber = NULL;
	this->_ns1__chkMoSNForAOI::SN = NULL;
	/* transient soap skipped */
}

void _ns1__chkMoSNForAOI::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkMoSNForAOI::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__chkMoSNForAOI::SN);
#endif
}

int _ns1__chkMoSNForAOI::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__chkMoSNForAOI(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__chkMoSNForAOI(struct soap *soap, const char *tag, int id, const _ns1__chkMoSNForAOI *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__chkMoSNForAOI), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__chkMoSNForAOI::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__chkMoSNForAOI::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__chkMoSNForAOI::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__chkMoSNForAOI(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__chkMoSNForAOI * SOAP_FMAC4 soap_in__ns1__chkMoSNForAOI(struct soap *soap, const char *tag, _ns1__chkMoSNForAOI *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__chkMoSNForAOI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__chkMoSNForAOI, sizeof(_ns1__chkMoSNForAOI), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__chkMoSNForAOI)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__chkMoSNForAOI *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__chkMoSNForAOI::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__chkMoSNForAOI::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__chkMoSNForAOI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__chkMoSNForAOI, SOAP_TYPE__ns1__chkMoSNForAOI, sizeof(_ns1__chkMoSNForAOI), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__chkMoSNForAOI * SOAP_FMAC2 soap_instantiate__ns1__chkMoSNForAOI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__chkMoSNForAOI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__chkMoSNForAOI *p;
	size_t k = sizeof(_ns1__chkMoSNForAOI);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__chkMoSNForAOI);
		if (p)
			((_ns1__chkMoSNForAOI*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__chkMoSNForAOI, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__chkMoSNForAOI*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__chkMoSNForAOI location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__chkMoSNForAOI, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__chkMoSNForAOI::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__chkMoSNForAOI(soap, tag ? tag : "ns1:chkMoSNForAOI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__chkMoSNForAOI::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__chkMoSNForAOI(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__chkMoSNForAOI * SOAP_FMAC4 soap_get__ns1__chkMoSNForAOI(struct soap *soap, _ns1__chkMoSNForAOI *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__chkMoSNForAOI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PunchOutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PunchOutResponse::PunchOutResult = NULL;
	/* transient soap skipped */
}

void _ns1__PunchOutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PunchOutResponse::PunchOutResult);
#endif
}

int _ns1__PunchOutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PunchOutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PunchOutResponse(struct soap *soap, const char *tag, int id, const _ns1__PunchOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PunchOutResponse), type))
		return soap->error;
	if (a->PunchOutResult)
		soap_element_result(soap, "ns1:PunchOutResult");
	if (soap_out_PointerTostd__string(soap, "ns1:PunchOutResult", -1, &a->_ns1__PunchOutResponse::PunchOutResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PunchOutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PunchOutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PunchOutResponse * SOAP_FMAC4 soap_in__ns1__PunchOutResponse(struct soap *soap, const char *tag, _ns1__PunchOutResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PunchOutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PunchOutResponse, sizeof(_ns1__PunchOutResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__PunchOutResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__PunchOutResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PunchOutResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PunchOutResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PunchOutResult", &a->_ns1__PunchOutResponse::PunchOutResult, "xsd:string"))
				{	soap_flag_PunchOutResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:PunchOutResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PunchOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PunchOutResponse, SOAP_TYPE__ns1__PunchOutResponse, sizeof(_ns1__PunchOutResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PunchOutResponse * SOAP_FMAC2 soap_instantiate__ns1__PunchOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PunchOutResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PunchOutResponse *p;
	size_t k = sizeof(_ns1__PunchOutResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PunchOutResponse);
		if (p)
			((_ns1__PunchOutResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PunchOutResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PunchOutResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PunchOutResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PunchOutResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PunchOutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__PunchOutResponse(soap, tag ? tag : "ns1:PunchOutResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PunchOutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PunchOutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PunchOutResponse * SOAP_FMAC4 soap_get__ns1__PunchOutResponse(struct soap *soap, _ns1__PunchOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PunchOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PunchOut::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PunchOut::BasketSN = NULL;
	this->_ns1__PunchOut::strUser = NULL;
	/* transient soap skipped */
}

void _ns1__PunchOut::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PunchOut::BasketSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PunchOut::strUser);
#endif
}

int _ns1__PunchOut::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PunchOut(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PunchOut(struct soap *soap, const char *tag, int id, const _ns1__PunchOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PunchOut), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BasketSN", -1, &a->_ns1__PunchOut::BasketSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__PunchOut::strUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PunchOut::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PunchOut(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PunchOut * SOAP_FMAC4 soap_in__ns1__PunchOut(struct soap *soap, const char *tag, _ns1__PunchOut *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PunchOut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PunchOut, sizeof(_ns1__PunchOut), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__PunchOut)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__PunchOut *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BasketSN1 = 1;
	size_t soap_flag_strUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BasketSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BasketSN", &a->_ns1__PunchOut::BasketSN, "xsd:string"))
				{	soap_flag_BasketSN1--;
					continue;
				}
			}
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__PunchOut::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PunchOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PunchOut, SOAP_TYPE__ns1__PunchOut, sizeof(_ns1__PunchOut), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PunchOut * SOAP_FMAC2 soap_instantiate__ns1__PunchOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PunchOut(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PunchOut *p;
	size_t k = sizeof(_ns1__PunchOut);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PunchOut);
		if (p)
			((_ns1__PunchOut*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PunchOut, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PunchOut*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PunchOut location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PunchOut, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PunchOut::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__PunchOut(soap, tag ? tag : "ns1:PunchOut", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PunchOut::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PunchOut(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PunchOut * SOAP_FMAC4 soap_get__ns1__PunchOut(struct soap *soap, _ns1__PunchOut *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PunchOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BasketLinkPunchResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BasketLinkPunchResponse::BasketLinkPunchResult = NULL;
	/* transient soap skipped */
}

void _ns1__BasketLinkPunchResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__BasketLinkPunchResponse::BasketLinkPunchResult);
#endif
}

int _ns1__BasketLinkPunchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BasketLinkPunchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BasketLinkPunchResponse(struct soap *soap, const char *tag, int id, const _ns1__BasketLinkPunchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BasketLinkPunchResponse), type))
		return soap->error;
	if (a->BasketLinkPunchResult)
		soap_element_result(soap, "ns1:BasketLinkPunchResult");
	if (soap_out_PointerTostd__string(soap, "ns1:BasketLinkPunchResult", -1, &a->_ns1__BasketLinkPunchResponse::BasketLinkPunchResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BasketLinkPunchResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BasketLinkPunchResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BasketLinkPunchResponse * SOAP_FMAC4 soap_in__ns1__BasketLinkPunchResponse(struct soap *soap, const char *tag, _ns1__BasketLinkPunchResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BasketLinkPunchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BasketLinkPunchResponse, sizeof(_ns1__BasketLinkPunchResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BasketLinkPunchResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BasketLinkPunchResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BasketLinkPunchResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BasketLinkPunchResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BasketLinkPunchResult", &a->_ns1__BasketLinkPunchResponse::BasketLinkPunchResult, "xsd:string"))
				{	soap_flag_BasketLinkPunchResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:BasketLinkPunchResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BasketLinkPunchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BasketLinkPunchResponse, SOAP_TYPE__ns1__BasketLinkPunchResponse, sizeof(_ns1__BasketLinkPunchResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BasketLinkPunchResponse * SOAP_FMAC2 soap_instantiate__ns1__BasketLinkPunchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BasketLinkPunchResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BasketLinkPunchResponse *p;
	size_t k = sizeof(_ns1__BasketLinkPunchResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__BasketLinkPunchResponse);
		if (p)
			((_ns1__BasketLinkPunchResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__BasketLinkPunchResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__BasketLinkPunchResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BasketLinkPunchResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__BasketLinkPunchResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__BasketLinkPunchResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BasketLinkPunchResponse(soap, tag ? tag : "ns1:BasketLinkPunchResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BasketLinkPunchResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BasketLinkPunchResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BasketLinkPunchResponse * SOAP_FMAC4 soap_get__ns1__BasketLinkPunchResponse(struct soap *soap, _ns1__BasketLinkPunchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BasketLinkPunchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BasketLinkPunch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BasketLinkPunch::BasketSN = NULL;
	this->_ns1__BasketLinkPunch::PunchSN = NULL;
	this->_ns1__BasketLinkPunch::Batch = NULL;
	this->_ns1__BasketLinkPunch::strUser = NULL;
	/* transient soap skipped */
}

void _ns1__BasketLinkPunch::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__BasketLinkPunch::BasketSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__BasketLinkPunch::PunchSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__BasketLinkPunch::Batch);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__BasketLinkPunch::strUser);
#endif
}

int _ns1__BasketLinkPunch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BasketLinkPunch(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BasketLinkPunch(struct soap *soap, const char *tag, int id, const _ns1__BasketLinkPunch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BasketLinkPunch), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BasketSN", -1, &a->_ns1__BasketLinkPunch::BasketSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PunchSN", -1, &a->_ns1__BasketLinkPunch::PunchSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Batch", -1, &a->_ns1__BasketLinkPunch::Batch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__BasketLinkPunch::strUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BasketLinkPunch::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BasketLinkPunch(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BasketLinkPunch * SOAP_FMAC4 soap_in__ns1__BasketLinkPunch(struct soap *soap, const char *tag, _ns1__BasketLinkPunch *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BasketLinkPunch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BasketLinkPunch, sizeof(_ns1__BasketLinkPunch), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BasketLinkPunch)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BasketLinkPunch *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BasketSN1 = 1;
	size_t soap_flag_PunchSN1 = 1;
	size_t soap_flag_Batch1 = 1;
	size_t soap_flag_strUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BasketSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BasketSN", &a->_ns1__BasketLinkPunch::BasketSN, "xsd:string"))
				{	soap_flag_BasketSN1--;
					continue;
				}
			}
			if (soap_flag_PunchSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PunchSN", &a->_ns1__BasketLinkPunch::PunchSN, "xsd:string"))
				{	soap_flag_PunchSN1--;
					continue;
				}
			}
			if (soap_flag_Batch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Batch", &a->_ns1__BasketLinkPunch::Batch, "xsd:string"))
				{	soap_flag_Batch1--;
					continue;
				}
			}
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__BasketLinkPunch::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BasketLinkPunch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BasketLinkPunch, SOAP_TYPE__ns1__BasketLinkPunch, sizeof(_ns1__BasketLinkPunch), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BasketLinkPunch * SOAP_FMAC2 soap_instantiate__ns1__BasketLinkPunch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BasketLinkPunch(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BasketLinkPunch *p;
	size_t k = sizeof(_ns1__BasketLinkPunch);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__BasketLinkPunch);
		if (p)
			((_ns1__BasketLinkPunch*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__BasketLinkPunch, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__BasketLinkPunch*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BasketLinkPunch location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__BasketLinkPunch, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__BasketLinkPunch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BasketLinkPunch(soap, tag ? tag : "ns1:BasketLinkPunch", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BasketLinkPunch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BasketLinkPunch(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BasketLinkPunch * SOAP_FMAC4 soap_get__ns1__BasketLinkPunch(struct soap *soap, _ns1__BasketLinkPunch *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BasketLinkPunch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HPSNLinkBasketResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__HPSNLinkBasketResponse::HPSNLinkBasketResult = NULL;
	/* transient soap skipped */
}

void _ns1__HPSNLinkBasketResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__HPSNLinkBasketResponse::HPSNLinkBasketResult);
#endif
}

int _ns1__HPSNLinkBasketResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HPSNLinkBasketResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HPSNLinkBasketResponse(struct soap *soap, const char *tag, int id, const _ns1__HPSNLinkBasketResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HPSNLinkBasketResponse), type))
		return soap->error;
	if (a->HPSNLinkBasketResult)
		soap_element_result(soap, "ns1:HPSNLinkBasketResult");
	if (soap_out_PointerTostd__string(soap, "ns1:HPSNLinkBasketResult", -1, &a->_ns1__HPSNLinkBasketResponse::HPSNLinkBasketResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HPSNLinkBasketResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HPSNLinkBasketResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HPSNLinkBasketResponse * SOAP_FMAC4 soap_in__ns1__HPSNLinkBasketResponse(struct soap *soap, const char *tag, _ns1__HPSNLinkBasketResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HPSNLinkBasketResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HPSNLinkBasketResponse, sizeof(_ns1__HPSNLinkBasketResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HPSNLinkBasketResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HPSNLinkBasketResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HPSNLinkBasketResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HPSNLinkBasketResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:HPSNLinkBasketResult", &a->_ns1__HPSNLinkBasketResponse::HPSNLinkBasketResult, "xsd:string"))
				{	soap_flag_HPSNLinkBasketResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:HPSNLinkBasketResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HPSNLinkBasketResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HPSNLinkBasketResponse, SOAP_TYPE__ns1__HPSNLinkBasketResponse, sizeof(_ns1__HPSNLinkBasketResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HPSNLinkBasketResponse * SOAP_FMAC2 soap_instantiate__ns1__HPSNLinkBasketResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HPSNLinkBasketResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HPSNLinkBasketResponse *p;
	size_t k = sizeof(_ns1__HPSNLinkBasketResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__HPSNLinkBasketResponse);
		if (p)
			((_ns1__HPSNLinkBasketResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__HPSNLinkBasketResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__HPSNLinkBasketResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HPSNLinkBasketResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__HPSNLinkBasketResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__HPSNLinkBasketResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HPSNLinkBasketResponse(soap, tag ? tag : "ns1:HPSNLinkBasketResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HPSNLinkBasketResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HPSNLinkBasketResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HPSNLinkBasketResponse * SOAP_FMAC4 soap_get__ns1__HPSNLinkBasketResponse(struct soap *soap, _ns1__HPSNLinkBasketResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HPSNLinkBasketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HPSNLinkBasket::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__HPSNLinkBasket::HPSN = NULL;
	this->_ns1__HPSNLinkBasket::BasketSN = NULL;
	this->_ns1__HPSNLinkBasket::strUser = NULL;
	/* transient soap skipped */
}

void _ns1__HPSNLinkBasket::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__HPSNLinkBasket::HPSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__HPSNLinkBasket::BasketSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__HPSNLinkBasket::strUser);
#endif
}

int _ns1__HPSNLinkBasket::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HPSNLinkBasket(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HPSNLinkBasket(struct soap *soap, const char *tag, int id, const _ns1__HPSNLinkBasket *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HPSNLinkBasket), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:HPSN", -1, &a->_ns1__HPSNLinkBasket::HPSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BasketSN", -1, &a->_ns1__HPSNLinkBasket::BasketSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__HPSNLinkBasket::strUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HPSNLinkBasket::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HPSNLinkBasket(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HPSNLinkBasket * SOAP_FMAC4 soap_in__ns1__HPSNLinkBasket(struct soap *soap, const char *tag, _ns1__HPSNLinkBasket *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HPSNLinkBasket *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HPSNLinkBasket, sizeof(_ns1__HPSNLinkBasket), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HPSNLinkBasket)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HPSNLinkBasket *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HPSN1 = 1;
	size_t soap_flag_BasketSN1 = 1;
	size_t soap_flag_strUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HPSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:HPSN", &a->_ns1__HPSNLinkBasket::HPSN, "xsd:string"))
				{	soap_flag_HPSN1--;
					continue;
				}
			}
			if (soap_flag_BasketSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BasketSN", &a->_ns1__HPSNLinkBasket::BasketSN, "xsd:string"))
				{	soap_flag_BasketSN1--;
					continue;
				}
			}
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__HPSNLinkBasket::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HPSNLinkBasket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HPSNLinkBasket, SOAP_TYPE__ns1__HPSNLinkBasket, sizeof(_ns1__HPSNLinkBasket), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HPSNLinkBasket * SOAP_FMAC2 soap_instantiate__ns1__HPSNLinkBasket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HPSNLinkBasket(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HPSNLinkBasket *p;
	size_t k = sizeof(_ns1__HPSNLinkBasket);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__HPSNLinkBasket);
		if (p)
			((_ns1__HPSNLinkBasket*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__HPSNLinkBasket, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__HPSNLinkBasket*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HPSNLinkBasket location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__HPSNLinkBasket, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__HPSNLinkBasket::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HPSNLinkBasket(soap, tag ? tag : "ns1:HPSNLinkBasket", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HPSNLinkBasket::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HPSNLinkBasket(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HPSNLinkBasket * SOAP_FMAC4 soap_get__ns1__HPSNLinkBasket(struct soap *soap, _ns1__HPSNLinkBasket *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HPSNLinkBasket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetAutoLineRecResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetAutoLineRecResponse::SetAutoLineRecResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetAutoLineRecResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetAutoLineRecResponse::SetAutoLineRecResult);
#endif
}

int _ns1__SetAutoLineRecResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetAutoLineRecResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetAutoLineRecResponse(struct soap *soap, const char *tag, int id, const _ns1__SetAutoLineRecResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetAutoLineRecResponse), type))
		return soap->error;
	if (a->SetAutoLineRecResult)
		soap_element_result(soap, "ns1:SetAutoLineRecResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SetAutoLineRecResult", -1, &a->_ns1__SetAutoLineRecResponse::SetAutoLineRecResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetAutoLineRecResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetAutoLineRecResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetAutoLineRecResponse * SOAP_FMAC4 soap_in__ns1__SetAutoLineRecResponse(struct soap *soap, const char *tag, _ns1__SetAutoLineRecResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetAutoLineRecResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetAutoLineRecResponse, sizeof(_ns1__SetAutoLineRecResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetAutoLineRecResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetAutoLineRecResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetAutoLineRecResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetAutoLineRecResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SetAutoLineRecResult", &a->_ns1__SetAutoLineRecResponse::SetAutoLineRecResult, "xsd:string"))
				{	soap_flag_SetAutoLineRecResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetAutoLineRecResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetAutoLineRecResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetAutoLineRecResponse, SOAP_TYPE__ns1__SetAutoLineRecResponse, sizeof(_ns1__SetAutoLineRecResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetAutoLineRecResponse * SOAP_FMAC2 soap_instantiate__ns1__SetAutoLineRecResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetAutoLineRecResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetAutoLineRecResponse *p;
	size_t k = sizeof(_ns1__SetAutoLineRecResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetAutoLineRecResponse);
		if (p)
			((_ns1__SetAutoLineRecResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetAutoLineRecResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetAutoLineRecResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetAutoLineRecResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetAutoLineRecResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetAutoLineRecResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetAutoLineRecResponse(soap, tag ? tag : "ns1:SetAutoLineRecResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetAutoLineRecResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetAutoLineRecResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetAutoLineRecResponse * SOAP_FMAC4 soap_get__ns1__SetAutoLineRecResponse(struct soap *soap, _ns1__SetAutoLineRecResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetAutoLineRecResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetAutoLineRec::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetAutoLineRec::strUser = NULL;
	this->_ns1__SetAutoLineRec::InData = NULL;
	/* transient soap skipped */
}

void _ns1__SetAutoLineRec::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetAutoLineRec::strUser);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetAutoLineRec::InData);
#endif
}

int _ns1__SetAutoLineRec::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetAutoLineRec(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetAutoLineRec(struct soap *soap, const char *tag, int id, const _ns1__SetAutoLineRec *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetAutoLineRec), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__SetAutoLineRec::strUser, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:InData", -1, &a->_ns1__SetAutoLineRec::InData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetAutoLineRec::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetAutoLineRec(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetAutoLineRec * SOAP_FMAC4 soap_in__ns1__SetAutoLineRec(struct soap *soap, const char *tag, _ns1__SetAutoLineRec *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetAutoLineRec *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetAutoLineRec, sizeof(_ns1__SetAutoLineRec), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetAutoLineRec)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetAutoLineRec *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strUser1 = 1;
	size_t soap_flag_InData1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__SetAutoLineRec::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap_flag_InData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InData", &a->_ns1__SetAutoLineRec::InData, "xsd:string"))
				{	soap_flag_InData1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetAutoLineRec *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetAutoLineRec, SOAP_TYPE__ns1__SetAutoLineRec, sizeof(_ns1__SetAutoLineRec), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetAutoLineRec * SOAP_FMAC2 soap_instantiate__ns1__SetAutoLineRec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetAutoLineRec(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetAutoLineRec *p;
	size_t k = sizeof(_ns1__SetAutoLineRec);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetAutoLineRec);
		if (p)
			((_ns1__SetAutoLineRec*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetAutoLineRec, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetAutoLineRec*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetAutoLineRec location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetAutoLineRec, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetAutoLineRec::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetAutoLineRec(soap, tag ? tag : "ns1:SetAutoLineRec", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetAutoLineRec::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetAutoLineRec(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetAutoLineRec * SOAP_FMAC4 soap_get__ns1__SetAutoLineRec(struct soap *soap, _ns1__SetAutoLineRec *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetAutoLineRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetSNForLinkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSNForLinkResponse::GetSNForLinkResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSNForLinkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSNForLinkResponse::GetSNForLinkResult);
#endif
}

int _ns1__GetSNForLinkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSNForLinkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSNForLinkResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSNForLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSNForLinkResponse), type))
		return soap->error;
	if (a->GetSNForLinkResult)
		soap_element_result(soap, "ns1:GetSNForLinkResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetSNForLinkResult", -1, &a->_ns1__GetSNForLinkResponse::GetSNForLinkResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSNForLinkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSNForLinkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSNForLinkResponse * SOAP_FMAC4 soap_in__ns1__GetSNForLinkResponse(struct soap *soap, const char *tag, _ns1__GetSNForLinkResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSNForLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSNForLinkResponse, sizeof(_ns1__GetSNForLinkResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetSNForLinkResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetSNForLinkResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetSNForLinkResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSNForLinkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetSNForLinkResult", &a->_ns1__GetSNForLinkResponse::GetSNForLinkResult, "xsd:string"))
				{	soap_flag_GetSNForLinkResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetSNForLinkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSNForLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSNForLinkResponse, SOAP_TYPE__ns1__GetSNForLinkResponse, sizeof(_ns1__GetSNForLinkResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetSNForLinkResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSNForLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSNForLinkResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetSNForLinkResponse *p;
	size_t k = sizeof(_ns1__GetSNForLinkResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetSNForLinkResponse);
		if (p)
			((_ns1__GetSNForLinkResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetSNForLinkResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetSNForLinkResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetSNForLinkResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetSNForLinkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetSNForLinkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetSNForLinkResponse(soap, tag ? tag : "ns1:GetSNForLinkResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSNForLinkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSNForLinkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSNForLinkResponse * SOAP_FMAC4 soap_get__ns1__GetSNForLinkResponse(struct soap *soap, _ns1__GetSNForLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSNForLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetSNForLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSNForLink::LinkSN = NULL;
	/* transient soap skipped */
}

void _ns1__GetSNForLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSNForLink::LinkSN);
#endif
}

int _ns1__GetSNForLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSNForLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSNForLink(struct soap *soap, const char *tag, int id, const _ns1__GetSNForLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSNForLink), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LinkSN", -1, &a->_ns1__GetSNForLink::LinkSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSNForLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSNForLink(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSNForLink * SOAP_FMAC4 soap_in__ns1__GetSNForLink(struct soap *soap, const char *tag, _ns1__GetSNForLink *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSNForLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSNForLink, sizeof(_ns1__GetSNForLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetSNForLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetSNForLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LinkSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LinkSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LinkSN", &a->_ns1__GetSNForLink::LinkSN, "xsd:string"))
				{	soap_flag_LinkSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSNForLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSNForLink, SOAP_TYPE__ns1__GetSNForLink, sizeof(_ns1__GetSNForLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetSNForLink * SOAP_FMAC2 soap_instantiate__ns1__GetSNForLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSNForLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetSNForLink *p;
	size_t k = sizeof(_ns1__GetSNForLink);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetSNForLink);
		if (p)
			((_ns1__GetSNForLink*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetSNForLink, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetSNForLink*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetSNForLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetSNForLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetSNForLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetSNForLink(soap, tag ? tag : "ns1:GetSNForLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSNForLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSNForLink(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSNForLink * SOAP_FMAC4 soap_get__ns1__GetSNForLink(struct soap *soap, _ns1__GetSNForLink *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSNForLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetFlatnessFruitRecResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetFlatnessFruitRecResponse::SetFlatnessFruitRecResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetFlatnessFruitRecResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetFlatnessFruitRecResponse::SetFlatnessFruitRecResult);
#endif
}

int _ns1__SetFlatnessFruitRecResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetFlatnessFruitRecResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetFlatnessFruitRecResponse(struct soap *soap, const char *tag, int id, const _ns1__SetFlatnessFruitRecResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetFlatnessFruitRecResponse), type))
		return soap->error;
	if (a->SetFlatnessFruitRecResult)
		soap_element_result(soap, "ns1:SetFlatnessFruitRecResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SetFlatnessFruitRecResult", -1, &a->_ns1__SetFlatnessFruitRecResponse::SetFlatnessFruitRecResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetFlatnessFruitRecResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetFlatnessFruitRecResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRecResponse * SOAP_FMAC4 soap_in__ns1__SetFlatnessFruitRecResponse(struct soap *soap, const char *tag, _ns1__SetFlatnessFruitRecResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetFlatnessFruitRecResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetFlatnessFruitRecResponse, sizeof(_ns1__SetFlatnessFruitRecResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetFlatnessFruitRecResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetFlatnessFruitRecResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetFlatnessFruitRecResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetFlatnessFruitRecResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SetFlatnessFruitRecResult", &a->_ns1__SetFlatnessFruitRecResponse::SetFlatnessFruitRecResult, "xsd:string"))
				{	soap_flag_SetFlatnessFruitRecResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetFlatnessFruitRecResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetFlatnessFruitRecResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetFlatnessFruitRecResponse, SOAP_TYPE__ns1__SetFlatnessFruitRecResponse, sizeof(_ns1__SetFlatnessFruitRecResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetFlatnessFruitRecResponse * SOAP_FMAC2 soap_instantiate__ns1__SetFlatnessFruitRecResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetFlatnessFruitRecResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetFlatnessFruitRecResponse *p;
	size_t k = sizeof(_ns1__SetFlatnessFruitRecResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetFlatnessFruitRecResponse);
		if (p)
			((_ns1__SetFlatnessFruitRecResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetFlatnessFruitRecResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetFlatnessFruitRecResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetFlatnessFruitRecResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetFlatnessFruitRecResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetFlatnessFruitRecResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetFlatnessFruitRecResponse(soap, tag ? tag : "ns1:SetFlatnessFruitRecResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetFlatnessFruitRecResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetFlatnessFruitRecResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRecResponse * SOAP_FMAC4 soap_get__ns1__SetFlatnessFruitRecResponse(struct soap *soap, _ns1__SetFlatnessFruitRecResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetFlatnessFruitRecResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetFlatnessFruitRec::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetFlatnessFruitRec::Sn = NULL;
	this->_ns1__SetFlatnessFruitRec::strUser = NULL;
	this->_ns1__SetFlatnessFruitRec::dt = NULL;
	/* transient soap skipped */
}

void _ns1__SetFlatnessFruitRec::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetFlatnessFruitRec::Sn);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetFlatnessFruitRec::strUser);
	soap_serialize_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, &this->_ns1__SetFlatnessFruitRec::dt);
#endif
}

int _ns1__SetFlatnessFruitRec::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetFlatnessFruitRec(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetFlatnessFruitRec(struct soap *soap, const char *tag, int id, const _ns1__SetFlatnessFruitRec *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetFlatnessFruitRec), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Sn", -1, &a->_ns1__SetFlatnessFruitRec::Sn, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__SetFlatnessFruitRec::strUser, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, "ns1:dt", -1, &a->_ns1__SetFlatnessFruitRec::dt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetFlatnessFruitRec::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetFlatnessFruitRec(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec * SOAP_FMAC4 soap_in__ns1__SetFlatnessFruitRec(struct soap *soap, const char *tag, _ns1__SetFlatnessFruitRec *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetFlatnessFruitRec *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetFlatnessFruitRec, sizeof(_ns1__SetFlatnessFruitRec), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetFlatnessFruitRec)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetFlatnessFruitRec *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Sn1 = 1;
	size_t soap_flag_strUser1 = 1;
	size_t soap_flag_dt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Sn", &a->_ns1__SetFlatnessFruitRec::Sn, "xsd:string"))
				{	soap_flag_Sn1--;
					continue;
				}
			}
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__SetFlatnessFruitRec::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap_flag_dt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, "ns1:dt", &a->_ns1__SetFlatnessFruitRec::dt, ""))
				{	soap_flag_dt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetFlatnessFruitRec *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetFlatnessFruitRec, SOAP_TYPE__ns1__SetFlatnessFruitRec, sizeof(_ns1__SetFlatnessFruitRec), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetFlatnessFruitRec * SOAP_FMAC2 soap_instantiate__ns1__SetFlatnessFruitRec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetFlatnessFruitRec(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetFlatnessFruitRec *p;
	size_t k = sizeof(_ns1__SetFlatnessFruitRec);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetFlatnessFruitRec);
		if (p)
			((_ns1__SetFlatnessFruitRec*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetFlatnessFruitRec, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetFlatnessFruitRec*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetFlatnessFruitRec location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetFlatnessFruitRec, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetFlatnessFruitRec::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetFlatnessFruitRec(soap, tag ? tag : "ns1:SetFlatnessFruitRec", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetFlatnessFruitRec::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetFlatnessFruitRec(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec * SOAP_FMAC4 soap_get__ns1__SetFlatnessFruitRec(struct soap *soap, _ns1__SetFlatnessFruitRec *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetFlatnessFruitRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getStationByMoForTestPadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getStationByMoForTestPadResponse::getStationByMoForTestPadResult = NULL;
	/* transient soap skipped */
}

void _ns1__getStationByMoForTestPadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationByMoForTestPadResponse::getStationByMoForTestPadResult);
#endif
}

int _ns1__getStationByMoForTestPadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getStationByMoForTestPadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getStationByMoForTestPadResponse(struct soap *soap, const char *tag, int id, const _ns1__getStationByMoForTestPadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getStationByMoForTestPadResponse), type))
		return soap->error;
	if (a->getStationByMoForTestPadResult)
		soap_element_result(soap, "ns1:getStationByMoForTestPadResult");
	if (soap_out_PointerTostd__string(soap, "ns1:getStationByMoForTestPadResult", -1, &a->_ns1__getStationByMoForTestPadResponse::getStationByMoForTestPadResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getStationByMoForTestPadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getStationByMoForTestPadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getStationByMoForTestPadResponse * SOAP_FMAC4 soap_in__ns1__getStationByMoForTestPadResponse(struct soap *soap, const char *tag, _ns1__getStationByMoForTestPadResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getStationByMoForTestPadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getStationByMoForTestPadResponse, sizeof(_ns1__getStationByMoForTestPadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getStationByMoForTestPadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getStationByMoForTestPadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getStationByMoForTestPadResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getStationByMoForTestPadResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:getStationByMoForTestPadResult", &a->_ns1__getStationByMoForTestPadResponse::getStationByMoForTestPadResult, "xsd:string"))
				{	soap_flag_getStationByMoForTestPadResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:getStationByMoForTestPadResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getStationByMoForTestPadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getStationByMoForTestPadResponse, SOAP_TYPE__ns1__getStationByMoForTestPadResponse, sizeof(_ns1__getStationByMoForTestPadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getStationByMoForTestPadResponse * SOAP_FMAC2 soap_instantiate__ns1__getStationByMoForTestPadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getStationByMoForTestPadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getStationByMoForTestPadResponse *p;
	size_t k = sizeof(_ns1__getStationByMoForTestPadResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getStationByMoForTestPadResponse);
		if (p)
			((_ns1__getStationByMoForTestPadResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getStationByMoForTestPadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getStationByMoForTestPadResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getStationByMoForTestPadResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getStationByMoForTestPadResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getStationByMoForTestPadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getStationByMoForTestPadResponse(soap, tag ? tag : "ns1:getStationByMoForTestPadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getStationByMoForTestPadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getStationByMoForTestPadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getStationByMoForTestPadResponse * SOAP_FMAC4 soap_get__ns1__getStationByMoForTestPadResponse(struct soap *soap, _ns1__getStationByMoForTestPadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getStationByMoForTestPadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getStationByMoForTestPad::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getStationByMoForTestPad::MoNumber = NULL;
	this->_ns1__getStationByMoForTestPad::strTest = NULL;
	/* transient soap skipped */
}

void _ns1__getStationByMoForTestPad::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationByMoForTestPad::MoNumber);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getStationByMoForTestPad::strTest);
#endif
}

int _ns1__getStationByMoForTestPad::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getStationByMoForTestPad(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getStationByMoForTestPad(struct soap *soap, const char *tag, int id, const _ns1__getStationByMoForTestPad *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getStationByMoForTestPad), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MoNumber", -1, &a->_ns1__getStationByMoForTestPad::MoNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strTest", -1, &a->_ns1__getStationByMoForTestPad::strTest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getStationByMoForTestPad::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getStationByMoForTestPad(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getStationByMoForTestPad * SOAP_FMAC4 soap_in__ns1__getStationByMoForTestPad(struct soap *soap, const char *tag, _ns1__getStationByMoForTestPad *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getStationByMoForTestPad *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getStationByMoForTestPad, sizeof(_ns1__getStationByMoForTestPad), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getStationByMoForTestPad)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getStationByMoForTestPad *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoNumber1 = 1;
	size_t soap_flag_strTest1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MoNumber", &a->_ns1__getStationByMoForTestPad::MoNumber, "xsd:string"))
				{	soap_flag_MoNumber1--;
					continue;
				}
			}
			if (soap_flag_strTest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strTest", &a->_ns1__getStationByMoForTestPad::strTest, "xsd:string"))
				{	soap_flag_strTest1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getStationByMoForTestPad *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getStationByMoForTestPad, SOAP_TYPE__ns1__getStationByMoForTestPad, sizeof(_ns1__getStationByMoForTestPad), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getStationByMoForTestPad * SOAP_FMAC2 soap_instantiate__ns1__getStationByMoForTestPad(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getStationByMoForTestPad(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getStationByMoForTestPad *p;
	size_t k = sizeof(_ns1__getStationByMoForTestPad);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getStationByMoForTestPad);
		if (p)
			((_ns1__getStationByMoForTestPad*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getStationByMoForTestPad, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getStationByMoForTestPad*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getStationByMoForTestPad location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getStationByMoForTestPad, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getStationByMoForTestPad::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getStationByMoForTestPad(soap, tag ? tag : "ns1:getStationByMoForTestPad", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getStationByMoForTestPad::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getStationByMoForTestPad(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getStationByMoForTestPad * SOAP_FMAC4 soap_get__ns1__getStationByMoForTestPad(struct soap *soap, _ns1__getStationByMoForTestPad *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getStationByMoForTestPad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingWeightResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingWeightResponse::GetShippingWeightResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingWeightResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, &this->_ns1__GetShippingWeightResponse::GetShippingWeightResult);
#endif
}

int _ns1__GetShippingWeightResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingWeightResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingWeightResponse(struct soap *soap, const char *tag, int id, const _ns1__GetShippingWeightResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingWeightResponse), type))
		return soap->error;
	if (a->GetShippingWeightResult)
		soap_element_result(soap, "ns1:GetShippingWeightResult");
	if (soap_out_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, "ns1:GetShippingWeightResult", -1, &a->_ns1__GetShippingWeightResponse::GetShippingWeightResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingWeightResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingWeightResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingWeightResponse * SOAP_FMAC4 soap_in__ns1__GetShippingWeightResponse(struct soap *soap, const char *tag, _ns1__GetShippingWeightResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingWeightResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingWeightResponse, sizeof(_ns1__GetShippingWeightResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingWeightResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingWeightResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetShippingWeightResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShippingWeightResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, "ns1:GetShippingWeightResult", &a->_ns1__GetShippingWeightResponse::GetShippingWeightResult, ""))
				{	soap_flag_GetShippingWeightResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetShippingWeightResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingWeightResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingWeightResponse, SOAP_TYPE__ns1__GetShippingWeightResponse, sizeof(_ns1__GetShippingWeightResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingWeightResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingWeightResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingWeightResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingWeightResponse *p;
	size_t k = sizeof(_ns1__GetShippingWeightResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingWeightResponse);
		if (p)
			((_ns1__GetShippingWeightResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingWeightResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingWeightResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingWeightResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingWeightResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingWeightResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingWeightResponse(soap, tag ? tag : "ns1:GetShippingWeightResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingWeightResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingWeightResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingWeightResponse * SOAP_FMAC4 soap_get__ns1__GetShippingWeightResponse(struct soap *soap, _ns1__GetShippingWeightResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingWeightResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingWeight::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingWeight::ListNo = NULL;
	this->_ns1__GetShippingWeight::CarNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingWeight::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingWeight::ListNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingWeight::CarNo);
#endif
}

int _ns1__GetShippingWeight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingWeight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingWeight(struct soap *soap, const char *tag, int id, const _ns1__GetShippingWeight *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingWeight), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ListNo", -1, &a->_ns1__GetShippingWeight::ListNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CarNo", -1, &a->_ns1__GetShippingWeight::CarNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingWeight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingWeight(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingWeight * SOAP_FMAC4 soap_in__ns1__GetShippingWeight(struct soap *soap, const char *tag, _ns1__GetShippingWeight *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingWeight *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingWeight, sizeof(_ns1__GetShippingWeight), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingWeight)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingWeight *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ListNo1 = 1;
	size_t soap_flag_CarNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ListNo", &a->_ns1__GetShippingWeight::ListNo, "xsd:string"))
				{	soap_flag_ListNo1--;
					continue;
				}
			}
			if (soap_flag_CarNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CarNo", &a->_ns1__GetShippingWeight::CarNo, "xsd:string"))
				{	soap_flag_CarNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingWeight *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingWeight, SOAP_TYPE__ns1__GetShippingWeight, sizeof(_ns1__GetShippingWeight), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingWeight * SOAP_FMAC2 soap_instantiate__ns1__GetShippingWeight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingWeight(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingWeight *p;
	size_t k = sizeof(_ns1__GetShippingWeight);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingWeight);
		if (p)
			((_ns1__GetShippingWeight*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingWeight, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingWeight*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingWeight location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingWeight, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingWeight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingWeight(soap, tag ? tag : "ns1:GetShippingWeight", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingWeight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingWeight(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingWeight * SOAP_FMAC4 soap_get__ns1__GetShippingWeight(struct soap *soap, _ns1__GetShippingWeight *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingWeight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingForBerthResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingForBerthResponse::GetShippingForBerthResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingForBerthResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, &this->_ns1__GetShippingForBerthResponse::GetShippingForBerthResult);
#endif
}

int _ns1__GetShippingForBerthResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingForBerthResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingForBerthResponse(struct soap *soap, const char *tag, int id, const _ns1__GetShippingForBerthResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingForBerthResponse), type))
		return soap->error;
	if (a->GetShippingForBerthResult)
		soap_element_result(soap, "ns1:GetShippingForBerthResult");
	if (soap_out_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, "ns1:GetShippingForBerthResult", -1, &a->_ns1__GetShippingForBerthResponse::GetShippingForBerthResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingForBerthResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingForBerthResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingForBerthResponse * SOAP_FMAC4 soap_in__ns1__GetShippingForBerthResponse(struct soap *soap, const char *tag, _ns1__GetShippingForBerthResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingForBerthResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingForBerthResponse, sizeof(_ns1__GetShippingForBerthResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingForBerthResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingForBerthResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetShippingForBerthResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShippingForBerthResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, "ns1:GetShippingForBerthResult", &a->_ns1__GetShippingForBerthResponse::GetShippingForBerthResult, ""))
				{	soap_flag_GetShippingForBerthResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetShippingForBerthResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingForBerthResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingForBerthResponse, SOAP_TYPE__ns1__GetShippingForBerthResponse, sizeof(_ns1__GetShippingForBerthResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingForBerthResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingForBerthResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingForBerthResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingForBerthResponse *p;
	size_t k = sizeof(_ns1__GetShippingForBerthResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingForBerthResponse);
		if (p)
			((_ns1__GetShippingForBerthResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingForBerthResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingForBerthResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingForBerthResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingForBerthResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingForBerthResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingForBerthResponse(soap, tag ? tag : "ns1:GetShippingForBerthResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingForBerthResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingForBerthResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingForBerthResponse * SOAP_FMAC4 soap_get__ns1__GetShippingForBerthResponse(struct soap *soap, _ns1__GetShippingForBerthResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingForBerthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingForBerth::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingForBerth::Berth = NULL;
	this->_ns1__GetShippingForBerth::CarNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingForBerth::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingForBerth::Berth);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingForBerth::CarNo);
#endif
}

int _ns1__GetShippingForBerth::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingForBerth(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingForBerth(struct soap *soap, const char *tag, int id, const _ns1__GetShippingForBerth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingForBerth), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Berth", -1, &a->_ns1__GetShippingForBerth::Berth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CarNo", -1, &a->_ns1__GetShippingForBerth::CarNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingForBerth::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingForBerth(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingForBerth * SOAP_FMAC4 soap_in__ns1__GetShippingForBerth(struct soap *soap, const char *tag, _ns1__GetShippingForBerth *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingForBerth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingForBerth, sizeof(_ns1__GetShippingForBerth), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingForBerth)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingForBerth *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Berth1 = 1;
	size_t soap_flag_CarNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Berth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Berth", &a->_ns1__GetShippingForBerth::Berth, "xsd:string"))
				{	soap_flag_Berth1--;
					continue;
				}
			}
			if (soap_flag_CarNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CarNo", &a->_ns1__GetShippingForBerth::CarNo, "xsd:string"))
				{	soap_flag_CarNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingForBerth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingForBerth, SOAP_TYPE__ns1__GetShippingForBerth, sizeof(_ns1__GetShippingForBerth), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingForBerth * SOAP_FMAC2 soap_instantiate__ns1__GetShippingForBerth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingForBerth(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingForBerth *p;
	size_t k = sizeof(_ns1__GetShippingForBerth);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingForBerth);
		if (p)
			((_ns1__GetShippingForBerth*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingForBerth, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingForBerth*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingForBerth location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingForBerth, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingForBerth::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingForBerth(soap, tag ? tag : "ns1:GetShippingForBerth", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingForBerth::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingForBerth(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingForBerth * SOAP_FMAC4 soap_get__ns1__GetShippingForBerth(struct soap *soap, _ns1__GetShippingForBerth *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingForBerth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsShippingBerthResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsShippingBerthResponse::InsShippingBerthResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsShippingBerthResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingBerthResponse::InsShippingBerthResult);
#endif
}

int _ns1__InsShippingBerthResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsShippingBerthResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsShippingBerthResponse(struct soap *soap, const char *tag, int id, const _ns1__InsShippingBerthResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsShippingBerthResponse), type))
		return soap->error;
	if (a->InsShippingBerthResult)
		soap_element_result(soap, "ns1:InsShippingBerthResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsShippingBerthResult", -1, &a->_ns1__InsShippingBerthResponse::InsShippingBerthResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsShippingBerthResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsShippingBerthResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsShippingBerthResponse * SOAP_FMAC4 soap_in__ns1__InsShippingBerthResponse(struct soap *soap, const char *tag, _ns1__InsShippingBerthResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsShippingBerthResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsShippingBerthResponse, sizeof(_ns1__InsShippingBerthResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsShippingBerthResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsShippingBerthResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsShippingBerthResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsShippingBerthResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsShippingBerthResult", &a->_ns1__InsShippingBerthResponse::InsShippingBerthResult, "xsd:string"))
				{	soap_flag_InsShippingBerthResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsShippingBerthResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsShippingBerthResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsShippingBerthResponse, SOAP_TYPE__ns1__InsShippingBerthResponse, sizeof(_ns1__InsShippingBerthResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsShippingBerthResponse * SOAP_FMAC2 soap_instantiate__ns1__InsShippingBerthResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsShippingBerthResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsShippingBerthResponse *p;
	size_t k = sizeof(_ns1__InsShippingBerthResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsShippingBerthResponse);
		if (p)
			((_ns1__InsShippingBerthResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsShippingBerthResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsShippingBerthResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsShippingBerthResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsShippingBerthResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsShippingBerthResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsShippingBerthResponse(soap, tag ? tag : "ns1:InsShippingBerthResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsShippingBerthResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsShippingBerthResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsShippingBerthResponse * SOAP_FMAC4 soap_get__ns1__InsShippingBerthResponse(struct soap *soap, _ns1__InsShippingBerthResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsShippingBerthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsShippingBerth::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsShippingBerth::ListNo = NULL;
	this->_ns1__InsShippingBerth::Berth = NULL;
	this->_ns1__InsShippingBerth::strTime = NULL;
	/* transient soap skipped */
}

void _ns1__InsShippingBerth::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingBerth::ListNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingBerth::Berth);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingBerth::strTime);
#endif
}

int _ns1__InsShippingBerth::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsShippingBerth(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsShippingBerth(struct soap *soap, const char *tag, int id, const _ns1__InsShippingBerth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsShippingBerth), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ListNo", -1, &a->_ns1__InsShippingBerth::ListNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Berth", -1, &a->_ns1__InsShippingBerth::Berth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strTime", -1, &a->_ns1__InsShippingBerth::strTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsShippingBerth::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsShippingBerth(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsShippingBerth * SOAP_FMAC4 soap_in__ns1__InsShippingBerth(struct soap *soap, const char *tag, _ns1__InsShippingBerth *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsShippingBerth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsShippingBerth, sizeof(_ns1__InsShippingBerth), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsShippingBerth)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsShippingBerth *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ListNo1 = 1;
	size_t soap_flag_Berth1 = 1;
	size_t soap_flag_strTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ListNo", &a->_ns1__InsShippingBerth::ListNo, "xsd:string"))
				{	soap_flag_ListNo1--;
					continue;
				}
			}
			if (soap_flag_Berth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Berth", &a->_ns1__InsShippingBerth::Berth, "xsd:string"))
				{	soap_flag_Berth1--;
					continue;
				}
			}
			if (soap_flag_strTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strTime", &a->_ns1__InsShippingBerth::strTime, "xsd:string"))
				{	soap_flag_strTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsShippingBerth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsShippingBerth, SOAP_TYPE__ns1__InsShippingBerth, sizeof(_ns1__InsShippingBerth), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsShippingBerth * SOAP_FMAC2 soap_instantiate__ns1__InsShippingBerth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsShippingBerth(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsShippingBerth *p;
	size_t k = sizeof(_ns1__InsShippingBerth);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsShippingBerth);
		if (p)
			((_ns1__InsShippingBerth*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsShippingBerth, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsShippingBerth*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsShippingBerth location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsShippingBerth, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsShippingBerth::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsShippingBerth(soap, tag ? tag : "ns1:InsShippingBerth", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsShippingBerth::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsShippingBerth(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsShippingBerth * SOAP_FMAC4 soap_get__ns1__InsShippingBerth(struct soap *soap, _ns1__InsShippingBerth *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsShippingBerth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsShippingPalleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsShippingPalleResponse::InsShippingPalleResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsShippingPalleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingPalleResponse::InsShippingPalleResult);
#endif
}

int _ns1__InsShippingPalleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsShippingPalleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsShippingPalleResponse(struct soap *soap, const char *tag, int id, const _ns1__InsShippingPalleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsShippingPalleResponse), type))
		return soap->error;
	if (a->InsShippingPalleResult)
		soap_element_result(soap, "ns1:InsShippingPalleResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsShippingPalleResult", -1, &a->_ns1__InsShippingPalleResponse::InsShippingPalleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsShippingPalleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsShippingPalleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsShippingPalleResponse * SOAP_FMAC4 soap_in__ns1__InsShippingPalleResponse(struct soap *soap, const char *tag, _ns1__InsShippingPalleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsShippingPalleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsShippingPalleResponse, sizeof(_ns1__InsShippingPalleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsShippingPalleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsShippingPalleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsShippingPalleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsShippingPalleResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsShippingPalleResult", &a->_ns1__InsShippingPalleResponse::InsShippingPalleResult, "xsd:string"))
				{	soap_flag_InsShippingPalleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsShippingPalleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsShippingPalleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsShippingPalleResponse, SOAP_TYPE__ns1__InsShippingPalleResponse, sizeof(_ns1__InsShippingPalleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsShippingPalleResponse * SOAP_FMAC2 soap_instantiate__ns1__InsShippingPalleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsShippingPalleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsShippingPalleResponse *p;
	size_t k = sizeof(_ns1__InsShippingPalleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsShippingPalleResponse);
		if (p)
			((_ns1__InsShippingPalleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsShippingPalleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsShippingPalleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsShippingPalleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsShippingPalleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsShippingPalleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsShippingPalleResponse(soap, tag ? tag : "ns1:InsShippingPalleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsShippingPalleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsShippingPalleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsShippingPalleResponse * SOAP_FMAC4 soap_get__ns1__InsShippingPalleResponse(struct soap *soap, _ns1__InsShippingPalleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsShippingPalleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsShippingPalle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsShippingPalle::ListNo = NULL;
	this->_ns1__InsShippingPalle::CarNo = NULL;
	this->_ns1__InsShippingPalle::PalQty = NULL;
	this->_ns1__InsShippingPalle::strUser = NULL;
	/* transient soap skipped */
}

void _ns1__InsShippingPalle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingPalle::ListNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingPalle::CarNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingPalle::PalQty);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsShippingPalle::strUser);
#endif
}

int _ns1__InsShippingPalle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsShippingPalle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsShippingPalle(struct soap *soap, const char *tag, int id, const _ns1__InsShippingPalle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsShippingPalle), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ListNo", -1, &a->_ns1__InsShippingPalle::ListNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CarNo", -1, &a->_ns1__InsShippingPalle::CarNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PalQty", -1, &a->_ns1__InsShippingPalle::PalQty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUser", -1, &a->_ns1__InsShippingPalle::strUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsShippingPalle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsShippingPalle(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsShippingPalle * SOAP_FMAC4 soap_in__ns1__InsShippingPalle(struct soap *soap, const char *tag, _ns1__InsShippingPalle *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsShippingPalle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsShippingPalle, sizeof(_ns1__InsShippingPalle), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsShippingPalle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsShippingPalle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ListNo1 = 1;
	size_t soap_flag_CarNo1 = 1;
	size_t soap_flag_PalQty1 = 1;
	size_t soap_flag_strUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ListNo", &a->_ns1__InsShippingPalle::ListNo, "xsd:string"))
				{	soap_flag_ListNo1--;
					continue;
				}
			}
			if (soap_flag_CarNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CarNo", &a->_ns1__InsShippingPalle::CarNo, "xsd:string"))
				{	soap_flag_CarNo1--;
					continue;
				}
			}
			if (soap_flag_PalQty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PalQty", &a->_ns1__InsShippingPalle::PalQty, "xsd:string"))
				{	soap_flag_PalQty1--;
					continue;
				}
			}
			if (soap_flag_strUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUser", &a->_ns1__InsShippingPalle::strUser, "xsd:string"))
				{	soap_flag_strUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsShippingPalle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsShippingPalle, SOAP_TYPE__ns1__InsShippingPalle, sizeof(_ns1__InsShippingPalle), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsShippingPalle * SOAP_FMAC2 soap_instantiate__ns1__InsShippingPalle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsShippingPalle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsShippingPalle *p;
	size_t k = sizeof(_ns1__InsShippingPalle);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsShippingPalle);
		if (p)
			((_ns1__InsShippingPalle*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsShippingPalle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsShippingPalle*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsShippingPalle location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsShippingPalle, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsShippingPalle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsShippingPalle(soap, tag ? tag : "ns1:InsShippingPalle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsShippingPalle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsShippingPalle(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsShippingPalle * SOAP_FMAC4 soap_get__ns1__InsShippingPalle(struct soap *soap, _ns1__InsShippingPalle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsShippingPalle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingPalleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingPalleResponse::GetShippingPalleResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingPalleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingPalleResponse::GetShippingPalleResult);
#endif
}

int _ns1__GetShippingPalleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingPalleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingPalleResponse(struct soap *soap, const char *tag, int id, const _ns1__GetShippingPalleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingPalleResponse), type))
		return soap->error;
	if (a->GetShippingPalleResult)
		soap_element_result(soap, "ns1:GetShippingPalleResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetShippingPalleResult", -1, &a->_ns1__GetShippingPalleResponse::GetShippingPalleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingPalleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingPalleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingPalleResponse * SOAP_FMAC4 soap_in__ns1__GetShippingPalleResponse(struct soap *soap, const char *tag, _ns1__GetShippingPalleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingPalleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingPalleResponse, sizeof(_ns1__GetShippingPalleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingPalleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingPalleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetShippingPalleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShippingPalleResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetShippingPalleResult", &a->_ns1__GetShippingPalleResponse::GetShippingPalleResult, "xsd:string"))
				{	soap_flag_GetShippingPalleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetShippingPalleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingPalleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingPalleResponse, SOAP_TYPE__ns1__GetShippingPalleResponse, sizeof(_ns1__GetShippingPalleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingPalleResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingPalleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingPalleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingPalleResponse *p;
	size_t k = sizeof(_ns1__GetShippingPalleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingPalleResponse);
		if (p)
			((_ns1__GetShippingPalleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingPalleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingPalleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingPalleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingPalleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingPalleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingPalleResponse(soap, tag ? tag : "ns1:GetShippingPalleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingPalleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingPalleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingPalleResponse * SOAP_FMAC4 soap_get__ns1__GetShippingPalleResponse(struct soap *soap, _ns1__GetShippingPalleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingPalleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingPalle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingPalle::ListNo = NULL;
	this->_ns1__GetShippingPalle::CarNo = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingPalle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingPalle::ListNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingPalle::CarNo);
#endif
}

int _ns1__GetShippingPalle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingPalle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingPalle(struct soap *soap, const char *tag, int id, const _ns1__GetShippingPalle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingPalle), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ListNo", -1, &a->_ns1__GetShippingPalle::ListNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CarNo", -1, &a->_ns1__GetShippingPalle::CarNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingPalle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingPalle(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingPalle * SOAP_FMAC4 soap_in__ns1__GetShippingPalle(struct soap *soap, const char *tag, _ns1__GetShippingPalle *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingPalle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingPalle, sizeof(_ns1__GetShippingPalle), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingPalle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingPalle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ListNo1 = 1;
	size_t soap_flag_CarNo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ListNo", &a->_ns1__GetShippingPalle::ListNo, "xsd:string"))
				{	soap_flag_ListNo1--;
					continue;
				}
			}
			if (soap_flag_CarNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CarNo", &a->_ns1__GetShippingPalle::CarNo, "xsd:string"))
				{	soap_flag_CarNo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingPalle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingPalle, SOAP_TYPE__ns1__GetShippingPalle, sizeof(_ns1__GetShippingPalle), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingPalle * SOAP_FMAC2 soap_instantiate__ns1__GetShippingPalle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingPalle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingPalle *p;
	size_t k = sizeof(_ns1__GetShippingPalle);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingPalle);
		if (p)
			((_ns1__GetShippingPalle*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingPalle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingPalle*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingPalle location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingPalle, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingPalle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingPalle(soap, tag ? tag : "ns1:GetShippingPalle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingPalle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingPalle(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingPalle * SOAP_FMAC4 soap_get__ns1__GetShippingPalle(struct soap *soap, _ns1__GetShippingPalle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingPalle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdShippingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdShippingResponse::UpdShippingResult = NULL;
	/* transient soap skipped */
}

void _ns1__UpdShippingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdShippingResponse::UpdShippingResult);
#endif
}

int _ns1__UpdShippingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdShippingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdShippingResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdShippingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdShippingResponse), type))
		return soap->error;
	if (a->UpdShippingResult)
		soap_element_result(soap, "ns1:UpdShippingResult");
	if (soap_out_PointerTostd__string(soap, "ns1:UpdShippingResult", -1, &a->_ns1__UpdShippingResponse::UpdShippingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdShippingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdShippingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdShippingResponse * SOAP_FMAC4 soap_in__ns1__UpdShippingResponse(struct soap *soap, const char *tag, _ns1__UpdShippingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdShippingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdShippingResponse, sizeof(_ns1__UpdShippingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdShippingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdShippingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpdShippingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdShippingResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UpdShippingResult", &a->_ns1__UpdShippingResponse::UpdShippingResult, "xsd:string"))
				{	soap_flag_UpdShippingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UpdShippingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdShippingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdShippingResponse, SOAP_TYPE__ns1__UpdShippingResponse, sizeof(_ns1__UpdShippingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdShippingResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdShippingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdShippingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdShippingResponse *p;
	size_t k = sizeof(_ns1__UpdShippingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdShippingResponse);
		if (p)
			((_ns1__UpdShippingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdShippingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdShippingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdShippingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdShippingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdShippingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdShippingResponse(soap, tag ? tag : "ns1:UpdShippingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdShippingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdShippingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdShippingResponse * SOAP_FMAC4 soap_get__ns1__UpdShippingResponse(struct soap *soap, _ns1__UpdShippingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdShippingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdShipping::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdShipping::ListNo = NULL;
	this->_ns1__UpdShipping::CarNo = NULL;
	this->_ns1__UpdShipping::RealTime = NULL;
	/* transient soap skipped */
}

void _ns1__UpdShipping::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdShipping::ListNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdShipping::CarNo);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdShipping::RealTime);
#endif
}

int _ns1__UpdShipping::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdShipping(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdShipping(struct soap *soap, const char *tag, int id, const _ns1__UpdShipping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdShipping), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ListNo", -1, &a->_ns1__UpdShipping::ListNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CarNo", -1, &a->_ns1__UpdShipping::CarNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:RealTime", -1, &a->_ns1__UpdShipping::RealTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdShipping::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdShipping(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdShipping * SOAP_FMAC4 soap_in__ns1__UpdShipping(struct soap *soap, const char *tag, _ns1__UpdShipping *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdShipping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdShipping, sizeof(_ns1__UpdShipping), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdShipping)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdShipping *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ListNo1 = 1;
	size_t soap_flag_CarNo1 = 1;
	size_t soap_flag_RealTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ListNo", &a->_ns1__UpdShipping::ListNo, "xsd:string"))
				{	soap_flag_ListNo1--;
					continue;
				}
			}
			if (soap_flag_CarNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:CarNo", &a->_ns1__UpdShipping::CarNo, "xsd:string"))
				{	soap_flag_CarNo1--;
					continue;
				}
			}
			if (soap_flag_RealTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:RealTime", &a->_ns1__UpdShipping::RealTime, "xsd:string"))
				{	soap_flag_RealTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdShipping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdShipping, SOAP_TYPE__ns1__UpdShipping, sizeof(_ns1__UpdShipping), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdShipping * SOAP_FMAC2 soap_instantiate__ns1__UpdShipping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdShipping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdShipping *p;
	size_t k = sizeof(_ns1__UpdShipping);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdShipping);
		if (p)
			((_ns1__UpdShipping*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdShipping, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdShipping*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdShipping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdShipping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdShipping::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdShipping(soap, tag ? tag : "ns1:UpdShipping", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdShipping::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdShipping(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdShipping * SOAP_FMAC4 soap_get__ns1__UpdShipping(struct soap *soap, _ns1__UpdShipping *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdShipping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingBerthListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingBerthListResponse::GetShippingBerthListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingBerthListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, &this->_ns1__GetShippingBerthListResponse::GetShippingBerthListResult);
#endif
}

int _ns1__GetShippingBerthListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingBerthListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingBerthListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetShippingBerthListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingBerthListResponse), type))
		return soap->error;
	if (a->GetShippingBerthListResult)
		soap_element_result(soap, "ns1:GetShippingBerthListResult");
	if (soap_out_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, "ns1:GetShippingBerthListResult", -1, &a->_ns1__GetShippingBerthListResponse::GetShippingBerthListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingBerthListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingBerthListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingBerthListResponse * SOAP_FMAC4 soap_in__ns1__GetShippingBerthListResponse(struct soap *soap, const char *tag, _ns1__GetShippingBerthListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingBerthListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingBerthListResponse, sizeof(_ns1__GetShippingBerthListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingBerthListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingBerthListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetShippingBerthListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShippingBerthListResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, "ns1:GetShippingBerthListResult", &a->_ns1__GetShippingBerthListResponse::GetShippingBerthListResult, ""))
				{	soap_flag_GetShippingBerthListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetShippingBerthListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingBerthListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingBerthListResponse, SOAP_TYPE__ns1__GetShippingBerthListResponse, sizeof(_ns1__GetShippingBerthListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingBerthListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingBerthListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingBerthListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingBerthListResponse *p;
	size_t k = sizeof(_ns1__GetShippingBerthListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingBerthListResponse);
		if (p)
			((_ns1__GetShippingBerthListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingBerthListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingBerthListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingBerthListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingBerthListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingBerthListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingBerthListResponse(soap, tag ? tag : "ns1:GetShippingBerthListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingBerthListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingBerthListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingBerthListResponse * SOAP_FMAC4 soap_get__ns1__GetShippingBerthListResponse(struct soap *soap, _ns1__GetShippingBerthListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingBerthListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingBerthList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingBerthList::strBerth = NULL;
	this->_ns1__GetShippingBerthList::strCar = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingBerthList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingBerthList::strBerth);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingBerthList::strCar);
#endif
}

int _ns1__GetShippingBerthList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingBerthList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingBerthList(struct soap *soap, const char *tag, int id, const _ns1__GetShippingBerthList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingBerthList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strBerth", -1, &a->_ns1__GetShippingBerthList::strBerth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strCar", -1, &a->_ns1__GetShippingBerthList::strCar, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingBerthList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingBerthList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingBerthList * SOAP_FMAC4 soap_in__ns1__GetShippingBerthList(struct soap *soap, const char *tag, _ns1__GetShippingBerthList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingBerthList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingBerthList, sizeof(_ns1__GetShippingBerthList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingBerthList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingBerthList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strBerth1 = 1;
	size_t soap_flag_strCar1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strBerth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strBerth", &a->_ns1__GetShippingBerthList::strBerth, "xsd:string"))
				{	soap_flag_strBerth1--;
					continue;
				}
			}
			if (soap_flag_strCar1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strCar", &a->_ns1__GetShippingBerthList::strCar, "xsd:string"))
				{	soap_flag_strCar1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingBerthList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingBerthList, SOAP_TYPE__ns1__GetShippingBerthList, sizeof(_ns1__GetShippingBerthList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingBerthList * SOAP_FMAC2 soap_instantiate__ns1__GetShippingBerthList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingBerthList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingBerthList *p;
	size_t k = sizeof(_ns1__GetShippingBerthList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingBerthList);
		if (p)
			((_ns1__GetShippingBerthList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingBerthList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingBerthList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingBerthList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingBerthList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingBerthList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingBerthList(soap, tag ? tag : "ns1:GetShippingBerthList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingBerthList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingBerthList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingBerthList * SOAP_FMAC4 soap_get__ns1__GetShippingBerthList(struct soap *soap, _ns1__GetShippingBerthList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingBerthList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingListResponse::GetShippingListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, &this->_ns1__GetShippingListResponse::GetShippingListResult);
#endif
}

int _ns1__GetShippingListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetShippingListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingListResponse), type))
		return soap->error;
	if (a->GetShippingListResult)
		soap_element_result(soap, "ns1:GetShippingListResult");
	if (soap_out_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, "ns1:GetShippingListResult", -1, &a->_ns1__GetShippingListResponse::GetShippingListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingListResponse * SOAP_FMAC4 soap_in__ns1__GetShippingListResponse(struct soap *soap, const char *tag, _ns1__GetShippingListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingListResponse, sizeof(_ns1__GetShippingListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetShippingListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShippingListResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, "ns1:GetShippingListResult", &a->_ns1__GetShippingListResponse::GetShippingListResult, ""))
				{	soap_flag_GetShippingListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetShippingListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingListResponse, SOAP_TYPE__ns1__GetShippingListResponse, sizeof(_ns1__GetShippingListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShippingListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingListResponse *p;
	size_t k = sizeof(_ns1__GetShippingListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingListResponse);
		if (p)
			((_ns1__GetShippingListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingListResponse(soap, tag ? tag : "ns1:GetShippingListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingListResponse * SOAP_FMAC4 soap_get__ns1__GetShippingListResponse(struct soap *soap, _ns1__GetShippingListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShippingList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShippingList::strDate = NULL;
	/* transient soap skipped */
}

void _ns1__GetShippingList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetShippingList::strDate);
#endif
}

int _ns1__GetShippingList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShippingList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShippingList(struct soap *soap, const char *tag, int id, const _ns1__GetShippingList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShippingList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strDate", -1, &a->_ns1__GetShippingList::strDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShippingList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShippingList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShippingList * SOAP_FMAC4 soap_in__ns1__GetShippingList(struct soap *soap, const char *tag, _ns1__GetShippingList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShippingList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShippingList, sizeof(_ns1__GetShippingList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShippingList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShippingList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strDate", &a->_ns1__GetShippingList::strDate, "xsd:string"))
				{	soap_flag_strDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShippingList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShippingList, SOAP_TYPE__ns1__GetShippingList, sizeof(_ns1__GetShippingList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShippingList * SOAP_FMAC2 soap_instantiate__ns1__GetShippingList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShippingList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShippingList *p;
	size_t k = sizeof(_ns1__GetShippingList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetShippingList);
		if (p)
			((_ns1__GetShippingList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetShippingList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetShippingList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShippingList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetShippingList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetShippingList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShippingList(soap, tag ? tag : "ns1:GetShippingList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShippingList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShippingList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShippingList * SOAP_FMAC4 soap_get__ns1__GetShippingList(struct soap *soap, _ns1__GetShippingList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShippingList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doLotLinkForAppleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doLotLinkForAppleResponse::doLotLinkForAppleResult = NULL;
	/* transient soap skipped */
}

void _ns1__doLotLinkForAppleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLotLinkForAppleResponse::doLotLinkForAppleResult);
#endif
}

int _ns1__doLotLinkForAppleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doLotLinkForAppleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doLotLinkForAppleResponse(struct soap *soap, const char *tag, int id, const _ns1__doLotLinkForAppleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doLotLinkForAppleResponse), type))
		return soap->error;
	if (a->doLotLinkForAppleResult)
		soap_element_result(soap, "ns1:doLotLinkForAppleResult");
	if (soap_out_PointerTostd__string(soap, "ns1:doLotLinkForAppleResult", -1, &a->_ns1__doLotLinkForAppleResponse::doLotLinkForAppleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doLotLinkForAppleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doLotLinkForAppleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doLotLinkForAppleResponse * SOAP_FMAC4 soap_in__ns1__doLotLinkForAppleResponse(struct soap *soap, const char *tag, _ns1__doLotLinkForAppleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doLotLinkForAppleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doLotLinkForAppleResponse, sizeof(_ns1__doLotLinkForAppleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doLotLinkForAppleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doLotLinkForAppleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_doLotLinkForAppleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_doLotLinkForAppleResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:doLotLinkForAppleResult", &a->_ns1__doLotLinkForAppleResponse::doLotLinkForAppleResult, "xsd:string"))
				{	soap_flag_doLotLinkForAppleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:doLotLinkForAppleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doLotLinkForAppleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doLotLinkForAppleResponse, SOAP_TYPE__ns1__doLotLinkForAppleResponse, sizeof(_ns1__doLotLinkForAppleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doLotLinkForAppleResponse * SOAP_FMAC2 soap_instantiate__ns1__doLotLinkForAppleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doLotLinkForAppleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doLotLinkForAppleResponse *p;
	size_t k = sizeof(_ns1__doLotLinkForAppleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doLotLinkForAppleResponse);
		if (p)
			((_ns1__doLotLinkForAppleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doLotLinkForAppleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doLotLinkForAppleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doLotLinkForAppleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doLotLinkForAppleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doLotLinkForAppleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doLotLinkForAppleResponse(soap, tag ? tag : "ns1:doLotLinkForAppleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doLotLinkForAppleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doLotLinkForAppleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doLotLinkForAppleResponse * SOAP_FMAC4 soap_get__ns1__doLotLinkForAppleResponse(struct soap *soap, _ns1__doLotLinkForAppleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doLotLinkForAppleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doLotLinkForApple::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doLotLinkForApple::assyDt = NULL;
	this->_ns1__doLotLinkForApple::empNO = NULL;
	this->_ns1__doLotLinkForApple::SN = NULL;
	this->_ns1__doLotLinkForApple::Station = NULL;
	/* transient soap skipped */
}

void _ns1__doLotLinkForApple::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doLotLinkForApple_assyDt(soap, &this->_ns1__doLotLinkForApple::assyDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLotLinkForApple::empNO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLotLinkForApple::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doLotLinkForApple::Station);
#endif
}

int _ns1__doLotLinkForApple::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doLotLinkForApple(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doLotLinkForApple(struct soap *soap, const char *tag, int id, const _ns1__doLotLinkForApple *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doLotLinkForApple), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__doLotLinkForApple_assyDt(soap, "ns1:assyDt", -1, &a->_ns1__doLotLinkForApple::assyDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:empNO", -1, &a->_ns1__doLotLinkForApple::empNO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__doLotLinkForApple::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__doLotLinkForApple::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doLotLinkForApple::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doLotLinkForApple(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doLotLinkForApple * SOAP_FMAC4 soap_in__ns1__doLotLinkForApple(struct soap *soap, const char *tag, _ns1__doLotLinkForApple *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doLotLinkForApple *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doLotLinkForApple, sizeof(_ns1__doLotLinkForApple), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doLotLinkForApple)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doLotLinkForApple *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assyDt1 = 1;
	size_t soap_flag_empNO1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assyDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doLotLinkForApple_assyDt(soap, "ns1:assyDt", &a->_ns1__doLotLinkForApple::assyDt, ""))
				{	soap_flag_assyDt1--;
					continue;
				}
			}
			if (soap_flag_empNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:empNO", &a->_ns1__doLotLinkForApple::empNO, "xsd:string"))
				{	soap_flag_empNO1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__doLotLinkForApple::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__doLotLinkForApple::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doLotLinkForApple *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doLotLinkForApple, SOAP_TYPE__ns1__doLotLinkForApple, sizeof(_ns1__doLotLinkForApple), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doLotLinkForApple * SOAP_FMAC2 soap_instantiate__ns1__doLotLinkForApple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doLotLinkForApple(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doLotLinkForApple *p;
	size_t k = sizeof(_ns1__doLotLinkForApple);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doLotLinkForApple);
		if (p)
			((_ns1__doLotLinkForApple*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doLotLinkForApple, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doLotLinkForApple*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doLotLinkForApple location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doLotLinkForApple, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doLotLinkForApple::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doLotLinkForApple(soap, tag ? tag : "ns1:doLotLinkForApple", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doLotLinkForApple::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doLotLinkForApple(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doLotLinkForApple * SOAP_FMAC4 soap_get__ns1__doLotLinkForApple(struct soap *soap, _ns1__doLotLinkForApple *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doLotLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLotLinkCountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetLotLinkCountResponse::GetLotLinkCountResult);
	/* transient soap skipped */
}

void _ns1__GetLotLinkCountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetLotLinkCountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotLinkCountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotLinkCountResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLotLinkCountResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotLinkCountResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetLotLinkCountResult");
	if (soap_out_int(soap, "ns1:GetLotLinkCountResult", -1, &a->_ns1__GetLotLinkCountResponse::GetLotLinkCountResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotLinkCountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotLinkCountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotLinkCountResponse * SOAP_FMAC4 soap_in__ns1__GetLotLinkCountResponse(struct soap *soap, const char *tag, _ns1__GetLotLinkCountResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotLinkCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotLinkCountResponse, sizeof(_ns1__GetLotLinkCountResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLotLinkCountResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLotLinkCountResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLotLinkCountResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLotLinkCountResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:GetLotLinkCountResult", &a->_ns1__GetLotLinkCountResponse::GetLotLinkCountResult, "xsd:int"))
				{	soap_flag_GetLotLinkCountResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetLotLinkCountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetLotLinkCountResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetLotLinkCountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotLinkCountResponse, SOAP_TYPE__ns1__GetLotLinkCountResponse, sizeof(_ns1__GetLotLinkCountResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLotLinkCountResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLotLinkCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotLinkCountResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLotLinkCountResponse *p;
	size_t k = sizeof(_ns1__GetLotLinkCountResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLotLinkCountResponse);
		if (p)
			((_ns1__GetLotLinkCountResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLotLinkCountResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotLinkCountResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLotLinkCountResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLotLinkCountResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLotLinkCountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLotLinkCountResponse(soap, tag ? tag : "ns1:GetLotLinkCountResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotLinkCountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotLinkCountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotLinkCountResponse * SOAP_FMAC4 soap_get__ns1__GetLotLinkCountResponse(struct soap *soap, _ns1__GetLotLinkCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotLinkCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLotLinkCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLotLinkCount::OUT_USCOREPN_USCORESN = NULL;
	/* transient soap skipped */
}

void _ns1__GetLotLinkCount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetLotLinkCount::OUT_USCOREPN_USCORESN);
#endif
}

int _ns1__GetLotLinkCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotLinkCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotLinkCount(struct soap *soap, const char *tag, int id, const _ns1__GetLotLinkCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotLinkCount), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:OUT_PN_SN", -1, &a->_ns1__GetLotLinkCount::OUT_USCOREPN_USCORESN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotLinkCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotLinkCount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotLinkCount * SOAP_FMAC4 soap_in__ns1__GetLotLinkCount(struct soap *soap, const char *tag, _ns1__GetLotLinkCount *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotLinkCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotLinkCount, sizeof(_ns1__GetLotLinkCount), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetLotLinkCount)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLotLinkCount *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OUT_USCOREPN_USCORESN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OUT_USCOREPN_USCORESN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:OUT_PN_SN", &a->_ns1__GetLotLinkCount::OUT_USCOREPN_USCORESN, "xsd:string"))
				{	soap_flag_OUT_USCOREPN_USCORESN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotLinkCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotLinkCount, SOAP_TYPE__ns1__GetLotLinkCount, sizeof(_ns1__GetLotLinkCount), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLotLinkCount * SOAP_FMAC2 soap_instantiate__ns1__GetLotLinkCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotLinkCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLotLinkCount *p;
	size_t k = sizeof(_ns1__GetLotLinkCount);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLotLinkCount);
		if (p)
			((_ns1__GetLotLinkCount*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLotLinkCount, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotLinkCount*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLotLinkCount location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLotLinkCount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLotLinkCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLotLinkCount(soap, tag ? tag : "ns1:GetLotLinkCount", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotLinkCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotLinkCount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotLinkCount * SOAP_FMAC4 soap_get__ns1__GetLotLinkCount(struct soap *soap, _ns1__GetLotLinkCount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotLinkCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFruitSNCheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFruitSNCheckResponse::GetFruitSNCheckResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetFruitSNCheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitSNCheckResponse::GetFruitSNCheckResult);
#endif
}

int _ns1__GetFruitSNCheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFruitSNCheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFruitSNCheckResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFruitSNCheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFruitSNCheckResponse), type))
		return soap->error;
	if (a->GetFruitSNCheckResult)
		soap_element_result(soap, "ns1:GetFruitSNCheckResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetFruitSNCheckResult", -1, &a->_ns1__GetFruitSNCheckResponse::GetFruitSNCheckResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFruitSNCheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFruitSNCheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFruitSNCheckResponse * SOAP_FMAC4 soap_in__ns1__GetFruitSNCheckResponse(struct soap *soap, const char *tag, _ns1__GetFruitSNCheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFruitSNCheckResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFruitSNCheckResponse, sizeof(_ns1__GetFruitSNCheckResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFruitSNCheckResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFruitSNCheckResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetFruitSNCheckResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFruitSNCheckResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetFruitSNCheckResult", &a->_ns1__GetFruitSNCheckResponse::GetFruitSNCheckResult, "xsd:string"))
				{	soap_flag_GetFruitSNCheckResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetFruitSNCheckResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFruitSNCheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFruitSNCheckResponse, SOAP_TYPE__ns1__GetFruitSNCheckResponse, sizeof(_ns1__GetFruitSNCheckResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFruitSNCheckResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFruitSNCheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFruitSNCheckResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFruitSNCheckResponse *p;
	size_t k = sizeof(_ns1__GetFruitSNCheckResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetFruitSNCheckResponse);
		if (p)
			((_ns1__GetFruitSNCheckResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetFruitSNCheckResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetFruitSNCheckResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFruitSNCheckResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetFruitSNCheckResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetFruitSNCheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFruitSNCheckResponse(soap, tag ? tag : "ns1:GetFruitSNCheckResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFruitSNCheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFruitSNCheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFruitSNCheckResponse * SOAP_FMAC4 soap_get__ns1__GetFruitSNCheckResponse(struct soap *soap, _ns1__GetFruitSNCheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFruitSNCheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFruitSNCheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFruitSNCheck::SN = NULL;
	this->_ns1__GetFruitSNCheck::Station = NULL;
	/* transient soap skipped */
}

void _ns1__GetFruitSNCheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitSNCheck::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetFruitSNCheck::Station);
#endif
}

int _ns1__GetFruitSNCheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFruitSNCheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFruitSNCheck(struct soap *soap, const char *tag, int id, const _ns1__GetFruitSNCheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFruitSNCheck), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetFruitSNCheck::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__GetFruitSNCheck::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFruitSNCheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFruitSNCheck(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFruitSNCheck * SOAP_FMAC4 soap_in__ns1__GetFruitSNCheck(struct soap *soap, const char *tag, _ns1__GetFruitSNCheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFruitSNCheck *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFruitSNCheck, sizeof(_ns1__GetFruitSNCheck), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFruitSNCheck)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFruitSNCheck *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetFruitSNCheck::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__GetFruitSNCheck::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFruitSNCheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFruitSNCheck, SOAP_TYPE__ns1__GetFruitSNCheck, sizeof(_ns1__GetFruitSNCheck), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFruitSNCheck * SOAP_FMAC2 soap_instantiate__ns1__GetFruitSNCheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFruitSNCheck(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFruitSNCheck *p;
	size_t k = sizeof(_ns1__GetFruitSNCheck);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetFruitSNCheck);
		if (p)
			((_ns1__GetFruitSNCheck*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetFruitSNCheck, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetFruitSNCheck*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFruitSNCheck location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetFruitSNCheck, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetFruitSNCheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFruitSNCheck(soap, tag ? tag : "ns1:GetFruitSNCheck", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFruitSNCheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFruitSNCheck(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFruitSNCheck * SOAP_FMAC4 soap_get__ns1__GetFruitSNCheck(struct soap *soap, _ns1__GetFruitSNCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFruitSNCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetObeNWResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetObeNWResponse::GetObeNWResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetObeNWResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObeNWResponse::GetObeNWResult);
#endif
}

int _ns1__GetObeNWResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObeNWResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObeNWResponse(struct soap *soap, const char *tag, int id, const _ns1__GetObeNWResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObeNWResponse), type))
		return soap->error;
	if (a->GetObeNWResult)
		soap_element_result(soap, "ns1:GetObeNWResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetObeNWResult", -1, &a->_ns1__GetObeNWResponse::GetObeNWResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObeNWResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObeNWResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObeNWResponse * SOAP_FMAC4 soap_in__ns1__GetObeNWResponse(struct soap *soap, const char *tag, _ns1__GetObeNWResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObeNWResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObeNWResponse, sizeof(_ns1__GetObeNWResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetObeNWResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetObeNWResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetObeNWResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetObeNWResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GetObeNWResult", &a->_ns1__GetObeNWResponse::GetObeNWResult, "xsd:string"))
				{	soap_flag_GetObeNWResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetObeNWResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObeNWResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObeNWResponse, SOAP_TYPE__ns1__GetObeNWResponse, sizeof(_ns1__GetObeNWResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetObeNWResponse * SOAP_FMAC2 soap_instantiate__ns1__GetObeNWResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObeNWResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetObeNWResponse *p;
	size_t k = sizeof(_ns1__GetObeNWResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetObeNWResponse);
		if (p)
			((_ns1__GetObeNWResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetObeNWResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetObeNWResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetObeNWResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetObeNWResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetObeNWResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetObeNWResponse(soap, tag ? tag : "ns1:GetObeNWResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObeNWResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObeNWResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObeNWResponse * SOAP_FMAC4 soap_get__ns1__GetObeNWResponse(struct soap *soap, _ns1__GetObeNWResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObeNWResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetObeNW::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetObeNW::SN = NULL;
	/* transient soap skipped */
}

void _ns1__GetObeNW::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObeNW::SN);
#endif
}

int _ns1__GetObeNW::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObeNW(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObeNW(struct soap *soap, const char *tag, int id, const _ns1__GetObeNW *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObeNW), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__GetObeNW::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObeNW::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObeNW(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObeNW * SOAP_FMAC4 soap_in__ns1__GetObeNW(struct soap *soap, const char *tag, _ns1__GetObeNW *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObeNW *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObeNW, sizeof(_ns1__GetObeNW), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetObeNW)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetObeNW *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__GetObeNW::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObeNW *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObeNW, SOAP_TYPE__ns1__GetObeNW, sizeof(_ns1__GetObeNW), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetObeNW * SOAP_FMAC2 soap_instantiate__ns1__GetObeNW(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObeNW(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetObeNW *p;
	size_t k = sizeof(_ns1__GetObeNW);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetObeNW);
		if (p)
			((_ns1__GetObeNW*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetObeNW, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetObeNW*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetObeNW location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetObeNW, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetObeNW::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetObeNW(soap, tag ? tag : "ns1:GetObeNW", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObeNW::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObeNW(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObeNW * SOAP_FMAC4 soap_get__ns1__GetObeNW(struct soap *soap, _ns1__GetObeNW *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObeNW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doSnLinkForAppleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doSnLinkForAppleResponse::doSnLinkForAppleResult = NULL;
	/* transient soap skipped */
}

void _ns1__doSnLinkForAppleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doSnLinkForAppleResponse::doSnLinkForAppleResult);
#endif
}

int _ns1__doSnLinkForAppleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doSnLinkForAppleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doSnLinkForAppleResponse(struct soap *soap, const char *tag, int id, const _ns1__doSnLinkForAppleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doSnLinkForAppleResponse), type))
		return soap->error;
	if (a->doSnLinkForAppleResult)
		soap_element_result(soap, "ns1:doSnLinkForAppleResult");
	if (soap_out_PointerTostd__string(soap, "ns1:doSnLinkForAppleResult", -1, &a->_ns1__doSnLinkForAppleResponse::doSnLinkForAppleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doSnLinkForAppleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doSnLinkForAppleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doSnLinkForAppleResponse * SOAP_FMAC4 soap_in__ns1__doSnLinkForAppleResponse(struct soap *soap, const char *tag, _ns1__doSnLinkForAppleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doSnLinkForAppleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doSnLinkForAppleResponse, sizeof(_ns1__doSnLinkForAppleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doSnLinkForAppleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doSnLinkForAppleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_doSnLinkForAppleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_doSnLinkForAppleResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:doSnLinkForAppleResult", &a->_ns1__doSnLinkForAppleResponse::doSnLinkForAppleResult, "xsd:string"))
				{	soap_flag_doSnLinkForAppleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:doSnLinkForAppleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doSnLinkForAppleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doSnLinkForAppleResponse, SOAP_TYPE__ns1__doSnLinkForAppleResponse, sizeof(_ns1__doSnLinkForAppleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doSnLinkForAppleResponse * SOAP_FMAC2 soap_instantiate__ns1__doSnLinkForAppleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doSnLinkForAppleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doSnLinkForAppleResponse *p;
	size_t k = sizeof(_ns1__doSnLinkForAppleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doSnLinkForAppleResponse);
		if (p)
			((_ns1__doSnLinkForAppleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doSnLinkForAppleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doSnLinkForAppleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doSnLinkForAppleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doSnLinkForAppleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doSnLinkForAppleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doSnLinkForAppleResponse(soap, tag ? tag : "ns1:doSnLinkForAppleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doSnLinkForAppleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doSnLinkForAppleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doSnLinkForAppleResponse * SOAP_FMAC4 soap_get__ns1__doSnLinkForAppleResponse(struct soap *soap, _ns1__doSnLinkForAppleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doSnLinkForAppleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__doSnLinkForApple::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__doSnLinkForApple::assyDt = NULL;
	this->_ns1__doSnLinkForApple::empNO = NULL;
	this->_ns1__doSnLinkForApple::SN = NULL;
	this->_ns1__doSnLinkForApple::Station = NULL;
	/* transient soap skipped */
}

void _ns1__doSnLinkForApple::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doSnLinkForApple_assyDt(soap, &this->_ns1__doSnLinkForApple::assyDt);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doSnLinkForApple::empNO);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doSnLinkForApple::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__doSnLinkForApple::Station);
#endif
}

int _ns1__doSnLinkForApple::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__doSnLinkForApple(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__doSnLinkForApple(struct soap *soap, const char *tag, int id, const _ns1__doSnLinkForApple *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__doSnLinkForApple), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__doSnLinkForApple_assyDt(soap, "ns1:assyDt", -1, &a->_ns1__doSnLinkForApple::assyDt, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:empNO", -1, &a->_ns1__doSnLinkForApple::empNO, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__doSnLinkForApple::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Station", -1, &a->_ns1__doSnLinkForApple::Station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__doSnLinkForApple::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__doSnLinkForApple(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__doSnLinkForApple * SOAP_FMAC4 soap_in__ns1__doSnLinkForApple(struct soap *soap, const char *tag, _ns1__doSnLinkForApple *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__doSnLinkForApple *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__doSnLinkForApple, sizeof(_ns1__doSnLinkForApple), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__doSnLinkForApple)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__doSnLinkForApple *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assyDt1 = 1;
	size_t soap_flag_empNO1 = 1;
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_Station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assyDt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doSnLinkForApple_assyDt(soap, "ns1:assyDt", &a->_ns1__doSnLinkForApple::assyDt, ""))
				{	soap_flag_assyDt1--;
					continue;
				}
			}
			if (soap_flag_empNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:empNO", &a->_ns1__doSnLinkForApple::empNO, "xsd:string"))
				{	soap_flag_empNO1--;
					continue;
				}
			}
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__doSnLinkForApple::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_Station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Station", &a->_ns1__doSnLinkForApple::Station, "xsd:string"))
				{	soap_flag_Station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__doSnLinkForApple *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__doSnLinkForApple, SOAP_TYPE__ns1__doSnLinkForApple, sizeof(_ns1__doSnLinkForApple), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__doSnLinkForApple * SOAP_FMAC2 soap_instantiate__ns1__doSnLinkForApple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__doSnLinkForApple(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__doSnLinkForApple *p;
	size_t k = sizeof(_ns1__doSnLinkForApple);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__doSnLinkForApple);
		if (p)
			((_ns1__doSnLinkForApple*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__doSnLinkForApple, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__doSnLinkForApple*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__doSnLinkForApple location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__doSnLinkForApple, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__doSnLinkForApple::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__doSnLinkForApple(soap, tag ? tag : "ns1:doSnLinkForApple", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__doSnLinkForApple::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__doSnLinkForApple(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__doSnLinkForApple * SOAP_FMAC4 soap_get__ns1__doSnLinkForApple(struct soap *soap, _ns1__doSnLinkForApple *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__doSnLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnLinkForAppleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnLinkForAppleResponse::ChkSnLinkForAppleResult = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnLinkForAppleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnLinkForAppleResponse::ChkSnLinkForAppleResult);
#endif
}

int _ns1__ChkSnLinkForAppleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnLinkForAppleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnLinkForAppleResponse(struct soap *soap, const char *tag, int id, const _ns1__ChkSnLinkForAppleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnLinkForAppleResponse), type))
		return soap->error;
	if (a->ChkSnLinkForAppleResult)
		soap_element_result(soap, "ns1:ChkSnLinkForAppleResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ChkSnLinkForAppleResult", -1, &a->_ns1__ChkSnLinkForAppleResponse::ChkSnLinkForAppleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnLinkForAppleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnLinkForAppleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnLinkForAppleResponse * SOAP_FMAC4 soap_in__ns1__ChkSnLinkForAppleResponse(struct soap *soap, const char *tag, _ns1__ChkSnLinkForAppleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnLinkForAppleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnLinkForAppleResponse, sizeof(_ns1__ChkSnLinkForAppleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnLinkForAppleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnLinkForAppleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChkSnLinkForAppleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChkSnLinkForAppleResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ChkSnLinkForAppleResult", &a->_ns1__ChkSnLinkForAppleResponse::ChkSnLinkForAppleResult, "xsd:string"))
				{	soap_flag_ChkSnLinkForAppleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChkSnLinkForAppleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnLinkForAppleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnLinkForAppleResponse, SOAP_TYPE__ns1__ChkSnLinkForAppleResponse, sizeof(_ns1__ChkSnLinkForAppleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnLinkForAppleResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLinkForAppleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnLinkForAppleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnLinkForAppleResponse *p;
	size_t k = sizeof(_ns1__ChkSnLinkForAppleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnLinkForAppleResponse);
		if (p)
			((_ns1__ChkSnLinkForAppleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnLinkForAppleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnLinkForAppleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnLinkForAppleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnLinkForAppleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnLinkForAppleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnLinkForAppleResponse(soap, tag ? tag : "ns1:ChkSnLinkForAppleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnLinkForAppleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnLinkForAppleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnLinkForAppleResponse * SOAP_FMAC4 soap_get__ns1__ChkSnLinkForAppleResponse(struct soap *soap, _ns1__ChkSnLinkForAppleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnLinkForAppleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkSnLinkForApple::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkSnLinkForApple::SN = NULL;
	/* transient soap skipped */
}

void _ns1__ChkSnLinkForApple::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkSnLinkForApple::SN);
#endif
}

int _ns1__ChkSnLinkForApple::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkSnLinkForApple(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkSnLinkForApple(struct soap *soap, const char *tag, int id, const _ns1__ChkSnLinkForApple *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkSnLinkForApple), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ChkSnLinkForApple::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkSnLinkForApple::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkSnLinkForApple(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkSnLinkForApple * SOAP_FMAC4 soap_in__ns1__ChkSnLinkForApple(struct soap *soap, const char *tag, _ns1__ChkSnLinkForApple *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkSnLinkForApple *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkSnLinkForApple, sizeof(_ns1__ChkSnLinkForApple), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkSnLinkForApple)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkSnLinkForApple *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ChkSnLinkForApple::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkSnLinkForApple *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkSnLinkForApple, SOAP_TYPE__ns1__ChkSnLinkForApple, sizeof(_ns1__ChkSnLinkForApple), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkSnLinkForApple * SOAP_FMAC2 soap_instantiate__ns1__ChkSnLinkForApple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkSnLinkForApple(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkSnLinkForApple *p;
	size_t k = sizeof(_ns1__ChkSnLinkForApple);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkSnLinkForApple);
		if (p)
			((_ns1__ChkSnLinkForApple*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkSnLinkForApple, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkSnLinkForApple*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkSnLinkForApple location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkSnLinkForApple, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkSnLinkForApple::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkSnLinkForApple(soap, tag ? tag : "ns1:ChkSnLinkForApple", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkSnLinkForApple::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkSnLinkForApple(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkSnLinkForApple * SOAP_FMAC4 soap_get__ns1__ChkSnLinkForApple(struct soap *soap, _ns1__ChkSnLinkForApple *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkSnLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DelSNTestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DelSNTestResponse::DelSNTestResult = NULL;
	/* transient soap skipped */
}

void _ns1__DelSNTestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DelSNTestResponse::DelSNTestResult);
#endif
}

int _ns1__DelSNTestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DelSNTestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DelSNTestResponse(struct soap *soap, const char *tag, int id, const _ns1__DelSNTestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DelSNTestResponse), type))
		return soap->error;
	if (a->DelSNTestResult)
		soap_element_result(soap, "ns1:DelSNTestResult");
	if (soap_out_PointerTostd__string(soap, "ns1:DelSNTestResult", -1, &a->_ns1__DelSNTestResponse::DelSNTestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DelSNTestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DelSNTestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DelSNTestResponse * SOAP_FMAC4 soap_in__ns1__DelSNTestResponse(struct soap *soap, const char *tag, _ns1__DelSNTestResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DelSNTestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DelSNTestResponse, sizeof(_ns1__DelSNTestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DelSNTestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DelSNTestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DelSNTestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DelSNTestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DelSNTestResult", &a->_ns1__DelSNTestResponse::DelSNTestResult, "xsd:string"))
				{	soap_flag_DelSNTestResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DelSNTestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DelSNTestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DelSNTestResponse, SOAP_TYPE__ns1__DelSNTestResponse, sizeof(_ns1__DelSNTestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DelSNTestResponse * SOAP_FMAC2 soap_instantiate__ns1__DelSNTestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DelSNTestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DelSNTestResponse *p;
	size_t k = sizeof(_ns1__DelSNTestResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DelSNTestResponse);
		if (p)
			((_ns1__DelSNTestResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DelSNTestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DelSNTestResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DelSNTestResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DelSNTestResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DelSNTestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DelSNTestResponse(soap, tag ? tag : "ns1:DelSNTestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DelSNTestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DelSNTestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DelSNTestResponse * SOAP_FMAC4 soap_get__ns1__DelSNTestResponse(struct soap *soap, _ns1__DelSNTestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DelSNTestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DelSNTest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DelSNTest::SN = NULL;
	/* transient soap skipped */
}

void _ns1__DelSNTest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DelSNTest::SN);
#endif
}

int _ns1__DelSNTest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DelSNTest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DelSNTest(struct soap *soap, const char *tag, int id, const _ns1__DelSNTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DelSNTest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__DelSNTest::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DelSNTest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DelSNTest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DelSNTest * SOAP_FMAC4 soap_in__ns1__DelSNTest(struct soap *soap, const char *tag, _ns1__DelSNTest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DelSNTest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DelSNTest, sizeof(_ns1__DelSNTest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DelSNTest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DelSNTest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__DelSNTest::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DelSNTest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DelSNTest, SOAP_TYPE__ns1__DelSNTest, sizeof(_ns1__DelSNTest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DelSNTest * SOAP_FMAC2 soap_instantiate__ns1__DelSNTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DelSNTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DelSNTest *p;
	size_t k = sizeof(_ns1__DelSNTest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DelSNTest);
		if (p)
			((_ns1__DelSNTest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DelSNTest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DelSNTest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DelSNTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DelSNTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DelSNTest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DelSNTest(soap, tag ? tag : "ns1:DelSNTest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DelSNTest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DelSNTest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DelSNTest * SOAP_FMAC4 soap_get__ns1__DelSNTest(struct soap *soap, _ns1__DelSNTest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DelSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelSNTestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SelSNTestResponse::SelSNTestResult = NULL;
	/* transient soap skipped */
}

void _ns1__SelSNTestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SelSNTestResponse::SelSNTestResult);
#endif
}

int _ns1__SelSNTestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelSNTestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelSNTestResponse(struct soap *soap, const char *tag, int id, const _ns1__SelSNTestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelSNTestResponse), type))
		return soap->error;
	if (a->SelSNTestResult)
		soap_element_result(soap, "ns1:SelSNTestResult");
	if (soap_out_PointerTostd__string(soap, "ns1:SelSNTestResult", -1, &a->_ns1__SelSNTestResponse::SelSNTestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelSNTestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelSNTestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelSNTestResponse * SOAP_FMAC4 soap_in__ns1__SelSNTestResponse(struct soap *soap, const char *tag, _ns1__SelSNTestResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelSNTestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelSNTestResponse, sizeof(_ns1__SelSNTestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelSNTestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelSNTestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelSNTestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelSNTestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SelSNTestResult", &a->_ns1__SelSNTestResponse::SelSNTestResult, "xsd:string"))
				{	soap_flag_SelSNTestResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SelSNTestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelSNTestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelSNTestResponse, SOAP_TYPE__ns1__SelSNTestResponse, sizeof(_ns1__SelSNTestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelSNTestResponse * SOAP_FMAC2 soap_instantiate__ns1__SelSNTestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelSNTestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelSNTestResponse *p;
	size_t k = sizeof(_ns1__SelSNTestResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SelSNTestResponse);
		if (p)
			((_ns1__SelSNTestResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SelSNTestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SelSNTestResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelSNTestResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SelSNTestResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SelSNTestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelSNTestResponse(soap, tag ? tag : "ns1:SelSNTestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelSNTestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelSNTestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelSNTestResponse * SOAP_FMAC4 soap_get__ns1__SelSNTestResponse(struct soap *soap, _ns1__SelSNTestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelSNTestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelSNTest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SelSNTest::SN = NULL;
	/* transient soap skipped */
}

void _ns1__SelSNTest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SelSNTest::SN);
#endif
}

int _ns1__SelSNTest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelSNTest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelSNTest(struct soap *soap, const char *tag, int id, const _ns1__SelSNTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelSNTest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__SelSNTest::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelSNTest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelSNTest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelSNTest * SOAP_FMAC4 soap_in__ns1__SelSNTest(struct soap *soap, const char *tag, _ns1__SelSNTest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelSNTest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelSNTest, sizeof(_ns1__SelSNTest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelSNTest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelSNTest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__SelSNTest::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelSNTest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelSNTest, SOAP_TYPE__ns1__SelSNTest, sizeof(_ns1__SelSNTest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelSNTest * SOAP_FMAC2 soap_instantiate__ns1__SelSNTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelSNTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelSNTest *p;
	size_t k = sizeof(_ns1__SelSNTest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SelSNTest);
		if (p)
			((_ns1__SelSNTest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SelSNTest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SelSNTest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelSNTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SelSNTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SelSNTest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelSNTest(soap, tag ? tag : "ns1:SelSNTest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelSNTest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelSNTest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelSNTest * SOAP_FMAC4 soap_get__ns1__SelSNTest(struct soap *soap, _ns1__SelSNTest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsSNTestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsSNTestResponse::InsSNTestResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsSNTestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTestResponse::InsSNTestResult);
#endif
}

int _ns1__InsSNTestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsSNTestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsSNTestResponse(struct soap *soap, const char *tag, int id, const _ns1__InsSNTestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsSNTestResponse), type))
		return soap->error;
	if (a->InsSNTestResult)
		soap_element_result(soap, "ns1:InsSNTestResult");
	if (soap_out_PointerTostd__string(soap, "ns1:InsSNTestResult", -1, &a->_ns1__InsSNTestResponse::InsSNTestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsSNTestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsSNTestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsSNTestResponse * SOAP_FMAC4 soap_in__ns1__InsSNTestResponse(struct soap *soap, const char *tag, _ns1__InsSNTestResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsSNTestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsSNTestResponse, sizeof(_ns1__InsSNTestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsSNTestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsSNTestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InsSNTestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsSNTestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsSNTestResult", &a->_ns1__InsSNTestResponse::InsSNTestResult, "xsd:string"))
				{	soap_flag_InsSNTestResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:InsSNTestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsSNTestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsSNTestResponse, SOAP_TYPE__ns1__InsSNTestResponse, sizeof(_ns1__InsSNTestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsSNTestResponse * SOAP_FMAC2 soap_instantiate__ns1__InsSNTestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsSNTestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsSNTestResponse *p;
	size_t k = sizeof(_ns1__InsSNTestResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsSNTestResponse);
		if (p)
			((_ns1__InsSNTestResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsSNTestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsSNTestResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsSNTestResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsSNTestResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsSNTestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsSNTestResponse(soap, tag ? tag : "ns1:InsSNTestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsSNTestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsSNTestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsSNTestResponse * SOAP_FMAC4 soap_get__ns1__InsSNTestResponse(struct soap *soap, _ns1__InsSNTestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsSNTestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsSNTest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsSNTest::SN = NULL;
	this->_ns1__InsSNTest::TestResult = NULL;
	/* transient soap skipped */
}

void _ns1__InsSNTest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTest::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsSNTest::TestResult);
#endif
}

int _ns1__InsSNTest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsSNTest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsSNTest(struct soap *soap, const char *tag, int id, const _ns1__InsSNTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsSNTest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__InsSNTest::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestResult", -1, &a->_ns1__InsSNTest::TestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsSNTest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsSNTest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsSNTest * SOAP_FMAC4 soap_in__ns1__InsSNTest(struct soap *soap, const char *tag, _ns1__InsSNTest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsSNTest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsSNTest, sizeof(_ns1__InsSNTest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsSNTest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsSNTest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_TestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__InsSNTest::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_TestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestResult", &a->_ns1__InsSNTest::TestResult, "xsd:string"))
				{	soap_flag_TestResult1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsSNTest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsSNTest, SOAP_TYPE__ns1__InsSNTest, sizeof(_ns1__InsSNTest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsSNTest * SOAP_FMAC2 soap_instantiate__ns1__InsSNTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsSNTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsSNTest *p;
	size_t k = sizeof(_ns1__InsSNTest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsSNTest);
		if (p)
			((_ns1__InsSNTest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsSNTest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsSNTest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsSNTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsSNTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsSNTest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InsSNTest(soap, tag ? tag : "ns1:InsSNTest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsSNTest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsSNTest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsSNTest * SOAP_FMAC4 soap_get__ns1__InsSNTest(struct soap *soap, _ns1__InsSNTest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkWeightTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkWeightTimeResponse::ChkWeightTimeResult = NULL;
	/* transient soap skipped */
}

void _ns1__ChkWeightTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkWeightTimeResponse::ChkWeightTimeResult);
#endif
}

int _ns1__ChkWeightTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkWeightTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkWeightTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__ChkWeightTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkWeightTimeResponse), type))
		return soap->error;
	if (a->ChkWeightTimeResult)
		soap_element_result(soap, "ns1:ChkWeightTimeResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ChkWeightTimeResult", -1, &a->_ns1__ChkWeightTimeResponse::ChkWeightTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkWeightTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkWeightTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkWeightTimeResponse * SOAP_FMAC4 soap_in__ns1__ChkWeightTimeResponse(struct soap *soap, const char *tag, _ns1__ChkWeightTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkWeightTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkWeightTimeResponse, sizeof(_ns1__ChkWeightTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkWeightTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkWeightTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChkWeightTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChkWeightTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ChkWeightTimeResult", &a->_ns1__ChkWeightTimeResponse::ChkWeightTimeResult, "xsd:string"))
				{	soap_flag_ChkWeightTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChkWeightTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkWeightTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkWeightTimeResponse, SOAP_TYPE__ns1__ChkWeightTimeResponse, sizeof(_ns1__ChkWeightTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkWeightTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__ChkWeightTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkWeightTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkWeightTimeResponse *p;
	size_t k = sizeof(_ns1__ChkWeightTimeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkWeightTimeResponse);
		if (p)
			((_ns1__ChkWeightTimeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkWeightTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkWeightTimeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkWeightTimeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkWeightTimeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkWeightTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkWeightTimeResponse(soap, tag ? tag : "ns1:ChkWeightTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkWeightTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkWeightTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkWeightTimeResponse * SOAP_FMAC4 soap_get__ns1__ChkWeightTimeResponse(struct soap *soap, _ns1__ChkWeightTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkWeightTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChkWeightTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ChkWeightTime::SN = NULL;
	this->_ns1__ChkWeightTime::strType = NULL;
	/* transient soap skipped */
}

void _ns1__ChkWeightTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkWeightTime::SN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ChkWeightTime::strType);
#endif
}

int _ns1__ChkWeightTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChkWeightTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChkWeightTime(struct soap *soap, const char *tag, int id, const _ns1__ChkWeightTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChkWeightTime), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:SN", -1, &a->_ns1__ChkWeightTime::SN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strType", -1, &a->_ns1__ChkWeightTime::strType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChkWeightTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChkWeightTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChkWeightTime * SOAP_FMAC4 soap_in__ns1__ChkWeightTime(struct soap *soap, const char *tag, _ns1__ChkWeightTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChkWeightTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChkWeightTime, sizeof(_ns1__ChkWeightTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChkWeightTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChkWeightTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	size_t soap_flag_strType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:SN", &a->_ns1__ChkWeightTime::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap_flag_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strType", &a->_ns1__ChkWeightTime::strType, "xsd:string"))
				{	soap_flag_strType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChkWeightTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChkWeightTime, SOAP_TYPE__ns1__ChkWeightTime, sizeof(_ns1__ChkWeightTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChkWeightTime * SOAP_FMAC2 soap_instantiate__ns1__ChkWeightTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChkWeightTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChkWeightTime *p;
	size_t k = sizeof(_ns1__ChkWeightTime);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChkWeightTime);
		if (p)
			((_ns1__ChkWeightTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChkWeightTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChkWeightTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChkWeightTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChkWeightTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChkWeightTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChkWeightTime(soap, tag ? tag : "ns1:ChkWeightTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChkWeightTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChkWeightTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChkWeightTime * SOAP_FMAC4 soap_get__ns1__ChkWeightTime(struct soap *soap, _ns1__ChkWeightTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChkWeightTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdAhsBarcodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdAhsBarcodeResponse::UpdAhsBarcodeResult = NULL;
	/* transient soap skipped */
}

void _ns1__UpdAhsBarcodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdAhsBarcodeResponse::UpdAhsBarcodeResult);
#endif
}

int _ns1__UpdAhsBarcodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdAhsBarcodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdAhsBarcodeResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdAhsBarcodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdAhsBarcodeResponse), type))
		return soap->error;
	if (a->UpdAhsBarcodeResult)
		soap_element_result(soap, "ns1:UpdAhsBarcodeResult");
	if (soap_out_PointerTostd__string(soap, "ns1:UpdAhsBarcodeResult", -1, &a->_ns1__UpdAhsBarcodeResponse::UpdAhsBarcodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdAhsBarcodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdAhsBarcodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdAhsBarcodeResponse * SOAP_FMAC4 soap_in__ns1__UpdAhsBarcodeResponse(struct soap *soap, const char *tag, _ns1__UpdAhsBarcodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdAhsBarcodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdAhsBarcodeResponse, sizeof(_ns1__UpdAhsBarcodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdAhsBarcodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdAhsBarcodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpdAhsBarcodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdAhsBarcodeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UpdAhsBarcodeResult", &a->_ns1__UpdAhsBarcodeResponse::UpdAhsBarcodeResult, "xsd:string"))
				{	soap_flag_UpdAhsBarcodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UpdAhsBarcodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdAhsBarcodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdAhsBarcodeResponse, SOAP_TYPE__ns1__UpdAhsBarcodeResponse, sizeof(_ns1__UpdAhsBarcodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdAhsBarcodeResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdAhsBarcodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdAhsBarcodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdAhsBarcodeResponse *p;
	size_t k = sizeof(_ns1__UpdAhsBarcodeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdAhsBarcodeResponse);
		if (p)
			((_ns1__UpdAhsBarcodeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdAhsBarcodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdAhsBarcodeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdAhsBarcodeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdAhsBarcodeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdAhsBarcodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdAhsBarcodeResponse(soap, tag ? tag : "ns1:UpdAhsBarcodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdAhsBarcodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdAhsBarcodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdAhsBarcodeResponse * SOAP_FMAC4 soap_get__ns1__UpdAhsBarcodeResponse(struct soap *soap, _ns1__UpdAhsBarcodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdAhsBarcodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdAhsBarcode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdAhsBarcode::Ikey = NULL;
	this->_ns1__UpdAhsBarcode::BarcodeKey = NULL;
	/* transient soap skipped */
}

void _ns1__UpdAhsBarcode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdAhsBarcode::Ikey);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdAhsBarcode::BarcodeKey);
#endif
}

int _ns1__UpdAhsBarcode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdAhsBarcode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdAhsBarcode(struct soap *soap, const char *tag, int id, const _ns1__UpdAhsBarcode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdAhsBarcode), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Ikey", -1, &a->_ns1__UpdAhsBarcode::Ikey, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:BarcodeKey", -1, &a->_ns1__UpdAhsBarcode::BarcodeKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdAhsBarcode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdAhsBarcode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdAhsBarcode * SOAP_FMAC4 soap_in__ns1__UpdAhsBarcode(struct soap *soap, const char *tag, _ns1__UpdAhsBarcode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdAhsBarcode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdAhsBarcode, sizeof(_ns1__UpdAhsBarcode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdAhsBarcode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdAhsBarcode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Ikey1 = 1;
	size_t soap_flag_BarcodeKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Ikey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Ikey", &a->_ns1__UpdAhsBarcode::Ikey, "xsd:string"))
				{	soap_flag_Ikey1--;
					continue;
				}
			}
			if (soap_flag_BarcodeKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:BarcodeKey", &a->_ns1__UpdAhsBarcode::BarcodeKey, "xsd:string"))
				{	soap_flag_BarcodeKey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdAhsBarcode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdAhsBarcode, SOAP_TYPE__ns1__UpdAhsBarcode, sizeof(_ns1__UpdAhsBarcode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdAhsBarcode * SOAP_FMAC2 soap_instantiate__ns1__UpdAhsBarcode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdAhsBarcode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdAhsBarcode *p;
	size_t k = sizeof(_ns1__UpdAhsBarcode);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdAhsBarcode);
		if (p)
			((_ns1__UpdAhsBarcode*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdAhsBarcode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdAhsBarcode*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdAhsBarcode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdAhsBarcode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdAhsBarcode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdAhsBarcode(soap, tag ? tag : "ns1:UpdAhsBarcode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdAhsBarcode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdAhsBarcode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdAhsBarcode * SOAP_FMAC4 soap_get__ns1__UpdAhsBarcode(struct soap *soap, _ns1__UpdAhsBarcode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdAhsBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAhsBarcodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAhsBarcodeResponse::GetAhsBarcodeResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAhsBarcodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, &this->_ns1__GetAhsBarcodeResponse::GetAhsBarcodeResult);
#endif
}

int _ns1__GetAhsBarcodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAhsBarcodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAhsBarcodeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAhsBarcodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAhsBarcodeResponse), type))
		return soap->error;
	if (a->GetAhsBarcodeResult)
		soap_element_result(soap, "ns1:GetAhsBarcodeResult");
	if (soap_out_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, "ns1:GetAhsBarcodeResult", -1, &a->_ns1__GetAhsBarcodeResponse::GetAhsBarcodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAhsBarcodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAhsBarcodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAhsBarcodeResponse * SOAP_FMAC4 soap_in__ns1__GetAhsBarcodeResponse(struct soap *soap, const char *tag, _ns1__GetAhsBarcodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAhsBarcodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAhsBarcodeResponse, sizeof(_ns1__GetAhsBarcodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAhsBarcodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAhsBarcodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAhsBarcodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAhsBarcodeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, "ns1:GetAhsBarcodeResult", &a->_ns1__GetAhsBarcodeResponse::GetAhsBarcodeResult, ""))
				{	soap_flag_GetAhsBarcodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetAhsBarcodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAhsBarcodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAhsBarcodeResponse, SOAP_TYPE__ns1__GetAhsBarcodeResponse, sizeof(_ns1__GetAhsBarcodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAhsBarcodeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAhsBarcodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAhsBarcodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAhsBarcodeResponse *p;
	size_t k = sizeof(_ns1__GetAhsBarcodeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAhsBarcodeResponse);
		if (p)
			((_ns1__GetAhsBarcodeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAhsBarcodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAhsBarcodeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAhsBarcodeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAhsBarcodeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAhsBarcodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAhsBarcodeResponse(soap, tag ? tag : "ns1:GetAhsBarcodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAhsBarcodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAhsBarcodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAhsBarcodeResponse * SOAP_FMAC4 soap_get__ns1__GetAhsBarcodeResponse(struct soap *soap, _ns1__GetAhsBarcodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAhsBarcodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAhsBarcode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAhsBarcode::Ikey = NULL;
	this->_ns1__GetAhsBarcode::VerIkey = NULL;
	this->_ns1__GetAhsBarcode::PrintType = NULL;
	/* transient soap skipped */
}

void _ns1__GetAhsBarcode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsBarcode::Ikey);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsBarcode::VerIkey);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAhsBarcode::PrintType);
#endif
}

int _ns1__GetAhsBarcode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAhsBarcode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAhsBarcode(struct soap *soap, const char *tag, int id, const _ns1__GetAhsBarcode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAhsBarcode), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Ikey", -1, &a->_ns1__GetAhsBarcode::Ikey, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VerIkey", -1, &a->_ns1__GetAhsBarcode::VerIkey, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:PrintType", -1, &a->_ns1__GetAhsBarcode::PrintType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAhsBarcode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAhsBarcode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAhsBarcode * SOAP_FMAC4 soap_in__ns1__GetAhsBarcode(struct soap *soap, const char *tag, _ns1__GetAhsBarcode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAhsBarcode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAhsBarcode, sizeof(_ns1__GetAhsBarcode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAhsBarcode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAhsBarcode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Ikey1 = 1;
	size_t soap_flag_VerIkey1 = 1;
	size_t soap_flag_PrintType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Ikey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Ikey", &a->_ns1__GetAhsBarcode::Ikey, "xsd:string"))
				{	soap_flag_Ikey1--;
					continue;
				}
			}
			if (soap_flag_VerIkey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:VerIkey", &a->_ns1__GetAhsBarcode::VerIkey, "xsd:string"))
				{	soap_flag_VerIkey1--;
					continue;
				}
			}
			if (soap_flag_PrintType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:PrintType", &a->_ns1__GetAhsBarcode::PrintType, "xsd:string"))
				{	soap_flag_PrintType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAhsBarcode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAhsBarcode, SOAP_TYPE__ns1__GetAhsBarcode, sizeof(_ns1__GetAhsBarcode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAhsBarcode * SOAP_FMAC2 soap_instantiate__ns1__GetAhsBarcode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAhsBarcode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAhsBarcode *p;
	size_t k = sizeof(_ns1__GetAhsBarcode);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAhsBarcode);
		if (p)
			((_ns1__GetAhsBarcode*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAhsBarcode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAhsBarcode*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAhsBarcode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAhsBarcode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAhsBarcode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAhsBarcode(soap, tag ? tag : "ns1:GetAhsBarcode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAhsBarcode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAhsBarcode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAhsBarcode * SOAP_FMAC4 soap_get__ns1__GetAhsBarcode(struct soap *soap, _ns1__GetAhsBarcode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAhsBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__ArrayOfString::string);
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__ArrayOfString::string);
#endif
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:string", -1, &a->ns1__ArrayOfString::string, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfString)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:string", &a->ns1__ArrayOfString::string, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfString *p;
	size_t k = sizeof(ns1__ArrayOfString);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfString);
		if (p)
			((ns1__ArrayOfString*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfString, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfString*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfString location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfString(soap, tag ? tag : "ns1:ArrayOfString", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAhsMo_(struct soap *soap, struct __ns1__GetAhsMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAhsMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAhsMo_(struct soap *soap, const struct __ns1__GetAhsMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAhsMo(soap, &a->ns1__GetAhsMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAhsMo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAhsMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAhsMo(soap, "ns1:GetAhsMo", -1, &a->ns1__GetAhsMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsMo_ * SOAP_FMAC4 soap_in___ns1__GetAhsMo_(struct soap *soap, const char *tag, struct __ns1__GetAhsMo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAhsMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAhsMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAhsMo_, sizeof(struct __ns1__GetAhsMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAhsMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAhsMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAhsMo(soap, "ns1:GetAhsMo", &a->ns1__GetAhsMo, ""))
				{	soap_flag_ns1__GetAhsMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAhsMo_ * SOAP_FMAC2 soap_instantiate___ns1__GetAhsMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAhsMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAhsMo_ *p;
	size_t k = sizeof(struct __ns1__GetAhsMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAhsMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAhsMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAhsMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAhsMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAhsMo_(struct soap *soap, const struct __ns1__GetAhsMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAhsMo_(soap, tag ? tag : "-ns1:GetAhsMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsMo_ * SOAP_FMAC4 soap_get___ns1__GetAhsMo_(struct soap *soap, struct __ns1__GetAhsMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAhsMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPackWeigth_(struct soap *soap, struct __ns1__GetPackWeigth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPackWeigth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPackWeigth_(struct soap *soap, const struct __ns1__GetPackWeigth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPackWeigth(soap, &a->ns1__GetPackWeigth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPackWeigth_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPackWeigth_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPackWeigth(soap, "ns1:GetPackWeigth", -1, &a->ns1__GetPackWeigth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackWeigth_ * SOAP_FMAC4 soap_in___ns1__GetPackWeigth_(struct soap *soap, const char *tag, struct __ns1__GetPackWeigth_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPackWeigth = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPackWeigth_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPackWeigth_, sizeof(struct __ns1__GetPackWeigth_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPackWeigth_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPackWeigth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPackWeigth(soap, "ns1:GetPackWeigth", &a->ns1__GetPackWeigth, ""))
				{	soap_flag_ns1__GetPackWeigth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPackWeigth_ * SOAP_FMAC2 soap_instantiate___ns1__GetPackWeigth_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPackWeigth_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPackWeigth_ *p;
	size_t k = sizeof(struct __ns1__GetPackWeigth_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPackWeigth_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPackWeigth_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPackWeigth_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPackWeigth_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPackWeigth_(struct soap *soap, const struct __ns1__GetPackWeigth_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPackWeigth_(soap, tag ? tag : "-ns1:GetPackWeigth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackWeigth_ * SOAP_FMAC4 soap_get___ns1__GetPackWeigth_(struct soap *soap, struct __ns1__GetPackWeigth_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPackWeigth_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPackStation_(struct soap *soap, struct __ns1__GetPackStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPackStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPackStation_(struct soap *soap, const struct __ns1__GetPackStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPackStation(soap, &a->ns1__GetPackStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPackStation_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPackStation_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPackStation(soap, "ns1:GetPackStation", -1, &a->ns1__GetPackStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackStation_ * SOAP_FMAC4 soap_in___ns1__GetPackStation_(struct soap *soap, const char *tag, struct __ns1__GetPackStation_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPackStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPackStation_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPackStation_, sizeof(struct __ns1__GetPackStation_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPackStation_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPackStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPackStation(soap, "ns1:GetPackStation", &a->ns1__GetPackStation, ""))
				{	soap_flag_ns1__GetPackStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPackStation_ * SOAP_FMAC2 soap_instantiate___ns1__GetPackStation_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPackStation_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPackStation_ *p;
	size_t k = sizeof(struct __ns1__GetPackStation_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPackStation_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPackStation_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPackStation_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPackStation_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPackStation_(struct soap *soap, const struct __ns1__GetPackStation_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPackStation_(soap, tag ? tag : "-ns1:GetPackStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackStation_ * SOAP_FMAC4 soap_get___ns1__GetPackStation_(struct soap *soap, struct __ns1__GetPackStation_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPackStation_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetPallentForWMS_(struct soap *soap, struct __ns1__SetPallentForWMS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPallentForWMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetPallentForWMS_(struct soap *soap, const struct __ns1__SetPallentForWMS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetPallentForWMS(soap, &a->ns1__SetPallentForWMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetPallentForWMS_(struct soap *soap, const char *tag, int id, const struct __ns1__SetPallentForWMS_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetPallentForWMS(soap, "ns1:SetPallentForWMS", -1, &a->ns1__SetPallentForWMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPallentForWMS_ * SOAP_FMAC4 soap_in___ns1__SetPallentForWMS_(struct soap *soap, const char *tag, struct __ns1__SetPallentForWMS_ *a, const char *type)
{
	size_t soap_flag_ns1__SetPallentForWMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetPallentForWMS_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetPallentForWMS_, sizeof(struct __ns1__SetPallentForWMS_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetPallentForWMS_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPallentForWMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetPallentForWMS(soap, "ns1:SetPallentForWMS", &a->ns1__SetPallentForWMS, ""))
				{	soap_flag_ns1__SetPallentForWMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetPallentForWMS_ * SOAP_FMAC2 soap_instantiate___ns1__SetPallentForWMS_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetPallentForWMS_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetPallentForWMS_ *p;
	size_t k = sizeof(struct __ns1__SetPallentForWMS_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetPallentForWMS_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetPallentForWMS_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetPallentForWMS_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetPallentForWMS_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetPallentForWMS_(struct soap *soap, const struct __ns1__SetPallentForWMS_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetPallentForWMS_(soap, tag ? tag : "-ns1:SetPallentForWMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPallentForWMS_ * SOAP_FMAC4 soap_get___ns1__SetPallentForWMS_(struct soap *soap, struct __ns1__SetPallentForWMS_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetPallentForWMS_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPallentToWMS_(struct soap *soap, struct __ns1__GetPallentToWMS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPallentToWMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPallentToWMS_(struct soap *soap, const struct __ns1__GetPallentToWMS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPallentToWMS(soap, &a->ns1__GetPallentToWMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPallentToWMS_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPallentToWMS_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPallentToWMS(soap, "ns1:GetPallentToWMS", -1, &a->ns1__GetPallentToWMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPallentToWMS_ * SOAP_FMAC4 soap_in___ns1__GetPallentToWMS_(struct soap *soap, const char *tag, struct __ns1__GetPallentToWMS_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPallentToWMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPallentToWMS_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPallentToWMS_, sizeof(struct __ns1__GetPallentToWMS_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPallentToWMS_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPallentToWMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPallentToWMS(soap, "ns1:GetPallentToWMS", &a->ns1__GetPallentToWMS, ""))
				{	soap_flag_ns1__GetPallentToWMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPallentToWMS_ * SOAP_FMAC2 soap_instantiate___ns1__GetPallentToWMS_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPallentToWMS_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPallentToWMS_ *p;
	size_t k = sizeof(struct __ns1__GetPallentToWMS_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPallentToWMS_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPallentToWMS_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPallentToWMS_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPallentToWMS_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPallentToWMS_(struct soap *soap, const struct __ns1__GetPallentToWMS_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPallentToWMS_(soap, tag ? tag : "-ns1:GetPallentToWMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPallentToWMS_ * SOAP_FMAC4 soap_get___ns1__GetPallentToWMS_(struct soap *soap, struct __ns1__GetPallentToWMS_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPallentToWMS_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPackToWMS_(struct soap *soap, struct __ns1__GetPackToWMS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPackToWMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPackToWMS_(struct soap *soap, const struct __ns1__GetPackToWMS_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPackToWMS(soap, &a->ns1__GetPackToWMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPackToWMS_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPackToWMS_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPackToWMS(soap, "ns1:GetPackToWMS", -1, &a->ns1__GetPackToWMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackToWMS_ * SOAP_FMAC4 soap_in___ns1__GetPackToWMS_(struct soap *soap, const char *tag, struct __ns1__GetPackToWMS_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPackToWMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPackToWMS_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPackToWMS_, sizeof(struct __ns1__GetPackToWMS_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPackToWMS_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPackToWMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPackToWMS(soap, "ns1:GetPackToWMS", &a->ns1__GetPackToWMS, ""))
				{	soap_flag_ns1__GetPackToWMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPackToWMS_ * SOAP_FMAC2 soap_instantiate___ns1__GetPackToWMS_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPackToWMS_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPackToWMS_ *p;
	size_t k = sizeof(struct __ns1__GetPackToWMS_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPackToWMS_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPackToWMS_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPackToWMS_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPackToWMS_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPackToWMS_(struct soap *soap, const struct __ns1__GetPackToWMS_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPackToWMS_(soap, tag ? tag : "-ns1:GetPackToWMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackToWMS_ * SOAP_FMAC4 soap_get___ns1__GetPackToWMS_(struct soap *soap, struct __ns1__GetPackToWMS_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPackToWMS_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetWeightSet_(struct soap *soap, struct __ns1__GetWeightSet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWeightSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetWeightSet_(struct soap *soap, const struct __ns1__GetWeightSet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetWeightSet(soap, &a->ns1__GetWeightSet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetWeightSet_(struct soap *soap, const char *tag, int id, const struct __ns1__GetWeightSet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetWeightSet(soap, "ns1:GetWeightSet", -1, &a->ns1__GetWeightSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWeightSet_ * SOAP_FMAC4 soap_in___ns1__GetWeightSet_(struct soap *soap, const char *tag, struct __ns1__GetWeightSet_ *a, const char *type)
{
	size_t soap_flag_ns1__GetWeightSet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetWeightSet_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetWeightSet_, sizeof(struct __ns1__GetWeightSet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetWeightSet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWeightSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetWeightSet(soap, "ns1:GetWeightSet", &a->ns1__GetWeightSet, ""))
				{	soap_flag_ns1__GetWeightSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetWeightSet_ * SOAP_FMAC2 soap_instantiate___ns1__GetWeightSet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetWeightSet_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetWeightSet_ *p;
	size_t k = sizeof(struct __ns1__GetWeightSet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetWeightSet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetWeightSet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetWeightSet_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetWeightSet_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetWeightSet_(struct soap *soap, const struct __ns1__GetWeightSet_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetWeightSet_(soap, tag ? tag : "-ns1:GetWeightSet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWeightSet_ * SOAP_FMAC4 soap_get___ns1__GetWeightSet_(struct soap *soap, struct __ns1__GetWeightSet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetWeightSet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CancelLnkSN_(struct soap *soap, struct __ns1__CancelLnkSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelLnkSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CancelLnkSN_(struct soap *soap, const struct __ns1__CancelLnkSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelLnkSN(soap, &a->ns1__CancelLnkSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CancelLnkSN_(struct soap *soap, const char *tag, int id, const struct __ns1__CancelLnkSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelLnkSN(soap, "ns1:CancelLnkSN", -1, &a->ns1__CancelLnkSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelLnkSN_ * SOAP_FMAC4 soap_in___ns1__CancelLnkSN_(struct soap *soap, const char *tag, struct __ns1__CancelLnkSN_ *a, const char *type)
{
	size_t soap_flag_ns1__CancelLnkSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CancelLnkSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CancelLnkSN_, sizeof(struct __ns1__CancelLnkSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CancelLnkSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelLnkSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CancelLnkSN(soap, "ns1:CancelLnkSN", &a->ns1__CancelLnkSN, ""))
				{	soap_flag_ns1__CancelLnkSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CancelLnkSN_ * SOAP_FMAC2 soap_instantiate___ns1__CancelLnkSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CancelLnkSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CancelLnkSN_ *p;
	size_t k = sizeof(struct __ns1__CancelLnkSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CancelLnkSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CancelLnkSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CancelLnkSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CancelLnkSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CancelLnkSN_(struct soap *soap, const struct __ns1__CancelLnkSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CancelLnkSN_(soap, tag ? tag : "-ns1:CancelLnkSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelLnkSN_ * SOAP_FMAC4 soap_get___ns1__CancelLnkSN_(struct soap *soap, struct __ns1__CancelLnkSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CancelLnkSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CancelGrillSN_(struct soap *soap, struct __ns1__CancelGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CancelGrillSN_(struct soap *soap, const struct __ns1__CancelGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelGrillSN(soap, &a->ns1__CancelGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CancelGrillSN_(struct soap *soap, const char *tag, int id, const struct __ns1__CancelGrillSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelGrillSN(soap, "ns1:CancelGrillSN", -1, &a->ns1__CancelGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelGrillSN_ * SOAP_FMAC4 soap_in___ns1__CancelGrillSN_(struct soap *soap, const char *tag, struct __ns1__CancelGrillSN_ *a, const char *type)
{
	size_t soap_flag_ns1__CancelGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CancelGrillSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CancelGrillSN_, sizeof(struct __ns1__CancelGrillSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CancelGrillSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CancelGrillSN(soap, "ns1:CancelGrillSN", &a->ns1__CancelGrillSN, ""))
				{	soap_flag_ns1__CancelGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CancelGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__CancelGrillSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CancelGrillSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CancelGrillSN_ *p;
	size_t k = sizeof(struct __ns1__CancelGrillSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CancelGrillSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CancelGrillSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CancelGrillSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CancelGrillSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CancelGrillSN_(struct soap *soap, const struct __ns1__CancelGrillSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CancelGrillSN_(soap, tag ? tag : "-ns1:CancelGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelGrillSN_ * SOAP_FMAC4 soap_get___ns1__CancelGrillSN_(struct soap *soap, struct __ns1__CancelGrillSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CancelGrillSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutGrillBySN_(struct soap *soap, struct __ns1__OutGrillBySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutGrillBySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutGrillBySN_(struct soap *soap, const struct __ns1__OutGrillBySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutGrillBySN(soap, &a->ns1__OutGrillBySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutGrillBySN_(struct soap *soap, const char *tag, int id, const struct __ns1__OutGrillBySN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutGrillBySN(soap, "ns1:OutGrillBySN", -1, &a->ns1__OutGrillBySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutGrillBySN_ * SOAP_FMAC4 soap_in___ns1__OutGrillBySN_(struct soap *soap, const char *tag, struct __ns1__OutGrillBySN_ *a, const char *type)
{
	size_t soap_flag_ns1__OutGrillBySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutGrillBySN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutGrillBySN_, sizeof(struct __ns1__OutGrillBySN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutGrillBySN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutGrillBySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutGrillBySN(soap, "ns1:OutGrillBySN", &a->ns1__OutGrillBySN, ""))
				{	soap_flag_ns1__OutGrillBySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutGrillBySN_ * SOAP_FMAC2 soap_instantiate___ns1__OutGrillBySN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutGrillBySN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutGrillBySN_ *p;
	size_t k = sizeof(struct __ns1__OutGrillBySN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OutGrillBySN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OutGrillBySN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutGrillBySN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OutGrillBySN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutGrillBySN_(struct soap *soap, const struct __ns1__OutGrillBySN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutGrillBySN_(soap, tag ? tag : "-ns1:OutGrillBySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutGrillBySN_ * SOAP_FMAC4 soap_get___ns1__OutGrillBySN_(struct soap *soap, struct __ns1__OutGrillBySN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutGrillBySN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGrillTime_(struct soap *soap, struct __ns1__GetGrillTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGrillTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGrillTime_(struct soap *soap, const struct __ns1__GetGrillTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetGrillTime(soap, &a->ns1__GetGrillTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGrillTime_(struct soap *soap, const char *tag, int id, const struct __ns1__GetGrillTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetGrillTime(soap, "ns1:GetGrillTime", -1, &a->ns1__GetGrillTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGrillTime_ * SOAP_FMAC4 soap_in___ns1__GetGrillTime_(struct soap *soap, const char *tag, struct __ns1__GetGrillTime_ *a, const char *type)
{
	size_t soap_flag_ns1__GetGrillTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetGrillTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGrillTime_, sizeof(struct __ns1__GetGrillTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGrillTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGrillTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetGrillTime(soap, "ns1:GetGrillTime", &a->ns1__GetGrillTime, ""))
				{	soap_flag_ns1__GetGrillTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetGrillTime_ * SOAP_FMAC2 soap_instantiate___ns1__GetGrillTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGrillTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetGrillTime_ *p;
	size_t k = sizeof(struct __ns1__GetGrillTime_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetGrillTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetGrillTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetGrillTime_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetGrillTime_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGrillTime_(struct soap *soap, const struct __ns1__GetGrillTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetGrillTime_(soap, tag ? tag : "-ns1:GetGrillTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGrillTime_ * SOAP_FMAC4 soap_get___ns1__GetGrillTime_(struct soap *soap, struct __ns1__GetGrillTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGrillTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsGrillBySN_(struct soap *soap, struct __ns1__InsGrillBySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsGrillBySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsGrillBySN_(struct soap *soap, const struct __ns1__InsGrillBySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsGrillBySN(soap, &a->ns1__InsGrillBySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsGrillBySN_(struct soap *soap, const char *tag, int id, const struct __ns1__InsGrillBySN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsGrillBySN(soap, "ns1:InsGrillBySN", -1, &a->ns1__InsGrillBySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsGrillBySN_ * SOAP_FMAC4 soap_in___ns1__InsGrillBySN_(struct soap *soap, const char *tag, struct __ns1__InsGrillBySN_ *a, const char *type)
{
	size_t soap_flag_ns1__InsGrillBySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsGrillBySN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsGrillBySN_, sizeof(struct __ns1__InsGrillBySN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsGrillBySN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsGrillBySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsGrillBySN(soap, "ns1:InsGrillBySN", &a->ns1__InsGrillBySN, ""))
				{	soap_flag_ns1__InsGrillBySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsGrillBySN_ * SOAP_FMAC2 soap_instantiate___ns1__InsGrillBySN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsGrillBySN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsGrillBySN_ *p;
	size_t k = sizeof(struct __ns1__InsGrillBySN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsGrillBySN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsGrillBySN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsGrillBySN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsGrillBySN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsGrillBySN_(struct soap *soap, const struct __ns1__InsGrillBySN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsGrillBySN_(soap, tag ? tag : "-ns1:InsGrillBySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsGrillBySN_ * SOAP_FMAC4 soap_get___ns1__InsGrillBySN_(struct soap *soap, struct __ns1__InsGrillBySN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsGrillBySN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseGrillSN_(struct soap *soap, struct __ns1__CloseGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseGrillSN_(struct soap *soap, const struct __ns1__CloseGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseGrillSN(soap, &a->ns1__CloseGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseGrillSN_(struct soap *soap, const char *tag, int id, const struct __ns1__CloseGrillSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseGrillSN(soap, "ns1:CloseGrillSN", -1, &a->ns1__CloseGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseGrillSN_ * SOAP_FMAC4 soap_in___ns1__CloseGrillSN_(struct soap *soap, const char *tag, struct __ns1__CloseGrillSN_ *a, const char *type)
{
	size_t soap_flag_ns1__CloseGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseGrillSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseGrillSN_, sizeof(struct __ns1__CloseGrillSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseGrillSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CloseGrillSN(soap, "ns1:CloseGrillSN", &a->ns1__CloseGrillSN, ""))
				{	soap_flag_ns1__CloseGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__CloseGrillSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseGrillSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseGrillSN_ *p;
	size_t k = sizeof(struct __ns1__CloseGrillSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseGrillSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseGrillSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseGrillSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseGrillSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseGrillSN_(struct soap *soap, const struct __ns1__CloseGrillSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseGrillSN_(soap, tag ? tag : "-ns1:CloseGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseGrillSN_ * SOAP_FMAC4 soap_get___ns1__CloseGrillSN_(struct soap *soap, struct __ns1__CloseGrillSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseGrillSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LnkGrillSN_(struct soap *soap, struct __ns1__LnkGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LnkGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LnkGrillSN_(struct soap *soap, const struct __ns1__LnkGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LnkGrillSN(soap, &a->ns1__LnkGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LnkGrillSN_(struct soap *soap, const char *tag, int id, const struct __ns1__LnkGrillSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LnkGrillSN(soap, "ns1:LnkGrillSN", -1, &a->ns1__LnkGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkGrillSN_ * SOAP_FMAC4 soap_in___ns1__LnkGrillSN_(struct soap *soap, const char *tag, struct __ns1__LnkGrillSN_ *a, const char *type)
{
	size_t soap_flag_ns1__LnkGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LnkGrillSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LnkGrillSN_, sizeof(struct __ns1__LnkGrillSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LnkGrillSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LnkGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__LnkGrillSN(soap, "ns1:LnkGrillSN", &a->ns1__LnkGrillSN, ""))
				{	soap_flag_ns1__LnkGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LnkGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__LnkGrillSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LnkGrillSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LnkGrillSN_ *p;
	size_t k = sizeof(struct __ns1__LnkGrillSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LnkGrillSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LnkGrillSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LnkGrillSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LnkGrillSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LnkGrillSN_(struct soap *soap, const struct __ns1__LnkGrillSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LnkGrillSN_(soap, tag ? tag : "-ns1:LnkGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkGrillSN_ * SOAP_FMAC4 soap_get___ns1__LnkGrillSN_(struct soap *soap, struct __ns1__LnkGrillSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LnkGrillSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkGrillSN_(struct soap *soap, struct __ns1__chkGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkGrillSN_(struct soap *soap, const struct __ns1__chkGrillSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkGrillSN(soap, &a->ns1__chkGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkGrillSN_(struct soap *soap, const char *tag, int id, const struct __ns1__chkGrillSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkGrillSN(soap, "ns1:chkGrillSN", -1, &a->ns1__chkGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkGrillSN_ * SOAP_FMAC4 soap_in___ns1__chkGrillSN_(struct soap *soap, const char *tag, struct __ns1__chkGrillSN_ *a, const char *type)
{
	size_t soap_flag_ns1__chkGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkGrillSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkGrillSN_, sizeof(struct __ns1__chkGrillSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkGrillSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkGrillSN(soap, "ns1:chkGrillSN", &a->ns1__chkGrillSN, ""))
				{	soap_flag_ns1__chkGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkGrillSN_ * SOAP_FMAC2 soap_instantiate___ns1__chkGrillSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkGrillSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkGrillSN_ *p;
	size_t k = sizeof(struct __ns1__chkGrillSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkGrillSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkGrillSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkGrillSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkGrillSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkGrillSN_(struct soap *soap, const struct __ns1__chkGrillSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkGrillSN_(soap, tag ? tag : "-ns1:chkGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkGrillSN_ * SOAP_FMAC4 soap_get___ns1__chkGrillSN_(struct soap *soap, struct __ns1__chkGrillSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkGrillSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LnkSideSN_(struct soap *soap, struct __ns1__LnkSideSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LnkSideSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LnkSideSN_(struct soap *soap, const struct __ns1__LnkSideSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LnkSideSN(soap, &a->ns1__LnkSideSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LnkSideSN_(struct soap *soap, const char *tag, int id, const struct __ns1__LnkSideSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LnkSideSN(soap, "ns1:LnkSideSN", -1, &a->ns1__LnkSideSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkSideSN_ * SOAP_FMAC4 soap_in___ns1__LnkSideSN_(struct soap *soap, const char *tag, struct __ns1__LnkSideSN_ *a, const char *type)
{
	size_t soap_flag_ns1__LnkSideSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LnkSideSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LnkSideSN_, sizeof(struct __ns1__LnkSideSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LnkSideSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LnkSideSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__LnkSideSN(soap, "ns1:LnkSideSN", &a->ns1__LnkSideSN, ""))
				{	soap_flag_ns1__LnkSideSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LnkSideSN_ * SOAP_FMAC2 soap_instantiate___ns1__LnkSideSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LnkSideSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LnkSideSN_ *p;
	size_t k = sizeof(struct __ns1__LnkSideSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LnkSideSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LnkSideSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LnkSideSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LnkSideSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LnkSideSN_(struct soap *soap, const struct __ns1__LnkSideSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LnkSideSN_(soap, tag ? tag : "-ns1:LnkSideSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkSideSN_ * SOAP_FMAC4 soap_get___ns1__LnkSideSN_(struct soap *soap, struct __ns1__LnkSideSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LnkSideSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LnkZJSN_(struct soap *soap, struct __ns1__LnkZJSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LnkZJSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LnkZJSN_(struct soap *soap, const struct __ns1__LnkZJSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LnkZJSN(soap, &a->ns1__LnkZJSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LnkZJSN_(struct soap *soap, const char *tag, int id, const struct __ns1__LnkZJSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LnkZJSN(soap, "ns1:LnkZJSN", -1, &a->ns1__LnkZJSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkZJSN_ * SOAP_FMAC4 soap_in___ns1__LnkZJSN_(struct soap *soap, const char *tag, struct __ns1__LnkZJSN_ *a, const char *type)
{
	size_t soap_flag_ns1__LnkZJSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LnkZJSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LnkZJSN_, sizeof(struct __ns1__LnkZJSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LnkZJSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LnkZJSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__LnkZJSN(soap, "ns1:LnkZJSN", &a->ns1__LnkZJSN, ""))
				{	soap_flag_ns1__LnkZJSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LnkZJSN_ * SOAP_FMAC2 soap_instantiate___ns1__LnkZJSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LnkZJSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LnkZJSN_ *p;
	size_t k = sizeof(struct __ns1__LnkZJSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LnkZJSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LnkZJSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LnkZJSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LnkZJSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LnkZJSN_(struct soap *soap, const struct __ns1__LnkZJSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LnkZJSN_(soap, tag ? tag : "-ns1:LnkZJSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkZJSN_ * SOAP_FMAC4 soap_get___ns1__LnkZJSN_(struct soap *soap, struct __ns1__LnkZJSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LnkZJSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkZJSN_(struct soap *soap, struct __ns1__chkZJSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkZJSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkZJSN_(struct soap *soap, const struct __ns1__chkZJSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkZJSN(soap, &a->ns1__chkZJSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkZJSN_(struct soap *soap, const char *tag, int id, const struct __ns1__chkZJSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkZJSN(soap, "ns1:chkZJSN", -1, &a->ns1__chkZJSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkZJSN_ * SOAP_FMAC4 soap_in___ns1__chkZJSN_(struct soap *soap, const char *tag, struct __ns1__chkZJSN_ *a, const char *type)
{
	size_t soap_flag_ns1__chkZJSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkZJSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkZJSN_, sizeof(struct __ns1__chkZJSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkZJSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkZJSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkZJSN(soap, "ns1:chkZJSN", &a->ns1__chkZJSN, ""))
				{	soap_flag_ns1__chkZJSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkZJSN_ * SOAP_FMAC2 soap_instantiate___ns1__chkZJSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkZJSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkZJSN_ *p;
	size_t k = sizeof(struct __ns1__chkZJSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkZJSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkZJSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkZJSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkZJSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkZJSN_(struct soap *soap, const struct __ns1__chkZJSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkZJSN_(soap, tag ? tag : "-ns1:chkZJSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkZJSN_ * SOAP_FMAC4 soap_get___ns1__chkZJSN_(struct soap *soap, struct __ns1__chkZJSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkZJSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkDispensing_(struct soap *soap, struct __ns1__chkDispensing_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkDispensing = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkDispensing_(struct soap *soap, const struct __ns1__chkDispensing_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkDispensing(soap, &a->ns1__chkDispensing);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkDispensing_(struct soap *soap, const char *tag, int id, const struct __ns1__chkDispensing_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkDispensing(soap, "ns1:chkDispensing", -1, &a->ns1__chkDispensing, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkDispensing_ * SOAP_FMAC4 soap_in___ns1__chkDispensing_(struct soap *soap, const char *tag, struct __ns1__chkDispensing_ *a, const char *type)
{
	size_t soap_flag_ns1__chkDispensing = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkDispensing_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkDispensing_, sizeof(struct __ns1__chkDispensing_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkDispensing_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkDispensing && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkDispensing(soap, "ns1:chkDispensing", &a->ns1__chkDispensing, ""))
				{	soap_flag_ns1__chkDispensing--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkDispensing_ * SOAP_FMAC2 soap_instantiate___ns1__chkDispensing_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkDispensing_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkDispensing_ *p;
	size_t k = sizeof(struct __ns1__chkDispensing_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkDispensing_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkDispensing_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkDispensing_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkDispensing_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkDispensing_(struct soap *soap, const struct __ns1__chkDispensing_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkDispensing_(soap, tag ? tag : "-ns1:chkDispensing", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkDispensing_ * SOAP_FMAC4 soap_get___ns1__chkDispensing_(struct soap *soap, struct __ns1__chkDispensing_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkDispensing_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsIotTestData_(struct soap *soap, struct __ns1__InsIotTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsIotTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsIotTestData_(struct soap *soap, const struct __ns1__InsIotTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsIotTestData(soap, &a->ns1__InsIotTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsIotTestData_(struct soap *soap, const char *tag, int id, const struct __ns1__InsIotTestData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsIotTestData(soap, "ns1:InsIotTestData", -1, &a->ns1__InsIotTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotTestData_ * SOAP_FMAC4 soap_in___ns1__InsIotTestData_(struct soap *soap, const char *tag, struct __ns1__InsIotTestData_ *a, const char *type)
{
	size_t soap_flag_ns1__InsIotTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsIotTestData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsIotTestData_, sizeof(struct __ns1__InsIotTestData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsIotTestData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsIotTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsIotTestData(soap, "ns1:InsIotTestData", &a->ns1__InsIotTestData, ""))
				{	soap_flag_ns1__InsIotTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsIotTestData_ * SOAP_FMAC2 soap_instantiate___ns1__InsIotTestData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsIotTestData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsIotTestData_ *p;
	size_t k = sizeof(struct __ns1__InsIotTestData_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsIotTestData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsIotTestData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsIotTestData_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsIotTestData_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsIotTestData_(struct soap *soap, const struct __ns1__InsIotTestData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsIotTestData_(soap, tag ? tag : "-ns1:InsIotTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotTestData_ * SOAP_FMAC4 soap_get___ns1__InsIotTestData_(struct soap *soap, struct __ns1__InsIotTestData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsIotTestData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsIotMachineRec_(struct soap *soap, struct __ns1__InsIotMachineRec_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsIotMachineRec = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsIotMachineRec_(struct soap *soap, const struct __ns1__InsIotMachineRec_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsIotMachineRec(soap, &a->ns1__InsIotMachineRec);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsIotMachineRec_(struct soap *soap, const char *tag, int id, const struct __ns1__InsIotMachineRec_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsIotMachineRec(soap, "ns1:InsIotMachineRec", -1, &a->ns1__InsIotMachineRec, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotMachineRec_ * SOAP_FMAC4 soap_in___ns1__InsIotMachineRec_(struct soap *soap, const char *tag, struct __ns1__InsIotMachineRec_ *a, const char *type)
{
	size_t soap_flag_ns1__InsIotMachineRec = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsIotMachineRec_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsIotMachineRec_, sizeof(struct __ns1__InsIotMachineRec_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsIotMachineRec_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsIotMachineRec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsIotMachineRec(soap, "ns1:InsIotMachineRec", &a->ns1__InsIotMachineRec, ""))
				{	soap_flag_ns1__InsIotMachineRec--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsIotMachineRec_ * SOAP_FMAC2 soap_instantiate___ns1__InsIotMachineRec_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsIotMachineRec_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsIotMachineRec_ *p;
	size_t k = sizeof(struct __ns1__InsIotMachineRec_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsIotMachineRec_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsIotMachineRec_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsIotMachineRec_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsIotMachineRec_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsIotMachineRec_(struct soap *soap, const struct __ns1__InsIotMachineRec_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsIotMachineRec_(soap, tag ? tag : "-ns1:InsIotMachineRec", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotMachineRec_ * SOAP_FMAC4 soap_get___ns1__InsIotMachineRec_(struct soap *soap, struct __ns1__InsIotMachineRec_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsIotMachineRec_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLnkData_(struct soap *soap, struct __ns1__GetLnkData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLnkData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLnkData_(struct soap *soap, const struct __ns1__GetLnkData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLnkData(soap, &a->ns1__GetLnkData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLnkData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLnkData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLnkData(soap, "ns1:GetLnkData", -1, &a->ns1__GetLnkData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLnkData_ * SOAP_FMAC4 soap_in___ns1__GetLnkData_(struct soap *soap, const char *tag, struct __ns1__GetLnkData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLnkData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLnkData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLnkData_, sizeof(struct __ns1__GetLnkData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLnkData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLnkData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLnkData(soap, "ns1:GetLnkData", &a->ns1__GetLnkData, ""))
				{	soap_flag_ns1__GetLnkData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLnkData_ * SOAP_FMAC2 soap_instantiate___ns1__GetLnkData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLnkData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLnkData_ *p;
	size_t k = sizeof(struct __ns1__GetLnkData_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLnkData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLnkData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLnkData_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLnkData_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLnkData_(struct soap *soap, const struct __ns1__GetLnkData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLnkData_(soap, tag ? tag : "-ns1:GetLnkData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLnkData_ * SOAP_FMAC4 soap_get___ns1__GetLnkData_(struct soap *soap, struct __ns1__GetLnkData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLnkData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTestValue_(struct soap *soap, struct __ns1__GetTestValue_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTestValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTestValue_(struct soap *soap, const struct __ns1__GetTestValue_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTestValue(soap, &a->ns1__GetTestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTestValue_(struct soap *soap, const char *tag, int id, const struct __ns1__GetTestValue_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTestValue(soap, "ns1:GetTestValue", -1, &a->ns1__GetTestValue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValue_ * SOAP_FMAC4 soap_in___ns1__GetTestValue_(struct soap *soap, const char *tag, struct __ns1__GetTestValue_ *a, const char *type)
{
	size_t soap_flag_ns1__GetTestValue = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTestValue_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTestValue_, sizeof(struct __ns1__GetTestValue_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTestValue_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTestValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTestValue(soap, "ns1:GetTestValue", &a->ns1__GetTestValue, ""))
				{	soap_flag_ns1__GetTestValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTestValue_ * SOAP_FMAC2 soap_instantiate___ns1__GetTestValue_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTestValue_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTestValue_ *p;
	size_t k = sizeof(struct __ns1__GetTestValue_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetTestValue_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetTestValue_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTestValue_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetTestValue_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTestValue_(struct soap *soap, const struct __ns1__GetTestValue_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTestValue_(soap, tag ? tag : "-ns1:GetTestValue", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValue_ * SOAP_FMAC4 soap_get___ns1__GetTestValue_(struct soap *soap, struct __ns1__GetTestValue_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTestValue_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMoBase_(struct soap *soap, struct __ns1__GetMoBase_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMoBase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMoBase_(struct soap *soap, const struct __ns1__GetMoBase_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMoBase(soap, &a->ns1__GetMoBase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMoBase_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMoBase_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMoBase(soap, "ns1:GetMoBase", -1, &a->ns1__GetMoBase, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMoBase_ * SOAP_FMAC4 soap_in___ns1__GetMoBase_(struct soap *soap, const char *tag, struct __ns1__GetMoBase_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMoBase = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMoBase_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMoBase_, sizeof(struct __ns1__GetMoBase_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMoBase_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMoBase && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMoBase(soap, "ns1:GetMoBase", &a->ns1__GetMoBase, ""))
				{	soap_flag_ns1__GetMoBase--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMoBase_ * SOAP_FMAC2 soap_instantiate___ns1__GetMoBase_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMoBase_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMoBase_ *p;
	size_t k = sizeof(struct __ns1__GetMoBase_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetMoBase_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetMoBase_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMoBase_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetMoBase_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMoBase_(struct soap *soap, const struct __ns1__GetMoBase_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMoBase_(soap, tag ? tag : "-ns1:GetMoBase", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMoBase_ * SOAP_FMAC4 soap_get___ns1__GetMoBase_(struct soap *soap, struct __ns1__GetMoBase_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMoBase_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdSnRecInfo_(struct soap *soap, struct __ns1__UpdSnRecInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdSnRecInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdSnRecInfo_(struct soap *soap, const struct __ns1__UpdSnRecInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdSnRecInfo(soap, &a->ns1__UpdSnRecInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdSnRecInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdSnRecInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdSnRecInfo(soap, "ns1:UpdSnRecInfo", -1, &a->ns1__UpdSnRecInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdSnRecInfo_ * SOAP_FMAC4 soap_in___ns1__UpdSnRecInfo_(struct soap *soap, const char *tag, struct __ns1__UpdSnRecInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdSnRecInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdSnRecInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdSnRecInfo_, sizeof(struct __ns1__UpdSnRecInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdSnRecInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdSnRecInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdSnRecInfo(soap, "ns1:UpdSnRecInfo", &a->ns1__UpdSnRecInfo, ""))
				{	soap_flag_ns1__UpdSnRecInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdSnRecInfo_ * SOAP_FMAC2 soap_instantiate___ns1__UpdSnRecInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdSnRecInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdSnRecInfo_ *p;
	size_t k = sizeof(struct __ns1__UpdSnRecInfo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdSnRecInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdSnRecInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdSnRecInfo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UpdSnRecInfo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdSnRecInfo_(struct soap *soap, const struct __ns1__UpdSnRecInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdSnRecInfo_(soap, tag ? tag : "-ns1:UpdSnRecInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdSnRecInfo_ * SOAP_FMAC4 soap_get___ns1__UpdSnRecInfo_(struct soap *soap, struct __ns1__UpdSnRecInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdSnRecInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsBoxInfo_(struct soap *soap, struct __ns1__InsBoxInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsBoxInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsBoxInfo_(struct soap *soap, const struct __ns1__InsBoxInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsBoxInfo(soap, &a->ns1__InsBoxInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsBoxInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InsBoxInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsBoxInfo(soap, "ns1:InsBoxInfo", -1, &a->ns1__InsBoxInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxInfo_ * SOAP_FMAC4 soap_in___ns1__InsBoxInfo_(struct soap *soap, const char *tag, struct __ns1__InsBoxInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InsBoxInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsBoxInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsBoxInfo_, sizeof(struct __ns1__InsBoxInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsBoxInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsBoxInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsBoxInfo(soap, "ns1:InsBoxInfo", &a->ns1__InsBoxInfo, ""))
				{	soap_flag_ns1__InsBoxInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsBoxInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InsBoxInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsBoxInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsBoxInfo_ *p;
	size_t k = sizeof(struct __ns1__InsBoxInfo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsBoxInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsBoxInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsBoxInfo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsBoxInfo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsBoxInfo_(struct soap *soap, const struct __ns1__InsBoxInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsBoxInfo_(soap, tag ? tag : "-ns1:InsBoxInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxInfo_ * SOAP_FMAC4 soap_get___ns1__InsBoxInfo_(struct soap *soap, struct __ns1__InsBoxInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsBoxInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsLnkOutSN_(struct soap *soap, struct __ns1__InsLnkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsLnkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsLnkOutSN_(struct soap *soap, const struct __ns1__InsLnkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsLnkOutSN(soap, &a->ns1__InsLnkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsLnkOutSN_(struct soap *soap, const char *tag, int id, const struct __ns1__InsLnkOutSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsLnkOutSN(soap, "ns1:InsLnkOutSN", -1, &a->ns1__InsLnkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLnkOutSN_ * SOAP_FMAC4 soap_in___ns1__InsLnkOutSN_(struct soap *soap, const char *tag, struct __ns1__InsLnkOutSN_ *a, const char *type)
{
	size_t soap_flag_ns1__InsLnkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsLnkOutSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsLnkOutSN_, sizeof(struct __ns1__InsLnkOutSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsLnkOutSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsLnkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsLnkOutSN(soap, "ns1:InsLnkOutSN", &a->ns1__InsLnkOutSN, ""))
				{	soap_flag_ns1__InsLnkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsLnkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__InsLnkOutSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsLnkOutSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsLnkOutSN_ *p;
	size_t k = sizeof(struct __ns1__InsLnkOutSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsLnkOutSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsLnkOutSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsLnkOutSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsLnkOutSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsLnkOutSN_(struct soap *soap, const struct __ns1__InsLnkOutSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsLnkOutSN_(soap, tag ? tag : "-ns1:InsLnkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLnkOutSN_ * SOAP_FMAC4 soap_get___ns1__InsLnkOutSN_(struct soap *soap, struct __ns1__InsLnkOutSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsLnkOutSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsSNStationEmp_(struct soap *soap, struct __ns1__InsSNStationEmp_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsSNStationEmp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsSNStationEmp_(struct soap *soap, const struct __ns1__InsSNStationEmp_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsSNStationEmp(soap, &a->ns1__InsSNStationEmp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsSNStationEmp_(struct soap *soap, const char *tag, int id, const struct __ns1__InsSNStationEmp_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsSNStationEmp(soap, "ns1:InsSNStationEmp", -1, &a->ns1__InsSNStationEmp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNStationEmp_ * SOAP_FMAC4 soap_in___ns1__InsSNStationEmp_(struct soap *soap, const char *tag, struct __ns1__InsSNStationEmp_ *a, const char *type)
{
	size_t soap_flag_ns1__InsSNStationEmp = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsSNStationEmp_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsSNStationEmp_, sizeof(struct __ns1__InsSNStationEmp_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsSNStationEmp_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsSNStationEmp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsSNStationEmp(soap, "ns1:InsSNStationEmp", &a->ns1__InsSNStationEmp, ""))
				{	soap_flag_ns1__InsSNStationEmp--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsSNStationEmp_ * SOAP_FMAC2 soap_instantiate___ns1__InsSNStationEmp_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsSNStationEmp_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsSNStationEmp_ *p;
	size_t k = sizeof(struct __ns1__InsSNStationEmp_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsSNStationEmp_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsSNStationEmp_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsSNStationEmp_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsSNStationEmp_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsSNStationEmp_(struct soap *soap, const struct __ns1__InsSNStationEmp_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsSNStationEmp_(soap, tag ? tag : "-ns1:InsSNStationEmp", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNStationEmp_ * SOAP_FMAC4 soap_get___ns1__InsSNStationEmp_(struct soap *soap, struct __ns1__InsSNStationEmp_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsSNStationEmp_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CancelBoxLnk_(struct soap *soap, struct __ns1__CancelBoxLnk_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelBoxLnk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CancelBoxLnk_(struct soap *soap, const struct __ns1__CancelBoxLnk_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelBoxLnk(soap, &a->ns1__CancelBoxLnk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CancelBoxLnk_(struct soap *soap, const char *tag, int id, const struct __ns1__CancelBoxLnk_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelBoxLnk(soap, "ns1:CancelBoxLnk", -1, &a->ns1__CancelBoxLnk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelBoxLnk_ * SOAP_FMAC4 soap_in___ns1__CancelBoxLnk_(struct soap *soap, const char *tag, struct __ns1__CancelBoxLnk_ *a, const char *type)
{
	size_t soap_flag_ns1__CancelBoxLnk = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CancelBoxLnk_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CancelBoxLnk_, sizeof(struct __ns1__CancelBoxLnk_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CancelBoxLnk_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelBoxLnk && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CancelBoxLnk(soap, "ns1:CancelBoxLnk", &a->ns1__CancelBoxLnk, ""))
				{	soap_flag_ns1__CancelBoxLnk--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CancelBoxLnk_ * SOAP_FMAC2 soap_instantiate___ns1__CancelBoxLnk_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CancelBoxLnk_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CancelBoxLnk_ *p;
	size_t k = sizeof(struct __ns1__CancelBoxLnk_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CancelBoxLnk_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CancelBoxLnk_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CancelBoxLnk_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CancelBoxLnk_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CancelBoxLnk_(struct soap *soap, const struct __ns1__CancelBoxLnk_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CancelBoxLnk_(soap, tag ? tag : "-ns1:CancelBoxLnk", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelBoxLnk_ * SOAP_FMAC4 soap_get___ns1__CancelBoxLnk_(struct soap *soap, struct __ns1__CancelBoxLnk_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CancelBoxLnk_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutStationbyBox_(struct soap *soap, struct __ns1__OutStationbyBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutStationbyBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutStationbyBox_(struct soap *soap, const struct __ns1__OutStationbyBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutStationbyBox(soap, &a->ns1__OutStationbyBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutStationbyBox_(struct soap *soap, const char *tag, int id, const struct __ns1__OutStationbyBox_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutStationbyBox(soap, "ns1:OutStationbyBox", -1, &a->ns1__OutStationbyBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutStationbyBox_ * SOAP_FMAC4 soap_in___ns1__OutStationbyBox_(struct soap *soap, const char *tag, struct __ns1__OutStationbyBox_ *a, const char *type)
{
	size_t soap_flag_ns1__OutStationbyBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutStationbyBox_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutStationbyBox_, sizeof(struct __ns1__OutStationbyBox_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutStationbyBox_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutStationbyBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutStationbyBox(soap, "ns1:OutStationbyBox", &a->ns1__OutStationbyBox, ""))
				{	soap_flag_ns1__OutStationbyBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutStationbyBox_ * SOAP_FMAC2 soap_instantiate___ns1__OutStationbyBox_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutStationbyBox_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutStationbyBox_ *p;
	size_t k = sizeof(struct __ns1__OutStationbyBox_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OutStationbyBox_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OutStationbyBox_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutStationbyBox_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OutStationbyBox_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutStationbyBox_(struct soap *soap, const struct __ns1__OutStationbyBox_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutStationbyBox_(soap, tag ? tag : "-ns1:OutStationbyBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutStationbyBox_ * SOAP_FMAC4 soap_get___ns1__OutStationbyBox_(struct soap *soap, struct __ns1__OutStationbyBox_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutStationbyBox_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InStationbyBox_(struct soap *soap, struct __ns1__InStationbyBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InStationbyBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InStationbyBox_(struct soap *soap, const struct __ns1__InStationbyBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InStationbyBox(soap, &a->ns1__InStationbyBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InStationbyBox_(struct soap *soap, const char *tag, int id, const struct __ns1__InStationbyBox_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InStationbyBox(soap, "ns1:InStationbyBox", -1, &a->ns1__InStationbyBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InStationbyBox_ * SOAP_FMAC4 soap_in___ns1__InStationbyBox_(struct soap *soap, const char *tag, struct __ns1__InStationbyBox_ *a, const char *type)
{
	size_t soap_flag_ns1__InStationbyBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InStationbyBox_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InStationbyBox_, sizeof(struct __ns1__InStationbyBox_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InStationbyBox_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InStationbyBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InStationbyBox(soap, "ns1:InStationbyBox", &a->ns1__InStationbyBox, ""))
				{	soap_flag_ns1__InStationbyBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InStationbyBox_ * SOAP_FMAC2 soap_instantiate___ns1__InStationbyBox_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InStationbyBox_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InStationbyBox_ *p;
	size_t k = sizeof(struct __ns1__InStationbyBox_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InStationbyBox_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InStationbyBox_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InStationbyBox_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InStationbyBox_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InStationbyBox_(struct soap *soap, const struct __ns1__InStationbyBox_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InStationbyBox_(soap, tag ? tag : "-ns1:InStationbyBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InStationbyBox_ * SOAP_FMAC4 soap_get___ns1__InStationbyBox_(struct soap *soap, struct __ns1__InStationbyBox_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InStationbyBox_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndSNtoBox_(struct soap *soap, struct __ns1__EndSNtoBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndSNtoBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndSNtoBox_(struct soap *soap, const struct __ns1__EndSNtoBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndSNtoBox(soap, &a->ns1__EndSNtoBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndSNtoBox_(struct soap *soap, const char *tag, int id, const struct __ns1__EndSNtoBox_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndSNtoBox(soap, "ns1:EndSNtoBox", -1, &a->ns1__EndSNtoBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndSNtoBox_ * SOAP_FMAC4 soap_in___ns1__EndSNtoBox_(struct soap *soap, const char *tag, struct __ns1__EndSNtoBox_ *a, const char *type)
{
	size_t soap_flag_ns1__EndSNtoBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndSNtoBox_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndSNtoBox_, sizeof(struct __ns1__EndSNtoBox_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndSNtoBox_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndSNtoBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EndSNtoBox(soap, "ns1:EndSNtoBox", &a->ns1__EndSNtoBox, ""))
				{	soap_flag_ns1__EndSNtoBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EndSNtoBox_ * SOAP_FMAC2 soap_instantiate___ns1__EndSNtoBox_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndSNtoBox_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EndSNtoBox_ *p;
	size_t k = sizeof(struct __ns1__EndSNtoBox_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__EndSNtoBox_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__EndSNtoBox_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EndSNtoBox_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__EndSNtoBox_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndSNtoBox_(struct soap *soap, const struct __ns1__EndSNtoBox_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EndSNtoBox_(soap, tag ? tag : "-ns1:EndSNtoBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndSNtoBox_ * SOAP_FMAC4 soap_get___ns1__EndSNtoBox_(struct soap *soap, struct __ns1__EndSNtoBox_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndSNtoBox_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InSNtoBox_(struct soap *soap, struct __ns1__InSNtoBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InSNtoBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InSNtoBox_(struct soap *soap, const struct __ns1__InSNtoBox_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InSNtoBox(soap, &a->ns1__InSNtoBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InSNtoBox_(struct soap *soap, const char *tag, int id, const struct __ns1__InSNtoBox_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InSNtoBox(soap, "ns1:InSNtoBox", -1, &a->ns1__InSNtoBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSNtoBox_ * SOAP_FMAC4 soap_in___ns1__InSNtoBox_(struct soap *soap, const char *tag, struct __ns1__InSNtoBox_ *a, const char *type)
{
	size_t soap_flag_ns1__InSNtoBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InSNtoBox_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InSNtoBox_, sizeof(struct __ns1__InSNtoBox_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InSNtoBox_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InSNtoBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InSNtoBox(soap, "ns1:InSNtoBox", &a->ns1__InSNtoBox, ""))
				{	soap_flag_ns1__InSNtoBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InSNtoBox_ * SOAP_FMAC2 soap_instantiate___ns1__InSNtoBox_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InSNtoBox_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InSNtoBox_ *p;
	size_t k = sizeof(struct __ns1__InSNtoBox_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InSNtoBox_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InSNtoBox_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InSNtoBox_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InSNtoBox_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InSNtoBox_(struct soap *soap, const struct __ns1__InSNtoBox_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InSNtoBox_(soap, tag ? tag : "-ns1:InSNtoBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSNtoBox_ * SOAP_FMAC4 soap_get___ns1__InSNtoBox_(struct soap *soap, struct __ns1__InSNtoBox_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InSNtoBox_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkBoxNo_(struct soap *soap, struct __ns1__chkBoxNo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkBoxNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkBoxNo_(struct soap *soap, const struct __ns1__chkBoxNo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkBoxNo(soap, &a->ns1__chkBoxNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkBoxNo_(struct soap *soap, const char *tag, int id, const struct __ns1__chkBoxNo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkBoxNo(soap, "ns1:chkBoxNo", -1, &a->ns1__chkBoxNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkBoxNo_ * SOAP_FMAC4 soap_in___ns1__chkBoxNo_(struct soap *soap, const char *tag, struct __ns1__chkBoxNo_ *a, const char *type)
{
	size_t soap_flag_ns1__chkBoxNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkBoxNo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkBoxNo_, sizeof(struct __ns1__chkBoxNo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkBoxNo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkBoxNo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkBoxNo(soap, "ns1:chkBoxNo", &a->ns1__chkBoxNo, ""))
				{	soap_flag_ns1__chkBoxNo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkBoxNo_ * SOAP_FMAC2 soap_instantiate___ns1__chkBoxNo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkBoxNo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkBoxNo_ *p;
	size_t k = sizeof(struct __ns1__chkBoxNo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkBoxNo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkBoxNo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkBoxNo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkBoxNo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkBoxNo_(struct soap *soap, const struct __ns1__chkBoxNo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkBoxNo_(soap, tag ? tag : "-ns1:chkBoxNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkBoxNo_ * SOAP_FMAC4 soap_get___ns1__chkBoxNo_(struct soap *soap, struct __ns1__chkBoxNo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkBoxNo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsBoxNOTime_(struct soap *soap, struct __ns1__InsBoxNOTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsBoxNOTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsBoxNOTime_(struct soap *soap, const struct __ns1__InsBoxNOTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsBoxNOTime(soap, &a->ns1__InsBoxNOTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsBoxNOTime_(struct soap *soap, const char *tag, int id, const struct __ns1__InsBoxNOTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsBoxNOTime(soap, "ns1:InsBoxNOTime", -1, &a->ns1__InsBoxNOTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxNOTime_ * SOAP_FMAC4 soap_in___ns1__InsBoxNOTime_(struct soap *soap, const char *tag, struct __ns1__InsBoxNOTime_ *a, const char *type)
{
	size_t soap_flag_ns1__InsBoxNOTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsBoxNOTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsBoxNOTime_, sizeof(struct __ns1__InsBoxNOTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsBoxNOTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsBoxNOTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsBoxNOTime(soap, "ns1:InsBoxNOTime", &a->ns1__InsBoxNOTime, ""))
				{	soap_flag_ns1__InsBoxNOTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsBoxNOTime_ * SOAP_FMAC2 soap_instantiate___ns1__InsBoxNOTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsBoxNOTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsBoxNOTime_ *p;
	size_t k = sizeof(struct __ns1__InsBoxNOTime_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsBoxNOTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsBoxNOTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsBoxNOTime_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsBoxNOTime_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsBoxNOTime_(struct soap *soap, const struct __ns1__InsBoxNOTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsBoxNOTime_(soap, tag ? tag : "-ns1:InsBoxNOTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxNOTime_ * SOAP_FMAC4 soap_get___ns1__InsBoxNOTime_(struct soap *soap, struct __ns1__InsBoxNOTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsBoxNOTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLinkZJCount_(struct soap *soap, struct __ns1__GetLinkZJCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLinkZJCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLinkZJCount_(struct soap *soap, const struct __ns1__GetLinkZJCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLinkZJCount(soap, &a->ns1__GetLinkZJCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLinkZJCount_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLinkZJCount_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLinkZJCount(soap, "ns1:GetLinkZJCount", -1, &a->ns1__GetLinkZJCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkZJCount_ * SOAP_FMAC4 soap_in___ns1__GetLinkZJCount_(struct soap *soap, const char *tag, struct __ns1__GetLinkZJCount_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLinkZJCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLinkZJCount_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLinkZJCount_, sizeof(struct __ns1__GetLinkZJCount_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLinkZJCount_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLinkZJCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLinkZJCount(soap, "ns1:GetLinkZJCount", &a->ns1__GetLinkZJCount, ""))
				{	soap_flag_ns1__GetLinkZJCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLinkZJCount_ * SOAP_FMAC2 soap_instantiate___ns1__GetLinkZJCount_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLinkZJCount_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLinkZJCount_ *p;
	size_t k = sizeof(struct __ns1__GetLinkZJCount_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLinkZJCount_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLinkZJCount_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLinkZJCount_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLinkZJCount_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLinkZJCount_(struct soap *soap, const struct __ns1__GetLinkZJCount_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLinkZJCount_(soap, tag ? tag : "-ns1:GetLinkZJCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkZJCount_ * SOAP_FMAC4 soap_get___ns1__GetLinkZJCount_(struct soap *soap, struct __ns1__GetLinkZJCount_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLinkZJCount_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsLinkSN_(struct soap *soap, struct __ns1__InsLinkSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsLinkSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsLinkSN_(struct soap *soap, const struct __ns1__InsLinkSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsLinkSN(soap, &a->ns1__InsLinkSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsLinkSN_(struct soap *soap, const char *tag, int id, const struct __ns1__InsLinkSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsLinkSN(soap, "ns1:InsLinkSN", -1, &a->ns1__InsLinkSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLinkSN_ * SOAP_FMAC4 soap_in___ns1__InsLinkSN_(struct soap *soap, const char *tag, struct __ns1__InsLinkSN_ *a, const char *type)
{
	size_t soap_flag_ns1__InsLinkSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsLinkSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsLinkSN_, sizeof(struct __ns1__InsLinkSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsLinkSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsLinkSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsLinkSN(soap, "ns1:InsLinkSN", &a->ns1__InsLinkSN, ""))
				{	soap_flag_ns1__InsLinkSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsLinkSN_ * SOAP_FMAC2 soap_instantiate___ns1__InsLinkSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsLinkSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsLinkSN_ *p;
	size_t k = sizeof(struct __ns1__InsLinkSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsLinkSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsLinkSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsLinkSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsLinkSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsLinkSN_(struct soap *soap, const struct __ns1__InsLinkSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsLinkSN_(soap, tag ? tag : "-ns1:InsLinkSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLinkSN_ * SOAP_FMAC4 soap_get___ns1__InsLinkSN_(struct soap *soap, struct __ns1__InsLinkSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsLinkSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doLinkOutSN_(struct soap *soap, struct __ns1__doLinkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doLinkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doLinkOutSN_(struct soap *soap, const struct __ns1__doLinkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doLinkOutSN(soap, &a->ns1__doLinkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doLinkOutSN_(struct soap *soap, const char *tag, int id, const struct __ns1__doLinkOutSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doLinkOutSN(soap, "ns1:doLinkOutSN", -1, &a->ns1__doLinkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLinkOutSN_ * SOAP_FMAC4 soap_in___ns1__doLinkOutSN_(struct soap *soap, const char *tag, struct __ns1__doLinkOutSN_ *a, const char *type)
{
	size_t soap_flag_ns1__doLinkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doLinkOutSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doLinkOutSN_, sizeof(struct __ns1__doLinkOutSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doLinkOutSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doLinkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doLinkOutSN(soap, "ns1:doLinkOutSN", &a->ns1__doLinkOutSN, ""))
				{	soap_flag_ns1__doLinkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doLinkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__doLinkOutSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doLinkOutSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doLinkOutSN_ *p;
	size_t k = sizeof(struct __ns1__doLinkOutSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doLinkOutSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doLinkOutSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doLinkOutSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doLinkOutSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doLinkOutSN_(struct soap *soap, const struct __ns1__doLinkOutSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doLinkOutSN_(soap, tag ? tag : "-ns1:doLinkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLinkOutSN_ * SOAP_FMAC4 soap_get___ns1__doLinkOutSN_(struct soap *soap, struct __ns1__doLinkOutSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doLinkOutSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkLinkOutSN_(struct soap *soap, struct __ns1__ChkLinkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkLinkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkLinkOutSN_(struct soap *soap, const struct __ns1__ChkLinkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkLinkOutSN(soap, &a->ns1__ChkLinkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkLinkOutSN_(struct soap *soap, const char *tag, int id, const struct __ns1__ChkLinkOutSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkLinkOutSN(soap, "ns1:ChkLinkOutSN", -1, &a->ns1__ChkLinkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkLinkOutSN_ * SOAP_FMAC4 soap_in___ns1__ChkLinkOutSN_(struct soap *soap, const char *tag, struct __ns1__ChkLinkOutSN_ *a, const char *type)
{
	size_t soap_flag_ns1__ChkLinkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkLinkOutSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkLinkOutSN_, sizeof(struct __ns1__ChkLinkOutSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkLinkOutSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkLinkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkLinkOutSN(soap, "ns1:ChkLinkOutSN", &a->ns1__ChkLinkOutSN, ""))
				{	soap_flag_ns1__ChkLinkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkLinkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__ChkLinkOutSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkLinkOutSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkLinkOutSN_ *p;
	size_t k = sizeof(struct __ns1__ChkLinkOutSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkLinkOutSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkLinkOutSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkLinkOutSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkLinkOutSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkLinkOutSN_(struct soap *soap, const struct __ns1__ChkLinkOutSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkLinkOutSN_(soap, tag ? tag : "-ns1:ChkLinkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkLinkOutSN_ * SOAP_FMAC4 soap_get___ns1__ChkLinkOutSN_(struct soap *soap, struct __ns1__ChkLinkOutSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkLinkOutSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkOutSN_(struct soap *soap, struct __ns1__chkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkOutSN_(struct soap *soap, const struct __ns1__chkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkOutSN(soap, &a->ns1__chkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkOutSN_(struct soap *soap, const char *tag, int id, const struct __ns1__chkOutSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkOutSN(soap, "ns1:chkOutSN", -1, &a->ns1__chkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkOutSN_ * SOAP_FMAC4 soap_in___ns1__chkOutSN_(struct soap *soap, const char *tag, struct __ns1__chkOutSN_ *a, const char *type)
{
	size_t soap_flag_ns1__chkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkOutSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkOutSN_, sizeof(struct __ns1__chkOutSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkOutSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkOutSN(soap, "ns1:chkOutSN", &a->ns1__chkOutSN, ""))
				{	soap_flag_ns1__chkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__chkOutSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkOutSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkOutSN_ *p;
	size_t k = sizeof(struct __ns1__chkOutSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkOutSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkOutSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkOutSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkOutSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkOutSN_(struct soap *soap, const struct __ns1__chkOutSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkOutSN_(soap, tag ? tag : "-ns1:chkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkOutSN_ * SOAP_FMAC4 soap_get___ns1__chkOutSN_(struct soap *soap, struct __ns1__chkOutSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkOutSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLintOutQty_(struct soap *soap, struct __ns1__GetLintOutQty_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLintOutQty = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLintOutQty_(struct soap *soap, const struct __ns1__GetLintOutQty_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLintOutQty(soap, &a->ns1__GetLintOutQty);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLintOutQty_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLintOutQty_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLintOutQty(soap, "ns1:GetLintOutQty", -1, &a->ns1__GetLintOutQty, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLintOutQty_ * SOAP_FMAC4 soap_in___ns1__GetLintOutQty_(struct soap *soap, const char *tag, struct __ns1__GetLintOutQty_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLintOutQty = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLintOutQty_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLintOutQty_, sizeof(struct __ns1__GetLintOutQty_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLintOutQty_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLintOutQty && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLintOutQty(soap, "ns1:GetLintOutQty", &a->ns1__GetLintOutQty, ""))
				{	soap_flag_ns1__GetLintOutQty--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLintOutQty_ * SOAP_FMAC2 soap_instantiate___ns1__GetLintOutQty_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLintOutQty_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLintOutQty_ *p;
	size_t k = sizeof(struct __ns1__GetLintOutQty_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLintOutQty_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLintOutQty_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLintOutQty_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLintOutQty_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLintOutQty_(struct soap *soap, const struct __ns1__GetLintOutQty_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLintOutQty_(soap, tag ? tag : "-ns1:GetLintOutQty", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLintOutQty_ * SOAP_FMAC4 soap_get___ns1__GetLintOutQty_(struct soap *soap, struct __ns1__GetLintOutQty_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLintOutQty_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SNLinkZJ_(struct soap *soap, struct __ns1__SNLinkZJ_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SNLinkZJ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SNLinkZJ_(struct soap *soap, const struct __ns1__SNLinkZJ_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SNLinkZJ(soap, &a->ns1__SNLinkZJ);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SNLinkZJ_(struct soap *soap, const char *tag, int id, const struct __ns1__SNLinkZJ_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SNLinkZJ(soap, "ns1:SNLinkZJ", -1, &a->ns1__SNLinkZJ, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkZJ_ * SOAP_FMAC4 soap_in___ns1__SNLinkZJ_(struct soap *soap, const char *tag, struct __ns1__SNLinkZJ_ *a, const char *type)
{
	size_t soap_flag_ns1__SNLinkZJ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SNLinkZJ_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SNLinkZJ_, sizeof(struct __ns1__SNLinkZJ_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SNLinkZJ_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SNLinkZJ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SNLinkZJ(soap, "ns1:SNLinkZJ", &a->ns1__SNLinkZJ, ""))
				{	soap_flag_ns1__SNLinkZJ--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SNLinkZJ_ * SOAP_FMAC2 soap_instantiate___ns1__SNLinkZJ_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SNLinkZJ_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SNLinkZJ_ *p;
	size_t k = sizeof(struct __ns1__SNLinkZJ_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SNLinkZJ_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SNLinkZJ_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SNLinkZJ_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SNLinkZJ_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SNLinkZJ_(struct soap *soap, const struct __ns1__SNLinkZJ_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SNLinkZJ_(soap, tag ? tag : "-ns1:SNLinkZJ", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkZJ_ * SOAP_FMAC4 soap_get___ns1__SNLinkZJ_(struct soap *soap, struct __ns1__SNLinkZJ_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SNLinkZJ_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsZJTestData_(struct soap *soap, struct __ns1__InsZJTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsZJTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsZJTestData_(struct soap *soap, const struct __ns1__InsZJTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsZJTestData(soap, &a->ns1__InsZJTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsZJTestData_(struct soap *soap, const char *tag, int id, const struct __ns1__InsZJTestData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsZJTestData(soap, "ns1:InsZJTestData", -1, &a->ns1__InsZJTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZJTestData_ * SOAP_FMAC4 soap_in___ns1__InsZJTestData_(struct soap *soap, const char *tag, struct __ns1__InsZJTestData_ *a, const char *type)
{
	size_t soap_flag_ns1__InsZJTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsZJTestData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsZJTestData_, sizeof(struct __ns1__InsZJTestData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsZJTestData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsZJTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsZJTestData(soap, "ns1:InsZJTestData", &a->ns1__InsZJTestData, ""))
				{	soap_flag_ns1__InsZJTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsZJTestData_ * SOAP_FMAC2 soap_instantiate___ns1__InsZJTestData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsZJTestData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsZJTestData_ *p;
	size_t k = sizeof(struct __ns1__InsZJTestData_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsZJTestData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsZJTestData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsZJTestData_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsZJTestData_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsZJTestData_(struct soap *soap, const struct __ns1__InsZJTestData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsZJTestData_(soap, tag ? tag : "-ns1:InsZJTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZJTestData_ * SOAP_FMAC4 soap_get___ns1__InsZJTestData_(struct soap *soap, struct __ns1__InsZJTestData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsZJTestData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doPmcSNLink_(struct soap *soap, struct __ns1__doPmcSNLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doPmcSNLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doPmcSNLink_(struct soap *soap, const struct __ns1__doPmcSNLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doPmcSNLink(soap, &a->ns1__doPmcSNLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doPmcSNLink_(struct soap *soap, const char *tag, int id, const struct __ns1__doPmcSNLink_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doPmcSNLink(soap, "ns1:doPmcSNLink", -1, &a->ns1__doPmcSNLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doPmcSNLink_ * SOAP_FMAC4 soap_in___ns1__doPmcSNLink_(struct soap *soap, const char *tag, struct __ns1__doPmcSNLink_ *a, const char *type)
{
	size_t soap_flag_ns1__doPmcSNLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doPmcSNLink_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doPmcSNLink_, sizeof(struct __ns1__doPmcSNLink_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doPmcSNLink_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doPmcSNLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doPmcSNLink(soap, "ns1:doPmcSNLink", &a->ns1__doPmcSNLink, ""))
				{	soap_flag_ns1__doPmcSNLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doPmcSNLink_ * SOAP_FMAC2 soap_instantiate___ns1__doPmcSNLink_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doPmcSNLink_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doPmcSNLink_ *p;
	size_t k = sizeof(struct __ns1__doPmcSNLink_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doPmcSNLink_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doPmcSNLink_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doPmcSNLink_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doPmcSNLink_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doPmcSNLink_(struct soap *soap, const struct __ns1__doPmcSNLink_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doPmcSNLink_(soap, tag ? tag : "-ns1:doPmcSNLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doPmcSNLink_ * SOAP_FMAC4 soap_get___ns1__doPmcSNLink_(struct soap *soap, struct __ns1__doPmcSNLink_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doPmcSNLink_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPmcSNPart_(struct soap *soap, struct __ns1__GetPmcSNPart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPmcSNPart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPmcSNPart_(struct soap *soap, const struct __ns1__GetPmcSNPart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPmcSNPart(soap, &a->ns1__GetPmcSNPart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPmcSNPart_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPmcSNPart_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPmcSNPart(soap, "ns1:GetPmcSNPart", -1, &a->ns1__GetPmcSNPart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPmcSNPart_ * SOAP_FMAC4 soap_in___ns1__GetPmcSNPart_(struct soap *soap, const char *tag, struct __ns1__GetPmcSNPart_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPmcSNPart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPmcSNPart_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPmcSNPart_, sizeof(struct __ns1__GetPmcSNPart_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPmcSNPart_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPmcSNPart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPmcSNPart(soap, "ns1:GetPmcSNPart", &a->ns1__GetPmcSNPart, ""))
				{	soap_flag_ns1__GetPmcSNPart--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPmcSNPart_ * SOAP_FMAC2 soap_instantiate___ns1__GetPmcSNPart_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPmcSNPart_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPmcSNPart_ *p;
	size_t k = sizeof(struct __ns1__GetPmcSNPart_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPmcSNPart_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPmcSNPart_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPmcSNPart_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPmcSNPart_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPmcSNPart_(struct soap *soap, const struct __ns1__GetPmcSNPart_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPmcSNPart_(soap, tag ? tag : "-ns1:GetPmcSNPart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPmcSNPart_ * SOAP_FMAC4 soap_get___ns1__GetPmcSNPart_(struct soap *soap, struct __ns1__GetPmcSNPart_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPmcSNPart_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPmcPartAssyList_(struct soap *soap, struct __ns1__getPmcPartAssyList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPmcPartAssyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPmcPartAssyList_(struct soap *soap, const struct __ns1__getPmcPartAssyList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPmcPartAssyList(soap, &a->ns1__getPmcPartAssyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPmcPartAssyList_(struct soap *soap, const char *tag, int id, const struct __ns1__getPmcPartAssyList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPmcPartAssyList(soap, "ns1:getPmcPartAssyList", -1, &a->ns1__getPmcPartAssyList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcPartAssyList_ * SOAP_FMAC4 soap_in___ns1__getPmcPartAssyList_(struct soap *soap, const char *tag, struct __ns1__getPmcPartAssyList_ *a, const char *type)
{
	size_t soap_flag_ns1__getPmcPartAssyList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPmcPartAssyList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPmcPartAssyList_, sizeof(struct __ns1__getPmcPartAssyList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPmcPartAssyList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPmcPartAssyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPmcPartAssyList(soap, "ns1:getPmcPartAssyList", &a->ns1__getPmcPartAssyList, ""))
				{	soap_flag_ns1__getPmcPartAssyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPmcPartAssyList_ * SOAP_FMAC2 soap_instantiate___ns1__getPmcPartAssyList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPmcPartAssyList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPmcPartAssyList_ *p;
	size_t k = sizeof(struct __ns1__getPmcPartAssyList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPmcPartAssyList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPmcPartAssyList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPmcPartAssyList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPmcPartAssyList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPmcPartAssyList_(struct soap *soap, const struct __ns1__getPmcPartAssyList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPmcPartAssyList_(soap, tag ? tag : "-ns1:getPmcPartAssyList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcPartAssyList_ * SOAP_FMAC4 soap_get___ns1__getPmcPartAssyList_(struct soap *soap, struct __ns1__getPmcPartAssyList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPmcPartAssyList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPmcAssyList_(struct soap *soap, struct __ns1__getPmcAssyList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPmcAssyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPmcAssyList_(struct soap *soap, const struct __ns1__getPmcAssyList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPmcAssyList(soap, &a->ns1__getPmcAssyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPmcAssyList_(struct soap *soap, const char *tag, int id, const struct __ns1__getPmcAssyList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPmcAssyList(soap, "ns1:getPmcAssyList", -1, &a->ns1__getPmcAssyList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcAssyList_ * SOAP_FMAC4 soap_in___ns1__getPmcAssyList_(struct soap *soap, const char *tag, struct __ns1__getPmcAssyList_ *a, const char *type)
{
	size_t soap_flag_ns1__getPmcAssyList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPmcAssyList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPmcAssyList_, sizeof(struct __ns1__getPmcAssyList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPmcAssyList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPmcAssyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPmcAssyList(soap, "ns1:getPmcAssyList", &a->ns1__getPmcAssyList, ""))
				{	soap_flag_ns1__getPmcAssyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPmcAssyList_ * SOAP_FMAC2 soap_instantiate___ns1__getPmcAssyList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPmcAssyList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPmcAssyList_ *p;
	size_t k = sizeof(struct __ns1__getPmcAssyList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPmcAssyList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPmcAssyList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPmcAssyList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPmcAssyList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPmcAssyList_(struct soap *soap, const struct __ns1__getPmcAssyList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPmcAssyList_(soap, tag ? tag : "-ns1:getPmcAssyList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcAssyList_ * SOAP_FMAC4 soap_get___ns1__getPmcAssyList_(struct soap *soap, struct __ns1__getPmcAssyList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPmcAssyList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doAssy_(struct soap *soap, struct __ns1__doAssy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doAssy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doAssy_(struct soap *soap, const struct __ns1__doAssy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doAssy(soap, &a->ns1__doAssy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doAssy_(struct soap *soap, const char *tag, int id, const struct __ns1__doAssy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doAssy(soap, "ns1:doAssy", -1, &a->ns1__doAssy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doAssy_ * SOAP_FMAC4 soap_in___ns1__doAssy_(struct soap *soap, const char *tag, struct __ns1__doAssy_ *a, const char *type)
{
	size_t soap_flag_ns1__doAssy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doAssy_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doAssy_, sizeof(struct __ns1__doAssy_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doAssy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doAssy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doAssy(soap, "ns1:doAssy", &a->ns1__doAssy, ""))
				{	soap_flag_ns1__doAssy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doAssy_ * SOAP_FMAC2 soap_instantiate___ns1__doAssy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doAssy_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doAssy_ *p;
	size_t k = sizeof(struct __ns1__doAssy_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doAssy_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doAssy_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doAssy_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doAssy_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doAssy_(struct soap *soap, const struct __ns1__doAssy_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doAssy_(soap, tag ? tag : "-ns1:doAssy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doAssy_ * SOAP_FMAC4 soap_get___ns1__doAssy_(struct soap *soap, struct __ns1__doAssy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doAssy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkAssySN_(struct soap *soap, struct __ns1__chkAssySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkAssySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkAssySN_(struct soap *soap, const struct __ns1__chkAssySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkAssySN(soap, &a->ns1__chkAssySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkAssySN_(struct soap *soap, const char *tag, int id, const struct __ns1__chkAssySN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkAssySN(soap, "ns1:chkAssySN", -1, &a->ns1__chkAssySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkAssySN_ * SOAP_FMAC4 soap_in___ns1__chkAssySN_(struct soap *soap, const char *tag, struct __ns1__chkAssySN_ *a, const char *type)
{
	size_t soap_flag_ns1__chkAssySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkAssySN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkAssySN_, sizeof(struct __ns1__chkAssySN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkAssySN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkAssySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkAssySN(soap, "ns1:chkAssySN", &a->ns1__chkAssySN, ""))
				{	soap_flag_ns1__chkAssySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkAssySN_ * SOAP_FMAC2 soap_instantiate___ns1__chkAssySN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkAssySN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkAssySN_ *p;
	size_t k = sizeof(struct __ns1__chkAssySN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkAssySN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkAssySN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkAssySN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkAssySN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkAssySN_(struct soap *soap, const struct __ns1__chkAssySN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkAssySN_(soap, tag ? tag : "-ns1:chkAssySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkAssySN_ * SOAP_FMAC4 soap_get___ns1__chkAssySN_(struct soap *soap, struct __ns1__chkAssySN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkAssySN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPNbySN_(struct soap *soap, struct __ns1__getPNbySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPNbySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPNbySN_(struct soap *soap, const struct __ns1__getPNbySN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPNbySN(soap, &a->ns1__getPNbySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPNbySN_(struct soap *soap, const char *tag, int id, const struct __ns1__getPNbySN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPNbySN(soap, "ns1:getPNbySN", -1, &a->ns1__getPNbySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPNbySN_ * SOAP_FMAC4 soap_in___ns1__getPNbySN_(struct soap *soap, const char *tag, struct __ns1__getPNbySN_ *a, const char *type)
{
	size_t soap_flag_ns1__getPNbySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPNbySN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPNbySN_, sizeof(struct __ns1__getPNbySN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPNbySN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPNbySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPNbySN(soap, "ns1:getPNbySN", &a->ns1__getPNbySN, ""))
				{	soap_flag_ns1__getPNbySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPNbySN_ * SOAP_FMAC2 soap_instantiate___ns1__getPNbySN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPNbySN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPNbySN_ *p;
	size_t k = sizeof(struct __ns1__getPNbySN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPNbySN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPNbySN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPNbySN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPNbySN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPNbySN_(struct soap *soap, const struct __ns1__getPNbySN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPNbySN_(soap, tag ? tag : "-ns1:getPNbySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPNbySN_ * SOAP_FMAC4 soap_get___ns1__getPNbySN_(struct soap *soap, struct __ns1__getPNbySN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPNbySN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMoAssyCount_(struct soap *soap, struct __ns1__getMoAssyCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMoAssyCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMoAssyCount_(struct soap *soap, const struct __ns1__getMoAssyCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoAssyCount(soap, &a->ns1__getMoAssyCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMoAssyCount_(struct soap *soap, const char *tag, int id, const struct __ns1__getMoAssyCount_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMoAssyCount(soap, "ns1:getMoAssyCount", -1, &a->ns1__getMoAssyCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyCount_ * SOAP_FMAC4 soap_in___ns1__getMoAssyCount_(struct soap *soap, const char *tag, struct __ns1__getMoAssyCount_ *a, const char *type)
{
	size_t soap_flag_ns1__getMoAssyCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMoAssyCount_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMoAssyCount_, sizeof(struct __ns1__getMoAssyCount_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMoAssyCount_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMoAssyCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoAssyCount(soap, "ns1:getMoAssyCount", &a->ns1__getMoAssyCount, ""))
				{	soap_flag_ns1__getMoAssyCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMoAssyCount_ * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyCount_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMoAssyCount_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMoAssyCount_ *p;
	size_t k = sizeof(struct __ns1__getMoAssyCount_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMoAssyCount_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMoAssyCount_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMoAssyCount_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMoAssyCount_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMoAssyCount_(struct soap *soap, const struct __ns1__getMoAssyCount_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMoAssyCount_(soap, tag ? tag : "-ns1:getMoAssyCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyCount_ * SOAP_FMAC4 soap_get___ns1__getMoAssyCount_(struct soap *soap, struct __ns1__getMoAssyCount_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMoAssyCount_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLinkOutSn_(struct soap *soap, struct __ns1__GetLinkOutSn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLinkOutSn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLinkOutSn_(struct soap *soap, const struct __ns1__GetLinkOutSn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLinkOutSn(soap, &a->ns1__GetLinkOutSn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLinkOutSn_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLinkOutSn_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLinkOutSn(soap, "ns1:GetLinkOutSn", -1, &a->ns1__GetLinkOutSn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkOutSn_ * SOAP_FMAC4 soap_in___ns1__GetLinkOutSn_(struct soap *soap, const char *tag, struct __ns1__GetLinkOutSn_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLinkOutSn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLinkOutSn_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLinkOutSn_, sizeof(struct __ns1__GetLinkOutSn_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLinkOutSn_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLinkOutSn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLinkOutSn(soap, "ns1:GetLinkOutSn", &a->ns1__GetLinkOutSn, ""))
				{	soap_flag_ns1__GetLinkOutSn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLinkOutSn_ * SOAP_FMAC2 soap_instantiate___ns1__GetLinkOutSn_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLinkOutSn_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLinkOutSn_ *p;
	size_t k = sizeof(struct __ns1__GetLinkOutSn_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLinkOutSn_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLinkOutSn_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLinkOutSn_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLinkOutSn_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLinkOutSn_(struct soap *soap, const struct __ns1__GetLinkOutSn_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLinkOutSn_(soap, tag ? tag : "-ns1:GetLinkOutSn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkOutSn_ * SOAP_FMAC4 soap_get___ns1__GetLinkOutSn_(struct soap *soap, struct __ns1__GetLinkOutSn_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLinkOutSn_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsPartAssy_(struct soap *soap, struct __ns1__InsPartAssy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsPartAssy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsPartAssy_(struct soap *soap, const struct __ns1__InsPartAssy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsPartAssy(soap, &a->ns1__InsPartAssy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsPartAssy_(struct soap *soap, const char *tag, int id, const struct __ns1__InsPartAssy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsPartAssy(soap, "ns1:InsPartAssy", -1, &a->ns1__InsPartAssy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsPartAssy_ * SOAP_FMAC4 soap_in___ns1__InsPartAssy_(struct soap *soap, const char *tag, struct __ns1__InsPartAssy_ *a, const char *type)
{
	size_t soap_flag_ns1__InsPartAssy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsPartAssy_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsPartAssy_, sizeof(struct __ns1__InsPartAssy_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsPartAssy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsPartAssy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsPartAssy(soap, "ns1:InsPartAssy", &a->ns1__InsPartAssy, ""))
				{	soap_flag_ns1__InsPartAssy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsPartAssy_ * SOAP_FMAC2 soap_instantiate___ns1__InsPartAssy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsPartAssy_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsPartAssy_ *p;
	size_t k = sizeof(struct __ns1__InsPartAssy_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsPartAssy_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsPartAssy_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsPartAssy_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsPartAssy_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsPartAssy_(struct soap *soap, const struct __ns1__InsPartAssy_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsPartAssy_(soap, tag ? tag : "-ns1:InsPartAssy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsPartAssy_ * SOAP_FMAC4 soap_get___ns1__InsPartAssy_(struct soap *soap, struct __ns1__InsPartAssy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsPartAssy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPartBomExt_(struct soap *soap, struct __ns1__getPartBomExt_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPartBomExt = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPartBomExt_(struct soap *soap, const struct __ns1__getPartBomExt_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPartBomExt(soap, &a->ns1__getPartBomExt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPartBomExt_(struct soap *soap, const char *tag, int id, const struct __ns1__getPartBomExt_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPartBomExt(soap, "ns1:getPartBomExt", -1, &a->ns1__getPartBomExt, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPartBomExt_ * SOAP_FMAC4 soap_in___ns1__getPartBomExt_(struct soap *soap, const char *tag, struct __ns1__getPartBomExt_ *a, const char *type)
{
	size_t soap_flag_ns1__getPartBomExt = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPartBomExt_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPartBomExt_, sizeof(struct __ns1__getPartBomExt_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPartBomExt_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPartBomExt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPartBomExt(soap, "ns1:getPartBomExt", &a->ns1__getPartBomExt, ""))
				{	soap_flag_ns1__getPartBomExt--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPartBomExt_ * SOAP_FMAC2 soap_instantiate___ns1__getPartBomExt_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPartBomExt_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPartBomExt_ *p;
	size_t k = sizeof(struct __ns1__getPartBomExt_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPartBomExt_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPartBomExt_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPartBomExt_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPartBomExt_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPartBomExt_(struct soap *soap, const struct __ns1__getPartBomExt_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPartBomExt_(soap, tag ? tag : "-ns1:getPartBomExt", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPartBomExt_ * SOAP_FMAC4 soap_get___ns1__getPartBomExt_(struct soap *soap, struct __ns1__getPartBomExt_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPartBomExt_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMoAssyList_(struct soap *soap, struct __ns1__getMoAssyList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMoAssyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMoAssyList_(struct soap *soap, const struct __ns1__getMoAssyList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoAssyList(soap, &a->ns1__getMoAssyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMoAssyList_(struct soap *soap, const char *tag, int id, const struct __ns1__getMoAssyList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMoAssyList(soap, "ns1:getMoAssyList", -1, &a->ns1__getMoAssyList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyList_ * SOAP_FMAC4 soap_in___ns1__getMoAssyList_(struct soap *soap, const char *tag, struct __ns1__getMoAssyList_ *a, const char *type)
{
	size_t soap_flag_ns1__getMoAssyList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMoAssyList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMoAssyList_, sizeof(struct __ns1__getMoAssyList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMoAssyList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMoAssyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoAssyList(soap, "ns1:getMoAssyList", &a->ns1__getMoAssyList, ""))
				{	soap_flag_ns1__getMoAssyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMoAssyList_ * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMoAssyList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMoAssyList_ *p;
	size_t k = sizeof(struct __ns1__getMoAssyList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMoAssyList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMoAssyList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMoAssyList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMoAssyList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMoAssyList_(struct soap *soap, const struct __ns1__getMoAssyList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMoAssyList_(soap, tag ? tag : "-ns1:getMoAssyList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyList_ * SOAP_FMAC4 soap_get___ns1__getMoAssyList_(struct soap *soap, struct __ns1__getMoAssyList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMoAssyList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkSnMapping_(struct soap *soap, struct __ns1__chkSnMapping_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkSnMapping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkSnMapping_(struct soap *soap, const struct __ns1__chkSnMapping_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkSnMapping(soap, &a->ns1__chkSnMapping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkSnMapping_(struct soap *soap, const char *tag, int id, const struct __ns1__chkSnMapping_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkSnMapping(soap, "ns1:chkSnMapping", -1, &a->ns1__chkSnMapping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkSnMapping_ * SOAP_FMAC4 soap_in___ns1__chkSnMapping_(struct soap *soap, const char *tag, struct __ns1__chkSnMapping_ *a, const char *type)
{
	size_t soap_flag_ns1__chkSnMapping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkSnMapping_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkSnMapping_, sizeof(struct __ns1__chkSnMapping_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkSnMapping_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkSnMapping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkSnMapping(soap, "ns1:chkSnMapping", &a->ns1__chkSnMapping, ""))
				{	soap_flag_ns1__chkSnMapping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkSnMapping_ * SOAP_FMAC2 soap_instantiate___ns1__chkSnMapping_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkSnMapping_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkSnMapping_ *p;
	size_t k = sizeof(struct __ns1__chkSnMapping_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkSnMapping_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkSnMapping_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkSnMapping_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkSnMapping_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkSnMapping_(struct soap *soap, const struct __ns1__chkSnMapping_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkSnMapping_(soap, tag ? tag : "-ns1:chkSnMapping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkSnMapping_ * SOAP_FMAC4 soap_get___ns1__chkSnMapping_(struct soap *soap, struct __ns1__chkSnMapping_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkSnMapping_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStationTypeDesc_(struct soap *soap, struct __ns1__getStationTypeDesc_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStationTypeDesc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStationTypeDesc_(struct soap *soap, const struct __ns1__getStationTypeDesc_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getStationTypeDesc(soap, &a->ns1__getStationTypeDesc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStationTypeDesc_(struct soap *soap, const char *tag, int id, const struct __ns1__getStationTypeDesc_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getStationTypeDesc(soap, "ns1:getStationTypeDesc", -1, &a->ns1__getStationTypeDesc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationTypeDesc_ * SOAP_FMAC4 soap_in___ns1__getStationTypeDesc_(struct soap *soap, const char *tag, struct __ns1__getStationTypeDesc_ *a, const char *type)
{
	size_t soap_flag_ns1__getStationTypeDesc = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getStationTypeDesc_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStationTypeDesc_, sizeof(struct __ns1__getStationTypeDesc_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStationTypeDesc_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStationTypeDesc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getStationTypeDesc(soap, "ns1:getStationTypeDesc", &a->ns1__getStationTypeDesc, ""))
				{	soap_flag_ns1__getStationTypeDesc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getStationTypeDesc_ * SOAP_FMAC2 soap_instantiate___ns1__getStationTypeDesc_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStationTypeDesc_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getStationTypeDesc_ *p;
	size_t k = sizeof(struct __ns1__getStationTypeDesc_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getStationTypeDesc_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getStationTypeDesc_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getStationTypeDesc_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getStationTypeDesc_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStationTypeDesc_(struct soap *soap, const struct __ns1__getStationTypeDesc_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getStationTypeDesc_(soap, tag ? tag : "-ns1:getStationTypeDesc", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationTypeDesc_ * SOAP_FMAC4 soap_get___ns1__getStationTypeDesc_(struct soap *soap, struct __ns1__getStationTypeDesc_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStationTypeDesc_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStationByMo_(struct soap *soap, struct __ns1__getStationByMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStationByMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStationByMo_(struct soap *soap, const struct __ns1__getStationByMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getStationByMo(soap, &a->ns1__getStationByMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStationByMo_(struct soap *soap, const char *tag, int id, const struct __ns1__getStationByMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getStationByMo(soap, "ns1:getStationByMo", -1, &a->ns1__getStationByMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMo_ * SOAP_FMAC4 soap_in___ns1__getStationByMo_(struct soap *soap, const char *tag, struct __ns1__getStationByMo_ *a, const char *type)
{
	size_t soap_flag_ns1__getStationByMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getStationByMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStationByMo_, sizeof(struct __ns1__getStationByMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStationByMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStationByMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getStationByMo(soap, "ns1:getStationByMo", &a->ns1__getStationByMo, ""))
				{	soap_flag_ns1__getStationByMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getStationByMo_ * SOAP_FMAC2 soap_instantiate___ns1__getStationByMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStationByMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getStationByMo_ *p;
	size_t k = sizeof(struct __ns1__getStationByMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getStationByMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getStationByMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getStationByMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getStationByMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStationByMo_(struct soap *soap, const struct __ns1__getStationByMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getStationByMo_(soap, tag ? tag : "-ns1:getStationByMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMo_ * SOAP_FMAC4 soap_get___ns1__getStationByMo_(struct soap *soap, struct __ns1__getStationByMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStationByMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SnDoMapping_(struct soap *soap, struct __ns1__SnDoMapping_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SnDoMapping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SnDoMapping_(struct soap *soap, const struct __ns1__SnDoMapping_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SnDoMapping(soap, &a->ns1__SnDoMapping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SnDoMapping_(struct soap *soap, const char *tag, int id, const struct __ns1__SnDoMapping_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SnDoMapping(soap, "ns1:SnDoMapping", -1, &a->ns1__SnDoMapping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnDoMapping_ * SOAP_FMAC4 soap_in___ns1__SnDoMapping_(struct soap *soap, const char *tag, struct __ns1__SnDoMapping_ *a, const char *type)
{
	size_t soap_flag_ns1__SnDoMapping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SnDoMapping_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SnDoMapping_, sizeof(struct __ns1__SnDoMapping_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SnDoMapping_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SnDoMapping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SnDoMapping(soap, "ns1:SnDoMapping", &a->ns1__SnDoMapping, ""))
				{	soap_flag_ns1__SnDoMapping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SnDoMapping_ * SOAP_FMAC2 soap_instantiate___ns1__SnDoMapping_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SnDoMapping_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SnDoMapping_ *p;
	size_t k = sizeof(struct __ns1__SnDoMapping_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SnDoMapping_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SnDoMapping_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SnDoMapping_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SnDoMapping_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SnDoMapping_(struct soap *soap, const struct __ns1__SnDoMapping_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SnDoMapping_(soap, tag ? tag : "-ns1:SnDoMapping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnDoMapping_ * SOAP_FMAC4 soap_get___ns1__SnDoMapping_(struct soap *soap, struct __ns1__SnDoMapping_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SnDoMapping_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__eMesNextMo_(struct soap *soap, struct __ns1__eMesNextMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__eMesNextMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__eMesNextMo_(struct soap *soap, const struct __ns1__eMesNextMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__eMesNextMo(soap, &a->ns1__eMesNextMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__eMesNextMo_(struct soap *soap, const char *tag, int id, const struct __ns1__eMesNextMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__eMesNextMo(soap, "ns1:eMesNextMo", -1, &a->ns1__eMesNextMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__eMesNextMo_ * SOAP_FMAC4 soap_in___ns1__eMesNextMo_(struct soap *soap, const char *tag, struct __ns1__eMesNextMo_ *a, const char *type)
{
	size_t soap_flag_ns1__eMesNextMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__eMesNextMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__eMesNextMo_, sizeof(struct __ns1__eMesNextMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__eMesNextMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__eMesNextMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__eMesNextMo(soap, "ns1:eMesNextMo", &a->ns1__eMesNextMo, ""))
				{	soap_flag_ns1__eMesNextMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__eMesNextMo_ * SOAP_FMAC2 soap_instantiate___ns1__eMesNextMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__eMesNextMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__eMesNextMo_ *p;
	size_t k = sizeof(struct __ns1__eMesNextMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__eMesNextMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__eMesNextMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__eMesNextMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__eMesNextMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__eMesNextMo_(struct soap *soap, const struct __ns1__eMesNextMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__eMesNextMo_(soap, tag ? tag : "-ns1:eMesNextMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__eMesNextMo_ * SOAP_FMAC4 soap_get___ns1__eMesNextMo_(struct soap *soap, struct __ns1__eMesNextMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__eMesNextMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendResultForStationNumber_(struct soap *soap, struct __ns1__sendResultForStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendResultForStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendResultForStationNumber_(struct soap *soap, const struct __ns1__sendResultForStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendResultForStationNumber(soap, &a->ns1__sendResultForStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendResultForStationNumber_(struct soap *soap, const char *tag, int id, const struct __ns1__sendResultForStationNumber_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendResultForStationNumber(soap, "ns1:sendResultForStationNumber", -1, &a->ns1__sendResultForStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendResultForStationNumber_ * SOAP_FMAC4 soap_in___ns1__sendResultForStationNumber_(struct soap *soap, const char *tag, struct __ns1__sendResultForStationNumber_ *a, const char *type)
{
	size_t soap_flag_ns1__sendResultForStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendResultForStationNumber_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendResultForStationNumber_, sizeof(struct __ns1__sendResultForStationNumber_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendResultForStationNumber_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendResultForStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendResultForStationNumber(soap, "ns1:sendResultForStationNumber", &a->ns1__sendResultForStationNumber, ""))
				{	soap_flag_ns1__sendResultForStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendResultForStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__sendResultForStationNumber_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendResultForStationNumber_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendResultForStationNumber_ *p;
	size_t k = sizeof(struct __ns1__sendResultForStationNumber_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendResultForStationNumber_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendResultForStationNumber_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendResultForStationNumber_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendResultForStationNumber_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendResultForStationNumber_(struct soap *soap, const struct __ns1__sendResultForStationNumber_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendResultForStationNumber_(soap, tag ? tag : "-ns1:sendResultForStationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendResultForStationNumber_ * SOAP_FMAC4 soap_get___ns1__sendResultForStationNumber_(struct soap *soap, struct __ns1__sendResultForStationNumber_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendResultForStationNumber_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendDataForStationNumber_(struct soap *soap, struct __ns1__sendDataForStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendDataForStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendDataForStationNumber_(struct soap *soap, const struct __ns1__sendDataForStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendDataForStationNumber(soap, &a->ns1__sendDataForStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendDataForStationNumber_(struct soap *soap, const char *tag, int id, const struct __ns1__sendDataForStationNumber_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendDataForStationNumber(soap, "ns1:sendDataForStationNumber", -1, &a->ns1__sendDataForStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendDataForStationNumber_ * SOAP_FMAC4 soap_in___ns1__sendDataForStationNumber_(struct soap *soap, const char *tag, struct __ns1__sendDataForStationNumber_ *a, const char *type)
{
	size_t soap_flag_ns1__sendDataForStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendDataForStationNumber_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendDataForStationNumber_, sizeof(struct __ns1__sendDataForStationNumber_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendDataForStationNumber_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendDataForStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendDataForStationNumber(soap, "ns1:sendDataForStationNumber", &a->ns1__sendDataForStationNumber, ""))
				{	soap_flag_ns1__sendDataForStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendDataForStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__sendDataForStationNumber_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendDataForStationNumber_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendDataForStationNumber_ *p;
	size_t k = sizeof(struct __ns1__sendDataForStationNumber_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendDataForStationNumber_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendDataForStationNumber_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendDataForStationNumber_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendDataForStationNumber_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendDataForStationNumber_(struct soap *soap, const struct __ns1__sendDataForStationNumber_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendDataForStationNumber_(soap, tag ? tag : "-ns1:sendDataForStationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendDataForStationNumber_ * SOAP_FMAC4 soap_get___ns1__sendDataForStationNumber_(struct soap *soap, struct __ns1__sendDataForStationNumber_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendDataForStationNumber_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkEmpForStationNumber_(struct soap *soap, struct __ns1__checkEmpForStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkEmpForStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkEmpForStationNumber_(struct soap *soap, const struct __ns1__checkEmpForStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkEmpForStationNumber(soap, &a->ns1__checkEmpForStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkEmpForStationNumber_(struct soap *soap, const char *tag, int id, const struct __ns1__checkEmpForStationNumber_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkEmpForStationNumber(soap, "ns1:checkEmpForStationNumber", -1, &a->ns1__checkEmpForStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpForStationNumber_ * SOAP_FMAC4 soap_in___ns1__checkEmpForStationNumber_(struct soap *soap, const char *tag, struct __ns1__checkEmpForStationNumber_ *a, const char *type)
{
	size_t soap_flag_ns1__checkEmpForStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkEmpForStationNumber_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkEmpForStationNumber_, sizeof(struct __ns1__checkEmpForStationNumber_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkEmpForStationNumber_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkEmpForStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkEmpForStationNumber(soap, "ns1:checkEmpForStationNumber", &a->ns1__checkEmpForStationNumber, ""))
				{	soap_flag_ns1__checkEmpForStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkEmpForStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__checkEmpForStationNumber_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkEmpForStationNumber_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkEmpForStationNumber_ *p;
	size_t k = sizeof(struct __ns1__checkEmpForStationNumber_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkEmpForStationNumber_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkEmpForStationNumber_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkEmpForStationNumber_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkEmpForStationNumber_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkEmpForStationNumber_(struct soap *soap, const struct __ns1__checkEmpForStationNumber_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkEmpForStationNumber_(soap, tag ? tag : "-ns1:checkEmpForStationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpForStationNumber_ * SOAP_FMAC4 soap_get___ns1__checkEmpForStationNumber_(struct soap *soap, struct __ns1__checkEmpForStationNumber_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkEmpForStationNumber_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkSN_USCOREStationNumber_(struct soap *soap, struct __ns1__checkSN_USCOREStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkSN_USCOREStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkSN_USCOREStationNumber_(struct soap *soap, const struct __ns1__checkSN_USCOREStationNumber_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkSN_USCOREStationNumber(soap, &a->ns1__checkSN_USCOREStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkSN_USCOREStationNumber_(struct soap *soap, const char *tag, int id, const struct __ns1__checkSN_USCOREStationNumber_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkSN_USCOREStationNumber(soap, "ns1:checkSN_StationNumber", -1, &a->ns1__checkSN_USCOREStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStationNumber_ * SOAP_FMAC4 soap_in___ns1__checkSN_USCOREStationNumber_(struct soap *soap, const char *tag, struct __ns1__checkSN_USCOREStationNumber_ *a, const char *type)
{
	size_t soap_flag_ns1__checkSN_USCOREStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkSN_USCOREStationNumber_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkSN_USCOREStationNumber_, sizeof(struct __ns1__checkSN_USCOREStationNumber_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkSN_USCOREStationNumber_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkSN_USCOREStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkSN_USCOREStationNumber(soap, "ns1:checkSN_StationNumber", &a->ns1__checkSN_USCOREStationNumber, ""))
				{	soap_flag_ns1__checkSN_USCOREStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkSN_USCOREStationNumber_ * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStationNumber_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkSN_USCOREStationNumber_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkSN_USCOREStationNumber_ *p;
	size_t k = sizeof(struct __ns1__checkSN_USCOREStationNumber_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkSN_USCOREStationNumber_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkSN_USCOREStationNumber_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkSN_USCOREStationNumber_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkSN_USCOREStationNumber_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkSN_USCOREStationNumber_(struct soap *soap, const struct __ns1__checkSN_USCOREStationNumber_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkSN_USCOREStationNumber_(soap, tag ? tag : "-ns1:checkSN_StationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStationNumber_ * SOAP_FMAC4 soap_get___ns1__checkSN_USCOREStationNumber_(struct soap *soap, struct __ns1__checkSN_USCOREStationNumber_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkSN_USCOREStationNumber_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnNextMo_(struct soap *soap, struct __ns1__ChkSnNextMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnNextMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnNextMo_(struct soap *soap, const struct __ns1__ChkSnNextMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnNextMo(soap, &a->ns1__ChkSnNextMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnNextMo_(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnNextMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnNextMo(soap, "ns1:ChkSnNextMo", -1, &a->ns1__ChkSnNextMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnNextMo_ * SOAP_FMAC4 soap_in___ns1__ChkSnNextMo_(struct soap *soap, const char *tag, struct __ns1__ChkSnNextMo_ *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnNextMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnNextMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnNextMo_, sizeof(struct __ns1__ChkSnNextMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnNextMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnNextMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnNextMo(soap, "ns1:ChkSnNextMo", &a->ns1__ChkSnNextMo, ""))
				{	soap_flag_ns1__ChkSnNextMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnNextMo_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnNextMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnNextMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnNextMo_ *p;
	size_t k = sizeof(struct __ns1__ChkSnNextMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnNextMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnNextMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnNextMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnNextMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnNextMo_(struct soap *soap, const struct __ns1__ChkSnNextMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnNextMo_(soap, tag ? tag : "-ns1:ChkSnNextMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnNextMo_ * SOAP_FMAC4 soap_get___ns1__ChkSnNextMo_(struct soap *soap, struct __ns1__ChkSnNextMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnNextMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnMo_(struct soap *soap, struct __ns1__ChkSnMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnMo_(struct soap *soap, const struct __ns1__ChkSnMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnMo(soap, &a->ns1__ChkSnMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnMo_(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnMo(soap, "ns1:ChkSnMo", -1, &a->ns1__ChkSnMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnMo_ * SOAP_FMAC4 soap_in___ns1__ChkSnMo_(struct soap *soap, const char *tag, struct __ns1__ChkSnMo_ *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnMo_, sizeof(struct __ns1__ChkSnMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnMo(soap, "ns1:ChkSnMo", &a->ns1__ChkSnMo, ""))
				{	soap_flag_ns1__ChkSnMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnMo_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnMo_ *p;
	size_t k = sizeof(struct __ns1__ChkSnMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnMo_(struct soap *soap, const struct __ns1__ChkSnMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnMo_(soap, tag ? tag : "-ns1:ChkSnMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnMo_ * SOAP_FMAC4 soap_get___ns1__ChkSnMo_(struct soap *soap, struct __ns1__ChkSnMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkMoStation_(struct soap *soap, struct __ns1__chkMoStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkMoStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkMoStation_(struct soap *soap, const struct __ns1__chkMoStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkMoStation(soap, &a->ns1__chkMoStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkMoStation_(struct soap *soap, const char *tag, int id, const struct __ns1__chkMoStation_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkMoStation(soap, "ns1:chkMoStation", -1, &a->ns1__chkMoStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoStation_ * SOAP_FMAC4 soap_in___ns1__chkMoStation_(struct soap *soap, const char *tag, struct __ns1__chkMoStation_ *a, const char *type)
{
	size_t soap_flag_ns1__chkMoStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkMoStation_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkMoStation_, sizeof(struct __ns1__chkMoStation_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkMoStation_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkMoStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkMoStation(soap, "ns1:chkMoStation", &a->ns1__chkMoStation, ""))
				{	soap_flag_ns1__chkMoStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkMoStation_ * SOAP_FMAC2 soap_instantiate___ns1__chkMoStation_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkMoStation_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkMoStation_ *p;
	size_t k = sizeof(struct __ns1__chkMoStation_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkMoStation_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkMoStation_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkMoStation_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkMoStation_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkMoStation_(struct soap *soap, const struct __ns1__chkMoStation_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkMoStation_(soap, tag ? tag : "-ns1:chkMoStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoStation_ * SOAP_FMAC4 soap_get___ns1__chkMoStation_(struct soap *soap, struct __ns1__chkMoStation_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkMoStation_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetEnergyStat_(struct soap *soap, struct __ns1__SetEnergyStat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetEnergyStat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetEnergyStat_(struct soap *soap, const struct __ns1__SetEnergyStat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetEnergyStat(soap, &a->ns1__SetEnergyStat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetEnergyStat_(struct soap *soap, const char *tag, int id, const struct __ns1__SetEnergyStat_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetEnergyStat(soap, "ns1:SetEnergyStat", -1, &a->ns1__SetEnergyStat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetEnergyStat_ * SOAP_FMAC4 soap_in___ns1__SetEnergyStat_(struct soap *soap, const char *tag, struct __ns1__SetEnergyStat_ *a, const char *type)
{
	size_t soap_flag_ns1__SetEnergyStat = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetEnergyStat_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetEnergyStat_, sizeof(struct __ns1__SetEnergyStat_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetEnergyStat_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetEnergyStat && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetEnergyStat(soap, "ns1:SetEnergyStat", &a->ns1__SetEnergyStat, ""))
				{	soap_flag_ns1__SetEnergyStat--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetEnergyStat_ * SOAP_FMAC2 soap_instantiate___ns1__SetEnergyStat_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetEnergyStat_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetEnergyStat_ *p;
	size_t k = sizeof(struct __ns1__SetEnergyStat_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetEnergyStat_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetEnergyStat_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetEnergyStat_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetEnergyStat_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetEnergyStat_(struct soap *soap, const struct __ns1__SetEnergyStat_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetEnergyStat_(soap, tag ? tag : "-ns1:SetEnergyStat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetEnergyStat_ * SOAP_FMAC4 soap_get___ns1__SetEnergyStat_(struct soap *soap, struct __ns1__SetEnergyStat_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetEnergyStat_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInfoByMo_(struct soap *soap, struct __ns1__getInfoByMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getInfoByMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInfoByMo_(struct soap *soap, const struct __ns1__getInfoByMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getInfoByMo(soap, &a->ns1__getInfoByMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInfoByMo_(struct soap *soap, const char *tag, int id, const struct __ns1__getInfoByMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getInfoByMo(soap, "ns1:getInfoByMo", -1, &a->ns1__getInfoByMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInfoByMo_ * SOAP_FMAC4 soap_in___ns1__getInfoByMo_(struct soap *soap, const char *tag, struct __ns1__getInfoByMo_ *a, const char *type)
{
	size_t soap_flag_ns1__getInfoByMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getInfoByMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInfoByMo_, sizeof(struct __ns1__getInfoByMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInfoByMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getInfoByMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getInfoByMo(soap, "ns1:getInfoByMo", &a->ns1__getInfoByMo, ""))
				{	soap_flag_ns1__getInfoByMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getInfoByMo_ * SOAP_FMAC2 soap_instantiate___ns1__getInfoByMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInfoByMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getInfoByMo_ *p;
	size_t k = sizeof(struct __ns1__getInfoByMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getInfoByMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getInfoByMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getInfoByMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getInfoByMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInfoByMo_(struct soap *soap, const struct __ns1__getInfoByMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getInfoByMo_(soap, tag ? tag : "-ns1:getInfoByMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInfoByMo_ * SOAP_FMAC4 soap_get___ns1__getInfoByMo_(struct soap *soap, struct __ns1__getInfoByMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInfoByMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsThermalNew_(struct soap *soap, struct __ns1__InsThermalNew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsThermalNew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsThermalNew_(struct soap *soap, const struct __ns1__InsThermalNew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsThermalNew(soap, &a->ns1__InsThermalNew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsThermalNew_(struct soap *soap, const char *tag, int id, const struct __ns1__InsThermalNew_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsThermalNew(soap, "ns1:InsThermalNew", -1, &a->ns1__InsThermalNew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermalNew_ * SOAP_FMAC4 soap_in___ns1__InsThermalNew_(struct soap *soap, const char *tag, struct __ns1__InsThermalNew_ *a, const char *type)
{
	size_t soap_flag_ns1__InsThermalNew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsThermalNew_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsThermalNew_, sizeof(struct __ns1__InsThermalNew_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsThermalNew_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsThermalNew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsThermalNew(soap, "ns1:InsThermalNew", &a->ns1__InsThermalNew, ""))
				{	soap_flag_ns1__InsThermalNew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsThermalNew_ * SOAP_FMAC2 soap_instantiate___ns1__InsThermalNew_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsThermalNew_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsThermalNew_ *p;
	size_t k = sizeof(struct __ns1__InsThermalNew_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsThermalNew_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsThermalNew_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsThermalNew_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsThermalNew_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsThermalNew_(struct soap *soap, const struct __ns1__InsThermalNew_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsThermalNew_(soap, tag ? tag : "-ns1:InsThermalNew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermalNew_ * SOAP_FMAC4 soap_get___ns1__InsThermalNew_(struct soap *soap, struct __ns1__InsThermalNew_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsThermalNew_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnLink_(struct soap *soap, struct __ns1__ChkSnLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnLink_(struct soap *soap, const struct __ns1__ChkSnLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnLink(soap, &a->ns1__ChkSnLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnLink_(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnLink_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnLink(soap, "ns1:ChkSnLink", -1, &a->ns1__ChkSnLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLink_ * SOAP_FMAC4 soap_in___ns1__ChkSnLink_(struct soap *soap, const char *tag, struct __ns1__ChkSnLink_ *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnLink_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnLink_, sizeof(struct __ns1__ChkSnLink_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnLink_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnLink(soap, "ns1:ChkSnLink", &a->ns1__ChkSnLink, ""))
				{	soap_flag_ns1__ChkSnLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnLink_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLink_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnLink_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnLink_ *p;
	size_t k = sizeof(struct __ns1__ChkSnLink_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnLink_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnLink_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnLink_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnLink_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnLink_(struct soap *soap, const struct __ns1__ChkSnLink_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnLink_(soap, tag ? tag : "-ns1:ChkSnLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLink_ * SOAP_FMAC4 soap_get___ns1__ChkSnLink_(struct soap *soap, struct __ns1__ChkSnLink_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnLink_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsThermal_(struct soap *soap, struct __ns1__InsThermal_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsThermal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsThermal_(struct soap *soap, const struct __ns1__InsThermal_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsThermal(soap, &a->ns1__InsThermal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsThermal_(struct soap *soap, const char *tag, int id, const struct __ns1__InsThermal_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsThermal(soap, "ns1:InsThermal", -1, &a->ns1__InsThermal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermal_ * SOAP_FMAC4 soap_in___ns1__InsThermal_(struct soap *soap, const char *tag, struct __ns1__InsThermal_ *a, const char *type)
{
	size_t soap_flag_ns1__InsThermal = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsThermal_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsThermal_, sizeof(struct __ns1__InsThermal_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsThermal_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsThermal && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsThermal(soap, "ns1:InsThermal", &a->ns1__InsThermal, ""))
				{	soap_flag_ns1__InsThermal--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsThermal_ * SOAP_FMAC2 soap_instantiate___ns1__InsThermal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsThermal_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsThermal_ *p;
	size_t k = sizeof(struct __ns1__InsThermal_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsThermal_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsThermal_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsThermal_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsThermal_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsThermal_(struct soap *soap, const struct __ns1__InsThermal_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsThermal_(soap, tag ? tag : "-ns1:InsThermal", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermal_ * SOAP_FMAC4 soap_get___ns1__InsThermal_(struct soap *soap, struct __ns1__InsThermal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsThermal_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsWHDetection_(struct soap *soap, struct __ns1__InsWHDetection_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsWHDetection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsWHDetection_(struct soap *soap, const struct __ns1__InsWHDetection_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsWHDetection(soap, &a->ns1__InsWHDetection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsWHDetection_(struct soap *soap, const char *tag, int id, const struct __ns1__InsWHDetection_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsWHDetection(soap, "ns1:InsWHDetection", -1, &a->ns1__InsWHDetection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsWHDetection_ * SOAP_FMAC4 soap_in___ns1__InsWHDetection_(struct soap *soap, const char *tag, struct __ns1__InsWHDetection_ *a, const char *type)
{
	size_t soap_flag_ns1__InsWHDetection = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsWHDetection_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsWHDetection_, sizeof(struct __ns1__InsWHDetection_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsWHDetection_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsWHDetection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsWHDetection(soap, "ns1:InsWHDetection", &a->ns1__InsWHDetection, ""))
				{	soap_flag_ns1__InsWHDetection--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsWHDetection_ * SOAP_FMAC2 soap_instantiate___ns1__InsWHDetection_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsWHDetection_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsWHDetection_ *p;
	size_t k = sizeof(struct __ns1__InsWHDetection_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsWHDetection_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsWHDetection_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsWHDetection_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsWHDetection_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsWHDetection_(struct soap *soap, const struct __ns1__InsWHDetection_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsWHDetection_(soap, tag ? tag : "-ns1:InsWHDetection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsWHDetection_ * SOAP_FMAC4 soap_get___ns1__InsWHDetection_(struct soap *soap, struct __ns1__InsWHDetection_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsWHDetection_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFlatNessForCL_(struct soap *soap, struct __ns1__InsFlatNessForCL_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFlatNessForCL = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFlatNessForCL_(struct soap *soap, const struct __ns1__InsFlatNessForCL_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFlatNessForCL(soap, &a->ns1__InsFlatNessForCL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFlatNessForCL_(struct soap *soap, const char *tag, int id, const struct __ns1__InsFlatNessForCL_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFlatNessForCL(soap, "ns1:InsFlatNessForCL", -1, &a->ns1__InsFlatNessForCL, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForCL_ * SOAP_FMAC4 soap_in___ns1__InsFlatNessForCL_(struct soap *soap, const char *tag, struct __ns1__InsFlatNessForCL_ *a, const char *type)
{
	size_t soap_flag_ns1__InsFlatNessForCL = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFlatNessForCL_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFlatNessForCL_, sizeof(struct __ns1__InsFlatNessForCL_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFlatNessForCL_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFlatNessForCL && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFlatNessForCL(soap, "ns1:InsFlatNessForCL", &a->ns1__InsFlatNessForCL, ""))
				{	soap_flag_ns1__InsFlatNessForCL--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFlatNessForCL_ * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForCL_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFlatNessForCL_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFlatNessForCL_ *p;
	size_t k = sizeof(struct __ns1__InsFlatNessForCL_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFlatNessForCL_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFlatNessForCL_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFlatNessForCL_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFlatNessForCL_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFlatNessForCL_(struct soap *soap, const struct __ns1__InsFlatNessForCL_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFlatNessForCL_(soap, tag ? tag : "-ns1:InsFlatNessForCL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForCL_ * SOAP_FMAC4 soap_get___ns1__InsFlatNessForCL_(struct soap *soap, struct __ns1__InsFlatNessForCL_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFlatNessForCL_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFlatNessForLSD_(struct soap *soap, struct __ns1__InsFlatNessForLSD_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFlatNessForLSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFlatNessForLSD_(struct soap *soap, const struct __ns1__InsFlatNessForLSD_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFlatNessForLSD(soap, &a->ns1__InsFlatNessForLSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFlatNessForLSD_(struct soap *soap, const char *tag, int id, const struct __ns1__InsFlatNessForLSD_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFlatNessForLSD(soap, "ns1:InsFlatNessForLSD", -1, &a->ns1__InsFlatNessForLSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForLSD_ * SOAP_FMAC4 soap_in___ns1__InsFlatNessForLSD_(struct soap *soap, const char *tag, struct __ns1__InsFlatNessForLSD_ *a, const char *type)
{
	size_t soap_flag_ns1__InsFlatNessForLSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFlatNessForLSD_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFlatNessForLSD_, sizeof(struct __ns1__InsFlatNessForLSD_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFlatNessForLSD_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFlatNessForLSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFlatNessForLSD(soap, "ns1:InsFlatNessForLSD", &a->ns1__InsFlatNessForLSD, ""))
				{	soap_flag_ns1__InsFlatNessForLSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFlatNessForLSD_ * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForLSD_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFlatNessForLSD_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFlatNessForLSD_ *p;
	size_t k = sizeof(struct __ns1__InsFlatNessForLSD_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFlatNessForLSD_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFlatNessForLSD_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFlatNessForLSD_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFlatNessForLSD_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFlatNessForLSD_(struct soap *soap, const struct __ns1__InsFlatNessForLSD_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFlatNessForLSD_(soap, tag ? tag : "-ns1:InsFlatNessForLSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForLSD_ * SOAP_FMAC4 soap_get___ns1__InsFlatNessForLSD_(struct soap *soap, struct __ns1__InsFlatNessForLSD_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFlatNessForLSD_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFlatNess_(struct soap *soap, struct __ns1__InsFlatNess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFlatNess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFlatNess_(struct soap *soap, const struct __ns1__InsFlatNess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFlatNess(soap, &a->ns1__InsFlatNess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFlatNess_(struct soap *soap, const char *tag, int id, const struct __ns1__InsFlatNess_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFlatNess(soap, "ns1:InsFlatNess", -1, &a->ns1__InsFlatNess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNess_ * SOAP_FMAC4 soap_in___ns1__InsFlatNess_(struct soap *soap, const char *tag, struct __ns1__InsFlatNess_ *a, const char *type)
{
	size_t soap_flag_ns1__InsFlatNess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFlatNess_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFlatNess_, sizeof(struct __ns1__InsFlatNess_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFlatNess_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFlatNess && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFlatNess(soap, "ns1:InsFlatNess", &a->ns1__InsFlatNess, ""))
				{	soap_flag_ns1__InsFlatNess--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFlatNess_ * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNess_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFlatNess_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFlatNess_ *p;
	size_t k = sizeof(struct __ns1__InsFlatNess_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFlatNess_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFlatNess_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFlatNess_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFlatNess_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFlatNess_(struct soap *soap, const struct __ns1__InsFlatNess_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFlatNess_(soap, tag ? tag : "-ns1:InsFlatNess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNess_ * SOAP_FMAC4 soap_get___ns1__InsFlatNess_(struct soap *soap, struct __ns1__InsFlatNess_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFlatNess_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ImpMesAteTestData_(struct soap *soap, struct __ns1__ImpMesAteTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ImpMesAteTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ImpMesAteTestData_(struct soap *soap, const struct __ns1__ImpMesAteTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ImpMesAteTestData(soap, &a->ns1__ImpMesAteTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ImpMesAteTestData_(struct soap *soap, const char *tag, int id, const struct __ns1__ImpMesAteTestData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ImpMesAteTestData(soap, "ns1:ImpMesAteTestData", -1, &a->ns1__ImpMesAteTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ImpMesAteTestData_ * SOAP_FMAC4 soap_in___ns1__ImpMesAteTestData_(struct soap *soap, const char *tag, struct __ns1__ImpMesAteTestData_ *a, const char *type)
{
	size_t soap_flag_ns1__ImpMesAteTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ImpMesAteTestData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ImpMesAteTestData_, sizeof(struct __ns1__ImpMesAteTestData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ImpMesAteTestData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ImpMesAteTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ImpMesAteTestData(soap, "ns1:ImpMesAteTestData", &a->ns1__ImpMesAteTestData, ""))
				{	soap_flag_ns1__ImpMesAteTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ImpMesAteTestData_ * SOAP_FMAC2 soap_instantiate___ns1__ImpMesAteTestData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ImpMesAteTestData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ImpMesAteTestData_ *p;
	size_t k = sizeof(struct __ns1__ImpMesAteTestData_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ImpMesAteTestData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ImpMesAteTestData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ImpMesAteTestData_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ImpMesAteTestData_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ImpMesAteTestData_(struct soap *soap, const struct __ns1__ImpMesAteTestData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ImpMesAteTestData_(soap, tag ? tag : "-ns1:ImpMesAteTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ImpMesAteTestData_ * SOAP_FMAC4 soap_get___ns1__ImpMesAteTestData_(struct soap *soap, struct __ns1__ImpMesAteTestData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ImpMesAteTestData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkStationTime_(struct soap *soap, struct __ns1__chkStationTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkStationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkStationTime_(struct soap *soap, const struct __ns1__chkStationTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkStationTime(soap, &a->ns1__chkStationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkStationTime_(struct soap *soap, const char *tag, int id, const struct __ns1__chkStationTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkStationTime(soap, "ns1:chkStationTime", -1, &a->ns1__chkStationTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkStationTime_ * SOAP_FMAC4 soap_in___ns1__chkStationTime_(struct soap *soap, const char *tag, struct __ns1__chkStationTime_ *a, const char *type)
{
	size_t soap_flag_ns1__chkStationTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkStationTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkStationTime_, sizeof(struct __ns1__chkStationTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkStationTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkStationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkStationTime(soap, "ns1:chkStationTime", &a->ns1__chkStationTime, ""))
				{	soap_flag_ns1__chkStationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkStationTime_ * SOAP_FMAC2 soap_instantiate___ns1__chkStationTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkStationTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkStationTime_ *p;
	size_t k = sizeof(struct __ns1__chkStationTime_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkStationTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkStationTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkStationTime_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkStationTime_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkStationTime_(struct soap *soap, const struct __ns1__chkStationTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkStationTime_(soap, tag ? tag : "-ns1:chkStationTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkStationTime_ * SOAP_FMAC4 soap_get___ns1__chkStationTime_(struct soap *soap, struct __ns1__chkStationTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkStationTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InFruitsOrtQty_(struct soap *soap, struct __ns1__InFruitsOrtQty_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InFruitsOrtQty = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InFruitsOrtQty_(struct soap *soap, const struct __ns1__InFruitsOrtQty_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InFruitsOrtQty(soap, &a->ns1__InFruitsOrtQty);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InFruitsOrtQty_(struct soap *soap, const char *tag, int id, const struct __ns1__InFruitsOrtQty_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InFruitsOrtQty(soap, "ns1:InFruitsOrtQty", -1, &a->ns1__InFruitsOrtQty, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InFruitsOrtQty_ * SOAP_FMAC4 soap_in___ns1__InFruitsOrtQty_(struct soap *soap, const char *tag, struct __ns1__InFruitsOrtQty_ *a, const char *type)
{
	size_t soap_flag_ns1__InFruitsOrtQty = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InFruitsOrtQty_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InFruitsOrtQty_, sizeof(struct __ns1__InFruitsOrtQty_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InFruitsOrtQty_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InFruitsOrtQty && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InFruitsOrtQty(soap, "ns1:InFruitsOrtQty", &a->ns1__InFruitsOrtQty, ""))
				{	soap_flag_ns1__InFruitsOrtQty--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InFruitsOrtQty_ * SOAP_FMAC2 soap_instantiate___ns1__InFruitsOrtQty_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InFruitsOrtQty_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InFruitsOrtQty_ *p;
	size_t k = sizeof(struct __ns1__InFruitsOrtQty_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InFruitsOrtQty_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InFruitsOrtQty_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InFruitsOrtQty_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InFruitsOrtQty_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InFruitsOrtQty_(struct soap *soap, const struct __ns1__InFruitsOrtQty_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InFruitsOrtQty_(soap, tag ? tag : "-ns1:InFruitsOrtQty", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InFruitsOrtQty_ * SOAP_FMAC4 soap_get___ns1__InFruitsOrtQty_(struct soap *soap, struct __ns1__InFruitsOrtQty_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InFruitsOrtQty_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendTestResult_(struct soap *soap, struct __ns1__sendTestResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendTestResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendTestResult_(struct soap *soap, const struct __ns1__sendTestResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendTestResult(soap, &a->ns1__sendTestResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendTestResult_(struct soap *soap, const char *tag, int id, const struct __ns1__sendTestResult_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendTestResult(soap, "ns1:sendTestResult", -1, &a->ns1__sendTestResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestResult_ * SOAP_FMAC4 soap_in___ns1__sendTestResult_(struct soap *soap, const char *tag, struct __ns1__sendTestResult_ *a, const char *type)
{
	size_t soap_flag_ns1__sendTestResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendTestResult_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendTestResult_, sizeof(struct __ns1__sendTestResult_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendTestResult_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendTestResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendTestResult(soap, "ns1:sendTestResult", &a->ns1__sendTestResult, ""))
				{	soap_flag_ns1__sendTestResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendTestResult_ * SOAP_FMAC2 soap_instantiate___ns1__sendTestResult_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendTestResult_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendTestResult_ *p;
	size_t k = sizeof(struct __ns1__sendTestResult_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendTestResult_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendTestResult_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendTestResult_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendTestResult_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendTestResult_(struct soap *soap, const struct __ns1__sendTestResult_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendTestResult_(soap, tag ? tag : "-ns1:sendTestResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestResult_ * SOAP_FMAC4 soap_get___ns1__sendTestResult_(struct soap *soap, struct __ns1__sendTestResult_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendTestResult_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendTestData_(struct soap *soap, struct __ns1__sendTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendTestData_(struct soap *soap, const struct __ns1__sendTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendTestData(soap, &a->ns1__sendTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendTestData_(struct soap *soap, const char *tag, int id, const struct __ns1__sendTestData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendTestData(soap, "ns1:sendTestData", -1, &a->ns1__sendTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestData_ * SOAP_FMAC4 soap_in___ns1__sendTestData_(struct soap *soap, const char *tag, struct __ns1__sendTestData_ *a, const char *type)
{
	size_t soap_flag_ns1__sendTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendTestData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendTestData_, sizeof(struct __ns1__sendTestData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendTestData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendTestData(soap, "ns1:sendTestData", &a->ns1__sendTestData, ""))
				{	soap_flag_ns1__sendTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendTestData_ * SOAP_FMAC2 soap_instantiate___ns1__sendTestData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendTestData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendTestData_ *p;
	size_t k = sizeof(struct __ns1__sendTestData_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendTestData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendTestData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendTestData_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendTestData_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendTestData_(struct soap *soap, const struct __ns1__sendTestData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendTestData_(soap, tag ? tag : "-ns1:sendTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestData_ * SOAP_FMAC4 soap_get___ns1__sendTestData_(struct soap *soap, struct __ns1__sendTestData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendTestData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkSN_USCOREStation_(struct soap *soap, struct __ns1__checkSN_USCOREStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkSN_USCOREStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkSN_USCOREStation_(struct soap *soap, const struct __ns1__checkSN_USCOREStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkSN_USCOREStation(soap, &a->ns1__checkSN_USCOREStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkSN_USCOREStation_(struct soap *soap, const char *tag, int id, const struct __ns1__checkSN_USCOREStation_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkSN_USCOREStation(soap, "ns1:checkSN_Station", -1, &a->ns1__checkSN_USCOREStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStation_ * SOAP_FMAC4 soap_in___ns1__checkSN_USCOREStation_(struct soap *soap, const char *tag, struct __ns1__checkSN_USCOREStation_ *a, const char *type)
{
	size_t soap_flag_ns1__checkSN_USCOREStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkSN_USCOREStation_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkSN_USCOREStation_, sizeof(struct __ns1__checkSN_USCOREStation_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkSN_USCOREStation_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkSN_USCOREStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkSN_USCOREStation(soap, "ns1:checkSN_Station", &a->ns1__checkSN_USCOREStation, ""))
				{	soap_flag_ns1__checkSN_USCOREStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkSN_USCOREStation_ * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStation_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkSN_USCOREStation_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkSN_USCOREStation_ *p;
	size_t k = sizeof(struct __ns1__checkSN_USCOREStation_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkSN_USCOREStation_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkSN_USCOREStation_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkSN_USCOREStation_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkSN_USCOREStation_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkSN_USCOREStation_(struct soap *soap, const struct __ns1__checkSN_USCOREStation_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkSN_USCOREStation_(soap, tag ? tag : "-ns1:checkSN_Station", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStation_ * SOAP_FMAC4 soap_get___ns1__checkSN_USCOREStation_(struct soap *soap, struct __ns1__checkSN_USCOREStation_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkSN_USCOREStation_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkEmpNo_(struct soap *soap, struct __ns1__checkEmpNo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkEmpNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkEmpNo_(struct soap *soap, const struct __ns1__checkEmpNo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkEmpNo(soap, &a->ns1__checkEmpNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkEmpNo_(struct soap *soap, const char *tag, int id, const struct __ns1__checkEmpNo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkEmpNo(soap, "ns1:checkEmpNo", -1, &a->ns1__checkEmpNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpNo_ * SOAP_FMAC4 soap_in___ns1__checkEmpNo_(struct soap *soap, const char *tag, struct __ns1__checkEmpNo_ *a, const char *type)
{
	size_t soap_flag_ns1__checkEmpNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkEmpNo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkEmpNo_, sizeof(struct __ns1__checkEmpNo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkEmpNo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkEmpNo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkEmpNo(soap, "ns1:checkEmpNo", &a->ns1__checkEmpNo, ""))
				{	soap_flag_ns1__checkEmpNo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkEmpNo_ * SOAP_FMAC2 soap_instantiate___ns1__checkEmpNo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkEmpNo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkEmpNo_ *p;
	size_t k = sizeof(struct __ns1__checkEmpNo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkEmpNo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkEmpNo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkEmpNo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkEmpNo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkEmpNo_(struct soap *soap, const struct __ns1__checkEmpNo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkEmpNo_(soap, tag ? tag : "-ns1:checkEmpNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpNo_ * SOAP_FMAC4 soap_get___ns1__checkEmpNo_(struct soap *soap, struct __ns1__checkEmpNo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkEmpNo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkTestData_(struct soap *soap, struct __ns1__checkTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkTestData_(struct soap *soap, const struct __ns1__checkTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkTestData(soap, &a->ns1__checkTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkTestData_(struct soap *soap, const char *tag, int id, const struct __ns1__checkTestData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkTestData(soap, "ns1:checkTestData", -1, &a->ns1__checkTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkTestData_ * SOAP_FMAC4 soap_in___ns1__checkTestData_(struct soap *soap, const char *tag, struct __ns1__checkTestData_ *a, const char *type)
{
	size_t soap_flag_ns1__checkTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkTestData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkTestData_, sizeof(struct __ns1__checkTestData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkTestData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkTestData(soap, "ns1:checkTestData", &a->ns1__checkTestData, ""))
				{	soap_flag_ns1__checkTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkTestData_ * SOAP_FMAC2 soap_instantiate___ns1__checkTestData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkTestData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkTestData_ *p;
	size_t k = sizeof(struct __ns1__checkTestData_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkTestData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkTestData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkTestData_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkTestData_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkTestData_(struct soap *soap, const struct __ns1__checkTestData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkTestData_(soap, tag ? tag : "-ns1:checkTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkTestData_ * SOAP_FMAC4 soap_get___ns1__checkTestData_(struct soap *soap, struct __ns1__checkTestData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkTestData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsZjList_(struct soap *soap, struct __ns1__InsZjList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsZjList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsZjList_(struct soap *soap, const struct __ns1__InsZjList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsZjList(soap, &a->ns1__InsZjList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsZjList_(struct soap *soap, const char *tag, int id, const struct __ns1__InsZjList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsZjList(soap, "ns1:InsZjList", -1, &a->ns1__InsZjList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZjList_ * SOAP_FMAC4 soap_in___ns1__InsZjList_(struct soap *soap, const char *tag, struct __ns1__InsZjList_ *a, const char *type)
{
	size_t soap_flag_ns1__InsZjList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsZjList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsZjList_, sizeof(struct __ns1__InsZjList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsZjList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsZjList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsZjList(soap, "ns1:InsZjList", &a->ns1__InsZjList, ""))
				{	soap_flag_ns1__InsZjList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsZjList_ * SOAP_FMAC2 soap_instantiate___ns1__InsZjList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsZjList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsZjList_ *p;
	size_t k = sizeof(struct __ns1__InsZjList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsZjList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsZjList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsZjList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsZjList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsZjList_(struct soap *soap, const struct __ns1__InsZjList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsZjList_(soap, tag ? tag : "-ns1:InsZjList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZjList_ * SOAP_FMAC4 soap_get___ns1__InsZjList_(struct soap *soap, struct __ns1__InsZjList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsZjList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFruitMachineChk_(struct soap *soap, struct __ns1__GetFruitMachineChk_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFruitMachineChk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFruitMachineChk_(struct soap *soap, const struct __ns1__GetFruitMachineChk_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFruitMachineChk(soap, &a->ns1__GetFruitMachineChk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFruitMachineChk_(struct soap *soap, const char *tag, int id, const struct __ns1__GetFruitMachineChk_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFruitMachineChk(soap, "ns1:GetFruitMachineChk", -1, &a->ns1__GetFruitMachineChk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitMachineChk_ * SOAP_FMAC4 soap_in___ns1__GetFruitMachineChk_(struct soap *soap, const char *tag, struct __ns1__GetFruitMachineChk_ *a, const char *type)
{
	size_t soap_flag_ns1__GetFruitMachineChk = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFruitMachineChk_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFruitMachineChk_, sizeof(struct __ns1__GetFruitMachineChk_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFruitMachineChk_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFruitMachineChk && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFruitMachineChk(soap, "ns1:GetFruitMachineChk", &a->ns1__GetFruitMachineChk, ""))
				{	soap_flag_ns1__GetFruitMachineChk--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFruitMachineChk_ * SOAP_FMAC2 soap_instantiate___ns1__GetFruitMachineChk_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFruitMachineChk_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFruitMachineChk_ *p;
	size_t k = sizeof(struct __ns1__GetFruitMachineChk_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetFruitMachineChk_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetFruitMachineChk_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFruitMachineChk_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetFruitMachineChk_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFruitMachineChk_(struct soap *soap, const struct __ns1__GetFruitMachineChk_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFruitMachineChk_(soap, tag ? tag : "-ns1:GetFruitMachineChk", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitMachineChk_ * SOAP_FMAC4 soap_get___ns1__GetFruitMachineChk_(struct soap *soap, struct __ns1__GetFruitMachineChk_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFruitMachineChk_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFruitMachineChk_(struct soap *soap, struct __ns1__InsFruitMachineChk_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFruitMachineChk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFruitMachineChk_(struct soap *soap, const struct __ns1__InsFruitMachineChk_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFruitMachineChk(soap, &a->ns1__InsFruitMachineChk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFruitMachineChk_(struct soap *soap, const char *tag, int id, const struct __ns1__InsFruitMachineChk_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFruitMachineChk(soap, "ns1:InsFruitMachineChk", -1, &a->ns1__InsFruitMachineChk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFruitMachineChk_ * SOAP_FMAC4 soap_in___ns1__InsFruitMachineChk_(struct soap *soap, const char *tag, struct __ns1__InsFruitMachineChk_ *a, const char *type)
{
	size_t soap_flag_ns1__InsFruitMachineChk = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFruitMachineChk_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFruitMachineChk_, sizeof(struct __ns1__InsFruitMachineChk_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFruitMachineChk_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFruitMachineChk && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFruitMachineChk(soap, "ns1:InsFruitMachineChk", &a->ns1__InsFruitMachineChk, ""))
				{	soap_flag_ns1__InsFruitMachineChk--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFruitMachineChk_ * SOAP_FMAC2 soap_instantiate___ns1__InsFruitMachineChk_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFruitMachineChk_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFruitMachineChk_ *p;
	size_t k = sizeof(struct __ns1__InsFruitMachineChk_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFruitMachineChk_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFruitMachineChk_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFruitMachineChk_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFruitMachineChk_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFruitMachineChk_(struct soap *soap, const struct __ns1__InsFruitMachineChk_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFruitMachineChk_(soap, tag ? tag : "-ns1:InsFruitMachineChk", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFruitMachineChk_ * SOAP_FMAC4 soap_get___ns1__InsFruitMachineChk_(struct soap *soap, struct __ns1__InsFruitMachineChk_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFruitMachineChk_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SnLnkOutSN_(struct soap *soap, struct __ns1__SnLnkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SnLnkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SnLnkOutSN_(struct soap *soap, const struct __ns1__SnLnkOutSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SnLnkOutSN(soap, &a->ns1__SnLnkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SnLnkOutSN_(struct soap *soap, const char *tag, int id, const struct __ns1__SnLnkOutSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SnLnkOutSN(soap, "ns1:SnLnkOutSN", -1, &a->ns1__SnLnkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnLnkOutSN_ * SOAP_FMAC4 soap_in___ns1__SnLnkOutSN_(struct soap *soap, const char *tag, struct __ns1__SnLnkOutSN_ *a, const char *type)
{
	size_t soap_flag_ns1__SnLnkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SnLnkOutSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SnLnkOutSN_, sizeof(struct __ns1__SnLnkOutSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SnLnkOutSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SnLnkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SnLnkOutSN(soap, "ns1:SnLnkOutSN", &a->ns1__SnLnkOutSN, ""))
				{	soap_flag_ns1__SnLnkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SnLnkOutSN_ * SOAP_FMAC2 soap_instantiate___ns1__SnLnkOutSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SnLnkOutSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SnLnkOutSN_ *p;
	size_t k = sizeof(struct __ns1__SnLnkOutSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SnLnkOutSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SnLnkOutSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SnLnkOutSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SnLnkOutSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SnLnkOutSN_(struct soap *soap, const struct __ns1__SnLnkOutSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SnLnkOutSN_(soap, tag ? tag : "-ns1:SnLnkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnLnkOutSN_ * SOAP_FMAC4 soap_get___ns1__SnLnkOutSN_(struct soap *soap, struct __ns1__SnLnkOutSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SnLnkOutSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMoBase_(struct soap *soap, struct __ns1__getMoBase_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMoBase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMoBase_(struct soap *soap, const struct __ns1__getMoBase_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoBase(soap, &a->ns1__getMoBase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMoBase_(struct soap *soap, const char *tag, int id, const struct __ns1__getMoBase_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMoBase(soap, "ns1:getMoBase", -1, &a->ns1__getMoBase, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoBase_ * SOAP_FMAC4 soap_in___ns1__getMoBase_(struct soap *soap, const char *tag, struct __ns1__getMoBase_ *a, const char *type)
{
	size_t soap_flag_ns1__getMoBase = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMoBase_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMoBase_, sizeof(struct __ns1__getMoBase_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMoBase_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMoBase && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoBase(soap, "ns1:getMoBase", &a->ns1__getMoBase, ""))
				{	soap_flag_ns1__getMoBase--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMoBase_ * SOAP_FMAC2 soap_instantiate___ns1__getMoBase_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMoBase_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMoBase_ *p;
	size_t k = sizeof(struct __ns1__getMoBase_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMoBase_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMoBase_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMoBase_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMoBase_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMoBase_(struct soap *soap, const struct __ns1__getMoBase_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMoBase_(soap, tag ? tag : "-ns1:getMoBase", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoBase_ * SOAP_FMAC4 soap_get___ns1__getMoBase_(struct soap *soap, struct __ns1__getMoBase_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMoBase_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetNgCode_(struct soap *soap, struct __ns1__GetNgCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNgCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetNgCode_(struct soap *soap, const struct __ns1__GetNgCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetNgCode(soap, &a->ns1__GetNgCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetNgCode_(struct soap *soap, const char *tag, int id, const struct __ns1__GetNgCode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetNgCode(soap, "ns1:GetNgCode", -1, &a->ns1__GetNgCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetNgCode_ * SOAP_FMAC4 soap_in___ns1__GetNgCode_(struct soap *soap, const char *tag, struct __ns1__GetNgCode_ *a, const char *type)
{
	size_t soap_flag_ns1__GetNgCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetNgCode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetNgCode_, sizeof(struct __ns1__GetNgCode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetNgCode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNgCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetNgCode(soap, "ns1:GetNgCode", &a->ns1__GetNgCode, ""))
				{	soap_flag_ns1__GetNgCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetNgCode_ * SOAP_FMAC2 soap_instantiate___ns1__GetNgCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetNgCode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetNgCode_ *p;
	size_t k = sizeof(struct __ns1__GetNgCode_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetNgCode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetNgCode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetNgCode_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetNgCode_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetNgCode_(struct soap *soap, const struct __ns1__GetNgCode_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetNgCode_(soap, tag ? tag : "-ns1:GetNgCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetNgCode_ * SOAP_FMAC4 soap_get___ns1__GetNgCode_(struct soap *soap, struct __ns1__GetNgCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetNgCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetDiecastSN_(struct soap *soap, struct __ns1__SetDiecastSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetDiecastSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetDiecastSN_(struct soap *soap, const struct __ns1__SetDiecastSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetDiecastSN(soap, &a->ns1__SetDiecastSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetDiecastSN_(struct soap *soap, const char *tag, int id, const struct __ns1__SetDiecastSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetDiecastSN(soap, "ns1:SetDiecastSN", -1, &a->ns1__SetDiecastSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDiecastSN_ * SOAP_FMAC4 soap_in___ns1__SetDiecastSN_(struct soap *soap, const char *tag, struct __ns1__SetDiecastSN_ *a, const char *type)
{
	size_t soap_flag_ns1__SetDiecastSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetDiecastSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetDiecastSN_, sizeof(struct __ns1__SetDiecastSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetDiecastSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetDiecastSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetDiecastSN(soap, "ns1:SetDiecastSN", &a->ns1__SetDiecastSN, ""))
				{	soap_flag_ns1__SetDiecastSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetDiecastSN_ * SOAP_FMAC2 soap_instantiate___ns1__SetDiecastSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetDiecastSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetDiecastSN_ *p;
	size_t k = sizeof(struct __ns1__SetDiecastSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetDiecastSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetDiecastSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetDiecastSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetDiecastSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetDiecastSN_(struct soap *soap, const struct __ns1__SetDiecastSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetDiecastSN_(soap, tag ? tag : "-ns1:SetDiecastSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDiecastSN_ * SOAP_FMAC4 soap_get___ns1__SetDiecastSN_(struct soap *soap, struct __ns1__SetDiecastSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetDiecastSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMachineForGroup_(struct soap *soap, struct __ns1__GetMachineForGroup_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMachineForGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMachineForGroup_(struct soap *soap, const struct __ns1__GetMachineForGroup_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMachineForGroup(soap, &a->ns1__GetMachineForGroup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMachineForGroup_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMachineForGroup_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMachineForGroup(soap, "ns1:GetMachineForGroup", -1, &a->ns1__GetMachineForGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMachineForGroup_ * SOAP_FMAC4 soap_in___ns1__GetMachineForGroup_(struct soap *soap, const char *tag, struct __ns1__GetMachineForGroup_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMachineForGroup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMachineForGroup_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMachineForGroup_, sizeof(struct __ns1__GetMachineForGroup_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMachineForGroup_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMachineForGroup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMachineForGroup(soap, "ns1:GetMachineForGroup", &a->ns1__GetMachineForGroup, ""))
				{	soap_flag_ns1__GetMachineForGroup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMachineForGroup_ * SOAP_FMAC2 soap_instantiate___ns1__GetMachineForGroup_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMachineForGroup_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMachineForGroup_ *p;
	size_t k = sizeof(struct __ns1__GetMachineForGroup_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetMachineForGroup_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetMachineForGroup_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMachineForGroup_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetMachineForGroup_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMachineForGroup_(struct soap *soap, const struct __ns1__GetMachineForGroup_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMachineForGroup_(soap, tag ? tag : "-ns1:GetMachineForGroup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMachineForGroup_ * SOAP_FMAC4 soap_get___ns1__GetMachineForGroup_(struct soap *soap, struct __ns1__GetMachineForGroup_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMachineForGroup_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadForHP_(struct soap *soap, struct __ns1__UploadForHP_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadForHP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadForHP_(struct soap *soap, const struct __ns1__UploadForHP_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadForHP(soap, &a->ns1__UploadForHP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadForHP_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadForHP_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadForHP(soap, "ns1:UploadForHP", -1, &a->ns1__UploadForHP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadForHP_ * SOAP_FMAC4 soap_in___ns1__UploadForHP_(struct soap *soap, const char *tag, struct __ns1__UploadForHP_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadForHP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadForHP_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadForHP_, sizeof(struct __ns1__UploadForHP_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadForHP_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadForHP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UploadForHP(soap, "ns1:UploadForHP", &a->ns1__UploadForHP, ""))
				{	soap_flag_ns1__UploadForHP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UploadForHP_ * SOAP_FMAC2 soap_instantiate___ns1__UploadForHP_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadForHP_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UploadForHP_ *p;
	size_t k = sizeof(struct __ns1__UploadForHP_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UploadForHP_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UploadForHP_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UploadForHP_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UploadForHP_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadForHP_(struct soap *soap, const struct __ns1__UploadForHP_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UploadForHP_(soap, tag ? tag : "-ns1:UploadForHP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadForHP_ * SOAP_FMAC4 soap_get___ns1__UploadForHP_(struct soap *soap, struct __ns1__UploadForHP_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadForHP_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelShelfLink_(struct soap *soap, struct __ns1__SelShelfLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelShelfLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelShelfLink_(struct soap *soap, const struct __ns1__SelShelfLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelShelfLink(soap, &a->ns1__SelShelfLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelShelfLink_(struct soap *soap, const char *tag, int id, const struct __ns1__SelShelfLink_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelShelfLink(soap, "ns1:SelShelfLink", -1, &a->ns1__SelShelfLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelShelfLink_ * SOAP_FMAC4 soap_in___ns1__SelShelfLink_(struct soap *soap, const char *tag, struct __ns1__SelShelfLink_ *a, const char *type)
{
	size_t soap_flag_ns1__SelShelfLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelShelfLink_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelShelfLink_, sizeof(struct __ns1__SelShelfLink_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelShelfLink_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelShelfLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelShelfLink(soap, "ns1:SelShelfLink", &a->ns1__SelShelfLink, ""))
				{	soap_flag_ns1__SelShelfLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelShelfLink_ * SOAP_FMAC2 soap_instantiate___ns1__SelShelfLink_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelShelfLink_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelShelfLink_ *p;
	size_t k = sizeof(struct __ns1__SelShelfLink_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SelShelfLink_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SelShelfLink_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelShelfLink_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SelShelfLink_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelShelfLink_(struct soap *soap, const struct __ns1__SelShelfLink_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelShelfLink_(soap, tag ? tag : "-ns1:SelShelfLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelShelfLink_ * SOAP_FMAC4 soap_get___ns1__SelShelfLink_(struct soap *soap, struct __ns1__SelShelfLink_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelShelfLink_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SNLinkShelf_(struct soap *soap, struct __ns1__SNLinkShelf_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SNLinkShelf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SNLinkShelf_(struct soap *soap, const struct __ns1__SNLinkShelf_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SNLinkShelf(soap, &a->ns1__SNLinkShelf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SNLinkShelf_(struct soap *soap, const char *tag, int id, const struct __ns1__SNLinkShelf_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SNLinkShelf(soap, "ns1:SNLinkShelf", -1, &a->ns1__SNLinkShelf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkShelf_ * SOAP_FMAC4 soap_in___ns1__SNLinkShelf_(struct soap *soap, const char *tag, struct __ns1__SNLinkShelf_ *a, const char *type)
{
	size_t soap_flag_ns1__SNLinkShelf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SNLinkShelf_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SNLinkShelf_, sizeof(struct __ns1__SNLinkShelf_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SNLinkShelf_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SNLinkShelf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SNLinkShelf(soap, "ns1:SNLinkShelf", &a->ns1__SNLinkShelf, ""))
				{	soap_flag_ns1__SNLinkShelf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SNLinkShelf_ * SOAP_FMAC2 soap_instantiate___ns1__SNLinkShelf_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SNLinkShelf_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SNLinkShelf_ *p;
	size_t k = sizeof(struct __ns1__SNLinkShelf_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SNLinkShelf_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SNLinkShelf_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SNLinkShelf_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SNLinkShelf_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SNLinkShelf_(struct soap *soap, const struct __ns1__SNLinkShelf_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SNLinkShelf_(soap, tag ? tag : "-ns1:SNLinkShelf", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkShelf_ * SOAP_FMAC4 soap_get___ns1__SNLinkShelf_(struct soap *soap, struct __ns1__SNLinkShelf_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SNLinkShelf_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelSNTestForFruit_(struct soap *soap, struct __ns1__SelSNTestForFruit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelSNTestForFruit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelSNTestForFruit_(struct soap *soap, const struct __ns1__SelSNTestForFruit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelSNTestForFruit(soap, &a->ns1__SelSNTestForFruit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelSNTestForFruit_(struct soap *soap, const char *tag, int id, const struct __ns1__SelSNTestForFruit_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelSNTestForFruit(soap, "ns1:SelSNTestForFruit", -1, &a->ns1__SelSNTestForFruit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTestForFruit_ * SOAP_FMAC4 soap_in___ns1__SelSNTestForFruit_(struct soap *soap, const char *tag, struct __ns1__SelSNTestForFruit_ *a, const char *type)
{
	size_t soap_flag_ns1__SelSNTestForFruit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelSNTestForFruit_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelSNTestForFruit_, sizeof(struct __ns1__SelSNTestForFruit_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelSNTestForFruit_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelSNTestForFruit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelSNTestForFruit(soap, "ns1:SelSNTestForFruit", &a->ns1__SelSNTestForFruit, ""))
				{	soap_flag_ns1__SelSNTestForFruit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelSNTestForFruit_ * SOAP_FMAC2 soap_instantiate___ns1__SelSNTestForFruit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelSNTestForFruit_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelSNTestForFruit_ *p;
	size_t k = sizeof(struct __ns1__SelSNTestForFruit_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SelSNTestForFruit_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SelSNTestForFruit_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelSNTestForFruit_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SelSNTestForFruit_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelSNTestForFruit_(struct soap *soap, const struct __ns1__SelSNTestForFruit_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelSNTestForFruit_(soap, tag ? tag : "-ns1:SelSNTestForFruit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTestForFruit_ * SOAP_FMAC4 soap_get___ns1__SelSNTestForFruit_(struct soap *soap, struct __ns1__SelSNTestForFruit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelSNTestForFruit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsSNTestForFruit_(struct soap *soap, struct __ns1__InsSNTestForFruit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsSNTestForFruit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsSNTestForFruit_(struct soap *soap, const struct __ns1__InsSNTestForFruit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsSNTestForFruit(soap, &a->ns1__InsSNTestForFruit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsSNTestForFruit_(struct soap *soap, const char *tag, int id, const struct __ns1__InsSNTestForFruit_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsSNTestForFruit(soap, "ns1:InsSNTestForFruit", -1, &a->ns1__InsSNTestForFruit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTestForFruit_ * SOAP_FMAC4 soap_in___ns1__InsSNTestForFruit_(struct soap *soap, const char *tag, struct __ns1__InsSNTestForFruit_ *a, const char *type)
{
	size_t soap_flag_ns1__InsSNTestForFruit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsSNTestForFruit_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsSNTestForFruit_, sizeof(struct __ns1__InsSNTestForFruit_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsSNTestForFruit_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsSNTestForFruit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsSNTestForFruit(soap, "ns1:InsSNTestForFruit", &a->ns1__InsSNTestForFruit, ""))
				{	soap_flag_ns1__InsSNTestForFruit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsSNTestForFruit_ * SOAP_FMAC2 soap_instantiate___ns1__InsSNTestForFruit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsSNTestForFruit_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsSNTestForFruit_ *p;
	size_t k = sizeof(struct __ns1__InsSNTestForFruit_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsSNTestForFruit_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsSNTestForFruit_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsSNTestForFruit_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsSNTestForFruit_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsSNTestForFruit_(struct soap *soap, const struct __ns1__InsSNTestForFruit_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsSNTestForFruit_(soap, tag ? tag : "-ns1:InsSNTestForFruit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTestForFruit_ * SOAP_FMAC4 soap_get___ns1__InsSNTestForFruit_(struct soap *soap, struct __ns1__InsSNTestForFruit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsSNTestForFruit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStationNumberForSN_(struct soap *soap, struct __ns1__GetStationNumberForSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStationNumberForSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStationNumberForSN_(struct soap *soap, const struct __ns1__GetStationNumberForSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetStationNumberForSN(soap, &a->ns1__GetStationNumberForSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStationNumberForSN_(struct soap *soap, const char *tag, int id, const struct __ns1__GetStationNumberForSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetStationNumberForSN(soap, "ns1:GetStationNumberForSN", -1, &a->ns1__GetStationNumberForSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationNumberForSN_ * SOAP_FMAC4 soap_in___ns1__GetStationNumberForSN_(struct soap *soap, const char *tag, struct __ns1__GetStationNumberForSN_ *a, const char *type)
{
	size_t soap_flag_ns1__GetStationNumberForSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetStationNumberForSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStationNumberForSN_, sizeof(struct __ns1__GetStationNumberForSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStationNumberForSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStationNumberForSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetStationNumberForSN(soap, "ns1:GetStationNumberForSN", &a->ns1__GetStationNumberForSN, ""))
				{	soap_flag_ns1__GetStationNumberForSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetStationNumberForSN_ * SOAP_FMAC2 soap_instantiate___ns1__GetStationNumberForSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStationNumberForSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetStationNumberForSN_ *p;
	size_t k = sizeof(struct __ns1__GetStationNumberForSN_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetStationNumberForSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetStationNumberForSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetStationNumberForSN_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetStationNumberForSN_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStationNumberForSN_(struct soap *soap, const struct __ns1__GetStationNumberForSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetStationNumberForSN_(soap, tag ? tag : "-ns1:GetStationNumberForSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationNumberForSN_ * SOAP_FMAC4 soap_get___ns1__GetStationNumberForSN_(struct soap *soap, struct __ns1__GetStationNumberForSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStationNumberForSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTestValueResult_(struct soap *soap, struct __ns1__GetTestValueResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTestValueResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTestValueResult_(struct soap *soap, const struct __ns1__GetTestValueResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTestValueResult(soap, &a->ns1__GetTestValueResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTestValueResult_(struct soap *soap, const char *tag, int id, const struct __ns1__GetTestValueResult_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTestValueResult(soap, "ns1:GetTestValueResult", -1, &a->ns1__GetTestValueResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValueResult_ * SOAP_FMAC4 soap_in___ns1__GetTestValueResult_(struct soap *soap, const char *tag, struct __ns1__GetTestValueResult_ *a, const char *type)
{
	size_t soap_flag_ns1__GetTestValueResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTestValueResult_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTestValueResult_, sizeof(struct __ns1__GetTestValueResult_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTestValueResult_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTestValueResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTestValueResult(soap, "ns1:GetTestValueResult", &a->ns1__GetTestValueResult, ""))
				{	soap_flag_ns1__GetTestValueResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTestValueResult_ * SOAP_FMAC2 soap_instantiate___ns1__GetTestValueResult_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTestValueResult_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTestValueResult_ *p;
	size_t k = sizeof(struct __ns1__GetTestValueResult_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetTestValueResult_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetTestValueResult_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTestValueResult_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetTestValueResult_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTestValueResult_(struct soap *soap, const struct __ns1__GetTestValueResult_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTestValueResult_(soap, tag ? tag : "-ns1:GetTestValueResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValueResult_ * SOAP_FMAC4 soap_get___ns1__GetTestValueResult_(struct soap *soap, struct __ns1__GetTestValueResult_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTestValueResult_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsCLScada_(struct soap *soap, struct __ns1__InsCLScada_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsCLScada = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsCLScada_(struct soap *soap, const struct __ns1__InsCLScada_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsCLScada(soap, &a->ns1__InsCLScada);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsCLScada_(struct soap *soap, const char *tag, int id, const struct __ns1__InsCLScada_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsCLScada(soap, "ns1:InsCLScada", -1, &a->ns1__InsCLScada, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsCLScada_ * SOAP_FMAC4 soap_in___ns1__InsCLScada_(struct soap *soap, const char *tag, struct __ns1__InsCLScada_ *a, const char *type)
{
	size_t soap_flag_ns1__InsCLScada = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsCLScada_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsCLScada_, sizeof(struct __ns1__InsCLScada_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsCLScada_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsCLScada && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsCLScada(soap, "ns1:InsCLScada", &a->ns1__InsCLScada, ""))
				{	soap_flag_ns1__InsCLScada--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsCLScada_ * SOAP_FMAC2 soap_instantiate___ns1__InsCLScada_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsCLScada_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsCLScada_ *p;
	size_t k = sizeof(struct __ns1__InsCLScada_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsCLScada_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsCLScada_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsCLScada_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsCLScada_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsCLScada_(struct soap *soap, const struct __ns1__InsCLScada_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsCLScada_(soap, tag ? tag : "-ns1:InsCLScada", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsCLScada_ * SOAP_FMAC4 soap_get___ns1__InsCLScada_(struct soap *soap, struct __ns1__InsCLScada_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsCLScada_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsAoiMo_(struct soap *soap, struct __ns1__InsAoiMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsAoiMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsAoiMo_(struct soap *soap, const struct __ns1__InsAoiMo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsAoiMo(soap, &a->ns1__InsAoiMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsAoiMo_(struct soap *soap, const char *tag, int id, const struct __ns1__InsAoiMo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsAoiMo(soap, "ns1:InsAoiMo", -1, &a->ns1__InsAoiMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsAoiMo_ * SOAP_FMAC4 soap_in___ns1__InsAoiMo_(struct soap *soap, const char *tag, struct __ns1__InsAoiMo_ *a, const char *type)
{
	size_t soap_flag_ns1__InsAoiMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsAoiMo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsAoiMo_, sizeof(struct __ns1__InsAoiMo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsAoiMo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsAoiMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsAoiMo(soap, "ns1:InsAoiMo", &a->ns1__InsAoiMo, ""))
				{	soap_flag_ns1__InsAoiMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsAoiMo_ * SOAP_FMAC2 soap_instantiate___ns1__InsAoiMo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsAoiMo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsAoiMo_ *p;
	size_t k = sizeof(struct __ns1__InsAoiMo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsAoiMo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsAoiMo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsAoiMo_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsAoiMo_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsAoiMo_(struct soap *soap, const struct __ns1__InsAoiMo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsAoiMo_(soap, tag ? tag : "-ns1:InsAoiMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsAoiMo_ * SOAP_FMAC4 soap_get___ns1__InsAoiMo_(struct soap *soap, struct __ns1__InsAoiMo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsAoiMo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkMoSNForAOI_(struct soap *soap, struct __ns1__chkMoSNForAOI_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkMoSNForAOI = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkMoSNForAOI_(struct soap *soap, const struct __ns1__chkMoSNForAOI_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkMoSNForAOI(soap, &a->ns1__chkMoSNForAOI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkMoSNForAOI_(struct soap *soap, const char *tag, int id, const struct __ns1__chkMoSNForAOI_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkMoSNForAOI(soap, "ns1:chkMoSNForAOI", -1, &a->ns1__chkMoSNForAOI, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoSNForAOI_ * SOAP_FMAC4 soap_in___ns1__chkMoSNForAOI_(struct soap *soap, const char *tag, struct __ns1__chkMoSNForAOI_ *a, const char *type)
{
	size_t soap_flag_ns1__chkMoSNForAOI = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkMoSNForAOI_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkMoSNForAOI_, sizeof(struct __ns1__chkMoSNForAOI_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkMoSNForAOI_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkMoSNForAOI && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkMoSNForAOI(soap, "ns1:chkMoSNForAOI", &a->ns1__chkMoSNForAOI, ""))
				{	soap_flag_ns1__chkMoSNForAOI--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkMoSNForAOI_ * SOAP_FMAC2 soap_instantiate___ns1__chkMoSNForAOI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkMoSNForAOI_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkMoSNForAOI_ *p;
	size_t k = sizeof(struct __ns1__chkMoSNForAOI_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkMoSNForAOI_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkMoSNForAOI_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkMoSNForAOI_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkMoSNForAOI_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkMoSNForAOI_(struct soap *soap, const struct __ns1__chkMoSNForAOI_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkMoSNForAOI_(soap, tag ? tag : "-ns1:chkMoSNForAOI", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoSNForAOI_ * SOAP_FMAC4 soap_get___ns1__chkMoSNForAOI_(struct soap *soap, struct __ns1__chkMoSNForAOI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkMoSNForAOI_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PunchOut_(struct soap *soap, struct __ns1__PunchOut_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PunchOut = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PunchOut_(struct soap *soap, const struct __ns1__PunchOut_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PunchOut(soap, &a->ns1__PunchOut);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PunchOut_(struct soap *soap, const char *tag, int id, const struct __ns1__PunchOut_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PunchOut(soap, "ns1:PunchOut", -1, &a->ns1__PunchOut, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PunchOut_ * SOAP_FMAC4 soap_in___ns1__PunchOut_(struct soap *soap, const char *tag, struct __ns1__PunchOut_ *a, const char *type)
{
	size_t soap_flag_ns1__PunchOut = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__PunchOut_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PunchOut_, sizeof(struct __ns1__PunchOut_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PunchOut_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PunchOut && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__PunchOut(soap, "ns1:PunchOut", &a->ns1__PunchOut, ""))
				{	soap_flag_ns1__PunchOut--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__PunchOut_ * SOAP_FMAC2 soap_instantiate___ns1__PunchOut_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PunchOut_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__PunchOut_ *p;
	size_t k = sizeof(struct __ns1__PunchOut_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__PunchOut_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__PunchOut_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__PunchOut_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__PunchOut_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PunchOut_(struct soap *soap, const struct __ns1__PunchOut_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__PunchOut_(soap, tag ? tag : "-ns1:PunchOut", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PunchOut_ * SOAP_FMAC4 soap_get___ns1__PunchOut_(struct soap *soap, struct __ns1__PunchOut_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PunchOut_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BasketLinkPunch_(struct soap *soap, struct __ns1__BasketLinkPunch_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BasketLinkPunch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BasketLinkPunch_(struct soap *soap, const struct __ns1__BasketLinkPunch_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BasketLinkPunch(soap, &a->ns1__BasketLinkPunch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BasketLinkPunch_(struct soap *soap, const char *tag, int id, const struct __ns1__BasketLinkPunch_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BasketLinkPunch(soap, "ns1:BasketLinkPunch", -1, &a->ns1__BasketLinkPunch, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BasketLinkPunch_ * SOAP_FMAC4 soap_in___ns1__BasketLinkPunch_(struct soap *soap, const char *tag, struct __ns1__BasketLinkPunch_ *a, const char *type)
{
	size_t soap_flag_ns1__BasketLinkPunch = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BasketLinkPunch_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BasketLinkPunch_, sizeof(struct __ns1__BasketLinkPunch_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BasketLinkPunch_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BasketLinkPunch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BasketLinkPunch(soap, "ns1:BasketLinkPunch", &a->ns1__BasketLinkPunch, ""))
				{	soap_flag_ns1__BasketLinkPunch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BasketLinkPunch_ * SOAP_FMAC2 soap_instantiate___ns1__BasketLinkPunch_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BasketLinkPunch_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BasketLinkPunch_ *p;
	size_t k = sizeof(struct __ns1__BasketLinkPunch_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BasketLinkPunch_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BasketLinkPunch_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BasketLinkPunch_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BasketLinkPunch_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BasketLinkPunch_(struct soap *soap, const struct __ns1__BasketLinkPunch_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BasketLinkPunch_(soap, tag ? tag : "-ns1:BasketLinkPunch", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BasketLinkPunch_ * SOAP_FMAC4 soap_get___ns1__BasketLinkPunch_(struct soap *soap, struct __ns1__BasketLinkPunch_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BasketLinkPunch_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__HPSNLinkBasket_(struct soap *soap, struct __ns1__HPSNLinkBasket_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HPSNLinkBasket = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__HPSNLinkBasket_(struct soap *soap, const struct __ns1__HPSNLinkBasket_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__HPSNLinkBasket(soap, &a->ns1__HPSNLinkBasket);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__HPSNLinkBasket_(struct soap *soap, const char *tag, int id, const struct __ns1__HPSNLinkBasket_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__HPSNLinkBasket(soap, "ns1:HPSNLinkBasket", -1, &a->ns1__HPSNLinkBasket, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HPSNLinkBasket_ * SOAP_FMAC4 soap_in___ns1__HPSNLinkBasket_(struct soap *soap, const char *tag, struct __ns1__HPSNLinkBasket_ *a, const char *type)
{
	size_t soap_flag_ns1__HPSNLinkBasket = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__HPSNLinkBasket_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__HPSNLinkBasket_, sizeof(struct __ns1__HPSNLinkBasket_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__HPSNLinkBasket_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HPSNLinkBasket && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__HPSNLinkBasket(soap, "ns1:HPSNLinkBasket", &a->ns1__HPSNLinkBasket, ""))
				{	soap_flag_ns1__HPSNLinkBasket--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__HPSNLinkBasket_ * SOAP_FMAC2 soap_instantiate___ns1__HPSNLinkBasket_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__HPSNLinkBasket_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__HPSNLinkBasket_ *p;
	size_t k = sizeof(struct __ns1__HPSNLinkBasket_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__HPSNLinkBasket_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__HPSNLinkBasket_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__HPSNLinkBasket_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__HPSNLinkBasket_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__HPSNLinkBasket_(struct soap *soap, const struct __ns1__HPSNLinkBasket_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__HPSNLinkBasket_(soap, tag ? tag : "-ns1:HPSNLinkBasket", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HPSNLinkBasket_ * SOAP_FMAC4 soap_get___ns1__HPSNLinkBasket_(struct soap *soap, struct __ns1__HPSNLinkBasket_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__HPSNLinkBasket_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetAutoLineRec_(struct soap *soap, struct __ns1__SetAutoLineRec_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetAutoLineRec = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetAutoLineRec_(struct soap *soap, const struct __ns1__SetAutoLineRec_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetAutoLineRec(soap, &a->ns1__SetAutoLineRec);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetAutoLineRec_(struct soap *soap, const char *tag, int id, const struct __ns1__SetAutoLineRec_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetAutoLineRec(soap, "ns1:SetAutoLineRec", -1, &a->ns1__SetAutoLineRec, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetAutoLineRec_ * SOAP_FMAC4 soap_in___ns1__SetAutoLineRec_(struct soap *soap, const char *tag, struct __ns1__SetAutoLineRec_ *a, const char *type)
{
	size_t soap_flag_ns1__SetAutoLineRec = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetAutoLineRec_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetAutoLineRec_, sizeof(struct __ns1__SetAutoLineRec_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetAutoLineRec_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetAutoLineRec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetAutoLineRec(soap, "ns1:SetAutoLineRec", &a->ns1__SetAutoLineRec, ""))
				{	soap_flag_ns1__SetAutoLineRec--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetAutoLineRec_ * SOAP_FMAC2 soap_instantiate___ns1__SetAutoLineRec_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetAutoLineRec_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetAutoLineRec_ *p;
	size_t k = sizeof(struct __ns1__SetAutoLineRec_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetAutoLineRec_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetAutoLineRec_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetAutoLineRec_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetAutoLineRec_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetAutoLineRec_(struct soap *soap, const struct __ns1__SetAutoLineRec_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetAutoLineRec_(soap, tag ? tag : "-ns1:SetAutoLineRec", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetAutoLineRec_ * SOAP_FMAC4 soap_get___ns1__SetAutoLineRec_(struct soap *soap, struct __ns1__SetAutoLineRec_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetAutoLineRec_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSNForLink_(struct soap *soap, struct __ns1__GetSNForLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSNForLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSNForLink_(struct soap *soap, const struct __ns1__GetSNForLink_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetSNForLink(soap, &a->ns1__GetSNForLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSNForLink_(struct soap *soap, const char *tag, int id, const struct __ns1__GetSNForLink_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetSNForLink(soap, "ns1:GetSNForLink", -1, &a->ns1__GetSNForLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSNForLink_ * SOAP_FMAC4 soap_in___ns1__GetSNForLink_(struct soap *soap, const char *tag, struct __ns1__GetSNForLink_ *a, const char *type)
{
	size_t soap_flag_ns1__GetSNForLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetSNForLink_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSNForLink_, sizeof(struct __ns1__GetSNForLink_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSNForLink_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSNForLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetSNForLink(soap, "ns1:GetSNForLink", &a->ns1__GetSNForLink, ""))
				{	soap_flag_ns1__GetSNForLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetSNForLink_ * SOAP_FMAC2 soap_instantiate___ns1__GetSNForLink_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSNForLink_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetSNForLink_ *p;
	size_t k = sizeof(struct __ns1__GetSNForLink_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetSNForLink_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetSNForLink_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetSNForLink_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetSNForLink_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSNForLink_(struct soap *soap, const struct __ns1__GetSNForLink_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetSNForLink_(soap, tag ? tag : "-ns1:GetSNForLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSNForLink_ * SOAP_FMAC4 soap_get___ns1__GetSNForLink_(struct soap *soap, struct __ns1__GetSNForLink_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSNForLink_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetFlatnessFruitRec_(struct soap *soap, struct __ns1__SetFlatnessFruitRec_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetFlatnessFruitRec = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetFlatnessFruitRec_(struct soap *soap, const struct __ns1__SetFlatnessFruitRec_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetFlatnessFruitRec(soap, &a->ns1__SetFlatnessFruitRec);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetFlatnessFruitRec_(struct soap *soap, const char *tag, int id, const struct __ns1__SetFlatnessFruitRec_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetFlatnessFruitRec(soap, "ns1:SetFlatnessFruitRec", -1, &a->ns1__SetFlatnessFruitRec, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFlatnessFruitRec_ * SOAP_FMAC4 soap_in___ns1__SetFlatnessFruitRec_(struct soap *soap, const char *tag, struct __ns1__SetFlatnessFruitRec_ *a, const char *type)
{
	size_t soap_flag_ns1__SetFlatnessFruitRec = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetFlatnessFruitRec_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetFlatnessFruitRec_, sizeof(struct __ns1__SetFlatnessFruitRec_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetFlatnessFruitRec_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetFlatnessFruitRec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetFlatnessFruitRec(soap, "ns1:SetFlatnessFruitRec", &a->ns1__SetFlatnessFruitRec, ""))
				{	soap_flag_ns1__SetFlatnessFruitRec--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetFlatnessFruitRec_ * SOAP_FMAC2 soap_instantiate___ns1__SetFlatnessFruitRec_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetFlatnessFruitRec_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetFlatnessFruitRec_ *p;
	size_t k = sizeof(struct __ns1__SetFlatnessFruitRec_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetFlatnessFruitRec_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetFlatnessFruitRec_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetFlatnessFruitRec_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetFlatnessFruitRec_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetFlatnessFruitRec_(struct soap *soap, const struct __ns1__SetFlatnessFruitRec_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetFlatnessFruitRec_(soap, tag ? tag : "-ns1:SetFlatnessFruitRec", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFlatnessFruitRec_ * SOAP_FMAC4 soap_get___ns1__SetFlatnessFruitRec_(struct soap *soap, struct __ns1__SetFlatnessFruitRec_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetFlatnessFruitRec_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStationByMoForTestPad_(struct soap *soap, struct __ns1__getStationByMoForTestPad_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStationByMoForTestPad = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStationByMoForTestPad_(struct soap *soap, const struct __ns1__getStationByMoForTestPad_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getStationByMoForTestPad(soap, &a->ns1__getStationByMoForTestPad);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStationByMoForTestPad_(struct soap *soap, const char *tag, int id, const struct __ns1__getStationByMoForTestPad_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getStationByMoForTestPad(soap, "ns1:getStationByMoForTestPad", -1, &a->ns1__getStationByMoForTestPad, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMoForTestPad_ * SOAP_FMAC4 soap_in___ns1__getStationByMoForTestPad_(struct soap *soap, const char *tag, struct __ns1__getStationByMoForTestPad_ *a, const char *type)
{
	size_t soap_flag_ns1__getStationByMoForTestPad = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getStationByMoForTestPad_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStationByMoForTestPad_, sizeof(struct __ns1__getStationByMoForTestPad_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStationByMoForTestPad_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStationByMoForTestPad && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getStationByMoForTestPad(soap, "ns1:getStationByMoForTestPad", &a->ns1__getStationByMoForTestPad, ""))
				{	soap_flag_ns1__getStationByMoForTestPad--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getStationByMoForTestPad_ * SOAP_FMAC2 soap_instantiate___ns1__getStationByMoForTestPad_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStationByMoForTestPad_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getStationByMoForTestPad_ *p;
	size_t k = sizeof(struct __ns1__getStationByMoForTestPad_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getStationByMoForTestPad_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getStationByMoForTestPad_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getStationByMoForTestPad_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getStationByMoForTestPad_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStationByMoForTestPad_(struct soap *soap, const struct __ns1__getStationByMoForTestPad_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getStationByMoForTestPad_(soap, tag ? tag : "-ns1:getStationByMoForTestPad", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMoForTestPad_ * SOAP_FMAC4 soap_get___ns1__getStationByMoForTestPad_(struct soap *soap, struct __ns1__getStationByMoForTestPad_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStationByMoForTestPad_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingWeight_(struct soap *soap, struct __ns1__GetShippingWeight_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingWeight = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingWeight_(struct soap *soap, const struct __ns1__GetShippingWeight_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingWeight(soap, &a->ns1__GetShippingWeight);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingWeight_(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingWeight_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingWeight(soap, "ns1:GetShippingWeight", -1, &a->ns1__GetShippingWeight, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingWeight_ * SOAP_FMAC4 soap_in___ns1__GetShippingWeight_(struct soap *soap, const char *tag, struct __ns1__GetShippingWeight_ *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingWeight = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingWeight_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingWeight_, sizeof(struct __ns1__GetShippingWeight_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingWeight_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingWeight && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingWeight(soap, "ns1:GetShippingWeight", &a->ns1__GetShippingWeight, ""))
				{	soap_flag_ns1__GetShippingWeight--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingWeight_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingWeight_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingWeight_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingWeight_ *p;
	size_t k = sizeof(struct __ns1__GetShippingWeight_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingWeight_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingWeight_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingWeight_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingWeight_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingWeight_(struct soap *soap, const struct __ns1__GetShippingWeight_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingWeight_(soap, tag ? tag : "-ns1:GetShippingWeight", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingWeight_ * SOAP_FMAC4 soap_get___ns1__GetShippingWeight_(struct soap *soap, struct __ns1__GetShippingWeight_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingWeight_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingForBerth_(struct soap *soap, struct __ns1__GetShippingForBerth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingForBerth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingForBerth_(struct soap *soap, const struct __ns1__GetShippingForBerth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingForBerth(soap, &a->ns1__GetShippingForBerth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingForBerth_(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingForBerth_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingForBerth(soap, "ns1:GetShippingForBerth", -1, &a->ns1__GetShippingForBerth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingForBerth_ * SOAP_FMAC4 soap_in___ns1__GetShippingForBerth_(struct soap *soap, const char *tag, struct __ns1__GetShippingForBerth_ *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingForBerth = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingForBerth_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingForBerth_, sizeof(struct __ns1__GetShippingForBerth_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingForBerth_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingForBerth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingForBerth(soap, "ns1:GetShippingForBerth", &a->ns1__GetShippingForBerth, ""))
				{	soap_flag_ns1__GetShippingForBerth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingForBerth_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingForBerth_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingForBerth_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingForBerth_ *p;
	size_t k = sizeof(struct __ns1__GetShippingForBerth_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingForBerth_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingForBerth_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingForBerth_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingForBerth_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingForBerth_(struct soap *soap, const struct __ns1__GetShippingForBerth_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingForBerth_(soap, tag ? tag : "-ns1:GetShippingForBerth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingForBerth_ * SOAP_FMAC4 soap_get___ns1__GetShippingForBerth_(struct soap *soap, struct __ns1__GetShippingForBerth_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingForBerth_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsShippingBerth_(struct soap *soap, struct __ns1__InsShippingBerth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsShippingBerth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsShippingBerth_(struct soap *soap, const struct __ns1__InsShippingBerth_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsShippingBerth(soap, &a->ns1__InsShippingBerth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsShippingBerth_(struct soap *soap, const char *tag, int id, const struct __ns1__InsShippingBerth_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsShippingBerth(soap, "ns1:InsShippingBerth", -1, &a->ns1__InsShippingBerth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingBerth_ * SOAP_FMAC4 soap_in___ns1__InsShippingBerth_(struct soap *soap, const char *tag, struct __ns1__InsShippingBerth_ *a, const char *type)
{
	size_t soap_flag_ns1__InsShippingBerth = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsShippingBerth_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsShippingBerth_, sizeof(struct __ns1__InsShippingBerth_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsShippingBerth_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsShippingBerth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsShippingBerth(soap, "ns1:InsShippingBerth", &a->ns1__InsShippingBerth, ""))
				{	soap_flag_ns1__InsShippingBerth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsShippingBerth_ * SOAP_FMAC2 soap_instantiate___ns1__InsShippingBerth_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsShippingBerth_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsShippingBerth_ *p;
	size_t k = sizeof(struct __ns1__InsShippingBerth_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsShippingBerth_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsShippingBerth_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsShippingBerth_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsShippingBerth_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsShippingBerth_(struct soap *soap, const struct __ns1__InsShippingBerth_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsShippingBerth_(soap, tag ? tag : "-ns1:InsShippingBerth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingBerth_ * SOAP_FMAC4 soap_get___ns1__InsShippingBerth_(struct soap *soap, struct __ns1__InsShippingBerth_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsShippingBerth_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsShippingPalle_(struct soap *soap, struct __ns1__InsShippingPalle_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsShippingPalle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsShippingPalle_(struct soap *soap, const struct __ns1__InsShippingPalle_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsShippingPalle(soap, &a->ns1__InsShippingPalle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsShippingPalle_(struct soap *soap, const char *tag, int id, const struct __ns1__InsShippingPalle_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsShippingPalle(soap, "ns1:InsShippingPalle", -1, &a->ns1__InsShippingPalle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingPalle_ * SOAP_FMAC4 soap_in___ns1__InsShippingPalle_(struct soap *soap, const char *tag, struct __ns1__InsShippingPalle_ *a, const char *type)
{
	size_t soap_flag_ns1__InsShippingPalle = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsShippingPalle_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsShippingPalle_, sizeof(struct __ns1__InsShippingPalle_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsShippingPalle_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsShippingPalle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsShippingPalle(soap, "ns1:InsShippingPalle", &a->ns1__InsShippingPalle, ""))
				{	soap_flag_ns1__InsShippingPalle--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsShippingPalle_ * SOAP_FMAC2 soap_instantiate___ns1__InsShippingPalle_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsShippingPalle_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsShippingPalle_ *p;
	size_t k = sizeof(struct __ns1__InsShippingPalle_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsShippingPalle_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsShippingPalle_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsShippingPalle_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsShippingPalle_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsShippingPalle_(struct soap *soap, const struct __ns1__InsShippingPalle_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsShippingPalle_(soap, tag ? tag : "-ns1:InsShippingPalle", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingPalle_ * SOAP_FMAC4 soap_get___ns1__InsShippingPalle_(struct soap *soap, struct __ns1__InsShippingPalle_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsShippingPalle_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingPalle_(struct soap *soap, struct __ns1__GetShippingPalle_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingPalle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingPalle_(struct soap *soap, const struct __ns1__GetShippingPalle_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingPalle(soap, &a->ns1__GetShippingPalle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingPalle_(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingPalle_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingPalle(soap, "ns1:GetShippingPalle", -1, &a->ns1__GetShippingPalle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingPalle_ * SOAP_FMAC4 soap_in___ns1__GetShippingPalle_(struct soap *soap, const char *tag, struct __ns1__GetShippingPalle_ *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingPalle = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingPalle_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingPalle_, sizeof(struct __ns1__GetShippingPalle_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingPalle_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingPalle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingPalle(soap, "ns1:GetShippingPalle", &a->ns1__GetShippingPalle, ""))
				{	soap_flag_ns1__GetShippingPalle--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingPalle_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingPalle_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingPalle_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingPalle_ *p;
	size_t k = sizeof(struct __ns1__GetShippingPalle_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingPalle_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingPalle_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingPalle_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingPalle_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingPalle_(struct soap *soap, const struct __ns1__GetShippingPalle_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingPalle_(soap, tag ? tag : "-ns1:GetShippingPalle", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingPalle_ * SOAP_FMAC4 soap_get___ns1__GetShippingPalle_(struct soap *soap, struct __ns1__GetShippingPalle_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingPalle_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdShipping_(struct soap *soap, struct __ns1__UpdShipping_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdShipping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdShipping_(struct soap *soap, const struct __ns1__UpdShipping_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdShipping(soap, &a->ns1__UpdShipping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdShipping_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdShipping_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdShipping(soap, "ns1:UpdShipping", -1, &a->ns1__UpdShipping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdShipping_ * SOAP_FMAC4 soap_in___ns1__UpdShipping_(struct soap *soap, const char *tag, struct __ns1__UpdShipping_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdShipping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdShipping_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdShipping_, sizeof(struct __ns1__UpdShipping_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdShipping_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdShipping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdShipping(soap, "ns1:UpdShipping", &a->ns1__UpdShipping, ""))
				{	soap_flag_ns1__UpdShipping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdShipping_ * SOAP_FMAC2 soap_instantiate___ns1__UpdShipping_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdShipping_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdShipping_ *p;
	size_t k = sizeof(struct __ns1__UpdShipping_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdShipping_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdShipping_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdShipping_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UpdShipping_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdShipping_(struct soap *soap, const struct __ns1__UpdShipping_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdShipping_(soap, tag ? tag : "-ns1:UpdShipping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdShipping_ * SOAP_FMAC4 soap_get___ns1__UpdShipping_(struct soap *soap, struct __ns1__UpdShipping_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdShipping_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingBerthList_(struct soap *soap, struct __ns1__GetShippingBerthList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingBerthList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingBerthList_(struct soap *soap, const struct __ns1__GetShippingBerthList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingBerthList(soap, &a->ns1__GetShippingBerthList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingBerthList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingBerthList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingBerthList(soap, "ns1:GetShippingBerthList", -1, &a->ns1__GetShippingBerthList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingBerthList_ * SOAP_FMAC4 soap_in___ns1__GetShippingBerthList_(struct soap *soap, const char *tag, struct __ns1__GetShippingBerthList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingBerthList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingBerthList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingBerthList_, sizeof(struct __ns1__GetShippingBerthList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingBerthList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingBerthList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingBerthList(soap, "ns1:GetShippingBerthList", &a->ns1__GetShippingBerthList, ""))
				{	soap_flag_ns1__GetShippingBerthList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingBerthList_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingBerthList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingBerthList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingBerthList_ *p;
	size_t k = sizeof(struct __ns1__GetShippingBerthList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingBerthList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingBerthList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingBerthList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingBerthList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingBerthList_(struct soap *soap, const struct __ns1__GetShippingBerthList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingBerthList_(soap, tag ? tag : "-ns1:GetShippingBerthList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingBerthList_ * SOAP_FMAC4 soap_get___ns1__GetShippingBerthList_(struct soap *soap, struct __ns1__GetShippingBerthList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingBerthList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingList_(struct soap *soap, struct __ns1__GetShippingList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingList_(struct soap *soap, const struct __ns1__GetShippingList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingList(soap, &a->ns1__GetShippingList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingList(soap, "ns1:GetShippingList", -1, &a->ns1__GetShippingList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingList_ * SOAP_FMAC4 soap_in___ns1__GetShippingList_(struct soap *soap, const char *tag, struct __ns1__GetShippingList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingList_, sizeof(struct __ns1__GetShippingList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingList(soap, "ns1:GetShippingList", &a->ns1__GetShippingList, ""))
				{	soap_flag_ns1__GetShippingList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingList_ * SOAP_FMAC2 soap_instantiate___ns1__GetShippingList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingList_ *p;
	size_t k = sizeof(struct __ns1__GetShippingList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingList_(struct soap *soap, const struct __ns1__GetShippingList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingList_(soap, tag ? tag : "-ns1:GetShippingList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingList_ * SOAP_FMAC4 soap_get___ns1__GetShippingList_(struct soap *soap, struct __ns1__GetShippingList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doLotLinkForApple_(struct soap *soap, struct __ns1__doLotLinkForApple_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doLotLinkForApple = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doLotLinkForApple_(struct soap *soap, const struct __ns1__doLotLinkForApple_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doLotLinkForApple(soap, &a->ns1__doLotLinkForApple);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doLotLinkForApple_(struct soap *soap, const char *tag, int id, const struct __ns1__doLotLinkForApple_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doLotLinkForApple(soap, "ns1:doLotLinkForApple", -1, &a->ns1__doLotLinkForApple, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLotLinkForApple_ * SOAP_FMAC4 soap_in___ns1__doLotLinkForApple_(struct soap *soap, const char *tag, struct __ns1__doLotLinkForApple_ *a, const char *type)
{
	size_t soap_flag_ns1__doLotLinkForApple = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doLotLinkForApple_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doLotLinkForApple_, sizeof(struct __ns1__doLotLinkForApple_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doLotLinkForApple_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doLotLinkForApple && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doLotLinkForApple(soap, "ns1:doLotLinkForApple", &a->ns1__doLotLinkForApple, ""))
				{	soap_flag_ns1__doLotLinkForApple--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doLotLinkForApple_ * SOAP_FMAC2 soap_instantiate___ns1__doLotLinkForApple_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doLotLinkForApple_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doLotLinkForApple_ *p;
	size_t k = sizeof(struct __ns1__doLotLinkForApple_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doLotLinkForApple_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doLotLinkForApple_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doLotLinkForApple_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doLotLinkForApple_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doLotLinkForApple_(struct soap *soap, const struct __ns1__doLotLinkForApple_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doLotLinkForApple_(soap, tag ? tag : "-ns1:doLotLinkForApple", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLotLinkForApple_ * SOAP_FMAC4 soap_get___ns1__doLotLinkForApple_(struct soap *soap, struct __ns1__doLotLinkForApple_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doLotLinkForApple_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotLinkCount_(struct soap *soap, struct __ns1__GetLotLinkCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotLinkCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotLinkCount_(struct soap *soap, const struct __ns1__GetLotLinkCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLotLinkCount(soap, &a->ns1__GetLotLinkCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotLinkCount_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotLinkCount_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLotLinkCount(soap, "ns1:GetLotLinkCount", -1, &a->ns1__GetLotLinkCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotLinkCount_ * SOAP_FMAC4 soap_in___ns1__GetLotLinkCount_(struct soap *soap, const char *tag, struct __ns1__GetLotLinkCount_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLotLinkCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLotLinkCount_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotLinkCount_, sizeof(struct __ns1__GetLotLinkCount_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotLinkCount_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotLinkCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLotLinkCount(soap, "ns1:GetLotLinkCount", &a->ns1__GetLotLinkCount, ""))
				{	soap_flag_ns1__GetLotLinkCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLotLinkCount_ * SOAP_FMAC2 soap_instantiate___ns1__GetLotLinkCount_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotLinkCount_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLotLinkCount_ *p;
	size_t k = sizeof(struct __ns1__GetLotLinkCount_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLotLinkCount_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLotLinkCount_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLotLinkCount_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLotLinkCount_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotLinkCount_(struct soap *soap, const struct __ns1__GetLotLinkCount_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLotLinkCount_(soap, tag ? tag : "-ns1:GetLotLinkCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotLinkCount_ * SOAP_FMAC4 soap_get___ns1__GetLotLinkCount_(struct soap *soap, struct __ns1__GetLotLinkCount_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotLinkCount_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFruitSNCheck_(struct soap *soap, struct __ns1__GetFruitSNCheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFruitSNCheck = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFruitSNCheck_(struct soap *soap, const struct __ns1__GetFruitSNCheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFruitSNCheck(soap, &a->ns1__GetFruitSNCheck);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFruitSNCheck_(struct soap *soap, const char *tag, int id, const struct __ns1__GetFruitSNCheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFruitSNCheck(soap, "ns1:GetFruitSNCheck", -1, &a->ns1__GetFruitSNCheck, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitSNCheck_ * SOAP_FMAC4 soap_in___ns1__GetFruitSNCheck_(struct soap *soap, const char *tag, struct __ns1__GetFruitSNCheck_ *a, const char *type)
{
	size_t soap_flag_ns1__GetFruitSNCheck = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFruitSNCheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFruitSNCheck_, sizeof(struct __ns1__GetFruitSNCheck_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFruitSNCheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFruitSNCheck && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFruitSNCheck(soap, "ns1:GetFruitSNCheck", &a->ns1__GetFruitSNCheck, ""))
				{	soap_flag_ns1__GetFruitSNCheck--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFruitSNCheck_ * SOAP_FMAC2 soap_instantiate___ns1__GetFruitSNCheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFruitSNCheck_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFruitSNCheck_ *p;
	size_t k = sizeof(struct __ns1__GetFruitSNCheck_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetFruitSNCheck_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetFruitSNCheck_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFruitSNCheck_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetFruitSNCheck_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFruitSNCheck_(struct soap *soap, const struct __ns1__GetFruitSNCheck_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFruitSNCheck_(soap, tag ? tag : "-ns1:GetFruitSNCheck", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitSNCheck_ * SOAP_FMAC4 soap_get___ns1__GetFruitSNCheck_(struct soap *soap, struct __ns1__GetFruitSNCheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFruitSNCheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetObeNW_(struct soap *soap, struct __ns1__GetObeNW_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetObeNW = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetObeNW_(struct soap *soap, const struct __ns1__GetObeNW_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetObeNW(soap, &a->ns1__GetObeNW);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetObeNW_(struct soap *soap, const char *tag, int id, const struct __ns1__GetObeNW_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetObeNW(soap, "ns1:GetObeNW", -1, &a->ns1__GetObeNW, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObeNW_ * SOAP_FMAC4 soap_in___ns1__GetObeNW_(struct soap *soap, const char *tag, struct __ns1__GetObeNW_ *a, const char *type)
{
	size_t soap_flag_ns1__GetObeNW = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetObeNW_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetObeNW_, sizeof(struct __ns1__GetObeNW_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetObeNW_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetObeNW && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetObeNW(soap, "ns1:GetObeNW", &a->ns1__GetObeNW, ""))
				{	soap_flag_ns1__GetObeNW--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetObeNW_ * SOAP_FMAC2 soap_instantiate___ns1__GetObeNW_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetObeNW_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetObeNW_ *p;
	size_t k = sizeof(struct __ns1__GetObeNW_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetObeNW_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetObeNW_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetObeNW_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetObeNW_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetObeNW_(struct soap *soap, const struct __ns1__GetObeNW_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetObeNW_(soap, tag ? tag : "-ns1:GetObeNW", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObeNW_ * SOAP_FMAC4 soap_get___ns1__GetObeNW_(struct soap *soap, struct __ns1__GetObeNW_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetObeNW_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doSnLinkForApple_(struct soap *soap, struct __ns1__doSnLinkForApple_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doSnLinkForApple = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doSnLinkForApple_(struct soap *soap, const struct __ns1__doSnLinkForApple_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doSnLinkForApple(soap, &a->ns1__doSnLinkForApple);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doSnLinkForApple_(struct soap *soap, const char *tag, int id, const struct __ns1__doSnLinkForApple_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doSnLinkForApple(soap, "ns1:doSnLinkForApple", -1, &a->ns1__doSnLinkForApple, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doSnLinkForApple_ * SOAP_FMAC4 soap_in___ns1__doSnLinkForApple_(struct soap *soap, const char *tag, struct __ns1__doSnLinkForApple_ *a, const char *type)
{
	size_t soap_flag_ns1__doSnLinkForApple = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doSnLinkForApple_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doSnLinkForApple_, sizeof(struct __ns1__doSnLinkForApple_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doSnLinkForApple_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doSnLinkForApple && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doSnLinkForApple(soap, "ns1:doSnLinkForApple", &a->ns1__doSnLinkForApple, ""))
				{	soap_flag_ns1__doSnLinkForApple--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doSnLinkForApple_ * SOAP_FMAC2 soap_instantiate___ns1__doSnLinkForApple_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doSnLinkForApple_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doSnLinkForApple_ *p;
	size_t k = sizeof(struct __ns1__doSnLinkForApple_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doSnLinkForApple_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doSnLinkForApple_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doSnLinkForApple_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doSnLinkForApple_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doSnLinkForApple_(struct soap *soap, const struct __ns1__doSnLinkForApple_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doSnLinkForApple_(soap, tag ? tag : "-ns1:doSnLinkForApple", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doSnLinkForApple_ * SOAP_FMAC4 soap_get___ns1__doSnLinkForApple_(struct soap *soap, struct __ns1__doSnLinkForApple_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doSnLinkForApple_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnLinkForApple_(struct soap *soap, struct __ns1__ChkSnLinkForApple_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnLinkForApple = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnLinkForApple_(struct soap *soap, const struct __ns1__ChkSnLinkForApple_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnLinkForApple(soap, &a->ns1__ChkSnLinkForApple);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnLinkForApple_(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnLinkForApple_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnLinkForApple(soap, "ns1:ChkSnLinkForApple", -1, &a->ns1__ChkSnLinkForApple, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLinkForApple_ * SOAP_FMAC4 soap_in___ns1__ChkSnLinkForApple_(struct soap *soap, const char *tag, struct __ns1__ChkSnLinkForApple_ *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnLinkForApple = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnLinkForApple_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnLinkForApple_, sizeof(struct __ns1__ChkSnLinkForApple_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnLinkForApple_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnLinkForApple && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnLinkForApple(soap, "ns1:ChkSnLinkForApple", &a->ns1__ChkSnLinkForApple, ""))
				{	soap_flag_ns1__ChkSnLinkForApple--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnLinkForApple_ * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLinkForApple_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnLinkForApple_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnLinkForApple_ *p;
	size_t k = sizeof(struct __ns1__ChkSnLinkForApple_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnLinkForApple_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnLinkForApple_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnLinkForApple_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnLinkForApple_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnLinkForApple_(struct soap *soap, const struct __ns1__ChkSnLinkForApple_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnLinkForApple_(soap, tag ? tag : "-ns1:ChkSnLinkForApple", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLinkForApple_ * SOAP_FMAC4 soap_get___ns1__ChkSnLinkForApple_(struct soap *soap, struct __ns1__ChkSnLinkForApple_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnLinkForApple_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DelSNTest_(struct soap *soap, struct __ns1__DelSNTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DelSNTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DelSNTest_(struct soap *soap, const struct __ns1__DelSNTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DelSNTest(soap, &a->ns1__DelSNTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DelSNTest_(struct soap *soap, const char *tag, int id, const struct __ns1__DelSNTest_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DelSNTest(soap, "ns1:DelSNTest", -1, &a->ns1__DelSNTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DelSNTest_ * SOAP_FMAC4 soap_in___ns1__DelSNTest_(struct soap *soap, const char *tag, struct __ns1__DelSNTest_ *a, const char *type)
{
	size_t soap_flag_ns1__DelSNTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DelSNTest_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DelSNTest_, sizeof(struct __ns1__DelSNTest_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DelSNTest_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DelSNTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DelSNTest(soap, "ns1:DelSNTest", &a->ns1__DelSNTest, ""))
				{	soap_flag_ns1__DelSNTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DelSNTest_ * SOAP_FMAC2 soap_instantiate___ns1__DelSNTest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DelSNTest_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DelSNTest_ *p;
	size_t k = sizeof(struct __ns1__DelSNTest_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DelSNTest_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DelSNTest_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DelSNTest_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__DelSNTest_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DelSNTest_(struct soap *soap, const struct __ns1__DelSNTest_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DelSNTest_(soap, tag ? tag : "-ns1:DelSNTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DelSNTest_ * SOAP_FMAC4 soap_get___ns1__DelSNTest_(struct soap *soap, struct __ns1__DelSNTest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DelSNTest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelSNTest_(struct soap *soap, struct __ns1__SelSNTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelSNTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelSNTest_(struct soap *soap, const struct __ns1__SelSNTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelSNTest(soap, &a->ns1__SelSNTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelSNTest_(struct soap *soap, const char *tag, int id, const struct __ns1__SelSNTest_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelSNTest(soap, "ns1:SelSNTest", -1, &a->ns1__SelSNTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTest_ * SOAP_FMAC4 soap_in___ns1__SelSNTest_(struct soap *soap, const char *tag, struct __ns1__SelSNTest_ *a, const char *type)
{
	size_t soap_flag_ns1__SelSNTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelSNTest_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelSNTest_, sizeof(struct __ns1__SelSNTest_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelSNTest_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelSNTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelSNTest(soap, "ns1:SelSNTest", &a->ns1__SelSNTest, ""))
				{	soap_flag_ns1__SelSNTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelSNTest_ * SOAP_FMAC2 soap_instantiate___ns1__SelSNTest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelSNTest_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelSNTest_ *p;
	size_t k = sizeof(struct __ns1__SelSNTest_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SelSNTest_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SelSNTest_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelSNTest_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SelSNTest_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelSNTest_(struct soap *soap, const struct __ns1__SelSNTest_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelSNTest_(soap, tag ? tag : "-ns1:SelSNTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTest_ * SOAP_FMAC4 soap_get___ns1__SelSNTest_(struct soap *soap, struct __ns1__SelSNTest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelSNTest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsSNTest_(struct soap *soap, struct __ns1__InsSNTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsSNTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsSNTest_(struct soap *soap, const struct __ns1__InsSNTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsSNTest(soap, &a->ns1__InsSNTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsSNTest_(struct soap *soap, const char *tag, int id, const struct __ns1__InsSNTest_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsSNTest(soap, "ns1:InsSNTest", -1, &a->ns1__InsSNTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTest_ * SOAP_FMAC4 soap_in___ns1__InsSNTest_(struct soap *soap, const char *tag, struct __ns1__InsSNTest_ *a, const char *type)
{
	size_t soap_flag_ns1__InsSNTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsSNTest_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsSNTest_, sizeof(struct __ns1__InsSNTest_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsSNTest_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsSNTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsSNTest(soap, "ns1:InsSNTest", &a->ns1__InsSNTest, ""))
				{	soap_flag_ns1__InsSNTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsSNTest_ * SOAP_FMAC2 soap_instantiate___ns1__InsSNTest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsSNTest_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsSNTest_ *p;
	size_t k = sizeof(struct __ns1__InsSNTest_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsSNTest_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsSNTest_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsSNTest_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsSNTest_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsSNTest_(struct soap *soap, const struct __ns1__InsSNTest_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsSNTest_(soap, tag ? tag : "-ns1:InsSNTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTest_ * SOAP_FMAC4 soap_get___ns1__InsSNTest_(struct soap *soap, struct __ns1__InsSNTest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsSNTest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkWeightTime_(struct soap *soap, struct __ns1__ChkWeightTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkWeightTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkWeightTime_(struct soap *soap, const struct __ns1__ChkWeightTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkWeightTime(soap, &a->ns1__ChkWeightTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkWeightTime_(struct soap *soap, const char *tag, int id, const struct __ns1__ChkWeightTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkWeightTime(soap, "ns1:ChkWeightTime", -1, &a->ns1__ChkWeightTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkWeightTime_ * SOAP_FMAC4 soap_in___ns1__ChkWeightTime_(struct soap *soap, const char *tag, struct __ns1__ChkWeightTime_ *a, const char *type)
{
	size_t soap_flag_ns1__ChkWeightTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkWeightTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkWeightTime_, sizeof(struct __ns1__ChkWeightTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkWeightTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkWeightTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkWeightTime(soap, "ns1:ChkWeightTime", &a->ns1__ChkWeightTime, ""))
				{	soap_flag_ns1__ChkWeightTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkWeightTime_ * SOAP_FMAC2 soap_instantiate___ns1__ChkWeightTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkWeightTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkWeightTime_ *p;
	size_t k = sizeof(struct __ns1__ChkWeightTime_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkWeightTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkWeightTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkWeightTime_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkWeightTime_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkWeightTime_(struct soap *soap, const struct __ns1__ChkWeightTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkWeightTime_(soap, tag ? tag : "-ns1:ChkWeightTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkWeightTime_ * SOAP_FMAC4 soap_get___ns1__ChkWeightTime_(struct soap *soap, struct __ns1__ChkWeightTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkWeightTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdAhsBarcode_(struct soap *soap, struct __ns1__UpdAhsBarcode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdAhsBarcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdAhsBarcode_(struct soap *soap, const struct __ns1__UpdAhsBarcode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdAhsBarcode(soap, &a->ns1__UpdAhsBarcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdAhsBarcode_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdAhsBarcode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdAhsBarcode(soap, "ns1:UpdAhsBarcode", -1, &a->ns1__UpdAhsBarcode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdAhsBarcode_ * SOAP_FMAC4 soap_in___ns1__UpdAhsBarcode_(struct soap *soap, const char *tag, struct __ns1__UpdAhsBarcode_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdAhsBarcode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdAhsBarcode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdAhsBarcode_, sizeof(struct __ns1__UpdAhsBarcode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdAhsBarcode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdAhsBarcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdAhsBarcode(soap, "ns1:UpdAhsBarcode", &a->ns1__UpdAhsBarcode, ""))
				{	soap_flag_ns1__UpdAhsBarcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdAhsBarcode_ * SOAP_FMAC2 soap_instantiate___ns1__UpdAhsBarcode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdAhsBarcode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdAhsBarcode_ *p;
	size_t k = sizeof(struct __ns1__UpdAhsBarcode_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdAhsBarcode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdAhsBarcode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdAhsBarcode_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UpdAhsBarcode_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdAhsBarcode_(struct soap *soap, const struct __ns1__UpdAhsBarcode_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdAhsBarcode_(soap, tag ? tag : "-ns1:UpdAhsBarcode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdAhsBarcode_ * SOAP_FMAC4 soap_get___ns1__UpdAhsBarcode_(struct soap *soap, struct __ns1__UpdAhsBarcode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdAhsBarcode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAhsBarcode_(struct soap *soap, struct __ns1__GetAhsBarcode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAhsBarcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAhsBarcode_(struct soap *soap, const struct __ns1__GetAhsBarcode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAhsBarcode(soap, &a->ns1__GetAhsBarcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAhsBarcode_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAhsBarcode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAhsBarcode(soap, "ns1:GetAhsBarcode", -1, &a->ns1__GetAhsBarcode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsBarcode_ * SOAP_FMAC4 soap_in___ns1__GetAhsBarcode_(struct soap *soap, const char *tag, struct __ns1__GetAhsBarcode_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAhsBarcode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAhsBarcode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAhsBarcode_, sizeof(struct __ns1__GetAhsBarcode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAhsBarcode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAhsBarcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAhsBarcode(soap, "ns1:GetAhsBarcode", &a->ns1__GetAhsBarcode, ""))
				{	soap_flag_ns1__GetAhsBarcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAhsBarcode_ * SOAP_FMAC2 soap_instantiate___ns1__GetAhsBarcode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAhsBarcode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAhsBarcode_ *p;
	size_t k = sizeof(struct __ns1__GetAhsBarcode_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAhsBarcode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAhsBarcode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAhsBarcode_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAhsBarcode_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAhsBarcode_(struct soap *soap, const struct __ns1__GetAhsBarcode_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAhsBarcode_(soap, tag ? tag : "-ns1:GetAhsBarcode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsBarcode_ * SOAP_FMAC4 soap_get___ns1__GetAhsBarcode_(struct soap *soap, struct __ns1__GetAhsBarcode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAhsBarcode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAhsMo(struct soap *soap, struct __ns1__GetAhsMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAhsMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAhsMo(struct soap *soap, const struct __ns1__GetAhsMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAhsMo(soap, &a->ns1__GetAhsMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAhsMo(struct soap *soap, const char *tag, int id, const struct __ns1__GetAhsMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAhsMo(soap, "ns1:GetAhsMo", -1, &a->ns1__GetAhsMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsMo * SOAP_FMAC4 soap_in___ns1__GetAhsMo(struct soap *soap, const char *tag, struct __ns1__GetAhsMo *a, const char *type)
{
	size_t soap_flag_ns1__GetAhsMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAhsMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAhsMo, sizeof(struct __ns1__GetAhsMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAhsMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAhsMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAhsMo(soap, "ns1:GetAhsMo", &a->ns1__GetAhsMo, ""))
				{	soap_flag_ns1__GetAhsMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAhsMo * SOAP_FMAC2 soap_instantiate___ns1__GetAhsMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAhsMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAhsMo *p;
	size_t k = sizeof(struct __ns1__GetAhsMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAhsMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAhsMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAhsMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAhsMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAhsMo(struct soap *soap, const struct __ns1__GetAhsMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAhsMo(soap, tag ? tag : "-ns1:GetAhsMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsMo * SOAP_FMAC4 soap_get___ns1__GetAhsMo(struct soap *soap, struct __ns1__GetAhsMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAhsMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPackWeigth(struct soap *soap, struct __ns1__GetPackWeigth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPackWeigth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPackWeigth(struct soap *soap, const struct __ns1__GetPackWeigth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPackWeigth(soap, &a->ns1__GetPackWeigth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPackWeigth(struct soap *soap, const char *tag, int id, const struct __ns1__GetPackWeigth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPackWeigth(soap, "ns1:GetPackWeigth", -1, &a->ns1__GetPackWeigth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackWeigth * SOAP_FMAC4 soap_in___ns1__GetPackWeigth(struct soap *soap, const char *tag, struct __ns1__GetPackWeigth *a, const char *type)
{
	size_t soap_flag_ns1__GetPackWeigth = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPackWeigth *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPackWeigth, sizeof(struct __ns1__GetPackWeigth), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPackWeigth(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPackWeigth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPackWeigth(soap, "ns1:GetPackWeigth", &a->ns1__GetPackWeigth, ""))
				{	soap_flag_ns1__GetPackWeigth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPackWeigth * SOAP_FMAC2 soap_instantiate___ns1__GetPackWeigth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPackWeigth(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPackWeigth *p;
	size_t k = sizeof(struct __ns1__GetPackWeigth);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPackWeigth);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPackWeigth, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPackWeigth location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPackWeigth, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPackWeigth(struct soap *soap, const struct __ns1__GetPackWeigth *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPackWeigth(soap, tag ? tag : "-ns1:GetPackWeigth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackWeigth * SOAP_FMAC4 soap_get___ns1__GetPackWeigth(struct soap *soap, struct __ns1__GetPackWeigth *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPackWeigth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPackStation(struct soap *soap, struct __ns1__GetPackStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPackStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPackStation(struct soap *soap, const struct __ns1__GetPackStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPackStation(soap, &a->ns1__GetPackStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPackStation(struct soap *soap, const char *tag, int id, const struct __ns1__GetPackStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPackStation(soap, "ns1:GetPackStation", -1, &a->ns1__GetPackStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackStation * SOAP_FMAC4 soap_in___ns1__GetPackStation(struct soap *soap, const char *tag, struct __ns1__GetPackStation *a, const char *type)
{
	size_t soap_flag_ns1__GetPackStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPackStation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPackStation, sizeof(struct __ns1__GetPackStation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPackStation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPackStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPackStation(soap, "ns1:GetPackStation", &a->ns1__GetPackStation, ""))
				{	soap_flag_ns1__GetPackStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPackStation * SOAP_FMAC2 soap_instantiate___ns1__GetPackStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPackStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPackStation *p;
	size_t k = sizeof(struct __ns1__GetPackStation);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPackStation);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPackStation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPackStation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPackStation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPackStation(struct soap *soap, const struct __ns1__GetPackStation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPackStation(soap, tag ? tag : "-ns1:GetPackStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackStation * SOAP_FMAC4 soap_get___ns1__GetPackStation(struct soap *soap, struct __ns1__GetPackStation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPackStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetPallentForWMS(struct soap *soap, struct __ns1__SetPallentForWMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPallentForWMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetPallentForWMS(struct soap *soap, const struct __ns1__SetPallentForWMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetPallentForWMS(soap, &a->ns1__SetPallentForWMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetPallentForWMS(struct soap *soap, const char *tag, int id, const struct __ns1__SetPallentForWMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetPallentForWMS(soap, "ns1:SetPallentForWMS", -1, &a->ns1__SetPallentForWMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPallentForWMS * SOAP_FMAC4 soap_in___ns1__SetPallentForWMS(struct soap *soap, const char *tag, struct __ns1__SetPallentForWMS *a, const char *type)
{
	size_t soap_flag_ns1__SetPallentForWMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetPallentForWMS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetPallentForWMS, sizeof(struct __ns1__SetPallentForWMS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetPallentForWMS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPallentForWMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetPallentForWMS(soap, "ns1:SetPallentForWMS", &a->ns1__SetPallentForWMS, ""))
				{	soap_flag_ns1__SetPallentForWMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetPallentForWMS * SOAP_FMAC2 soap_instantiate___ns1__SetPallentForWMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetPallentForWMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetPallentForWMS *p;
	size_t k = sizeof(struct __ns1__SetPallentForWMS);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetPallentForWMS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetPallentForWMS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetPallentForWMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetPallentForWMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetPallentForWMS(struct soap *soap, const struct __ns1__SetPallentForWMS *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetPallentForWMS(soap, tag ? tag : "-ns1:SetPallentForWMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPallentForWMS * SOAP_FMAC4 soap_get___ns1__SetPallentForWMS(struct soap *soap, struct __ns1__SetPallentForWMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetPallentForWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPallentToWMS(struct soap *soap, struct __ns1__GetPallentToWMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPallentToWMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPallentToWMS(struct soap *soap, const struct __ns1__GetPallentToWMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPallentToWMS(soap, &a->ns1__GetPallentToWMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPallentToWMS(struct soap *soap, const char *tag, int id, const struct __ns1__GetPallentToWMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPallentToWMS(soap, "ns1:GetPallentToWMS", -1, &a->ns1__GetPallentToWMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPallentToWMS * SOAP_FMAC4 soap_in___ns1__GetPallentToWMS(struct soap *soap, const char *tag, struct __ns1__GetPallentToWMS *a, const char *type)
{
	size_t soap_flag_ns1__GetPallentToWMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPallentToWMS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPallentToWMS, sizeof(struct __ns1__GetPallentToWMS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPallentToWMS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPallentToWMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPallentToWMS(soap, "ns1:GetPallentToWMS", &a->ns1__GetPallentToWMS, ""))
				{	soap_flag_ns1__GetPallentToWMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPallentToWMS * SOAP_FMAC2 soap_instantiate___ns1__GetPallentToWMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPallentToWMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPallentToWMS *p;
	size_t k = sizeof(struct __ns1__GetPallentToWMS);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPallentToWMS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPallentToWMS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPallentToWMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPallentToWMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPallentToWMS(struct soap *soap, const struct __ns1__GetPallentToWMS *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPallentToWMS(soap, tag ? tag : "-ns1:GetPallentToWMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPallentToWMS * SOAP_FMAC4 soap_get___ns1__GetPallentToWMS(struct soap *soap, struct __ns1__GetPallentToWMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPallentToWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPackToWMS(struct soap *soap, struct __ns1__GetPackToWMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPackToWMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPackToWMS(struct soap *soap, const struct __ns1__GetPackToWMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPackToWMS(soap, &a->ns1__GetPackToWMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPackToWMS(struct soap *soap, const char *tag, int id, const struct __ns1__GetPackToWMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPackToWMS(soap, "ns1:GetPackToWMS", -1, &a->ns1__GetPackToWMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackToWMS * SOAP_FMAC4 soap_in___ns1__GetPackToWMS(struct soap *soap, const char *tag, struct __ns1__GetPackToWMS *a, const char *type)
{
	size_t soap_flag_ns1__GetPackToWMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPackToWMS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPackToWMS, sizeof(struct __ns1__GetPackToWMS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPackToWMS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPackToWMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPackToWMS(soap, "ns1:GetPackToWMS", &a->ns1__GetPackToWMS, ""))
				{	soap_flag_ns1__GetPackToWMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPackToWMS * SOAP_FMAC2 soap_instantiate___ns1__GetPackToWMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPackToWMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPackToWMS *p;
	size_t k = sizeof(struct __ns1__GetPackToWMS);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPackToWMS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPackToWMS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPackToWMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPackToWMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPackToWMS(struct soap *soap, const struct __ns1__GetPackToWMS *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPackToWMS(soap, tag ? tag : "-ns1:GetPackToWMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPackToWMS * SOAP_FMAC4 soap_get___ns1__GetPackToWMS(struct soap *soap, struct __ns1__GetPackToWMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPackToWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetWeightSet(struct soap *soap, struct __ns1__GetWeightSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWeightSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetWeightSet(struct soap *soap, const struct __ns1__GetWeightSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetWeightSet(soap, &a->ns1__GetWeightSet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetWeightSet(struct soap *soap, const char *tag, int id, const struct __ns1__GetWeightSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetWeightSet(soap, "ns1:GetWeightSet", -1, &a->ns1__GetWeightSet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWeightSet * SOAP_FMAC4 soap_in___ns1__GetWeightSet(struct soap *soap, const char *tag, struct __ns1__GetWeightSet *a, const char *type)
{
	size_t soap_flag_ns1__GetWeightSet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetWeightSet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetWeightSet, sizeof(struct __ns1__GetWeightSet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetWeightSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWeightSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetWeightSet(soap, "ns1:GetWeightSet", &a->ns1__GetWeightSet, ""))
				{	soap_flag_ns1__GetWeightSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetWeightSet * SOAP_FMAC2 soap_instantiate___ns1__GetWeightSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetWeightSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetWeightSet *p;
	size_t k = sizeof(struct __ns1__GetWeightSet);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetWeightSet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetWeightSet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetWeightSet location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetWeightSet, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetWeightSet(struct soap *soap, const struct __ns1__GetWeightSet *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetWeightSet(soap, tag ? tag : "-ns1:GetWeightSet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWeightSet * SOAP_FMAC4 soap_get___ns1__GetWeightSet(struct soap *soap, struct __ns1__GetWeightSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetWeightSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CancelLnkSN(struct soap *soap, struct __ns1__CancelLnkSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelLnkSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CancelLnkSN(struct soap *soap, const struct __ns1__CancelLnkSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelLnkSN(soap, &a->ns1__CancelLnkSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CancelLnkSN(struct soap *soap, const char *tag, int id, const struct __ns1__CancelLnkSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelLnkSN(soap, "ns1:CancelLnkSN", -1, &a->ns1__CancelLnkSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelLnkSN * SOAP_FMAC4 soap_in___ns1__CancelLnkSN(struct soap *soap, const char *tag, struct __ns1__CancelLnkSN *a, const char *type)
{
	size_t soap_flag_ns1__CancelLnkSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CancelLnkSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CancelLnkSN, sizeof(struct __ns1__CancelLnkSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CancelLnkSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelLnkSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CancelLnkSN(soap, "ns1:CancelLnkSN", &a->ns1__CancelLnkSN, ""))
				{	soap_flag_ns1__CancelLnkSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CancelLnkSN * SOAP_FMAC2 soap_instantiate___ns1__CancelLnkSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CancelLnkSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CancelLnkSN *p;
	size_t k = sizeof(struct __ns1__CancelLnkSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CancelLnkSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CancelLnkSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CancelLnkSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CancelLnkSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CancelLnkSN(struct soap *soap, const struct __ns1__CancelLnkSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CancelLnkSN(soap, tag ? tag : "-ns1:CancelLnkSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelLnkSN * SOAP_FMAC4 soap_get___ns1__CancelLnkSN(struct soap *soap, struct __ns1__CancelLnkSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CancelLnkSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CancelGrillSN(struct soap *soap, struct __ns1__CancelGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CancelGrillSN(struct soap *soap, const struct __ns1__CancelGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelGrillSN(soap, &a->ns1__CancelGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CancelGrillSN(struct soap *soap, const char *tag, int id, const struct __ns1__CancelGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelGrillSN(soap, "ns1:CancelGrillSN", -1, &a->ns1__CancelGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelGrillSN * SOAP_FMAC4 soap_in___ns1__CancelGrillSN(struct soap *soap, const char *tag, struct __ns1__CancelGrillSN *a, const char *type)
{
	size_t soap_flag_ns1__CancelGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CancelGrillSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CancelGrillSN, sizeof(struct __ns1__CancelGrillSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CancelGrillSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CancelGrillSN(soap, "ns1:CancelGrillSN", &a->ns1__CancelGrillSN, ""))
				{	soap_flag_ns1__CancelGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CancelGrillSN * SOAP_FMAC2 soap_instantiate___ns1__CancelGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CancelGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CancelGrillSN *p;
	size_t k = sizeof(struct __ns1__CancelGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CancelGrillSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CancelGrillSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CancelGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CancelGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CancelGrillSN(struct soap *soap, const struct __ns1__CancelGrillSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CancelGrillSN(soap, tag ? tag : "-ns1:CancelGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelGrillSN * SOAP_FMAC4 soap_get___ns1__CancelGrillSN(struct soap *soap, struct __ns1__CancelGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CancelGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutGrillBySN(struct soap *soap, struct __ns1__OutGrillBySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutGrillBySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutGrillBySN(struct soap *soap, const struct __ns1__OutGrillBySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutGrillBySN(soap, &a->ns1__OutGrillBySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutGrillBySN(struct soap *soap, const char *tag, int id, const struct __ns1__OutGrillBySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutGrillBySN(soap, "ns1:OutGrillBySN", -1, &a->ns1__OutGrillBySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutGrillBySN * SOAP_FMAC4 soap_in___ns1__OutGrillBySN(struct soap *soap, const char *tag, struct __ns1__OutGrillBySN *a, const char *type)
{
	size_t soap_flag_ns1__OutGrillBySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutGrillBySN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutGrillBySN, sizeof(struct __ns1__OutGrillBySN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutGrillBySN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutGrillBySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutGrillBySN(soap, "ns1:OutGrillBySN", &a->ns1__OutGrillBySN, ""))
				{	soap_flag_ns1__OutGrillBySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutGrillBySN * SOAP_FMAC2 soap_instantiate___ns1__OutGrillBySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutGrillBySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutGrillBySN *p;
	size_t k = sizeof(struct __ns1__OutGrillBySN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OutGrillBySN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OutGrillBySN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutGrillBySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OutGrillBySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutGrillBySN(struct soap *soap, const struct __ns1__OutGrillBySN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutGrillBySN(soap, tag ? tag : "-ns1:OutGrillBySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutGrillBySN * SOAP_FMAC4 soap_get___ns1__OutGrillBySN(struct soap *soap, struct __ns1__OutGrillBySN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutGrillBySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGrillTime(struct soap *soap, struct __ns1__GetGrillTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGrillTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGrillTime(struct soap *soap, const struct __ns1__GetGrillTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetGrillTime(soap, &a->ns1__GetGrillTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGrillTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetGrillTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetGrillTime(soap, "ns1:GetGrillTime", -1, &a->ns1__GetGrillTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGrillTime * SOAP_FMAC4 soap_in___ns1__GetGrillTime(struct soap *soap, const char *tag, struct __ns1__GetGrillTime *a, const char *type)
{
	size_t soap_flag_ns1__GetGrillTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetGrillTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGrillTime, sizeof(struct __ns1__GetGrillTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGrillTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGrillTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetGrillTime(soap, "ns1:GetGrillTime", &a->ns1__GetGrillTime, ""))
				{	soap_flag_ns1__GetGrillTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetGrillTime * SOAP_FMAC2 soap_instantiate___ns1__GetGrillTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGrillTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetGrillTime *p;
	size_t k = sizeof(struct __ns1__GetGrillTime);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetGrillTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetGrillTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetGrillTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetGrillTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGrillTime(struct soap *soap, const struct __ns1__GetGrillTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetGrillTime(soap, tag ? tag : "-ns1:GetGrillTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGrillTime * SOAP_FMAC4 soap_get___ns1__GetGrillTime(struct soap *soap, struct __ns1__GetGrillTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGrillTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsGrillBySN(struct soap *soap, struct __ns1__InsGrillBySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsGrillBySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsGrillBySN(struct soap *soap, const struct __ns1__InsGrillBySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsGrillBySN(soap, &a->ns1__InsGrillBySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsGrillBySN(struct soap *soap, const char *tag, int id, const struct __ns1__InsGrillBySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsGrillBySN(soap, "ns1:InsGrillBySN", -1, &a->ns1__InsGrillBySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsGrillBySN * SOAP_FMAC4 soap_in___ns1__InsGrillBySN(struct soap *soap, const char *tag, struct __ns1__InsGrillBySN *a, const char *type)
{
	size_t soap_flag_ns1__InsGrillBySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsGrillBySN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsGrillBySN, sizeof(struct __ns1__InsGrillBySN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsGrillBySN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsGrillBySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsGrillBySN(soap, "ns1:InsGrillBySN", &a->ns1__InsGrillBySN, ""))
				{	soap_flag_ns1__InsGrillBySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsGrillBySN * SOAP_FMAC2 soap_instantiate___ns1__InsGrillBySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsGrillBySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsGrillBySN *p;
	size_t k = sizeof(struct __ns1__InsGrillBySN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsGrillBySN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsGrillBySN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsGrillBySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsGrillBySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsGrillBySN(struct soap *soap, const struct __ns1__InsGrillBySN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsGrillBySN(soap, tag ? tag : "-ns1:InsGrillBySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsGrillBySN * SOAP_FMAC4 soap_get___ns1__InsGrillBySN(struct soap *soap, struct __ns1__InsGrillBySN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsGrillBySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseGrillSN(struct soap *soap, struct __ns1__CloseGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseGrillSN(struct soap *soap, const struct __ns1__CloseGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseGrillSN(soap, &a->ns1__CloseGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseGrillSN(struct soap *soap, const char *tag, int id, const struct __ns1__CloseGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseGrillSN(soap, "ns1:CloseGrillSN", -1, &a->ns1__CloseGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseGrillSN * SOAP_FMAC4 soap_in___ns1__CloseGrillSN(struct soap *soap, const char *tag, struct __ns1__CloseGrillSN *a, const char *type)
{
	size_t soap_flag_ns1__CloseGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseGrillSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseGrillSN, sizeof(struct __ns1__CloseGrillSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseGrillSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CloseGrillSN(soap, "ns1:CloseGrillSN", &a->ns1__CloseGrillSN, ""))
				{	soap_flag_ns1__CloseGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseGrillSN * SOAP_FMAC2 soap_instantiate___ns1__CloseGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseGrillSN *p;
	size_t k = sizeof(struct __ns1__CloseGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseGrillSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseGrillSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseGrillSN(struct soap *soap, const struct __ns1__CloseGrillSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseGrillSN(soap, tag ? tag : "-ns1:CloseGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseGrillSN * SOAP_FMAC4 soap_get___ns1__CloseGrillSN(struct soap *soap, struct __ns1__CloseGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LnkGrillSN(struct soap *soap, struct __ns1__LnkGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LnkGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LnkGrillSN(struct soap *soap, const struct __ns1__LnkGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LnkGrillSN(soap, &a->ns1__LnkGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LnkGrillSN(struct soap *soap, const char *tag, int id, const struct __ns1__LnkGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LnkGrillSN(soap, "ns1:LnkGrillSN", -1, &a->ns1__LnkGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkGrillSN * SOAP_FMAC4 soap_in___ns1__LnkGrillSN(struct soap *soap, const char *tag, struct __ns1__LnkGrillSN *a, const char *type)
{
	size_t soap_flag_ns1__LnkGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LnkGrillSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LnkGrillSN, sizeof(struct __ns1__LnkGrillSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LnkGrillSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LnkGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__LnkGrillSN(soap, "ns1:LnkGrillSN", &a->ns1__LnkGrillSN, ""))
				{	soap_flag_ns1__LnkGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LnkGrillSN * SOAP_FMAC2 soap_instantiate___ns1__LnkGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LnkGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LnkGrillSN *p;
	size_t k = sizeof(struct __ns1__LnkGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LnkGrillSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LnkGrillSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LnkGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LnkGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LnkGrillSN(struct soap *soap, const struct __ns1__LnkGrillSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LnkGrillSN(soap, tag ? tag : "-ns1:LnkGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkGrillSN * SOAP_FMAC4 soap_get___ns1__LnkGrillSN(struct soap *soap, struct __ns1__LnkGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LnkGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkGrillSN(struct soap *soap, struct __ns1__chkGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkGrillSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkGrillSN(struct soap *soap, const struct __ns1__chkGrillSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkGrillSN(soap, &a->ns1__chkGrillSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkGrillSN(struct soap *soap, const char *tag, int id, const struct __ns1__chkGrillSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkGrillSN(soap, "ns1:chkGrillSN", -1, &a->ns1__chkGrillSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkGrillSN * SOAP_FMAC4 soap_in___ns1__chkGrillSN(struct soap *soap, const char *tag, struct __ns1__chkGrillSN *a, const char *type)
{
	size_t soap_flag_ns1__chkGrillSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkGrillSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkGrillSN, sizeof(struct __ns1__chkGrillSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkGrillSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkGrillSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkGrillSN(soap, "ns1:chkGrillSN", &a->ns1__chkGrillSN, ""))
				{	soap_flag_ns1__chkGrillSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkGrillSN * SOAP_FMAC2 soap_instantiate___ns1__chkGrillSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkGrillSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkGrillSN *p;
	size_t k = sizeof(struct __ns1__chkGrillSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkGrillSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkGrillSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkGrillSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkGrillSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkGrillSN(struct soap *soap, const struct __ns1__chkGrillSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkGrillSN(soap, tag ? tag : "-ns1:chkGrillSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkGrillSN * SOAP_FMAC4 soap_get___ns1__chkGrillSN(struct soap *soap, struct __ns1__chkGrillSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LnkSideSN(struct soap *soap, struct __ns1__LnkSideSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LnkSideSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LnkSideSN(struct soap *soap, const struct __ns1__LnkSideSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LnkSideSN(soap, &a->ns1__LnkSideSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LnkSideSN(struct soap *soap, const char *tag, int id, const struct __ns1__LnkSideSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LnkSideSN(soap, "ns1:LnkSideSN", -1, &a->ns1__LnkSideSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkSideSN * SOAP_FMAC4 soap_in___ns1__LnkSideSN(struct soap *soap, const char *tag, struct __ns1__LnkSideSN *a, const char *type)
{
	size_t soap_flag_ns1__LnkSideSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LnkSideSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LnkSideSN, sizeof(struct __ns1__LnkSideSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LnkSideSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LnkSideSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__LnkSideSN(soap, "ns1:LnkSideSN", &a->ns1__LnkSideSN, ""))
				{	soap_flag_ns1__LnkSideSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LnkSideSN * SOAP_FMAC2 soap_instantiate___ns1__LnkSideSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LnkSideSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LnkSideSN *p;
	size_t k = sizeof(struct __ns1__LnkSideSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LnkSideSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LnkSideSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LnkSideSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LnkSideSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LnkSideSN(struct soap *soap, const struct __ns1__LnkSideSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LnkSideSN(soap, tag ? tag : "-ns1:LnkSideSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkSideSN * SOAP_FMAC4 soap_get___ns1__LnkSideSN(struct soap *soap, struct __ns1__LnkSideSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LnkSideSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LnkZJSN(struct soap *soap, struct __ns1__LnkZJSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LnkZJSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LnkZJSN(struct soap *soap, const struct __ns1__LnkZJSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LnkZJSN(soap, &a->ns1__LnkZJSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LnkZJSN(struct soap *soap, const char *tag, int id, const struct __ns1__LnkZJSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LnkZJSN(soap, "ns1:LnkZJSN", -1, &a->ns1__LnkZJSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkZJSN * SOAP_FMAC4 soap_in___ns1__LnkZJSN(struct soap *soap, const char *tag, struct __ns1__LnkZJSN *a, const char *type)
{
	size_t soap_flag_ns1__LnkZJSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LnkZJSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LnkZJSN, sizeof(struct __ns1__LnkZJSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LnkZJSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LnkZJSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__LnkZJSN(soap, "ns1:LnkZJSN", &a->ns1__LnkZJSN, ""))
				{	soap_flag_ns1__LnkZJSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LnkZJSN * SOAP_FMAC2 soap_instantiate___ns1__LnkZJSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LnkZJSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LnkZJSN *p;
	size_t k = sizeof(struct __ns1__LnkZJSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LnkZJSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LnkZJSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LnkZJSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LnkZJSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LnkZJSN(struct soap *soap, const struct __ns1__LnkZJSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LnkZJSN(soap, tag ? tag : "-ns1:LnkZJSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LnkZJSN * SOAP_FMAC4 soap_get___ns1__LnkZJSN(struct soap *soap, struct __ns1__LnkZJSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LnkZJSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkZJSN(struct soap *soap, struct __ns1__chkZJSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkZJSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkZJSN(struct soap *soap, const struct __ns1__chkZJSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkZJSN(soap, &a->ns1__chkZJSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkZJSN(struct soap *soap, const char *tag, int id, const struct __ns1__chkZJSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkZJSN(soap, "ns1:chkZJSN", -1, &a->ns1__chkZJSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkZJSN * SOAP_FMAC4 soap_in___ns1__chkZJSN(struct soap *soap, const char *tag, struct __ns1__chkZJSN *a, const char *type)
{
	size_t soap_flag_ns1__chkZJSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkZJSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkZJSN, sizeof(struct __ns1__chkZJSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkZJSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkZJSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkZJSN(soap, "ns1:chkZJSN", &a->ns1__chkZJSN, ""))
				{	soap_flag_ns1__chkZJSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkZJSN * SOAP_FMAC2 soap_instantiate___ns1__chkZJSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkZJSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkZJSN *p;
	size_t k = sizeof(struct __ns1__chkZJSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkZJSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkZJSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkZJSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkZJSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkZJSN(struct soap *soap, const struct __ns1__chkZJSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkZJSN(soap, tag ? tag : "-ns1:chkZJSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkZJSN * SOAP_FMAC4 soap_get___ns1__chkZJSN(struct soap *soap, struct __ns1__chkZJSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkZJSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkDispensing(struct soap *soap, struct __ns1__chkDispensing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkDispensing = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkDispensing(struct soap *soap, const struct __ns1__chkDispensing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkDispensing(soap, &a->ns1__chkDispensing);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkDispensing(struct soap *soap, const char *tag, int id, const struct __ns1__chkDispensing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkDispensing(soap, "ns1:chkDispensing", -1, &a->ns1__chkDispensing, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkDispensing * SOAP_FMAC4 soap_in___ns1__chkDispensing(struct soap *soap, const char *tag, struct __ns1__chkDispensing *a, const char *type)
{
	size_t soap_flag_ns1__chkDispensing = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkDispensing *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkDispensing, sizeof(struct __ns1__chkDispensing), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkDispensing(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkDispensing && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkDispensing(soap, "ns1:chkDispensing", &a->ns1__chkDispensing, ""))
				{	soap_flag_ns1__chkDispensing--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkDispensing * SOAP_FMAC2 soap_instantiate___ns1__chkDispensing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkDispensing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkDispensing *p;
	size_t k = sizeof(struct __ns1__chkDispensing);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkDispensing);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkDispensing, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkDispensing location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkDispensing, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkDispensing(struct soap *soap, const struct __ns1__chkDispensing *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkDispensing(soap, tag ? tag : "-ns1:chkDispensing", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkDispensing * SOAP_FMAC4 soap_get___ns1__chkDispensing(struct soap *soap, struct __ns1__chkDispensing *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkDispensing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsIotTestData(struct soap *soap, struct __ns1__InsIotTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsIotTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsIotTestData(struct soap *soap, const struct __ns1__InsIotTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsIotTestData(soap, &a->ns1__InsIotTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsIotTestData(struct soap *soap, const char *tag, int id, const struct __ns1__InsIotTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsIotTestData(soap, "ns1:InsIotTestData", -1, &a->ns1__InsIotTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotTestData * SOAP_FMAC4 soap_in___ns1__InsIotTestData(struct soap *soap, const char *tag, struct __ns1__InsIotTestData *a, const char *type)
{
	size_t soap_flag_ns1__InsIotTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsIotTestData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsIotTestData, sizeof(struct __ns1__InsIotTestData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsIotTestData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsIotTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsIotTestData(soap, "ns1:InsIotTestData", &a->ns1__InsIotTestData, ""))
				{	soap_flag_ns1__InsIotTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsIotTestData * SOAP_FMAC2 soap_instantiate___ns1__InsIotTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsIotTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsIotTestData *p;
	size_t k = sizeof(struct __ns1__InsIotTestData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsIotTestData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsIotTestData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsIotTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsIotTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsIotTestData(struct soap *soap, const struct __ns1__InsIotTestData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsIotTestData(soap, tag ? tag : "-ns1:InsIotTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotTestData * SOAP_FMAC4 soap_get___ns1__InsIotTestData(struct soap *soap, struct __ns1__InsIotTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsIotTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsIotMachineRec(struct soap *soap, struct __ns1__InsIotMachineRec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsIotMachineRec = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsIotMachineRec(struct soap *soap, const struct __ns1__InsIotMachineRec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsIotMachineRec(soap, &a->ns1__InsIotMachineRec);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsIotMachineRec(struct soap *soap, const char *tag, int id, const struct __ns1__InsIotMachineRec *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsIotMachineRec(soap, "ns1:InsIotMachineRec", -1, &a->ns1__InsIotMachineRec, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotMachineRec * SOAP_FMAC4 soap_in___ns1__InsIotMachineRec(struct soap *soap, const char *tag, struct __ns1__InsIotMachineRec *a, const char *type)
{
	size_t soap_flag_ns1__InsIotMachineRec = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsIotMachineRec *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsIotMachineRec, sizeof(struct __ns1__InsIotMachineRec), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsIotMachineRec(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsIotMachineRec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsIotMachineRec(soap, "ns1:InsIotMachineRec", &a->ns1__InsIotMachineRec, ""))
				{	soap_flag_ns1__InsIotMachineRec--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsIotMachineRec * SOAP_FMAC2 soap_instantiate___ns1__InsIotMachineRec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsIotMachineRec(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsIotMachineRec *p;
	size_t k = sizeof(struct __ns1__InsIotMachineRec);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsIotMachineRec);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsIotMachineRec, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsIotMachineRec location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsIotMachineRec, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsIotMachineRec(struct soap *soap, const struct __ns1__InsIotMachineRec *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsIotMachineRec(soap, tag ? tag : "-ns1:InsIotMachineRec", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsIotMachineRec * SOAP_FMAC4 soap_get___ns1__InsIotMachineRec(struct soap *soap, struct __ns1__InsIotMachineRec *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsIotMachineRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLnkData(struct soap *soap, struct __ns1__GetLnkData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLnkData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLnkData(struct soap *soap, const struct __ns1__GetLnkData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLnkData(soap, &a->ns1__GetLnkData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLnkData(struct soap *soap, const char *tag, int id, const struct __ns1__GetLnkData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLnkData(soap, "ns1:GetLnkData", -1, &a->ns1__GetLnkData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLnkData * SOAP_FMAC4 soap_in___ns1__GetLnkData(struct soap *soap, const char *tag, struct __ns1__GetLnkData *a, const char *type)
{
	size_t soap_flag_ns1__GetLnkData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLnkData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLnkData, sizeof(struct __ns1__GetLnkData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLnkData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLnkData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLnkData(soap, "ns1:GetLnkData", &a->ns1__GetLnkData, ""))
				{	soap_flag_ns1__GetLnkData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLnkData * SOAP_FMAC2 soap_instantiate___ns1__GetLnkData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLnkData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLnkData *p;
	size_t k = sizeof(struct __ns1__GetLnkData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLnkData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLnkData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLnkData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLnkData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLnkData(struct soap *soap, const struct __ns1__GetLnkData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLnkData(soap, tag ? tag : "-ns1:GetLnkData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLnkData * SOAP_FMAC4 soap_get___ns1__GetLnkData(struct soap *soap, struct __ns1__GetLnkData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLnkData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTestValue(struct soap *soap, struct __ns1__GetTestValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTestValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTestValue(struct soap *soap, const struct __ns1__GetTestValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTestValue(soap, &a->ns1__GetTestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTestValue(struct soap *soap, const char *tag, int id, const struct __ns1__GetTestValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTestValue(soap, "ns1:GetTestValue", -1, &a->ns1__GetTestValue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValue * SOAP_FMAC4 soap_in___ns1__GetTestValue(struct soap *soap, const char *tag, struct __ns1__GetTestValue *a, const char *type)
{
	size_t soap_flag_ns1__GetTestValue = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTestValue *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTestValue, sizeof(struct __ns1__GetTestValue), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTestValue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTestValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTestValue(soap, "ns1:GetTestValue", &a->ns1__GetTestValue, ""))
				{	soap_flag_ns1__GetTestValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTestValue * SOAP_FMAC2 soap_instantiate___ns1__GetTestValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTestValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTestValue *p;
	size_t k = sizeof(struct __ns1__GetTestValue);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetTestValue);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetTestValue, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTestValue location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetTestValue, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTestValue(struct soap *soap, const struct __ns1__GetTestValue *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTestValue(soap, tag ? tag : "-ns1:GetTestValue", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValue * SOAP_FMAC4 soap_get___ns1__GetTestValue(struct soap *soap, struct __ns1__GetTestValue *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTestValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMoBase(struct soap *soap, struct __ns1__GetMoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMoBase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMoBase(struct soap *soap, const struct __ns1__GetMoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMoBase(soap, &a->ns1__GetMoBase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMoBase(struct soap *soap, const char *tag, int id, const struct __ns1__GetMoBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMoBase(soap, "ns1:GetMoBase", -1, &a->ns1__GetMoBase, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMoBase * SOAP_FMAC4 soap_in___ns1__GetMoBase(struct soap *soap, const char *tag, struct __ns1__GetMoBase *a, const char *type)
{
	size_t soap_flag_ns1__GetMoBase = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMoBase *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMoBase, sizeof(struct __ns1__GetMoBase), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMoBase(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMoBase && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMoBase(soap, "ns1:GetMoBase", &a->ns1__GetMoBase, ""))
				{	soap_flag_ns1__GetMoBase--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMoBase * SOAP_FMAC2 soap_instantiate___ns1__GetMoBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMoBase(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMoBase *p;
	size_t k = sizeof(struct __ns1__GetMoBase);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetMoBase);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetMoBase, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMoBase location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetMoBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMoBase(struct soap *soap, const struct __ns1__GetMoBase *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMoBase(soap, tag ? tag : "-ns1:GetMoBase", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMoBase * SOAP_FMAC4 soap_get___ns1__GetMoBase(struct soap *soap, struct __ns1__GetMoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdSnRecInfo(struct soap *soap, struct __ns1__UpdSnRecInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdSnRecInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdSnRecInfo(struct soap *soap, const struct __ns1__UpdSnRecInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdSnRecInfo(soap, &a->ns1__UpdSnRecInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdSnRecInfo(struct soap *soap, const char *tag, int id, const struct __ns1__UpdSnRecInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdSnRecInfo(soap, "ns1:UpdSnRecInfo", -1, &a->ns1__UpdSnRecInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdSnRecInfo * SOAP_FMAC4 soap_in___ns1__UpdSnRecInfo(struct soap *soap, const char *tag, struct __ns1__UpdSnRecInfo *a, const char *type)
{
	size_t soap_flag_ns1__UpdSnRecInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdSnRecInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdSnRecInfo, sizeof(struct __ns1__UpdSnRecInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdSnRecInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdSnRecInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdSnRecInfo(soap, "ns1:UpdSnRecInfo", &a->ns1__UpdSnRecInfo, ""))
				{	soap_flag_ns1__UpdSnRecInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdSnRecInfo * SOAP_FMAC2 soap_instantiate___ns1__UpdSnRecInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdSnRecInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdSnRecInfo *p;
	size_t k = sizeof(struct __ns1__UpdSnRecInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdSnRecInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdSnRecInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdSnRecInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UpdSnRecInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdSnRecInfo(struct soap *soap, const struct __ns1__UpdSnRecInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdSnRecInfo(soap, tag ? tag : "-ns1:UpdSnRecInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdSnRecInfo * SOAP_FMAC4 soap_get___ns1__UpdSnRecInfo(struct soap *soap, struct __ns1__UpdSnRecInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdSnRecInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsBoxInfo(struct soap *soap, struct __ns1__InsBoxInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsBoxInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsBoxInfo(struct soap *soap, const struct __ns1__InsBoxInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsBoxInfo(soap, &a->ns1__InsBoxInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsBoxInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InsBoxInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsBoxInfo(soap, "ns1:InsBoxInfo", -1, &a->ns1__InsBoxInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxInfo * SOAP_FMAC4 soap_in___ns1__InsBoxInfo(struct soap *soap, const char *tag, struct __ns1__InsBoxInfo *a, const char *type)
{
	size_t soap_flag_ns1__InsBoxInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsBoxInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsBoxInfo, sizeof(struct __ns1__InsBoxInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsBoxInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsBoxInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsBoxInfo(soap, "ns1:InsBoxInfo", &a->ns1__InsBoxInfo, ""))
				{	soap_flag_ns1__InsBoxInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsBoxInfo * SOAP_FMAC2 soap_instantiate___ns1__InsBoxInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsBoxInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsBoxInfo *p;
	size_t k = sizeof(struct __ns1__InsBoxInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsBoxInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsBoxInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsBoxInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsBoxInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsBoxInfo(struct soap *soap, const struct __ns1__InsBoxInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsBoxInfo(soap, tag ? tag : "-ns1:InsBoxInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxInfo * SOAP_FMAC4 soap_get___ns1__InsBoxInfo(struct soap *soap, struct __ns1__InsBoxInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsBoxInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsLnkOutSN(struct soap *soap, struct __ns1__InsLnkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsLnkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsLnkOutSN(struct soap *soap, const struct __ns1__InsLnkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsLnkOutSN(soap, &a->ns1__InsLnkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsLnkOutSN(struct soap *soap, const char *tag, int id, const struct __ns1__InsLnkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsLnkOutSN(soap, "ns1:InsLnkOutSN", -1, &a->ns1__InsLnkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLnkOutSN * SOAP_FMAC4 soap_in___ns1__InsLnkOutSN(struct soap *soap, const char *tag, struct __ns1__InsLnkOutSN *a, const char *type)
{
	size_t soap_flag_ns1__InsLnkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsLnkOutSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsLnkOutSN, sizeof(struct __ns1__InsLnkOutSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsLnkOutSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsLnkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsLnkOutSN(soap, "ns1:InsLnkOutSN", &a->ns1__InsLnkOutSN, ""))
				{	soap_flag_ns1__InsLnkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsLnkOutSN * SOAP_FMAC2 soap_instantiate___ns1__InsLnkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsLnkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsLnkOutSN *p;
	size_t k = sizeof(struct __ns1__InsLnkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsLnkOutSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsLnkOutSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsLnkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsLnkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsLnkOutSN(struct soap *soap, const struct __ns1__InsLnkOutSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsLnkOutSN(soap, tag ? tag : "-ns1:InsLnkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLnkOutSN * SOAP_FMAC4 soap_get___ns1__InsLnkOutSN(struct soap *soap, struct __ns1__InsLnkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsLnkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsSNStationEmp(struct soap *soap, struct __ns1__InsSNStationEmp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsSNStationEmp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsSNStationEmp(struct soap *soap, const struct __ns1__InsSNStationEmp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsSNStationEmp(soap, &a->ns1__InsSNStationEmp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsSNStationEmp(struct soap *soap, const char *tag, int id, const struct __ns1__InsSNStationEmp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsSNStationEmp(soap, "ns1:InsSNStationEmp", -1, &a->ns1__InsSNStationEmp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNStationEmp * SOAP_FMAC4 soap_in___ns1__InsSNStationEmp(struct soap *soap, const char *tag, struct __ns1__InsSNStationEmp *a, const char *type)
{
	size_t soap_flag_ns1__InsSNStationEmp = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsSNStationEmp *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsSNStationEmp, sizeof(struct __ns1__InsSNStationEmp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsSNStationEmp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsSNStationEmp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsSNStationEmp(soap, "ns1:InsSNStationEmp", &a->ns1__InsSNStationEmp, ""))
				{	soap_flag_ns1__InsSNStationEmp--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsSNStationEmp * SOAP_FMAC2 soap_instantiate___ns1__InsSNStationEmp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsSNStationEmp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsSNStationEmp *p;
	size_t k = sizeof(struct __ns1__InsSNStationEmp);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsSNStationEmp);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsSNStationEmp, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsSNStationEmp location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsSNStationEmp, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsSNStationEmp(struct soap *soap, const struct __ns1__InsSNStationEmp *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsSNStationEmp(soap, tag ? tag : "-ns1:InsSNStationEmp", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNStationEmp * SOAP_FMAC4 soap_get___ns1__InsSNStationEmp(struct soap *soap, struct __ns1__InsSNStationEmp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsSNStationEmp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CancelBoxLnk(struct soap *soap, struct __ns1__CancelBoxLnk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelBoxLnk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CancelBoxLnk(struct soap *soap, const struct __ns1__CancelBoxLnk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelBoxLnk(soap, &a->ns1__CancelBoxLnk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CancelBoxLnk(struct soap *soap, const char *tag, int id, const struct __ns1__CancelBoxLnk *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelBoxLnk(soap, "ns1:CancelBoxLnk", -1, &a->ns1__CancelBoxLnk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelBoxLnk * SOAP_FMAC4 soap_in___ns1__CancelBoxLnk(struct soap *soap, const char *tag, struct __ns1__CancelBoxLnk *a, const char *type)
{
	size_t soap_flag_ns1__CancelBoxLnk = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CancelBoxLnk *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CancelBoxLnk, sizeof(struct __ns1__CancelBoxLnk), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CancelBoxLnk(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelBoxLnk && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CancelBoxLnk(soap, "ns1:CancelBoxLnk", &a->ns1__CancelBoxLnk, ""))
				{	soap_flag_ns1__CancelBoxLnk--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CancelBoxLnk * SOAP_FMAC2 soap_instantiate___ns1__CancelBoxLnk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CancelBoxLnk(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CancelBoxLnk *p;
	size_t k = sizeof(struct __ns1__CancelBoxLnk);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CancelBoxLnk);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CancelBoxLnk, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CancelBoxLnk location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CancelBoxLnk, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CancelBoxLnk(struct soap *soap, const struct __ns1__CancelBoxLnk *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CancelBoxLnk(soap, tag ? tag : "-ns1:CancelBoxLnk", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CancelBoxLnk * SOAP_FMAC4 soap_get___ns1__CancelBoxLnk(struct soap *soap, struct __ns1__CancelBoxLnk *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CancelBoxLnk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OutStationbyBox(struct soap *soap, struct __ns1__OutStationbyBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OutStationbyBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OutStationbyBox(struct soap *soap, const struct __ns1__OutStationbyBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OutStationbyBox(soap, &a->ns1__OutStationbyBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OutStationbyBox(struct soap *soap, const char *tag, int id, const struct __ns1__OutStationbyBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OutStationbyBox(soap, "ns1:OutStationbyBox", -1, &a->ns1__OutStationbyBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutStationbyBox * SOAP_FMAC4 soap_in___ns1__OutStationbyBox(struct soap *soap, const char *tag, struct __ns1__OutStationbyBox *a, const char *type)
{
	size_t soap_flag_ns1__OutStationbyBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OutStationbyBox *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OutStationbyBox, sizeof(struct __ns1__OutStationbyBox), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OutStationbyBox(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OutStationbyBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OutStationbyBox(soap, "ns1:OutStationbyBox", &a->ns1__OutStationbyBox, ""))
				{	soap_flag_ns1__OutStationbyBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OutStationbyBox * SOAP_FMAC2 soap_instantiate___ns1__OutStationbyBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OutStationbyBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OutStationbyBox *p;
	size_t k = sizeof(struct __ns1__OutStationbyBox);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OutStationbyBox);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OutStationbyBox, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OutStationbyBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OutStationbyBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OutStationbyBox(struct soap *soap, const struct __ns1__OutStationbyBox *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OutStationbyBox(soap, tag ? tag : "-ns1:OutStationbyBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OutStationbyBox * SOAP_FMAC4 soap_get___ns1__OutStationbyBox(struct soap *soap, struct __ns1__OutStationbyBox *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OutStationbyBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InStationbyBox(struct soap *soap, struct __ns1__InStationbyBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InStationbyBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InStationbyBox(struct soap *soap, const struct __ns1__InStationbyBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InStationbyBox(soap, &a->ns1__InStationbyBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InStationbyBox(struct soap *soap, const char *tag, int id, const struct __ns1__InStationbyBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InStationbyBox(soap, "ns1:InStationbyBox", -1, &a->ns1__InStationbyBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InStationbyBox * SOAP_FMAC4 soap_in___ns1__InStationbyBox(struct soap *soap, const char *tag, struct __ns1__InStationbyBox *a, const char *type)
{
	size_t soap_flag_ns1__InStationbyBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InStationbyBox *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InStationbyBox, sizeof(struct __ns1__InStationbyBox), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InStationbyBox(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InStationbyBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InStationbyBox(soap, "ns1:InStationbyBox", &a->ns1__InStationbyBox, ""))
				{	soap_flag_ns1__InStationbyBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InStationbyBox * SOAP_FMAC2 soap_instantiate___ns1__InStationbyBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InStationbyBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InStationbyBox *p;
	size_t k = sizeof(struct __ns1__InStationbyBox);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InStationbyBox);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InStationbyBox, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InStationbyBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InStationbyBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InStationbyBox(struct soap *soap, const struct __ns1__InStationbyBox *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InStationbyBox(soap, tag ? tag : "-ns1:InStationbyBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InStationbyBox * SOAP_FMAC4 soap_get___ns1__InStationbyBox(struct soap *soap, struct __ns1__InStationbyBox *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InStationbyBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndSNtoBox(struct soap *soap, struct __ns1__EndSNtoBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndSNtoBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndSNtoBox(struct soap *soap, const struct __ns1__EndSNtoBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndSNtoBox(soap, &a->ns1__EndSNtoBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndSNtoBox(struct soap *soap, const char *tag, int id, const struct __ns1__EndSNtoBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndSNtoBox(soap, "ns1:EndSNtoBox", -1, &a->ns1__EndSNtoBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndSNtoBox * SOAP_FMAC4 soap_in___ns1__EndSNtoBox(struct soap *soap, const char *tag, struct __ns1__EndSNtoBox *a, const char *type)
{
	size_t soap_flag_ns1__EndSNtoBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndSNtoBox *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndSNtoBox, sizeof(struct __ns1__EndSNtoBox), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndSNtoBox(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndSNtoBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EndSNtoBox(soap, "ns1:EndSNtoBox", &a->ns1__EndSNtoBox, ""))
				{	soap_flag_ns1__EndSNtoBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EndSNtoBox * SOAP_FMAC2 soap_instantiate___ns1__EndSNtoBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndSNtoBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EndSNtoBox *p;
	size_t k = sizeof(struct __ns1__EndSNtoBox);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__EndSNtoBox);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__EndSNtoBox, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EndSNtoBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__EndSNtoBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndSNtoBox(struct soap *soap, const struct __ns1__EndSNtoBox *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EndSNtoBox(soap, tag ? tag : "-ns1:EndSNtoBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndSNtoBox * SOAP_FMAC4 soap_get___ns1__EndSNtoBox(struct soap *soap, struct __ns1__EndSNtoBox *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndSNtoBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InSNtoBox(struct soap *soap, struct __ns1__InSNtoBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InSNtoBox = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InSNtoBox(struct soap *soap, const struct __ns1__InSNtoBox *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InSNtoBox(soap, &a->ns1__InSNtoBox);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InSNtoBox(struct soap *soap, const char *tag, int id, const struct __ns1__InSNtoBox *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InSNtoBox(soap, "ns1:InSNtoBox", -1, &a->ns1__InSNtoBox, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSNtoBox * SOAP_FMAC4 soap_in___ns1__InSNtoBox(struct soap *soap, const char *tag, struct __ns1__InSNtoBox *a, const char *type)
{
	size_t soap_flag_ns1__InSNtoBox = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InSNtoBox *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InSNtoBox, sizeof(struct __ns1__InSNtoBox), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InSNtoBox(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InSNtoBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InSNtoBox(soap, "ns1:InSNtoBox", &a->ns1__InSNtoBox, ""))
				{	soap_flag_ns1__InSNtoBox--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InSNtoBox * SOAP_FMAC2 soap_instantiate___ns1__InSNtoBox(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InSNtoBox(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InSNtoBox *p;
	size_t k = sizeof(struct __ns1__InSNtoBox);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InSNtoBox);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InSNtoBox, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InSNtoBox location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InSNtoBox, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InSNtoBox(struct soap *soap, const struct __ns1__InSNtoBox *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InSNtoBox(soap, tag ? tag : "-ns1:InSNtoBox", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSNtoBox * SOAP_FMAC4 soap_get___ns1__InSNtoBox(struct soap *soap, struct __ns1__InSNtoBox *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InSNtoBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkBoxNo(struct soap *soap, struct __ns1__chkBoxNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkBoxNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkBoxNo(struct soap *soap, const struct __ns1__chkBoxNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkBoxNo(soap, &a->ns1__chkBoxNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkBoxNo(struct soap *soap, const char *tag, int id, const struct __ns1__chkBoxNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkBoxNo(soap, "ns1:chkBoxNo", -1, &a->ns1__chkBoxNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkBoxNo * SOAP_FMAC4 soap_in___ns1__chkBoxNo(struct soap *soap, const char *tag, struct __ns1__chkBoxNo *a, const char *type)
{
	size_t soap_flag_ns1__chkBoxNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkBoxNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkBoxNo, sizeof(struct __ns1__chkBoxNo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkBoxNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkBoxNo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkBoxNo(soap, "ns1:chkBoxNo", &a->ns1__chkBoxNo, ""))
				{	soap_flag_ns1__chkBoxNo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkBoxNo * SOAP_FMAC2 soap_instantiate___ns1__chkBoxNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkBoxNo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkBoxNo *p;
	size_t k = sizeof(struct __ns1__chkBoxNo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkBoxNo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkBoxNo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkBoxNo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkBoxNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkBoxNo(struct soap *soap, const struct __ns1__chkBoxNo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkBoxNo(soap, tag ? tag : "-ns1:chkBoxNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkBoxNo * SOAP_FMAC4 soap_get___ns1__chkBoxNo(struct soap *soap, struct __ns1__chkBoxNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkBoxNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsBoxNOTime(struct soap *soap, struct __ns1__InsBoxNOTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsBoxNOTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsBoxNOTime(struct soap *soap, const struct __ns1__InsBoxNOTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsBoxNOTime(soap, &a->ns1__InsBoxNOTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsBoxNOTime(struct soap *soap, const char *tag, int id, const struct __ns1__InsBoxNOTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsBoxNOTime(soap, "ns1:InsBoxNOTime", -1, &a->ns1__InsBoxNOTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxNOTime * SOAP_FMAC4 soap_in___ns1__InsBoxNOTime(struct soap *soap, const char *tag, struct __ns1__InsBoxNOTime *a, const char *type)
{
	size_t soap_flag_ns1__InsBoxNOTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsBoxNOTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsBoxNOTime, sizeof(struct __ns1__InsBoxNOTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsBoxNOTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsBoxNOTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsBoxNOTime(soap, "ns1:InsBoxNOTime", &a->ns1__InsBoxNOTime, ""))
				{	soap_flag_ns1__InsBoxNOTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsBoxNOTime * SOAP_FMAC2 soap_instantiate___ns1__InsBoxNOTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsBoxNOTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsBoxNOTime *p;
	size_t k = sizeof(struct __ns1__InsBoxNOTime);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsBoxNOTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsBoxNOTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsBoxNOTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsBoxNOTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsBoxNOTime(struct soap *soap, const struct __ns1__InsBoxNOTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsBoxNOTime(soap, tag ? tag : "-ns1:InsBoxNOTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsBoxNOTime * SOAP_FMAC4 soap_get___ns1__InsBoxNOTime(struct soap *soap, struct __ns1__InsBoxNOTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsBoxNOTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLinkZJCount(struct soap *soap, struct __ns1__GetLinkZJCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLinkZJCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLinkZJCount(struct soap *soap, const struct __ns1__GetLinkZJCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLinkZJCount(soap, &a->ns1__GetLinkZJCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLinkZJCount(struct soap *soap, const char *tag, int id, const struct __ns1__GetLinkZJCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLinkZJCount(soap, "ns1:GetLinkZJCount", -1, &a->ns1__GetLinkZJCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkZJCount * SOAP_FMAC4 soap_in___ns1__GetLinkZJCount(struct soap *soap, const char *tag, struct __ns1__GetLinkZJCount *a, const char *type)
{
	size_t soap_flag_ns1__GetLinkZJCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLinkZJCount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLinkZJCount, sizeof(struct __ns1__GetLinkZJCount), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLinkZJCount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLinkZJCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLinkZJCount(soap, "ns1:GetLinkZJCount", &a->ns1__GetLinkZJCount, ""))
				{	soap_flag_ns1__GetLinkZJCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLinkZJCount * SOAP_FMAC2 soap_instantiate___ns1__GetLinkZJCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLinkZJCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLinkZJCount *p;
	size_t k = sizeof(struct __ns1__GetLinkZJCount);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLinkZJCount);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLinkZJCount, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLinkZJCount location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLinkZJCount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLinkZJCount(struct soap *soap, const struct __ns1__GetLinkZJCount *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLinkZJCount(soap, tag ? tag : "-ns1:GetLinkZJCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkZJCount * SOAP_FMAC4 soap_get___ns1__GetLinkZJCount(struct soap *soap, struct __ns1__GetLinkZJCount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLinkZJCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsLinkSN(struct soap *soap, struct __ns1__InsLinkSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsLinkSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsLinkSN(struct soap *soap, const struct __ns1__InsLinkSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsLinkSN(soap, &a->ns1__InsLinkSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsLinkSN(struct soap *soap, const char *tag, int id, const struct __ns1__InsLinkSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsLinkSN(soap, "ns1:InsLinkSN", -1, &a->ns1__InsLinkSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLinkSN * SOAP_FMAC4 soap_in___ns1__InsLinkSN(struct soap *soap, const char *tag, struct __ns1__InsLinkSN *a, const char *type)
{
	size_t soap_flag_ns1__InsLinkSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsLinkSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsLinkSN, sizeof(struct __ns1__InsLinkSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsLinkSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsLinkSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsLinkSN(soap, "ns1:InsLinkSN", &a->ns1__InsLinkSN, ""))
				{	soap_flag_ns1__InsLinkSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsLinkSN * SOAP_FMAC2 soap_instantiate___ns1__InsLinkSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsLinkSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsLinkSN *p;
	size_t k = sizeof(struct __ns1__InsLinkSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsLinkSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsLinkSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsLinkSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsLinkSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsLinkSN(struct soap *soap, const struct __ns1__InsLinkSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsLinkSN(soap, tag ? tag : "-ns1:InsLinkSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsLinkSN * SOAP_FMAC4 soap_get___ns1__InsLinkSN(struct soap *soap, struct __ns1__InsLinkSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsLinkSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doLinkOutSN(struct soap *soap, struct __ns1__doLinkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doLinkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doLinkOutSN(struct soap *soap, const struct __ns1__doLinkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doLinkOutSN(soap, &a->ns1__doLinkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doLinkOutSN(struct soap *soap, const char *tag, int id, const struct __ns1__doLinkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doLinkOutSN(soap, "ns1:doLinkOutSN", -1, &a->ns1__doLinkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLinkOutSN * SOAP_FMAC4 soap_in___ns1__doLinkOutSN(struct soap *soap, const char *tag, struct __ns1__doLinkOutSN *a, const char *type)
{
	size_t soap_flag_ns1__doLinkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doLinkOutSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doLinkOutSN, sizeof(struct __ns1__doLinkOutSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doLinkOutSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doLinkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doLinkOutSN(soap, "ns1:doLinkOutSN", &a->ns1__doLinkOutSN, ""))
				{	soap_flag_ns1__doLinkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doLinkOutSN * SOAP_FMAC2 soap_instantiate___ns1__doLinkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doLinkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doLinkOutSN *p;
	size_t k = sizeof(struct __ns1__doLinkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doLinkOutSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doLinkOutSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doLinkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doLinkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doLinkOutSN(struct soap *soap, const struct __ns1__doLinkOutSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doLinkOutSN(soap, tag ? tag : "-ns1:doLinkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLinkOutSN * SOAP_FMAC4 soap_get___ns1__doLinkOutSN(struct soap *soap, struct __ns1__doLinkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doLinkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkLinkOutSN(struct soap *soap, struct __ns1__ChkLinkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkLinkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkLinkOutSN(struct soap *soap, const struct __ns1__ChkLinkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkLinkOutSN(soap, &a->ns1__ChkLinkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkLinkOutSN(struct soap *soap, const char *tag, int id, const struct __ns1__ChkLinkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkLinkOutSN(soap, "ns1:ChkLinkOutSN", -1, &a->ns1__ChkLinkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkLinkOutSN * SOAP_FMAC4 soap_in___ns1__ChkLinkOutSN(struct soap *soap, const char *tag, struct __ns1__ChkLinkOutSN *a, const char *type)
{
	size_t soap_flag_ns1__ChkLinkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkLinkOutSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkLinkOutSN, sizeof(struct __ns1__ChkLinkOutSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkLinkOutSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkLinkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkLinkOutSN(soap, "ns1:ChkLinkOutSN", &a->ns1__ChkLinkOutSN, ""))
				{	soap_flag_ns1__ChkLinkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkLinkOutSN * SOAP_FMAC2 soap_instantiate___ns1__ChkLinkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkLinkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkLinkOutSN *p;
	size_t k = sizeof(struct __ns1__ChkLinkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkLinkOutSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkLinkOutSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkLinkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkLinkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkLinkOutSN(struct soap *soap, const struct __ns1__ChkLinkOutSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkLinkOutSN(soap, tag ? tag : "-ns1:ChkLinkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkLinkOutSN * SOAP_FMAC4 soap_get___ns1__ChkLinkOutSN(struct soap *soap, struct __ns1__ChkLinkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkLinkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkOutSN(struct soap *soap, struct __ns1__chkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkOutSN(struct soap *soap, const struct __ns1__chkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkOutSN(soap, &a->ns1__chkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkOutSN(struct soap *soap, const char *tag, int id, const struct __ns1__chkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkOutSN(soap, "ns1:chkOutSN", -1, &a->ns1__chkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkOutSN * SOAP_FMAC4 soap_in___ns1__chkOutSN(struct soap *soap, const char *tag, struct __ns1__chkOutSN *a, const char *type)
{
	size_t soap_flag_ns1__chkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkOutSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkOutSN, sizeof(struct __ns1__chkOutSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkOutSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkOutSN(soap, "ns1:chkOutSN", &a->ns1__chkOutSN, ""))
				{	soap_flag_ns1__chkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkOutSN * SOAP_FMAC2 soap_instantiate___ns1__chkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkOutSN *p;
	size_t k = sizeof(struct __ns1__chkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkOutSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkOutSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkOutSN(struct soap *soap, const struct __ns1__chkOutSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkOutSN(soap, tag ? tag : "-ns1:chkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkOutSN * SOAP_FMAC4 soap_get___ns1__chkOutSN(struct soap *soap, struct __ns1__chkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLintOutQty(struct soap *soap, struct __ns1__GetLintOutQty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLintOutQty = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLintOutQty(struct soap *soap, const struct __ns1__GetLintOutQty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLintOutQty(soap, &a->ns1__GetLintOutQty);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLintOutQty(struct soap *soap, const char *tag, int id, const struct __ns1__GetLintOutQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLintOutQty(soap, "ns1:GetLintOutQty", -1, &a->ns1__GetLintOutQty, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLintOutQty * SOAP_FMAC4 soap_in___ns1__GetLintOutQty(struct soap *soap, const char *tag, struct __ns1__GetLintOutQty *a, const char *type)
{
	size_t soap_flag_ns1__GetLintOutQty = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLintOutQty *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLintOutQty, sizeof(struct __ns1__GetLintOutQty), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLintOutQty(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLintOutQty && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLintOutQty(soap, "ns1:GetLintOutQty", &a->ns1__GetLintOutQty, ""))
				{	soap_flag_ns1__GetLintOutQty--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLintOutQty * SOAP_FMAC2 soap_instantiate___ns1__GetLintOutQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLintOutQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLintOutQty *p;
	size_t k = sizeof(struct __ns1__GetLintOutQty);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLintOutQty);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLintOutQty, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLintOutQty location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLintOutQty, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLintOutQty(struct soap *soap, const struct __ns1__GetLintOutQty *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLintOutQty(soap, tag ? tag : "-ns1:GetLintOutQty", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLintOutQty * SOAP_FMAC4 soap_get___ns1__GetLintOutQty(struct soap *soap, struct __ns1__GetLintOutQty *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLintOutQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SNLinkZJ(struct soap *soap, struct __ns1__SNLinkZJ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SNLinkZJ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SNLinkZJ(struct soap *soap, const struct __ns1__SNLinkZJ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SNLinkZJ(soap, &a->ns1__SNLinkZJ);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SNLinkZJ(struct soap *soap, const char *tag, int id, const struct __ns1__SNLinkZJ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SNLinkZJ(soap, "ns1:SNLinkZJ", -1, &a->ns1__SNLinkZJ, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkZJ * SOAP_FMAC4 soap_in___ns1__SNLinkZJ(struct soap *soap, const char *tag, struct __ns1__SNLinkZJ *a, const char *type)
{
	size_t soap_flag_ns1__SNLinkZJ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SNLinkZJ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SNLinkZJ, sizeof(struct __ns1__SNLinkZJ), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SNLinkZJ(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SNLinkZJ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SNLinkZJ(soap, "ns1:SNLinkZJ", &a->ns1__SNLinkZJ, ""))
				{	soap_flag_ns1__SNLinkZJ--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SNLinkZJ * SOAP_FMAC2 soap_instantiate___ns1__SNLinkZJ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SNLinkZJ(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SNLinkZJ *p;
	size_t k = sizeof(struct __ns1__SNLinkZJ);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SNLinkZJ);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SNLinkZJ, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SNLinkZJ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SNLinkZJ, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SNLinkZJ(struct soap *soap, const struct __ns1__SNLinkZJ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SNLinkZJ(soap, tag ? tag : "-ns1:SNLinkZJ", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkZJ * SOAP_FMAC4 soap_get___ns1__SNLinkZJ(struct soap *soap, struct __ns1__SNLinkZJ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SNLinkZJ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsZJTestData(struct soap *soap, struct __ns1__InsZJTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsZJTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsZJTestData(struct soap *soap, const struct __ns1__InsZJTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsZJTestData(soap, &a->ns1__InsZJTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsZJTestData(struct soap *soap, const char *tag, int id, const struct __ns1__InsZJTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsZJTestData(soap, "ns1:InsZJTestData", -1, &a->ns1__InsZJTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZJTestData * SOAP_FMAC4 soap_in___ns1__InsZJTestData(struct soap *soap, const char *tag, struct __ns1__InsZJTestData *a, const char *type)
{
	size_t soap_flag_ns1__InsZJTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsZJTestData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsZJTestData, sizeof(struct __ns1__InsZJTestData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsZJTestData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsZJTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsZJTestData(soap, "ns1:InsZJTestData", &a->ns1__InsZJTestData, ""))
				{	soap_flag_ns1__InsZJTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsZJTestData * SOAP_FMAC2 soap_instantiate___ns1__InsZJTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsZJTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsZJTestData *p;
	size_t k = sizeof(struct __ns1__InsZJTestData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsZJTestData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsZJTestData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsZJTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsZJTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsZJTestData(struct soap *soap, const struct __ns1__InsZJTestData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsZJTestData(soap, tag ? tag : "-ns1:InsZJTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZJTestData * SOAP_FMAC4 soap_get___ns1__InsZJTestData(struct soap *soap, struct __ns1__InsZJTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsZJTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doPmcSNLink(struct soap *soap, struct __ns1__doPmcSNLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doPmcSNLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doPmcSNLink(struct soap *soap, const struct __ns1__doPmcSNLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doPmcSNLink(soap, &a->ns1__doPmcSNLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doPmcSNLink(struct soap *soap, const char *tag, int id, const struct __ns1__doPmcSNLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doPmcSNLink(soap, "ns1:doPmcSNLink", -1, &a->ns1__doPmcSNLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doPmcSNLink * SOAP_FMAC4 soap_in___ns1__doPmcSNLink(struct soap *soap, const char *tag, struct __ns1__doPmcSNLink *a, const char *type)
{
	size_t soap_flag_ns1__doPmcSNLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doPmcSNLink *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doPmcSNLink, sizeof(struct __ns1__doPmcSNLink), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doPmcSNLink(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doPmcSNLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doPmcSNLink(soap, "ns1:doPmcSNLink", &a->ns1__doPmcSNLink, ""))
				{	soap_flag_ns1__doPmcSNLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doPmcSNLink * SOAP_FMAC2 soap_instantiate___ns1__doPmcSNLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doPmcSNLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doPmcSNLink *p;
	size_t k = sizeof(struct __ns1__doPmcSNLink);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doPmcSNLink);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doPmcSNLink, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doPmcSNLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doPmcSNLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doPmcSNLink(struct soap *soap, const struct __ns1__doPmcSNLink *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doPmcSNLink(soap, tag ? tag : "-ns1:doPmcSNLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doPmcSNLink * SOAP_FMAC4 soap_get___ns1__doPmcSNLink(struct soap *soap, struct __ns1__doPmcSNLink *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doPmcSNLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPmcSNPart(struct soap *soap, struct __ns1__GetPmcSNPart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPmcSNPart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPmcSNPart(struct soap *soap, const struct __ns1__GetPmcSNPart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPmcSNPart(soap, &a->ns1__GetPmcSNPart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPmcSNPart(struct soap *soap, const char *tag, int id, const struct __ns1__GetPmcSNPart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPmcSNPart(soap, "ns1:GetPmcSNPart", -1, &a->ns1__GetPmcSNPart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPmcSNPart * SOAP_FMAC4 soap_in___ns1__GetPmcSNPart(struct soap *soap, const char *tag, struct __ns1__GetPmcSNPart *a, const char *type)
{
	size_t soap_flag_ns1__GetPmcSNPart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPmcSNPart *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPmcSNPart, sizeof(struct __ns1__GetPmcSNPart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPmcSNPart(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPmcSNPart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPmcSNPart(soap, "ns1:GetPmcSNPart", &a->ns1__GetPmcSNPart, ""))
				{	soap_flag_ns1__GetPmcSNPart--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPmcSNPart * SOAP_FMAC2 soap_instantiate___ns1__GetPmcSNPart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPmcSNPart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPmcSNPart *p;
	size_t k = sizeof(struct __ns1__GetPmcSNPart);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetPmcSNPart);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetPmcSNPart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPmcSNPart location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetPmcSNPart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPmcSNPart(struct soap *soap, const struct __ns1__GetPmcSNPart *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPmcSNPart(soap, tag ? tag : "-ns1:GetPmcSNPart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPmcSNPart * SOAP_FMAC4 soap_get___ns1__GetPmcSNPart(struct soap *soap, struct __ns1__GetPmcSNPart *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPmcSNPart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPmcPartAssyList(struct soap *soap, struct __ns1__getPmcPartAssyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPmcPartAssyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPmcPartAssyList(struct soap *soap, const struct __ns1__getPmcPartAssyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPmcPartAssyList(soap, &a->ns1__getPmcPartAssyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPmcPartAssyList(struct soap *soap, const char *tag, int id, const struct __ns1__getPmcPartAssyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPmcPartAssyList(soap, "ns1:getPmcPartAssyList", -1, &a->ns1__getPmcPartAssyList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcPartAssyList * SOAP_FMAC4 soap_in___ns1__getPmcPartAssyList(struct soap *soap, const char *tag, struct __ns1__getPmcPartAssyList *a, const char *type)
{
	size_t soap_flag_ns1__getPmcPartAssyList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPmcPartAssyList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPmcPartAssyList, sizeof(struct __ns1__getPmcPartAssyList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPmcPartAssyList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPmcPartAssyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPmcPartAssyList(soap, "ns1:getPmcPartAssyList", &a->ns1__getPmcPartAssyList, ""))
				{	soap_flag_ns1__getPmcPartAssyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPmcPartAssyList * SOAP_FMAC2 soap_instantiate___ns1__getPmcPartAssyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPmcPartAssyList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPmcPartAssyList *p;
	size_t k = sizeof(struct __ns1__getPmcPartAssyList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPmcPartAssyList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPmcPartAssyList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPmcPartAssyList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPmcPartAssyList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPmcPartAssyList(struct soap *soap, const struct __ns1__getPmcPartAssyList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPmcPartAssyList(soap, tag ? tag : "-ns1:getPmcPartAssyList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcPartAssyList * SOAP_FMAC4 soap_get___ns1__getPmcPartAssyList(struct soap *soap, struct __ns1__getPmcPartAssyList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPmcPartAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPmcAssyList(struct soap *soap, struct __ns1__getPmcAssyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPmcAssyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPmcAssyList(struct soap *soap, const struct __ns1__getPmcAssyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPmcAssyList(soap, &a->ns1__getPmcAssyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPmcAssyList(struct soap *soap, const char *tag, int id, const struct __ns1__getPmcAssyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPmcAssyList(soap, "ns1:getPmcAssyList", -1, &a->ns1__getPmcAssyList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcAssyList * SOAP_FMAC4 soap_in___ns1__getPmcAssyList(struct soap *soap, const char *tag, struct __ns1__getPmcAssyList *a, const char *type)
{
	size_t soap_flag_ns1__getPmcAssyList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPmcAssyList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPmcAssyList, sizeof(struct __ns1__getPmcAssyList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPmcAssyList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPmcAssyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPmcAssyList(soap, "ns1:getPmcAssyList", &a->ns1__getPmcAssyList, ""))
				{	soap_flag_ns1__getPmcAssyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPmcAssyList * SOAP_FMAC2 soap_instantiate___ns1__getPmcAssyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPmcAssyList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPmcAssyList *p;
	size_t k = sizeof(struct __ns1__getPmcAssyList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPmcAssyList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPmcAssyList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPmcAssyList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPmcAssyList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPmcAssyList(struct soap *soap, const struct __ns1__getPmcAssyList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPmcAssyList(soap, tag ? tag : "-ns1:getPmcAssyList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPmcAssyList * SOAP_FMAC4 soap_get___ns1__getPmcAssyList(struct soap *soap, struct __ns1__getPmcAssyList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPmcAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doAssy(struct soap *soap, struct __ns1__doAssy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doAssy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doAssy(struct soap *soap, const struct __ns1__doAssy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doAssy(soap, &a->ns1__doAssy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doAssy(struct soap *soap, const char *tag, int id, const struct __ns1__doAssy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doAssy(soap, "ns1:doAssy", -1, &a->ns1__doAssy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doAssy * SOAP_FMAC4 soap_in___ns1__doAssy(struct soap *soap, const char *tag, struct __ns1__doAssy *a, const char *type)
{
	size_t soap_flag_ns1__doAssy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doAssy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doAssy, sizeof(struct __ns1__doAssy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doAssy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doAssy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doAssy(soap, "ns1:doAssy", &a->ns1__doAssy, ""))
				{	soap_flag_ns1__doAssy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doAssy * SOAP_FMAC2 soap_instantiate___ns1__doAssy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doAssy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doAssy *p;
	size_t k = sizeof(struct __ns1__doAssy);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doAssy);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doAssy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doAssy location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doAssy, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doAssy(struct soap *soap, const struct __ns1__doAssy *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doAssy(soap, tag ? tag : "-ns1:doAssy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doAssy * SOAP_FMAC4 soap_get___ns1__doAssy(struct soap *soap, struct __ns1__doAssy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doAssy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkAssySN(struct soap *soap, struct __ns1__chkAssySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkAssySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkAssySN(struct soap *soap, const struct __ns1__chkAssySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkAssySN(soap, &a->ns1__chkAssySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkAssySN(struct soap *soap, const char *tag, int id, const struct __ns1__chkAssySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkAssySN(soap, "ns1:chkAssySN", -1, &a->ns1__chkAssySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkAssySN * SOAP_FMAC4 soap_in___ns1__chkAssySN(struct soap *soap, const char *tag, struct __ns1__chkAssySN *a, const char *type)
{
	size_t soap_flag_ns1__chkAssySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkAssySN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkAssySN, sizeof(struct __ns1__chkAssySN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkAssySN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkAssySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkAssySN(soap, "ns1:chkAssySN", &a->ns1__chkAssySN, ""))
				{	soap_flag_ns1__chkAssySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkAssySN * SOAP_FMAC2 soap_instantiate___ns1__chkAssySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkAssySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkAssySN *p;
	size_t k = sizeof(struct __ns1__chkAssySN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkAssySN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkAssySN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkAssySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkAssySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkAssySN(struct soap *soap, const struct __ns1__chkAssySN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkAssySN(soap, tag ? tag : "-ns1:chkAssySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkAssySN * SOAP_FMAC4 soap_get___ns1__chkAssySN(struct soap *soap, struct __ns1__chkAssySN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkAssySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPNbySN(struct soap *soap, struct __ns1__getPNbySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPNbySN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPNbySN(struct soap *soap, const struct __ns1__getPNbySN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPNbySN(soap, &a->ns1__getPNbySN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPNbySN(struct soap *soap, const char *tag, int id, const struct __ns1__getPNbySN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPNbySN(soap, "ns1:getPNbySN", -1, &a->ns1__getPNbySN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPNbySN * SOAP_FMAC4 soap_in___ns1__getPNbySN(struct soap *soap, const char *tag, struct __ns1__getPNbySN *a, const char *type)
{
	size_t soap_flag_ns1__getPNbySN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPNbySN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPNbySN, sizeof(struct __ns1__getPNbySN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPNbySN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPNbySN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPNbySN(soap, "ns1:getPNbySN", &a->ns1__getPNbySN, ""))
				{	soap_flag_ns1__getPNbySN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPNbySN * SOAP_FMAC2 soap_instantiate___ns1__getPNbySN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPNbySN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPNbySN *p;
	size_t k = sizeof(struct __ns1__getPNbySN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPNbySN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPNbySN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPNbySN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPNbySN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPNbySN(struct soap *soap, const struct __ns1__getPNbySN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPNbySN(soap, tag ? tag : "-ns1:getPNbySN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPNbySN * SOAP_FMAC4 soap_get___ns1__getPNbySN(struct soap *soap, struct __ns1__getPNbySN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPNbySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMoAssyCount(struct soap *soap, struct __ns1__getMoAssyCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMoAssyCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMoAssyCount(struct soap *soap, const struct __ns1__getMoAssyCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoAssyCount(soap, &a->ns1__getMoAssyCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMoAssyCount(struct soap *soap, const char *tag, int id, const struct __ns1__getMoAssyCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMoAssyCount(soap, "ns1:getMoAssyCount", -1, &a->ns1__getMoAssyCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyCount * SOAP_FMAC4 soap_in___ns1__getMoAssyCount(struct soap *soap, const char *tag, struct __ns1__getMoAssyCount *a, const char *type)
{
	size_t soap_flag_ns1__getMoAssyCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMoAssyCount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMoAssyCount, sizeof(struct __ns1__getMoAssyCount), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMoAssyCount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMoAssyCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoAssyCount(soap, "ns1:getMoAssyCount", &a->ns1__getMoAssyCount, ""))
				{	soap_flag_ns1__getMoAssyCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMoAssyCount * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMoAssyCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMoAssyCount *p;
	size_t k = sizeof(struct __ns1__getMoAssyCount);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMoAssyCount);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMoAssyCount, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMoAssyCount location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMoAssyCount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMoAssyCount(struct soap *soap, const struct __ns1__getMoAssyCount *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMoAssyCount(soap, tag ? tag : "-ns1:getMoAssyCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyCount * SOAP_FMAC4 soap_get___ns1__getMoAssyCount(struct soap *soap, struct __ns1__getMoAssyCount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMoAssyCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLinkOutSn(struct soap *soap, struct __ns1__GetLinkOutSn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLinkOutSn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLinkOutSn(struct soap *soap, const struct __ns1__GetLinkOutSn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLinkOutSn(soap, &a->ns1__GetLinkOutSn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLinkOutSn(struct soap *soap, const char *tag, int id, const struct __ns1__GetLinkOutSn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLinkOutSn(soap, "ns1:GetLinkOutSn", -1, &a->ns1__GetLinkOutSn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkOutSn * SOAP_FMAC4 soap_in___ns1__GetLinkOutSn(struct soap *soap, const char *tag, struct __ns1__GetLinkOutSn *a, const char *type)
{
	size_t soap_flag_ns1__GetLinkOutSn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLinkOutSn *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLinkOutSn, sizeof(struct __ns1__GetLinkOutSn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLinkOutSn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLinkOutSn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLinkOutSn(soap, "ns1:GetLinkOutSn", &a->ns1__GetLinkOutSn, ""))
				{	soap_flag_ns1__GetLinkOutSn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLinkOutSn * SOAP_FMAC2 soap_instantiate___ns1__GetLinkOutSn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLinkOutSn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLinkOutSn *p;
	size_t k = sizeof(struct __ns1__GetLinkOutSn);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLinkOutSn);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLinkOutSn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLinkOutSn location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLinkOutSn, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLinkOutSn(struct soap *soap, const struct __ns1__GetLinkOutSn *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLinkOutSn(soap, tag ? tag : "-ns1:GetLinkOutSn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLinkOutSn * SOAP_FMAC4 soap_get___ns1__GetLinkOutSn(struct soap *soap, struct __ns1__GetLinkOutSn *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLinkOutSn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsPartAssy(struct soap *soap, struct __ns1__InsPartAssy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsPartAssy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsPartAssy(struct soap *soap, const struct __ns1__InsPartAssy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsPartAssy(soap, &a->ns1__InsPartAssy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsPartAssy(struct soap *soap, const char *tag, int id, const struct __ns1__InsPartAssy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsPartAssy(soap, "ns1:InsPartAssy", -1, &a->ns1__InsPartAssy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsPartAssy * SOAP_FMAC4 soap_in___ns1__InsPartAssy(struct soap *soap, const char *tag, struct __ns1__InsPartAssy *a, const char *type)
{
	size_t soap_flag_ns1__InsPartAssy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsPartAssy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsPartAssy, sizeof(struct __ns1__InsPartAssy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsPartAssy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsPartAssy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsPartAssy(soap, "ns1:InsPartAssy", &a->ns1__InsPartAssy, ""))
				{	soap_flag_ns1__InsPartAssy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsPartAssy * SOAP_FMAC2 soap_instantiate___ns1__InsPartAssy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsPartAssy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsPartAssy *p;
	size_t k = sizeof(struct __ns1__InsPartAssy);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsPartAssy);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsPartAssy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsPartAssy location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsPartAssy, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsPartAssy(struct soap *soap, const struct __ns1__InsPartAssy *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsPartAssy(soap, tag ? tag : "-ns1:InsPartAssy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsPartAssy * SOAP_FMAC4 soap_get___ns1__InsPartAssy(struct soap *soap, struct __ns1__InsPartAssy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsPartAssy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPartBomExt(struct soap *soap, struct __ns1__getPartBomExt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPartBomExt = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPartBomExt(struct soap *soap, const struct __ns1__getPartBomExt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getPartBomExt(soap, &a->ns1__getPartBomExt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPartBomExt(struct soap *soap, const char *tag, int id, const struct __ns1__getPartBomExt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getPartBomExt(soap, "ns1:getPartBomExt", -1, &a->ns1__getPartBomExt, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPartBomExt * SOAP_FMAC4 soap_in___ns1__getPartBomExt(struct soap *soap, const char *tag, struct __ns1__getPartBomExt *a, const char *type)
{
	size_t soap_flag_ns1__getPartBomExt = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPartBomExt *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPartBomExt, sizeof(struct __ns1__getPartBomExt), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPartBomExt(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPartBomExt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getPartBomExt(soap, "ns1:getPartBomExt", &a->ns1__getPartBomExt, ""))
				{	soap_flag_ns1__getPartBomExt--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPartBomExt * SOAP_FMAC2 soap_instantiate___ns1__getPartBomExt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPartBomExt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPartBomExt *p;
	size_t k = sizeof(struct __ns1__getPartBomExt);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPartBomExt);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPartBomExt, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPartBomExt location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPartBomExt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPartBomExt(struct soap *soap, const struct __ns1__getPartBomExt *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPartBomExt(soap, tag ? tag : "-ns1:getPartBomExt", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPartBomExt * SOAP_FMAC4 soap_get___ns1__getPartBomExt(struct soap *soap, struct __ns1__getPartBomExt *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPartBomExt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMoAssyList(struct soap *soap, struct __ns1__getMoAssyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMoAssyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMoAssyList(struct soap *soap, const struct __ns1__getMoAssyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoAssyList(soap, &a->ns1__getMoAssyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMoAssyList(struct soap *soap, const char *tag, int id, const struct __ns1__getMoAssyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMoAssyList(soap, "ns1:getMoAssyList", -1, &a->ns1__getMoAssyList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyList * SOAP_FMAC4 soap_in___ns1__getMoAssyList(struct soap *soap, const char *tag, struct __ns1__getMoAssyList *a, const char *type)
{
	size_t soap_flag_ns1__getMoAssyList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMoAssyList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMoAssyList, sizeof(struct __ns1__getMoAssyList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMoAssyList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMoAssyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoAssyList(soap, "ns1:getMoAssyList", &a->ns1__getMoAssyList, ""))
				{	soap_flag_ns1__getMoAssyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMoAssyList * SOAP_FMAC2 soap_instantiate___ns1__getMoAssyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMoAssyList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMoAssyList *p;
	size_t k = sizeof(struct __ns1__getMoAssyList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMoAssyList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMoAssyList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMoAssyList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMoAssyList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMoAssyList(struct soap *soap, const struct __ns1__getMoAssyList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMoAssyList(soap, tag ? tag : "-ns1:getMoAssyList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoAssyList * SOAP_FMAC4 soap_get___ns1__getMoAssyList(struct soap *soap, struct __ns1__getMoAssyList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMoAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkSnMapping(struct soap *soap, struct __ns1__chkSnMapping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkSnMapping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkSnMapping(struct soap *soap, const struct __ns1__chkSnMapping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkSnMapping(soap, &a->ns1__chkSnMapping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkSnMapping(struct soap *soap, const char *tag, int id, const struct __ns1__chkSnMapping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkSnMapping(soap, "ns1:chkSnMapping", -1, &a->ns1__chkSnMapping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkSnMapping * SOAP_FMAC4 soap_in___ns1__chkSnMapping(struct soap *soap, const char *tag, struct __ns1__chkSnMapping *a, const char *type)
{
	size_t soap_flag_ns1__chkSnMapping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkSnMapping *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkSnMapping, sizeof(struct __ns1__chkSnMapping), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkSnMapping(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkSnMapping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkSnMapping(soap, "ns1:chkSnMapping", &a->ns1__chkSnMapping, ""))
				{	soap_flag_ns1__chkSnMapping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkSnMapping * SOAP_FMAC2 soap_instantiate___ns1__chkSnMapping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkSnMapping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkSnMapping *p;
	size_t k = sizeof(struct __ns1__chkSnMapping);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkSnMapping);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkSnMapping, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkSnMapping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkSnMapping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkSnMapping(struct soap *soap, const struct __ns1__chkSnMapping *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkSnMapping(soap, tag ? tag : "-ns1:chkSnMapping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkSnMapping * SOAP_FMAC4 soap_get___ns1__chkSnMapping(struct soap *soap, struct __ns1__chkSnMapping *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkSnMapping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStationTypeDesc(struct soap *soap, struct __ns1__getStationTypeDesc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStationTypeDesc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStationTypeDesc(struct soap *soap, const struct __ns1__getStationTypeDesc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getStationTypeDesc(soap, &a->ns1__getStationTypeDesc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStationTypeDesc(struct soap *soap, const char *tag, int id, const struct __ns1__getStationTypeDesc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getStationTypeDesc(soap, "ns1:getStationTypeDesc", -1, &a->ns1__getStationTypeDesc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationTypeDesc * SOAP_FMAC4 soap_in___ns1__getStationTypeDesc(struct soap *soap, const char *tag, struct __ns1__getStationTypeDesc *a, const char *type)
{
	size_t soap_flag_ns1__getStationTypeDesc = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getStationTypeDesc *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStationTypeDesc, sizeof(struct __ns1__getStationTypeDesc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStationTypeDesc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStationTypeDesc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getStationTypeDesc(soap, "ns1:getStationTypeDesc", &a->ns1__getStationTypeDesc, ""))
				{	soap_flag_ns1__getStationTypeDesc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getStationTypeDesc * SOAP_FMAC2 soap_instantiate___ns1__getStationTypeDesc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStationTypeDesc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getStationTypeDesc *p;
	size_t k = sizeof(struct __ns1__getStationTypeDesc);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getStationTypeDesc);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getStationTypeDesc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getStationTypeDesc location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getStationTypeDesc, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStationTypeDesc(struct soap *soap, const struct __ns1__getStationTypeDesc *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getStationTypeDesc(soap, tag ? tag : "-ns1:getStationTypeDesc", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationTypeDesc * SOAP_FMAC4 soap_get___ns1__getStationTypeDesc(struct soap *soap, struct __ns1__getStationTypeDesc *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStationTypeDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStationByMo(struct soap *soap, struct __ns1__getStationByMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStationByMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStationByMo(struct soap *soap, const struct __ns1__getStationByMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getStationByMo(soap, &a->ns1__getStationByMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStationByMo(struct soap *soap, const char *tag, int id, const struct __ns1__getStationByMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getStationByMo(soap, "ns1:getStationByMo", -1, &a->ns1__getStationByMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMo * SOAP_FMAC4 soap_in___ns1__getStationByMo(struct soap *soap, const char *tag, struct __ns1__getStationByMo *a, const char *type)
{
	size_t soap_flag_ns1__getStationByMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getStationByMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStationByMo, sizeof(struct __ns1__getStationByMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStationByMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStationByMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getStationByMo(soap, "ns1:getStationByMo", &a->ns1__getStationByMo, ""))
				{	soap_flag_ns1__getStationByMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getStationByMo * SOAP_FMAC2 soap_instantiate___ns1__getStationByMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStationByMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getStationByMo *p;
	size_t k = sizeof(struct __ns1__getStationByMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getStationByMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getStationByMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getStationByMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getStationByMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStationByMo(struct soap *soap, const struct __ns1__getStationByMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getStationByMo(soap, tag ? tag : "-ns1:getStationByMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMo * SOAP_FMAC4 soap_get___ns1__getStationByMo(struct soap *soap, struct __ns1__getStationByMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStationByMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SnDoMapping(struct soap *soap, struct __ns1__SnDoMapping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SnDoMapping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SnDoMapping(struct soap *soap, const struct __ns1__SnDoMapping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SnDoMapping(soap, &a->ns1__SnDoMapping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SnDoMapping(struct soap *soap, const char *tag, int id, const struct __ns1__SnDoMapping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SnDoMapping(soap, "ns1:SnDoMapping", -1, &a->ns1__SnDoMapping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnDoMapping * SOAP_FMAC4 soap_in___ns1__SnDoMapping(struct soap *soap, const char *tag, struct __ns1__SnDoMapping *a, const char *type)
{
	size_t soap_flag_ns1__SnDoMapping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SnDoMapping *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SnDoMapping, sizeof(struct __ns1__SnDoMapping), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SnDoMapping(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SnDoMapping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SnDoMapping(soap, "ns1:SnDoMapping", &a->ns1__SnDoMapping, ""))
				{	soap_flag_ns1__SnDoMapping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SnDoMapping * SOAP_FMAC2 soap_instantiate___ns1__SnDoMapping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SnDoMapping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SnDoMapping *p;
	size_t k = sizeof(struct __ns1__SnDoMapping);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SnDoMapping);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SnDoMapping, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SnDoMapping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SnDoMapping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SnDoMapping(struct soap *soap, const struct __ns1__SnDoMapping *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SnDoMapping(soap, tag ? tag : "-ns1:SnDoMapping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnDoMapping * SOAP_FMAC4 soap_get___ns1__SnDoMapping(struct soap *soap, struct __ns1__SnDoMapping *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SnDoMapping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__eMesNextMo(struct soap *soap, struct __ns1__eMesNextMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__eMesNextMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__eMesNextMo(struct soap *soap, const struct __ns1__eMesNextMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__eMesNextMo(soap, &a->ns1__eMesNextMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__eMesNextMo(struct soap *soap, const char *tag, int id, const struct __ns1__eMesNextMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__eMesNextMo(soap, "ns1:eMesNextMo", -1, &a->ns1__eMesNextMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__eMesNextMo * SOAP_FMAC4 soap_in___ns1__eMesNextMo(struct soap *soap, const char *tag, struct __ns1__eMesNextMo *a, const char *type)
{
	size_t soap_flag_ns1__eMesNextMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__eMesNextMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__eMesNextMo, sizeof(struct __ns1__eMesNextMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__eMesNextMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__eMesNextMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__eMesNextMo(soap, "ns1:eMesNextMo", &a->ns1__eMesNextMo, ""))
				{	soap_flag_ns1__eMesNextMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__eMesNextMo * SOAP_FMAC2 soap_instantiate___ns1__eMesNextMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__eMesNextMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__eMesNextMo *p;
	size_t k = sizeof(struct __ns1__eMesNextMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__eMesNextMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__eMesNextMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__eMesNextMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__eMesNextMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__eMesNextMo(struct soap *soap, const struct __ns1__eMesNextMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__eMesNextMo(soap, tag ? tag : "-ns1:eMesNextMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__eMesNextMo * SOAP_FMAC4 soap_get___ns1__eMesNextMo(struct soap *soap, struct __ns1__eMesNextMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__eMesNextMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendResultForStationNumber(struct soap *soap, struct __ns1__sendResultForStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendResultForStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendResultForStationNumber(struct soap *soap, const struct __ns1__sendResultForStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendResultForStationNumber(soap, &a->ns1__sendResultForStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendResultForStationNumber(struct soap *soap, const char *tag, int id, const struct __ns1__sendResultForStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendResultForStationNumber(soap, "ns1:sendResultForStationNumber", -1, &a->ns1__sendResultForStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendResultForStationNumber * SOAP_FMAC4 soap_in___ns1__sendResultForStationNumber(struct soap *soap, const char *tag, struct __ns1__sendResultForStationNumber *a, const char *type)
{
	size_t soap_flag_ns1__sendResultForStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendResultForStationNumber *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendResultForStationNumber, sizeof(struct __ns1__sendResultForStationNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendResultForStationNumber(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendResultForStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendResultForStationNumber(soap, "ns1:sendResultForStationNumber", &a->ns1__sendResultForStationNumber, ""))
				{	soap_flag_ns1__sendResultForStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendResultForStationNumber * SOAP_FMAC2 soap_instantiate___ns1__sendResultForStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendResultForStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendResultForStationNumber *p;
	size_t k = sizeof(struct __ns1__sendResultForStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendResultForStationNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendResultForStationNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendResultForStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendResultForStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendResultForStationNumber(struct soap *soap, const struct __ns1__sendResultForStationNumber *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendResultForStationNumber(soap, tag ? tag : "-ns1:sendResultForStationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendResultForStationNumber * SOAP_FMAC4 soap_get___ns1__sendResultForStationNumber(struct soap *soap, struct __ns1__sendResultForStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendResultForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendDataForStationNumber(struct soap *soap, struct __ns1__sendDataForStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendDataForStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendDataForStationNumber(struct soap *soap, const struct __ns1__sendDataForStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendDataForStationNumber(soap, &a->ns1__sendDataForStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendDataForStationNumber(struct soap *soap, const char *tag, int id, const struct __ns1__sendDataForStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendDataForStationNumber(soap, "ns1:sendDataForStationNumber", -1, &a->ns1__sendDataForStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendDataForStationNumber * SOAP_FMAC4 soap_in___ns1__sendDataForStationNumber(struct soap *soap, const char *tag, struct __ns1__sendDataForStationNumber *a, const char *type)
{
	size_t soap_flag_ns1__sendDataForStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendDataForStationNumber *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendDataForStationNumber, sizeof(struct __ns1__sendDataForStationNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendDataForStationNumber(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendDataForStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendDataForStationNumber(soap, "ns1:sendDataForStationNumber", &a->ns1__sendDataForStationNumber, ""))
				{	soap_flag_ns1__sendDataForStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendDataForStationNumber * SOAP_FMAC2 soap_instantiate___ns1__sendDataForStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendDataForStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendDataForStationNumber *p;
	size_t k = sizeof(struct __ns1__sendDataForStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendDataForStationNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendDataForStationNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendDataForStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendDataForStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendDataForStationNumber(struct soap *soap, const struct __ns1__sendDataForStationNumber *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendDataForStationNumber(soap, tag ? tag : "-ns1:sendDataForStationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendDataForStationNumber * SOAP_FMAC4 soap_get___ns1__sendDataForStationNumber(struct soap *soap, struct __ns1__sendDataForStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendDataForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkEmpForStationNumber(struct soap *soap, struct __ns1__checkEmpForStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkEmpForStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkEmpForStationNumber(struct soap *soap, const struct __ns1__checkEmpForStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkEmpForStationNumber(soap, &a->ns1__checkEmpForStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkEmpForStationNumber(struct soap *soap, const char *tag, int id, const struct __ns1__checkEmpForStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkEmpForStationNumber(soap, "ns1:checkEmpForStationNumber", -1, &a->ns1__checkEmpForStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpForStationNumber * SOAP_FMAC4 soap_in___ns1__checkEmpForStationNumber(struct soap *soap, const char *tag, struct __ns1__checkEmpForStationNumber *a, const char *type)
{
	size_t soap_flag_ns1__checkEmpForStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkEmpForStationNumber *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkEmpForStationNumber, sizeof(struct __ns1__checkEmpForStationNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkEmpForStationNumber(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkEmpForStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkEmpForStationNumber(soap, "ns1:checkEmpForStationNumber", &a->ns1__checkEmpForStationNumber, ""))
				{	soap_flag_ns1__checkEmpForStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkEmpForStationNumber * SOAP_FMAC2 soap_instantiate___ns1__checkEmpForStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkEmpForStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkEmpForStationNumber *p;
	size_t k = sizeof(struct __ns1__checkEmpForStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkEmpForStationNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkEmpForStationNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkEmpForStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkEmpForStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkEmpForStationNumber(struct soap *soap, const struct __ns1__checkEmpForStationNumber *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkEmpForStationNumber(soap, tag ? tag : "-ns1:checkEmpForStationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpForStationNumber * SOAP_FMAC4 soap_get___ns1__checkEmpForStationNumber(struct soap *soap, struct __ns1__checkEmpForStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkEmpForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkSN_USCOREStationNumber(struct soap *soap, struct __ns1__checkSN_USCOREStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkSN_USCOREStationNumber = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkSN_USCOREStationNumber(struct soap *soap, const struct __ns1__checkSN_USCOREStationNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkSN_USCOREStationNumber(soap, &a->ns1__checkSN_USCOREStationNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *tag, int id, const struct __ns1__checkSN_USCOREStationNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkSN_USCOREStationNumber(soap, "ns1:checkSN_StationNumber", -1, &a->ns1__checkSN_USCOREStationNumber, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStationNumber * SOAP_FMAC4 soap_in___ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *tag, struct __ns1__checkSN_USCOREStationNumber *a, const char *type)
{
	size_t soap_flag_ns1__checkSN_USCOREStationNumber = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkSN_USCOREStationNumber *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkSN_USCOREStationNumber, sizeof(struct __ns1__checkSN_USCOREStationNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkSN_USCOREStationNumber(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkSN_USCOREStationNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkSN_USCOREStationNumber(soap, "ns1:checkSN_StationNumber", &a->ns1__checkSN_USCOREStationNumber, ""))
				{	soap_flag_ns1__checkSN_USCOREStationNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkSN_USCOREStationNumber * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStationNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkSN_USCOREStationNumber(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkSN_USCOREStationNumber *p;
	size_t k = sizeof(struct __ns1__checkSN_USCOREStationNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkSN_USCOREStationNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkSN_USCOREStationNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkSN_USCOREStationNumber location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkSN_USCOREStationNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkSN_USCOREStationNumber(struct soap *soap, const struct __ns1__checkSN_USCOREStationNumber *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkSN_USCOREStationNumber(soap, tag ? tag : "-ns1:checkSN_StationNumber", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStationNumber * SOAP_FMAC4 soap_get___ns1__checkSN_USCOREStationNumber(struct soap *soap, struct __ns1__checkSN_USCOREStationNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkSN_USCOREStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnNextMo(struct soap *soap, struct __ns1__ChkSnNextMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnNextMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnNextMo(struct soap *soap, const struct __ns1__ChkSnNextMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnNextMo(soap, &a->ns1__ChkSnNextMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnNextMo(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnNextMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnNextMo(soap, "ns1:ChkSnNextMo", -1, &a->ns1__ChkSnNextMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnNextMo * SOAP_FMAC4 soap_in___ns1__ChkSnNextMo(struct soap *soap, const char *tag, struct __ns1__ChkSnNextMo *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnNextMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnNextMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnNextMo, sizeof(struct __ns1__ChkSnNextMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnNextMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnNextMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnNextMo(soap, "ns1:ChkSnNextMo", &a->ns1__ChkSnNextMo, ""))
				{	soap_flag_ns1__ChkSnNextMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnNextMo * SOAP_FMAC2 soap_instantiate___ns1__ChkSnNextMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnNextMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnNextMo *p;
	size_t k = sizeof(struct __ns1__ChkSnNextMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnNextMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnNextMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnNextMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnNextMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnNextMo(struct soap *soap, const struct __ns1__ChkSnNextMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnNextMo(soap, tag ? tag : "-ns1:ChkSnNextMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnNextMo * SOAP_FMAC4 soap_get___ns1__ChkSnNextMo(struct soap *soap, struct __ns1__ChkSnNextMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnNextMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnMo(struct soap *soap, struct __ns1__ChkSnMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnMo(struct soap *soap, const struct __ns1__ChkSnMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnMo(soap, &a->ns1__ChkSnMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnMo(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnMo(soap, "ns1:ChkSnMo", -1, &a->ns1__ChkSnMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnMo * SOAP_FMAC4 soap_in___ns1__ChkSnMo(struct soap *soap, const char *tag, struct __ns1__ChkSnMo *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnMo, sizeof(struct __ns1__ChkSnMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnMo(soap, "ns1:ChkSnMo", &a->ns1__ChkSnMo, ""))
				{	soap_flag_ns1__ChkSnMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnMo * SOAP_FMAC2 soap_instantiate___ns1__ChkSnMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnMo *p;
	size_t k = sizeof(struct __ns1__ChkSnMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnMo(struct soap *soap, const struct __ns1__ChkSnMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnMo(soap, tag ? tag : "-ns1:ChkSnMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnMo * SOAP_FMAC4 soap_get___ns1__ChkSnMo(struct soap *soap, struct __ns1__ChkSnMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkMoStation(struct soap *soap, struct __ns1__chkMoStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkMoStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkMoStation(struct soap *soap, const struct __ns1__chkMoStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkMoStation(soap, &a->ns1__chkMoStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkMoStation(struct soap *soap, const char *tag, int id, const struct __ns1__chkMoStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkMoStation(soap, "ns1:chkMoStation", -1, &a->ns1__chkMoStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoStation * SOAP_FMAC4 soap_in___ns1__chkMoStation(struct soap *soap, const char *tag, struct __ns1__chkMoStation *a, const char *type)
{
	size_t soap_flag_ns1__chkMoStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkMoStation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkMoStation, sizeof(struct __ns1__chkMoStation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkMoStation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkMoStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkMoStation(soap, "ns1:chkMoStation", &a->ns1__chkMoStation, ""))
				{	soap_flag_ns1__chkMoStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkMoStation * SOAP_FMAC2 soap_instantiate___ns1__chkMoStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkMoStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkMoStation *p;
	size_t k = sizeof(struct __ns1__chkMoStation);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkMoStation);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkMoStation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkMoStation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkMoStation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkMoStation(struct soap *soap, const struct __ns1__chkMoStation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkMoStation(soap, tag ? tag : "-ns1:chkMoStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoStation * SOAP_FMAC4 soap_get___ns1__chkMoStation(struct soap *soap, struct __ns1__chkMoStation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkMoStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetEnergyStat(struct soap *soap, struct __ns1__SetEnergyStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetEnergyStat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetEnergyStat(struct soap *soap, const struct __ns1__SetEnergyStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetEnergyStat(soap, &a->ns1__SetEnergyStat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetEnergyStat(struct soap *soap, const char *tag, int id, const struct __ns1__SetEnergyStat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetEnergyStat(soap, "ns1:SetEnergyStat", -1, &a->ns1__SetEnergyStat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetEnergyStat * SOAP_FMAC4 soap_in___ns1__SetEnergyStat(struct soap *soap, const char *tag, struct __ns1__SetEnergyStat *a, const char *type)
{
	size_t soap_flag_ns1__SetEnergyStat = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetEnergyStat *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetEnergyStat, sizeof(struct __ns1__SetEnergyStat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetEnergyStat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetEnergyStat && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetEnergyStat(soap, "ns1:SetEnergyStat", &a->ns1__SetEnergyStat, ""))
				{	soap_flag_ns1__SetEnergyStat--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetEnergyStat * SOAP_FMAC2 soap_instantiate___ns1__SetEnergyStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetEnergyStat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetEnergyStat *p;
	size_t k = sizeof(struct __ns1__SetEnergyStat);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetEnergyStat);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetEnergyStat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetEnergyStat location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetEnergyStat, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetEnergyStat(struct soap *soap, const struct __ns1__SetEnergyStat *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetEnergyStat(soap, tag ? tag : "-ns1:SetEnergyStat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetEnergyStat * SOAP_FMAC4 soap_get___ns1__SetEnergyStat(struct soap *soap, struct __ns1__SetEnergyStat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetEnergyStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInfoByMo(struct soap *soap, struct __ns1__getInfoByMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getInfoByMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInfoByMo(struct soap *soap, const struct __ns1__getInfoByMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getInfoByMo(soap, &a->ns1__getInfoByMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInfoByMo(struct soap *soap, const char *tag, int id, const struct __ns1__getInfoByMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getInfoByMo(soap, "ns1:getInfoByMo", -1, &a->ns1__getInfoByMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInfoByMo * SOAP_FMAC4 soap_in___ns1__getInfoByMo(struct soap *soap, const char *tag, struct __ns1__getInfoByMo *a, const char *type)
{
	size_t soap_flag_ns1__getInfoByMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getInfoByMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInfoByMo, sizeof(struct __ns1__getInfoByMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInfoByMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getInfoByMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getInfoByMo(soap, "ns1:getInfoByMo", &a->ns1__getInfoByMo, ""))
				{	soap_flag_ns1__getInfoByMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getInfoByMo * SOAP_FMAC2 soap_instantiate___ns1__getInfoByMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInfoByMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getInfoByMo *p;
	size_t k = sizeof(struct __ns1__getInfoByMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getInfoByMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getInfoByMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getInfoByMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getInfoByMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInfoByMo(struct soap *soap, const struct __ns1__getInfoByMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getInfoByMo(soap, tag ? tag : "-ns1:getInfoByMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInfoByMo * SOAP_FMAC4 soap_get___ns1__getInfoByMo(struct soap *soap, struct __ns1__getInfoByMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInfoByMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsThermalNew(struct soap *soap, struct __ns1__InsThermalNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsThermalNew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsThermalNew(struct soap *soap, const struct __ns1__InsThermalNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsThermalNew(soap, &a->ns1__InsThermalNew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsThermalNew(struct soap *soap, const char *tag, int id, const struct __ns1__InsThermalNew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsThermalNew(soap, "ns1:InsThermalNew", -1, &a->ns1__InsThermalNew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermalNew * SOAP_FMAC4 soap_in___ns1__InsThermalNew(struct soap *soap, const char *tag, struct __ns1__InsThermalNew *a, const char *type)
{
	size_t soap_flag_ns1__InsThermalNew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsThermalNew *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsThermalNew, sizeof(struct __ns1__InsThermalNew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsThermalNew(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsThermalNew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsThermalNew(soap, "ns1:InsThermalNew", &a->ns1__InsThermalNew, ""))
				{	soap_flag_ns1__InsThermalNew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsThermalNew * SOAP_FMAC2 soap_instantiate___ns1__InsThermalNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsThermalNew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsThermalNew *p;
	size_t k = sizeof(struct __ns1__InsThermalNew);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsThermalNew);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsThermalNew, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsThermalNew location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsThermalNew, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsThermalNew(struct soap *soap, const struct __ns1__InsThermalNew *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsThermalNew(soap, tag ? tag : "-ns1:InsThermalNew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermalNew * SOAP_FMAC4 soap_get___ns1__InsThermalNew(struct soap *soap, struct __ns1__InsThermalNew *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsThermalNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnLink(struct soap *soap, struct __ns1__ChkSnLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnLink(struct soap *soap, const struct __ns1__ChkSnLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnLink(soap, &a->ns1__ChkSnLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnLink(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnLink(soap, "ns1:ChkSnLink", -1, &a->ns1__ChkSnLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLink * SOAP_FMAC4 soap_in___ns1__ChkSnLink(struct soap *soap, const char *tag, struct __ns1__ChkSnLink *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnLink *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnLink, sizeof(struct __ns1__ChkSnLink), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnLink(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnLink(soap, "ns1:ChkSnLink", &a->ns1__ChkSnLink, ""))
				{	soap_flag_ns1__ChkSnLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnLink * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnLink *p;
	size_t k = sizeof(struct __ns1__ChkSnLink);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnLink);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnLink, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnLink(struct soap *soap, const struct __ns1__ChkSnLink *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnLink(soap, tag ? tag : "-ns1:ChkSnLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLink * SOAP_FMAC4 soap_get___ns1__ChkSnLink(struct soap *soap, struct __ns1__ChkSnLink *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsThermal(struct soap *soap, struct __ns1__InsThermal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsThermal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsThermal(struct soap *soap, const struct __ns1__InsThermal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsThermal(soap, &a->ns1__InsThermal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsThermal(struct soap *soap, const char *tag, int id, const struct __ns1__InsThermal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsThermal(soap, "ns1:InsThermal", -1, &a->ns1__InsThermal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermal * SOAP_FMAC4 soap_in___ns1__InsThermal(struct soap *soap, const char *tag, struct __ns1__InsThermal *a, const char *type)
{
	size_t soap_flag_ns1__InsThermal = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsThermal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsThermal, sizeof(struct __ns1__InsThermal), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsThermal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsThermal && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsThermal(soap, "ns1:InsThermal", &a->ns1__InsThermal, ""))
				{	soap_flag_ns1__InsThermal--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsThermal * SOAP_FMAC2 soap_instantiate___ns1__InsThermal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsThermal(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsThermal *p;
	size_t k = sizeof(struct __ns1__InsThermal);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsThermal);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsThermal, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsThermal location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsThermal, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsThermal(struct soap *soap, const struct __ns1__InsThermal *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsThermal(soap, tag ? tag : "-ns1:InsThermal", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsThermal * SOAP_FMAC4 soap_get___ns1__InsThermal(struct soap *soap, struct __ns1__InsThermal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsThermal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsWHDetection(struct soap *soap, struct __ns1__InsWHDetection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsWHDetection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsWHDetection(struct soap *soap, const struct __ns1__InsWHDetection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsWHDetection(soap, &a->ns1__InsWHDetection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsWHDetection(struct soap *soap, const char *tag, int id, const struct __ns1__InsWHDetection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsWHDetection(soap, "ns1:InsWHDetection", -1, &a->ns1__InsWHDetection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsWHDetection * SOAP_FMAC4 soap_in___ns1__InsWHDetection(struct soap *soap, const char *tag, struct __ns1__InsWHDetection *a, const char *type)
{
	size_t soap_flag_ns1__InsWHDetection = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsWHDetection *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsWHDetection, sizeof(struct __ns1__InsWHDetection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsWHDetection(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsWHDetection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsWHDetection(soap, "ns1:InsWHDetection", &a->ns1__InsWHDetection, ""))
				{	soap_flag_ns1__InsWHDetection--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsWHDetection * SOAP_FMAC2 soap_instantiate___ns1__InsWHDetection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsWHDetection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsWHDetection *p;
	size_t k = sizeof(struct __ns1__InsWHDetection);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsWHDetection);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsWHDetection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsWHDetection location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsWHDetection, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsWHDetection(struct soap *soap, const struct __ns1__InsWHDetection *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsWHDetection(soap, tag ? tag : "-ns1:InsWHDetection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsWHDetection * SOAP_FMAC4 soap_get___ns1__InsWHDetection(struct soap *soap, struct __ns1__InsWHDetection *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsWHDetection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFlatNessForCL(struct soap *soap, struct __ns1__InsFlatNessForCL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFlatNessForCL = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFlatNessForCL(struct soap *soap, const struct __ns1__InsFlatNessForCL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFlatNessForCL(soap, &a->ns1__InsFlatNessForCL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFlatNessForCL(struct soap *soap, const char *tag, int id, const struct __ns1__InsFlatNessForCL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFlatNessForCL(soap, "ns1:InsFlatNessForCL", -1, &a->ns1__InsFlatNessForCL, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForCL * SOAP_FMAC4 soap_in___ns1__InsFlatNessForCL(struct soap *soap, const char *tag, struct __ns1__InsFlatNessForCL *a, const char *type)
{
	size_t soap_flag_ns1__InsFlatNessForCL = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFlatNessForCL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFlatNessForCL, sizeof(struct __ns1__InsFlatNessForCL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFlatNessForCL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFlatNessForCL && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFlatNessForCL(soap, "ns1:InsFlatNessForCL", &a->ns1__InsFlatNessForCL, ""))
				{	soap_flag_ns1__InsFlatNessForCL--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFlatNessForCL * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForCL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFlatNessForCL(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFlatNessForCL *p;
	size_t k = sizeof(struct __ns1__InsFlatNessForCL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFlatNessForCL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFlatNessForCL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFlatNessForCL location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFlatNessForCL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFlatNessForCL(struct soap *soap, const struct __ns1__InsFlatNessForCL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFlatNessForCL(soap, tag ? tag : "-ns1:InsFlatNessForCL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForCL * SOAP_FMAC4 soap_get___ns1__InsFlatNessForCL(struct soap *soap, struct __ns1__InsFlatNessForCL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFlatNessForCL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFlatNessForLSD(struct soap *soap, struct __ns1__InsFlatNessForLSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFlatNessForLSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFlatNessForLSD(struct soap *soap, const struct __ns1__InsFlatNessForLSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFlatNessForLSD(soap, &a->ns1__InsFlatNessForLSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFlatNessForLSD(struct soap *soap, const char *tag, int id, const struct __ns1__InsFlatNessForLSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFlatNessForLSD(soap, "ns1:InsFlatNessForLSD", -1, &a->ns1__InsFlatNessForLSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForLSD * SOAP_FMAC4 soap_in___ns1__InsFlatNessForLSD(struct soap *soap, const char *tag, struct __ns1__InsFlatNessForLSD *a, const char *type)
{
	size_t soap_flag_ns1__InsFlatNessForLSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFlatNessForLSD *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFlatNessForLSD, sizeof(struct __ns1__InsFlatNessForLSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFlatNessForLSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFlatNessForLSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFlatNessForLSD(soap, "ns1:InsFlatNessForLSD", &a->ns1__InsFlatNessForLSD, ""))
				{	soap_flag_ns1__InsFlatNessForLSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFlatNessForLSD * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNessForLSD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFlatNessForLSD(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFlatNessForLSD *p;
	size_t k = sizeof(struct __ns1__InsFlatNessForLSD);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFlatNessForLSD);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFlatNessForLSD, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFlatNessForLSD location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFlatNessForLSD, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFlatNessForLSD(struct soap *soap, const struct __ns1__InsFlatNessForLSD *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFlatNessForLSD(soap, tag ? tag : "-ns1:InsFlatNessForLSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNessForLSD * SOAP_FMAC4 soap_get___ns1__InsFlatNessForLSD(struct soap *soap, struct __ns1__InsFlatNessForLSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFlatNessForLSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFlatNess(struct soap *soap, struct __ns1__InsFlatNess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFlatNess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFlatNess(struct soap *soap, const struct __ns1__InsFlatNess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFlatNess(soap, &a->ns1__InsFlatNess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFlatNess(struct soap *soap, const char *tag, int id, const struct __ns1__InsFlatNess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFlatNess(soap, "ns1:InsFlatNess", -1, &a->ns1__InsFlatNess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNess * SOAP_FMAC4 soap_in___ns1__InsFlatNess(struct soap *soap, const char *tag, struct __ns1__InsFlatNess *a, const char *type)
{
	size_t soap_flag_ns1__InsFlatNess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFlatNess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFlatNess, sizeof(struct __ns1__InsFlatNess), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFlatNess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFlatNess && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFlatNess(soap, "ns1:InsFlatNess", &a->ns1__InsFlatNess, ""))
				{	soap_flag_ns1__InsFlatNess--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFlatNess * SOAP_FMAC2 soap_instantiate___ns1__InsFlatNess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFlatNess(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFlatNess *p;
	size_t k = sizeof(struct __ns1__InsFlatNess);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFlatNess);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFlatNess, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFlatNess location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFlatNess, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFlatNess(struct soap *soap, const struct __ns1__InsFlatNess *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFlatNess(soap, tag ? tag : "-ns1:InsFlatNess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFlatNess * SOAP_FMAC4 soap_get___ns1__InsFlatNess(struct soap *soap, struct __ns1__InsFlatNess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFlatNess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ImpMesAteTestData(struct soap *soap, struct __ns1__ImpMesAteTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ImpMesAteTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ImpMesAteTestData(struct soap *soap, const struct __ns1__ImpMesAteTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ImpMesAteTestData(soap, &a->ns1__ImpMesAteTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ImpMesAteTestData(struct soap *soap, const char *tag, int id, const struct __ns1__ImpMesAteTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ImpMesAteTestData(soap, "ns1:ImpMesAteTestData", -1, &a->ns1__ImpMesAteTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ImpMesAteTestData * SOAP_FMAC4 soap_in___ns1__ImpMesAteTestData(struct soap *soap, const char *tag, struct __ns1__ImpMesAteTestData *a, const char *type)
{
	size_t soap_flag_ns1__ImpMesAteTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ImpMesAteTestData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ImpMesAteTestData, sizeof(struct __ns1__ImpMesAteTestData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ImpMesAteTestData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ImpMesAteTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ImpMesAteTestData(soap, "ns1:ImpMesAteTestData", &a->ns1__ImpMesAteTestData, ""))
				{	soap_flag_ns1__ImpMesAteTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ImpMesAteTestData * SOAP_FMAC2 soap_instantiate___ns1__ImpMesAteTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ImpMesAteTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ImpMesAteTestData *p;
	size_t k = sizeof(struct __ns1__ImpMesAteTestData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ImpMesAteTestData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ImpMesAteTestData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ImpMesAteTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ImpMesAteTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ImpMesAteTestData(struct soap *soap, const struct __ns1__ImpMesAteTestData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ImpMesAteTestData(soap, tag ? tag : "-ns1:ImpMesAteTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ImpMesAteTestData * SOAP_FMAC4 soap_get___ns1__ImpMesAteTestData(struct soap *soap, struct __ns1__ImpMesAteTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ImpMesAteTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkStationTime(struct soap *soap, struct __ns1__chkStationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkStationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkStationTime(struct soap *soap, const struct __ns1__chkStationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkStationTime(soap, &a->ns1__chkStationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkStationTime(struct soap *soap, const char *tag, int id, const struct __ns1__chkStationTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkStationTime(soap, "ns1:chkStationTime", -1, &a->ns1__chkStationTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkStationTime * SOAP_FMAC4 soap_in___ns1__chkStationTime(struct soap *soap, const char *tag, struct __ns1__chkStationTime *a, const char *type)
{
	size_t soap_flag_ns1__chkStationTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkStationTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkStationTime, sizeof(struct __ns1__chkStationTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkStationTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkStationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkStationTime(soap, "ns1:chkStationTime", &a->ns1__chkStationTime, ""))
				{	soap_flag_ns1__chkStationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkStationTime * SOAP_FMAC2 soap_instantiate___ns1__chkStationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkStationTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkStationTime *p;
	size_t k = sizeof(struct __ns1__chkStationTime);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkStationTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkStationTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkStationTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkStationTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkStationTime(struct soap *soap, const struct __ns1__chkStationTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkStationTime(soap, tag ? tag : "-ns1:chkStationTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkStationTime * SOAP_FMAC4 soap_get___ns1__chkStationTime(struct soap *soap, struct __ns1__chkStationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkStationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InFruitsOrtQty(struct soap *soap, struct __ns1__InFruitsOrtQty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InFruitsOrtQty = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InFruitsOrtQty(struct soap *soap, const struct __ns1__InFruitsOrtQty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InFruitsOrtQty(soap, &a->ns1__InFruitsOrtQty);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InFruitsOrtQty(struct soap *soap, const char *tag, int id, const struct __ns1__InFruitsOrtQty *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InFruitsOrtQty(soap, "ns1:InFruitsOrtQty", -1, &a->ns1__InFruitsOrtQty, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InFruitsOrtQty * SOAP_FMAC4 soap_in___ns1__InFruitsOrtQty(struct soap *soap, const char *tag, struct __ns1__InFruitsOrtQty *a, const char *type)
{
	size_t soap_flag_ns1__InFruitsOrtQty = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InFruitsOrtQty *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InFruitsOrtQty, sizeof(struct __ns1__InFruitsOrtQty), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InFruitsOrtQty(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InFruitsOrtQty && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InFruitsOrtQty(soap, "ns1:InFruitsOrtQty", &a->ns1__InFruitsOrtQty, ""))
				{	soap_flag_ns1__InFruitsOrtQty--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InFruitsOrtQty * SOAP_FMAC2 soap_instantiate___ns1__InFruitsOrtQty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InFruitsOrtQty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InFruitsOrtQty *p;
	size_t k = sizeof(struct __ns1__InFruitsOrtQty);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InFruitsOrtQty);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InFruitsOrtQty, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InFruitsOrtQty location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InFruitsOrtQty, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InFruitsOrtQty(struct soap *soap, const struct __ns1__InFruitsOrtQty *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InFruitsOrtQty(soap, tag ? tag : "-ns1:InFruitsOrtQty", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InFruitsOrtQty * SOAP_FMAC4 soap_get___ns1__InFruitsOrtQty(struct soap *soap, struct __ns1__InFruitsOrtQty *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InFruitsOrtQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendTestResult(struct soap *soap, struct __ns1__sendTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendTestResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendTestResult(struct soap *soap, const struct __ns1__sendTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendTestResult(soap, &a->ns1__sendTestResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendTestResult(struct soap *soap, const char *tag, int id, const struct __ns1__sendTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendTestResult(soap, "ns1:sendTestResult", -1, &a->ns1__sendTestResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestResult * SOAP_FMAC4 soap_in___ns1__sendTestResult(struct soap *soap, const char *tag, struct __ns1__sendTestResult *a, const char *type)
{
	size_t soap_flag_ns1__sendTestResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendTestResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendTestResult, sizeof(struct __ns1__sendTestResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendTestResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendTestResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendTestResult(soap, "ns1:sendTestResult", &a->ns1__sendTestResult, ""))
				{	soap_flag_ns1__sendTestResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendTestResult * SOAP_FMAC2 soap_instantiate___ns1__sendTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendTestResult *p;
	size_t k = sizeof(struct __ns1__sendTestResult);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendTestResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendTestResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendTestResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendTestResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendTestResult(struct soap *soap, const struct __ns1__sendTestResult *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendTestResult(soap, tag ? tag : "-ns1:sendTestResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestResult * SOAP_FMAC4 soap_get___ns1__sendTestResult(struct soap *soap, struct __ns1__sendTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendTestData(struct soap *soap, struct __ns1__sendTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendTestData(struct soap *soap, const struct __ns1__sendTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__sendTestData(soap, &a->ns1__sendTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendTestData(struct soap *soap, const char *tag, int id, const struct __ns1__sendTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__sendTestData(soap, "ns1:sendTestData", -1, &a->ns1__sendTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestData * SOAP_FMAC4 soap_in___ns1__sendTestData(struct soap *soap, const char *tag, struct __ns1__sendTestData *a, const char *type)
{
	size_t soap_flag_ns1__sendTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendTestData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendTestData, sizeof(struct __ns1__sendTestData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendTestData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__sendTestData(soap, "ns1:sendTestData", &a->ns1__sendTestData, ""))
				{	soap_flag_ns1__sendTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__sendTestData * SOAP_FMAC2 soap_instantiate___ns1__sendTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__sendTestData *p;
	size_t k = sizeof(struct __ns1__sendTestData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__sendTestData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__sendTestData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__sendTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__sendTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendTestData(struct soap *soap, const struct __ns1__sendTestData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__sendTestData(soap, tag ? tag : "-ns1:sendTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTestData * SOAP_FMAC4 soap_get___ns1__sendTestData(struct soap *soap, struct __ns1__sendTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkSN_USCOREStation(struct soap *soap, struct __ns1__checkSN_USCOREStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkSN_USCOREStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkSN_USCOREStation(struct soap *soap, const struct __ns1__checkSN_USCOREStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkSN_USCOREStation(soap, &a->ns1__checkSN_USCOREStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkSN_USCOREStation(struct soap *soap, const char *tag, int id, const struct __ns1__checkSN_USCOREStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkSN_USCOREStation(soap, "ns1:checkSN_Station", -1, &a->ns1__checkSN_USCOREStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStation * SOAP_FMAC4 soap_in___ns1__checkSN_USCOREStation(struct soap *soap, const char *tag, struct __ns1__checkSN_USCOREStation *a, const char *type)
{
	size_t soap_flag_ns1__checkSN_USCOREStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkSN_USCOREStation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkSN_USCOREStation, sizeof(struct __ns1__checkSN_USCOREStation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkSN_USCOREStation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkSN_USCOREStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkSN_USCOREStation(soap, "ns1:checkSN_Station", &a->ns1__checkSN_USCOREStation, ""))
				{	soap_flag_ns1__checkSN_USCOREStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkSN_USCOREStation * SOAP_FMAC2 soap_instantiate___ns1__checkSN_USCOREStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkSN_USCOREStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkSN_USCOREStation *p;
	size_t k = sizeof(struct __ns1__checkSN_USCOREStation);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkSN_USCOREStation);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkSN_USCOREStation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkSN_USCOREStation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkSN_USCOREStation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkSN_USCOREStation(struct soap *soap, const struct __ns1__checkSN_USCOREStation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkSN_USCOREStation(soap, tag ? tag : "-ns1:checkSN_Station", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSN_USCOREStation * SOAP_FMAC4 soap_get___ns1__checkSN_USCOREStation(struct soap *soap, struct __ns1__checkSN_USCOREStation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkSN_USCOREStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkEmpNo(struct soap *soap, struct __ns1__checkEmpNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkEmpNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkEmpNo(struct soap *soap, const struct __ns1__checkEmpNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkEmpNo(soap, &a->ns1__checkEmpNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkEmpNo(struct soap *soap, const char *tag, int id, const struct __ns1__checkEmpNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkEmpNo(soap, "ns1:checkEmpNo", -1, &a->ns1__checkEmpNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpNo * SOAP_FMAC4 soap_in___ns1__checkEmpNo(struct soap *soap, const char *tag, struct __ns1__checkEmpNo *a, const char *type)
{
	size_t soap_flag_ns1__checkEmpNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkEmpNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkEmpNo, sizeof(struct __ns1__checkEmpNo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkEmpNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkEmpNo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkEmpNo(soap, "ns1:checkEmpNo", &a->ns1__checkEmpNo, ""))
				{	soap_flag_ns1__checkEmpNo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkEmpNo * SOAP_FMAC2 soap_instantiate___ns1__checkEmpNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkEmpNo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkEmpNo *p;
	size_t k = sizeof(struct __ns1__checkEmpNo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkEmpNo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkEmpNo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkEmpNo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkEmpNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkEmpNo(struct soap *soap, const struct __ns1__checkEmpNo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkEmpNo(soap, tag ? tag : "-ns1:checkEmpNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkEmpNo * SOAP_FMAC4 soap_get___ns1__checkEmpNo(struct soap *soap, struct __ns1__checkEmpNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkEmpNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkTestData(struct soap *soap, struct __ns1__checkTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkTestData(struct soap *soap, const struct __ns1__checkTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkTestData(soap, &a->ns1__checkTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkTestData(struct soap *soap, const char *tag, int id, const struct __ns1__checkTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkTestData(soap, "ns1:checkTestData", -1, &a->ns1__checkTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkTestData * SOAP_FMAC4 soap_in___ns1__checkTestData(struct soap *soap, const char *tag, struct __ns1__checkTestData *a, const char *type)
{
	size_t soap_flag_ns1__checkTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkTestData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkTestData, sizeof(struct __ns1__checkTestData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkTestData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkTestData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__checkTestData(soap, "ns1:checkTestData", &a->ns1__checkTestData, ""))
				{	soap_flag_ns1__checkTestData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkTestData * SOAP_FMAC2 soap_instantiate___ns1__checkTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkTestData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkTestData *p;
	size_t k = sizeof(struct __ns1__checkTestData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkTestData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkTestData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkTestData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkTestData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkTestData(struct soap *soap, const struct __ns1__checkTestData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkTestData(soap, tag ? tag : "-ns1:checkTestData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkTestData * SOAP_FMAC4 soap_get___ns1__checkTestData(struct soap *soap, struct __ns1__checkTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsZjList(struct soap *soap, struct __ns1__InsZjList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsZjList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsZjList(struct soap *soap, const struct __ns1__InsZjList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsZjList(soap, &a->ns1__InsZjList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsZjList(struct soap *soap, const char *tag, int id, const struct __ns1__InsZjList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsZjList(soap, "ns1:InsZjList", -1, &a->ns1__InsZjList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZjList * SOAP_FMAC4 soap_in___ns1__InsZjList(struct soap *soap, const char *tag, struct __ns1__InsZjList *a, const char *type)
{
	size_t soap_flag_ns1__InsZjList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsZjList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsZjList, sizeof(struct __ns1__InsZjList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsZjList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsZjList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsZjList(soap, "ns1:InsZjList", &a->ns1__InsZjList, ""))
				{	soap_flag_ns1__InsZjList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsZjList * SOAP_FMAC2 soap_instantiate___ns1__InsZjList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsZjList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsZjList *p;
	size_t k = sizeof(struct __ns1__InsZjList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsZjList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsZjList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsZjList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsZjList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsZjList(struct soap *soap, const struct __ns1__InsZjList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsZjList(soap, tag ? tag : "-ns1:InsZjList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsZjList * SOAP_FMAC4 soap_get___ns1__InsZjList(struct soap *soap, struct __ns1__InsZjList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsZjList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFruitMachineChk(struct soap *soap, struct __ns1__GetFruitMachineChk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFruitMachineChk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFruitMachineChk(struct soap *soap, const struct __ns1__GetFruitMachineChk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFruitMachineChk(soap, &a->ns1__GetFruitMachineChk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFruitMachineChk(struct soap *soap, const char *tag, int id, const struct __ns1__GetFruitMachineChk *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFruitMachineChk(soap, "ns1:GetFruitMachineChk", -1, &a->ns1__GetFruitMachineChk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitMachineChk * SOAP_FMAC4 soap_in___ns1__GetFruitMachineChk(struct soap *soap, const char *tag, struct __ns1__GetFruitMachineChk *a, const char *type)
{
	size_t soap_flag_ns1__GetFruitMachineChk = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFruitMachineChk *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFruitMachineChk, sizeof(struct __ns1__GetFruitMachineChk), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFruitMachineChk(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFruitMachineChk && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFruitMachineChk(soap, "ns1:GetFruitMachineChk", &a->ns1__GetFruitMachineChk, ""))
				{	soap_flag_ns1__GetFruitMachineChk--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFruitMachineChk * SOAP_FMAC2 soap_instantiate___ns1__GetFruitMachineChk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFruitMachineChk(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFruitMachineChk *p;
	size_t k = sizeof(struct __ns1__GetFruitMachineChk);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetFruitMachineChk);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetFruitMachineChk, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFruitMachineChk location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetFruitMachineChk, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFruitMachineChk(struct soap *soap, const struct __ns1__GetFruitMachineChk *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFruitMachineChk(soap, tag ? tag : "-ns1:GetFruitMachineChk", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitMachineChk * SOAP_FMAC4 soap_get___ns1__GetFruitMachineChk(struct soap *soap, struct __ns1__GetFruitMachineChk *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFruitMachineChk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsFruitMachineChk(struct soap *soap, struct __ns1__InsFruitMachineChk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsFruitMachineChk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsFruitMachineChk(struct soap *soap, const struct __ns1__InsFruitMachineChk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsFruitMachineChk(soap, &a->ns1__InsFruitMachineChk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsFruitMachineChk(struct soap *soap, const char *tag, int id, const struct __ns1__InsFruitMachineChk *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsFruitMachineChk(soap, "ns1:InsFruitMachineChk", -1, &a->ns1__InsFruitMachineChk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFruitMachineChk * SOAP_FMAC4 soap_in___ns1__InsFruitMachineChk(struct soap *soap, const char *tag, struct __ns1__InsFruitMachineChk *a, const char *type)
{
	size_t soap_flag_ns1__InsFruitMachineChk = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsFruitMachineChk *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsFruitMachineChk, sizeof(struct __ns1__InsFruitMachineChk), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsFruitMachineChk(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsFruitMachineChk && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsFruitMachineChk(soap, "ns1:InsFruitMachineChk", &a->ns1__InsFruitMachineChk, ""))
				{	soap_flag_ns1__InsFruitMachineChk--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsFruitMachineChk * SOAP_FMAC2 soap_instantiate___ns1__InsFruitMachineChk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsFruitMachineChk(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsFruitMachineChk *p;
	size_t k = sizeof(struct __ns1__InsFruitMachineChk);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsFruitMachineChk);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsFruitMachineChk, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsFruitMachineChk location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsFruitMachineChk, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsFruitMachineChk(struct soap *soap, const struct __ns1__InsFruitMachineChk *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsFruitMachineChk(soap, tag ? tag : "-ns1:InsFruitMachineChk", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsFruitMachineChk * SOAP_FMAC4 soap_get___ns1__InsFruitMachineChk(struct soap *soap, struct __ns1__InsFruitMachineChk *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsFruitMachineChk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SnLnkOutSN(struct soap *soap, struct __ns1__SnLnkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SnLnkOutSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SnLnkOutSN(struct soap *soap, const struct __ns1__SnLnkOutSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SnLnkOutSN(soap, &a->ns1__SnLnkOutSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SnLnkOutSN(struct soap *soap, const char *tag, int id, const struct __ns1__SnLnkOutSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SnLnkOutSN(soap, "ns1:SnLnkOutSN", -1, &a->ns1__SnLnkOutSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnLnkOutSN * SOAP_FMAC4 soap_in___ns1__SnLnkOutSN(struct soap *soap, const char *tag, struct __ns1__SnLnkOutSN *a, const char *type)
{
	size_t soap_flag_ns1__SnLnkOutSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SnLnkOutSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SnLnkOutSN, sizeof(struct __ns1__SnLnkOutSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SnLnkOutSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SnLnkOutSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SnLnkOutSN(soap, "ns1:SnLnkOutSN", &a->ns1__SnLnkOutSN, ""))
				{	soap_flag_ns1__SnLnkOutSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SnLnkOutSN * SOAP_FMAC2 soap_instantiate___ns1__SnLnkOutSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SnLnkOutSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SnLnkOutSN *p;
	size_t k = sizeof(struct __ns1__SnLnkOutSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SnLnkOutSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SnLnkOutSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SnLnkOutSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SnLnkOutSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SnLnkOutSN(struct soap *soap, const struct __ns1__SnLnkOutSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SnLnkOutSN(soap, tag ? tag : "-ns1:SnLnkOutSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnLnkOutSN * SOAP_FMAC4 soap_get___ns1__SnLnkOutSN(struct soap *soap, struct __ns1__SnLnkOutSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SnLnkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMoBase(struct soap *soap, struct __ns1__getMoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMoBase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMoBase(struct soap *soap, const struct __ns1__getMoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMoBase(soap, &a->ns1__getMoBase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMoBase(struct soap *soap, const char *tag, int id, const struct __ns1__getMoBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMoBase(soap, "ns1:getMoBase", -1, &a->ns1__getMoBase, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoBase * SOAP_FMAC4 soap_in___ns1__getMoBase(struct soap *soap, const char *tag, struct __ns1__getMoBase *a, const char *type)
{
	size_t soap_flag_ns1__getMoBase = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMoBase *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMoBase, sizeof(struct __ns1__getMoBase), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMoBase(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMoBase && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getMoBase(soap, "ns1:getMoBase", &a->ns1__getMoBase, ""))
				{	soap_flag_ns1__getMoBase--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMoBase * SOAP_FMAC2 soap_instantiate___ns1__getMoBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMoBase(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMoBase *p;
	size_t k = sizeof(struct __ns1__getMoBase);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMoBase);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMoBase, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMoBase location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMoBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMoBase(struct soap *soap, const struct __ns1__getMoBase *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMoBase(soap, tag ? tag : "-ns1:getMoBase", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMoBase * SOAP_FMAC4 soap_get___ns1__getMoBase(struct soap *soap, struct __ns1__getMoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetNgCode(struct soap *soap, struct __ns1__GetNgCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNgCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetNgCode(struct soap *soap, const struct __ns1__GetNgCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetNgCode(soap, &a->ns1__GetNgCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetNgCode(struct soap *soap, const char *tag, int id, const struct __ns1__GetNgCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetNgCode(soap, "ns1:GetNgCode", -1, &a->ns1__GetNgCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetNgCode * SOAP_FMAC4 soap_in___ns1__GetNgCode(struct soap *soap, const char *tag, struct __ns1__GetNgCode *a, const char *type)
{
	size_t soap_flag_ns1__GetNgCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetNgCode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetNgCode, sizeof(struct __ns1__GetNgCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetNgCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNgCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetNgCode(soap, "ns1:GetNgCode", &a->ns1__GetNgCode, ""))
				{	soap_flag_ns1__GetNgCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetNgCode * SOAP_FMAC2 soap_instantiate___ns1__GetNgCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetNgCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetNgCode *p;
	size_t k = sizeof(struct __ns1__GetNgCode);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetNgCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetNgCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetNgCode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetNgCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetNgCode(struct soap *soap, const struct __ns1__GetNgCode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetNgCode(soap, tag ? tag : "-ns1:GetNgCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetNgCode * SOAP_FMAC4 soap_get___ns1__GetNgCode(struct soap *soap, struct __ns1__GetNgCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetNgCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetDiecastSN(struct soap *soap, struct __ns1__SetDiecastSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetDiecastSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetDiecastSN(struct soap *soap, const struct __ns1__SetDiecastSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetDiecastSN(soap, &a->ns1__SetDiecastSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetDiecastSN(struct soap *soap, const char *tag, int id, const struct __ns1__SetDiecastSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetDiecastSN(soap, "ns1:SetDiecastSN", -1, &a->ns1__SetDiecastSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDiecastSN * SOAP_FMAC4 soap_in___ns1__SetDiecastSN(struct soap *soap, const char *tag, struct __ns1__SetDiecastSN *a, const char *type)
{
	size_t soap_flag_ns1__SetDiecastSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetDiecastSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetDiecastSN, sizeof(struct __ns1__SetDiecastSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetDiecastSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetDiecastSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetDiecastSN(soap, "ns1:SetDiecastSN", &a->ns1__SetDiecastSN, ""))
				{	soap_flag_ns1__SetDiecastSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetDiecastSN * SOAP_FMAC2 soap_instantiate___ns1__SetDiecastSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetDiecastSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetDiecastSN *p;
	size_t k = sizeof(struct __ns1__SetDiecastSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetDiecastSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetDiecastSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetDiecastSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetDiecastSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetDiecastSN(struct soap *soap, const struct __ns1__SetDiecastSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetDiecastSN(soap, tag ? tag : "-ns1:SetDiecastSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDiecastSN * SOAP_FMAC4 soap_get___ns1__SetDiecastSN(struct soap *soap, struct __ns1__SetDiecastSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetDiecastSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMachineForGroup(struct soap *soap, struct __ns1__GetMachineForGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMachineForGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMachineForGroup(struct soap *soap, const struct __ns1__GetMachineForGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMachineForGroup(soap, &a->ns1__GetMachineForGroup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMachineForGroup(struct soap *soap, const char *tag, int id, const struct __ns1__GetMachineForGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMachineForGroup(soap, "ns1:GetMachineForGroup", -1, &a->ns1__GetMachineForGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMachineForGroup * SOAP_FMAC4 soap_in___ns1__GetMachineForGroup(struct soap *soap, const char *tag, struct __ns1__GetMachineForGroup *a, const char *type)
{
	size_t soap_flag_ns1__GetMachineForGroup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMachineForGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMachineForGroup, sizeof(struct __ns1__GetMachineForGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMachineForGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMachineForGroup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMachineForGroup(soap, "ns1:GetMachineForGroup", &a->ns1__GetMachineForGroup, ""))
				{	soap_flag_ns1__GetMachineForGroup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMachineForGroup * SOAP_FMAC2 soap_instantiate___ns1__GetMachineForGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMachineForGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMachineForGroup *p;
	size_t k = sizeof(struct __ns1__GetMachineForGroup);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetMachineForGroup);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetMachineForGroup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMachineForGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetMachineForGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMachineForGroup(struct soap *soap, const struct __ns1__GetMachineForGroup *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMachineForGroup(soap, tag ? tag : "-ns1:GetMachineForGroup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMachineForGroup * SOAP_FMAC4 soap_get___ns1__GetMachineForGroup(struct soap *soap, struct __ns1__GetMachineForGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMachineForGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadForHP(struct soap *soap, struct __ns1__UploadForHP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadForHP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadForHP(struct soap *soap, const struct __ns1__UploadForHP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadForHP(soap, &a->ns1__UploadForHP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadForHP(struct soap *soap, const char *tag, int id, const struct __ns1__UploadForHP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadForHP(soap, "ns1:UploadForHP", -1, &a->ns1__UploadForHP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadForHP * SOAP_FMAC4 soap_in___ns1__UploadForHP(struct soap *soap, const char *tag, struct __ns1__UploadForHP *a, const char *type)
{
	size_t soap_flag_ns1__UploadForHP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadForHP *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadForHP, sizeof(struct __ns1__UploadForHP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadForHP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadForHP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UploadForHP(soap, "ns1:UploadForHP", &a->ns1__UploadForHP, ""))
				{	soap_flag_ns1__UploadForHP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UploadForHP * SOAP_FMAC2 soap_instantiate___ns1__UploadForHP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadForHP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UploadForHP *p;
	size_t k = sizeof(struct __ns1__UploadForHP);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UploadForHP);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UploadForHP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UploadForHP location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UploadForHP, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadForHP(struct soap *soap, const struct __ns1__UploadForHP *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UploadForHP(soap, tag ? tag : "-ns1:UploadForHP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadForHP * SOAP_FMAC4 soap_get___ns1__UploadForHP(struct soap *soap, struct __ns1__UploadForHP *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadForHP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelShelfLink(struct soap *soap, struct __ns1__SelShelfLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelShelfLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelShelfLink(struct soap *soap, const struct __ns1__SelShelfLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelShelfLink(soap, &a->ns1__SelShelfLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelShelfLink(struct soap *soap, const char *tag, int id, const struct __ns1__SelShelfLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelShelfLink(soap, "ns1:SelShelfLink", -1, &a->ns1__SelShelfLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelShelfLink * SOAP_FMAC4 soap_in___ns1__SelShelfLink(struct soap *soap, const char *tag, struct __ns1__SelShelfLink *a, const char *type)
{
	size_t soap_flag_ns1__SelShelfLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelShelfLink *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelShelfLink, sizeof(struct __ns1__SelShelfLink), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelShelfLink(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelShelfLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelShelfLink(soap, "ns1:SelShelfLink", &a->ns1__SelShelfLink, ""))
				{	soap_flag_ns1__SelShelfLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelShelfLink * SOAP_FMAC2 soap_instantiate___ns1__SelShelfLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelShelfLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelShelfLink *p;
	size_t k = sizeof(struct __ns1__SelShelfLink);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SelShelfLink);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SelShelfLink, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelShelfLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SelShelfLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelShelfLink(struct soap *soap, const struct __ns1__SelShelfLink *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelShelfLink(soap, tag ? tag : "-ns1:SelShelfLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelShelfLink * SOAP_FMAC4 soap_get___ns1__SelShelfLink(struct soap *soap, struct __ns1__SelShelfLink *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelShelfLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SNLinkShelf(struct soap *soap, struct __ns1__SNLinkShelf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SNLinkShelf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SNLinkShelf(struct soap *soap, const struct __ns1__SNLinkShelf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SNLinkShelf(soap, &a->ns1__SNLinkShelf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SNLinkShelf(struct soap *soap, const char *tag, int id, const struct __ns1__SNLinkShelf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SNLinkShelf(soap, "ns1:SNLinkShelf", -1, &a->ns1__SNLinkShelf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkShelf * SOAP_FMAC4 soap_in___ns1__SNLinkShelf(struct soap *soap, const char *tag, struct __ns1__SNLinkShelf *a, const char *type)
{
	size_t soap_flag_ns1__SNLinkShelf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SNLinkShelf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SNLinkShelf, sizeof(struct __ns1__SNLinkShelf), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SNLinkShelf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SNLinkShelf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SNLinkShelf(soap, "ns1:SNLinkShelf", &a->ns1__SNLinkShelf, ""))
				{	soap_flag_ns1__SNLinkShelf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SNLinkShelf * SOAP_FMAC2 soap_instantiate___ns1__SNLinkShelf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SNLinkShelf(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SNLinkShelf *p;
	size_t k = sizeof(struct __ns1__SNLinkShelf);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SNLinkShelf);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SNLinkShelf, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SNLinkShelf location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SNLinkShelf, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SNLinkShelf(struct soap *soap, const struct __ns1__SNLinkShelf *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SNLinkShelf(soap, tag ? tag : "-ns1:SNLinkShelf", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SNLinkShelf * SOAP_FMAC4 soap_get___ns1__SNLinkShelf(struct soap *soap, struct __ns1__SNLinkShelf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SNLinkShelf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelSNTestForFruit(struct soap *soap, struct __ns1__SelSNTestForFruit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelSNTestForFruit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelSNTestForFruit(struct soap *soap, const struct __ns1__SelSNTestForFruit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelSNTestForFruit(soap, &a->ns1__SelSNTestForFruit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelSNTestForFruit(struct soap *soap, const char *tag, int id, const struct __ns1__SelSNTestForFruit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelSNTestForFruit(soap, "ns1:SelSNTestForFruit", -1, &a->ns1__SelSNTestForFruit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTestForFruit * SOAP_FMAC4 soap_in___ns1__SelSNTestForFruit(struct soap *soap, const char *tag, struct __ns1__SelSNTestForFruit *a, const char *type)
{
	size_t soap_flag_ns1__SelSNTestForFruit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelSNTestForFruit *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelSNTestForFruit, sizeof(struct __ns1__SelSNTestForFruit), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelSNTestForFruit(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelSNTestForFruit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelSNTestForFruit(soap, "ns1:SelSNTestForFruit", &a->ns1__SelSNTestForFruit, ""))
				{	soap_flag_ns1__SelSNTestForFruit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelSNTestForFruit * SOAP_FMAC2 soap_instantiate___ns1__SelSNTestForFruit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelSNTestForFruit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelSNTestForFruit *p;
	size_t k = sizeof(struct __ns1__SelSNTestForFruit);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SelSNTestForFruit);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SelSNTestForFruit, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelSNTestForFruit location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SelSNTestForFruit, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelSNTestForFruit(struct soap *soap, const struct __ns1__SelSNTestForFruit *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelSNTestForFruit(soap, tag ? tag : "-ns1:SelSNTestForFruit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTestForFruit * SOAP_FMAC4 soap_get___ns1__SelSNTestForFruit(struct soap *soap, struct __ns1__SelSNTestForFruit *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelSNTestForFruit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsSNTestForFruit(struct soap *soap, struct __ns1__InsSNTestForFruit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsSNTestForFruit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsSNTestForFruit(struct soap *soap, const struct __ns1__InsSNTestForFruit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsSNTestForFruit(soap, &a->ns1__InsSNTestForFruit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsSNTestForFruit(struct soap *soap, const char *tag, int id, const struct __ns1__InsSNTestForFruit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsSNTestForFruit(soap, "ns1:InsSNTestForFruit", -1, &a->ns1__InsSNTestForFruit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTestForFruit * SOAP_FMAC4 soap_in___ns1__InsSNTestForFruit(struct soap *soap, const char *tag, struct __ns1__InsSNTestForFruit *a, const char *type)
{
	size_t soap_flag_ns1__InsSNTestForFruit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsSNTestForFruit *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsSNTestForFruit, sizeof(struct __ns1__InsSNTestForFruit), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsSNTestForFruit(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsSNTestForFruit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsSNTestForFruit(soap, "ns1:InsSNTestForFruit", &a->ns1__InsSNTestForFruit, ""))
				{	soap_flag_ns1__InsSNTestForFruit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsSNTestForFruit * SOAP_FMAC2 soap_instantiate___ns1__InsSNTestForFruit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsSNTestForFruit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsSNTestForFruit *p;
	size_t k = sizeof(struct __ns1__InsSNTestForFruit);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsSNTestForFruit);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsSNTestForFruit, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsSNTestForFruit location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsSNTestForFruit, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsSNTestForFruit(struct soap *soap, const struct __ns1__InsSNTestForFruit *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsSNTestForFruit(soap, tag ? tag : "-ns1:InsSNTestForFruit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTestForFruit * SOAP_FMAC4 soap_get___ns1__InsSNTestForFruit(struct soap *soap, struct __ns1__InsSNTestForFruit *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsSNTestForFruit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStationNumberForSN(struct soap *soap, struct __ns1__GetStationNumberForSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStationNumberForSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStationNumberForSN(struct soap *soap, const struct __ns1__GetStationNumberForSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetStationNumberForSN(soap, &a->ns1__GetStationNumberForSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStationNumberForSN(struct soap *soap, const char *tag, int id, const struct __ns1__GetStationNumberForSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetStationNumberForSN(soap, "ns1:GetStationNumberForSN", -1, &a->ns1__GetStationNumberForSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationNumberForSN * SOAP_FMAC4 soap_in___ns1__GetStationNumberForSN(struct soap *soap, const char *tag, struct __ns1__GetStationNumberForSN *a, const char *type)
{
	size_t soap_flag_ns1__GetStationNumberForSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetStationNumberForSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStationNumberForSN, sizeof(struct __ns1__GetStationNumberForSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStationNumberForSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStationNumberForSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetStationNumberForSN(soap, "ns1:GetStationNumberForSN", &a->ns1__GetStationNumberForSN, ""))
				{	soap_flag_ns1__GetStationNumberForSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetStationNumberForSN * SOAP_FMAC2 soap_instantiate___ns1__GetStationNumberForSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStationNumberForSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetStationNumberForSN *p;
	size_t k = sizeof(struct __ns1__GetStationNumberForSN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetStationNumberForSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetStationNumberForSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetStationNumberForSN location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetStationNumberForSN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStationNumberForSN(struct soap *soap, const struct __ns1__GetStationNumberForSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetStationNumberForSN(soap, tag ? tag : "-ns1:GetStationNumberForSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationNumberForSN * SOAP_FMAC4 soap_get___ns1__GetStationNumberForSN(struct soap *soap, struct __ns1__GetStationNumberForSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStationNumberForSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTestValueResult(struct soap *soap, struct __ns1__GetTestValueResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTestValueResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTestValueResult(struct soap *soap, const struct __ns1__GetTestValueResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTestValueResult(soap, &a->ns1__GetTestValueResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTestValueResult(struct soap *soap, const char *tag, int id, const struct __ns1__GetTestValueResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTestValueResult(soap, "ns1:GetTestValueResult", -1, &a->ns1__GetTestValueResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValueResult * SOAP_FMAC4 soap_in___ns1__GetTestValueResult(struct soap *soap, const char *tag, struct __ns1__GetTestValueResult *a, const char *type)
{
	size_t soap_flag_ns1__GetTestValueResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTestValueResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTestValueResult, sizeof(struct __ns1__GetTestValueResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTestValueResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTestValueResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTestValueResult(soap, "ns1:GetTestValueResult", &a->ns1__GetTestValueResult, ""))
				{	soap_flag_ns1__GetTestValueResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTestValueResult * SOAP_FMAC2 soap_instantiate___ns1__GetTestValueResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTestValueResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTestValueResult *p;
	size_t k = sizeof(struct __ns1__GetTestValueResult);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetTestValueResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetTestValueResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTestValueResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetTestValueResult, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTestValueResult(struct soap *soap, const struct __ns1__GetTestValueResult *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTestValueResult(soap, tag ? tag : "-ns1:GetTestValueResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTestValueResult * SOAP_FMAC4 soap_get___ns1__GetTestValueResult(struct soap *soap, struct __ns1__GetTestValueResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTestValueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsCLScada(struct soap *soap, struct __ns1__InsCLScada *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsCLScada = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsCLScada(struct soap *soap, const struct __ns1__InsCLScada *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsCLScada(soap, &a->ns1__InsCLScada);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsCLScada(struct soap *soap, const char *tag, int id, const struct __ns1__InsCLScada *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsCLScada(soap, "ns1:InsCLScada", -1, &a->ns1__InsCLScada, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsCLScada * SOAP_FMAC4 soap_in___ns1__InsCLScada(struct soap *soap, const char *tag, struct __ns1__InsCLScada *a, const char *type)
{
	size_t soap_flag_ns1__InsCLScada = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsCLScada *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsCLScada, sizeof(struct __ns1__InsCLScada), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsCLScada(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsCLScada && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsCLScada(soap, "ns1:InsCLScada", &a->ns1__InsCLScada, ""))
				{	soap_flag_ns1__InsCLScada--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsCLScada * SOAP_FMAC2 soap_instantiate___ns1__InsCLScada(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsCLScada(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsCLScada *p;
	size_t k = sizeof(struct __ns1__InsCLScada);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsCLScada);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsCLScada, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsCLScada location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsCLScada, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsCLScada(struct soap *soap, const struct __ns1__InsCLScada *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsCLScada(soap, tag ? tag : "-ns1:InsCLScada", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsCLScada * SOAP_FMAC4 soap_get___ns1__InsCLScada(struct soap *soap, struct __ns1__InsCLScada *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsCLScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsAoiMo(struct soap *soap, struct __ns1__InsAoiMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsAoiMo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsAoiMo(struct soap *soap, const struct __ns1__InsAoiMo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsAoiMo(soap, &a->ns1__InsAoiMo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsAoiMo(struct soap *soap, const char *tag, int id, const struct __ns1__InsAoiMo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsAoiMo(soap, "ns1:InsAoiMo", -1, &a->ns1__InsAoiMo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsAoiMo * SOAP_FMAC4 soap_in___ns1__InsAoiMo(struct soap *soap, const char *tag, struct __ns1__InsAoiMo *a, const char *type)
{
	size_t soap_flag_ns1__InsAoiMo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsAoiMo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsAoiMo, sizeof(struct __ns1__InsAoiMo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsAoiMo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsAoiMo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsAoiMo(soap, "ns1:InsAoiMo", &a->ns1__InsAoiMo, ""))
				{	soap_flag_ns1__InsAoiMo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsAoiMo * SOAP_FMAC2 soap_instantiate___ns1__InsAoiMo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsAoiMo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsAoiMo *p;
	size_t k = sizeof(struct __ns1__InsAoiMo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsAoiMo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsAoiMo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsAoiMo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsAoiMo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsAoiMo(struct soap *soap, const struct __ns1__InsAoiMo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsAoiMo(soap, tag ? tag : "-ns1:InsAoiMo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsAoiMo * SOAP_FMAC4 soap_get___ns1__InsAoiMo(struct soap *soap, struct __ns1__InsAoiMo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsAoiMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__chkMoSNForAOI(struct soap *soap, struct __ns1__chkMoSNForAOI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__chkMoSNForAOI = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__chkMoSNForAOI(struct soap *soap, const struct __ns1__chkMoSNForAOI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__chkMoSNForAOI(soap, &a->ns1__chkMoSNForAOI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__chkMoSNForAOI(struct soap *soap, const char *tag, int id, const struct __ns1__chkMoSNForAOI *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__chkMoSNForAOI(soap, "ns1:chkMoSNForAOI", -1, &a->ns1__chkMoSNForAOI, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoSNForAOI * SOAP_FMAC4 soap_in___ns1__chkMoSNForAOI(struct soap *soap, const char *tag, struct __ns1__chkMoSNForAOI *a, const char *type)
{
	size_t soap_flag_ns1__chkMoSNForAOI = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__chkMoSNForAOI *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__chkMoSNForAOI, sizeof(struct __ns1__chkMoSNForAOI), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__chkMoSNForAOI(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__chkMoSNForAOI && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__chkMoSNForAOI(soap, "ns1:chkMoSNForAOI", &a->ns1__chkMoSNForAOI, ""))
				{	soap_flag_ns1__chkMoSNForAOI--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__chkMoSNForAOI * SOAP_FMAC2 soap_instantiate___ns1__chkMoSNForAOI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__chkMoSNForAOI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__chkMoSNForAOI *p;
	size_t k = sizeof(struct __ns1__chkMoSNForAOI);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__chkMoSNForAOI);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__chkMoSNForAOI, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__chkMoSNForAOI location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__chkMoSNForAOI, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__chkMoSNForAOI(struct soap *soap, const struct __ns1__chkMoSNForAOI *a, const char *tag, const char *type)
{
	if (soap_out___ns1__chkMoSNForAOI(soap, tag ? tag : "-ns1:chkMoSNForAOI", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__chkMoSNForAOI * SOAP_FMAC4 soap_get___ns1__chkMoSNForAOI(struct soap *soap, struct __ns1__chkMoSNForAOI *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__chkMoSNForAOI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PunchOut(struct soap *soap, struct __ns1__PunchOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PunchOut = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PunchOut(struct soap *soap, const struct __ns1__PunchOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PunchOut(soap, &a->ns1__PunchOut);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PunchOut(struct soap *soap, const char *tag, int id, const struct __ns1__PunchOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PunchOut(soap, "ns1:PunchOut", -1, &a->ns1__PunchOut, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PunchOut * SOAP_FMAC4 soap_in___ns1__PunchOut(struct soap *soap, const char *tag, struct __ns1__PunchOut *a, const char *type)
{
	size_t soap_flag_ns1__PunchOut = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__PunchOut *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PunchOut, sizeof(struct __ns1__PunchOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PunchOut(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PunchOut && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__PunchOut(soap, "ns1:PunchOut", &a->ns1__PunchOut, ""))
				{	soap_flag_ns1__PunchOut--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__PunchOut * SOAP_FMAC2 soap_instantiate___ns1__PunchOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PunchOut(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__PunchOut *p;
	size_t k = sizeof(struct __ns1__PunchOut);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__PunchOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__PunchOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__PunchOut location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__PunchOut, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PunchOut(struct soap *soap, const struct __ns1__PunchOut *a, const char *tag, const char *type)
{
	if (soap_out___ns1__PunchOut(soap, tag ? tag : "-ns1:PunchOut", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PunchOut * SOAP_FMAC4 soap_get___ns1__PunchOut(struct soap *soap, struct __ns1__PunchOut *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PunchOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BasketLinkPunch(struct soap *soap, struct __ns1__BasketLinkPunch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BasketLinkPunch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BasketLinkPunch(struct soap *soap, const struct __ns1__BasketLinkPunch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BasketLinkPunch(soap, &a->ns1__BasketLinkPunch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BasketLinkPunch(struct soap *soap, const char *tag, int id, const struct __ns1__BasketLinkPunch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BasketLinkPunch(soap, "ns1:BasketLinkPunch", -1, &a->ns1__BasketLinkPunch, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BasketLinkPunch * SOAP_FMAC4 soap_in___ns1__BasketLinkPunch(struct soap *soap, const char *tag, struct __ns1__BasketLinkPunch *a, const char *type)
{
	size_t soap_flag_ns1__BasketLinkPunch = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BasketLinkPunch *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BasketLinkPunch, sizeof(struct __ns1__BasketLinkPunch), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BasketLinkPunch(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BasketLinkPunch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BasketLinkPunch(soap, "ns1:BasketLinkPunch", &a->ns1__BasketLinkPunch, ""))
				{	soap_flag_ns1__BasketLinkPunch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BasketLinkPunch * SOAP_FMAC2 soap_instantiate___ns1__BasketLinkPunch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BasketLinkPunch(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BasketLinkPunch *p;
	size_t k = sizeof(struct __ns1__BasketLinkPunch);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BasketLinkPunch);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BasketLinkPunch, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BasketLinkPunch location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BasketLinkPunch, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BasketLinkPunch(struct soap *soap, const struct __ns1__BasketLinkPunch *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BasketLinkPunch(soap, tag ? tag : "-ns1:BasketLinkPunch", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BasketLinkPunch * SOAP_FMAC4 soap_get___ns1__BasketLinkPunch(struct soap *soap, struct __ns1__BasketLinkPunch *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BasketLinkPunch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__HPSNLinkBasket(struct soap *soap, struct __ns1__HPSNLinkBasket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HPSNLinkBasket = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__HPSNLinkBasket(struct soap *soap, const struct __ns1__HPSNLinkBasket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__HPSNLinkBasket(soap, &a->ns1__HPSNLinkBasket);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__HPSNLinkBasket(struct soap *soap, const char *tag, int id, const struct __ns1__HPSNLinkBasket *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__HPSNLinkBasket(soap, "ns1:HPSNLinkBasket", -1, &a->ns1__HPSNLinkBasket, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HPSNLinkBasket * SOAP_FMAC4 soap_in___ns1__HPSNLinkBasket(struct soap *soap, const char *tag, struct __ns1__HPSNLinkBasket *a, const char *type)
{
	size_t soap_flag_ns1__HPSNLinkBasket = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__HPSNLinkBasket *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__HPSNLinkBasket, sizeof(struct __ns1__HPSNLinkBasket), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__HPSNLinkBasket(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HPSNLinkBasket && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__HPSNLinkBasket(soap, "ns1:HPSNLinkBasket", &a->ns1__HPSNLinkBasket, ""))
				{	soap_flag_ns1__HPSNLinkBasket--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__HPSNLinkBasket * SOAP_FMAC2 soap_instantiate___ns1__HPSNLinkBasket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__HPSNLinkBasket(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__HPSNLinkBasket *p;
	size_t k = sizeof(struct __ns1__HPSNLinkBasket);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__HPSNLinkBasket);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__HPSNLinkBasket, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__HPSNLinkBasket location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__HPSNLinkBasket, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__HPSNLinkBasket(struct soap *soap, const struct __ns1__HPSNLinkBasket *a, const char *tag, const char *type)
{
	if (soap_out___ns1__HPSNLinkBasket(soap, tag ? tag : "-ns1:HPSNLinkBasket", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HPSNLinkBasket * SOAP_FMAC4 soap_get___ns1__HPSNLinkBasket(struct soap *soap, struct __ns1__HPSNLinkBasket *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__HPSNLinkBasket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetAutoLineRec(struct soap *soap, struct __ns1__SetAutoLineRec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetAutoLineRec = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetAutoLineRec(struct soap *soap, const struct __ns1__SetAutoLineRec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetAutoLineRec(soap, &a->ns1__SetAutoLineRec);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetAutoLineRec(struct soap *soap, const char *tag, int id, const struct __ns1__SetAutoLineRec *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetAutoLineRec(soap, "ns1:SetAutoLineRec", -1, &a->ns1__SetAutoLineRec, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetAutoLineRec * SOAP_FMAC4 soap_in___ns1__SetAutoLineRec(struct soap *soap, const char *tag, struct __ns1__SetAutoLineRec *a, const char *type)
{
	size_t soap_flag_ns1__SetAutoLineRec = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetAutoLineRec *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetAutoLineRec, sizeof(struct __ns1__SetAutoLineRec), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetAutoLineRec(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetAutoLineRec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetAutoLineRec(soap, "ns1:SetAutoLineRec", &a->ns1__SetAutoLineRec, ""))
				{	soap_flag_ns1__SetAutoLineRec--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetAutoLineRec * SOAP_FMAC2 soap_instantiate___ns1__SetAutoLineRec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetAutoLineRec(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetAutoLineRec *p;
	size_t k = sizeof(struct __ns1__SetAutoLineRec);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetAutoLineRec);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetAutoLineRec, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetAutoLineRec location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetAutoLineRec, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetAutoLineRec(struct soap *soap, const struct __ns1__SetAutoLineRec *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetAutoLineRec(soap, tag ? tag : "-ns1:SetAutoLineRec", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetAutoLineRec * SOAP_FMAC4 soap_get___ns1__SetAutoLineRec(struct soap *soap, struct __ns1__SetAutoLineRec *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetAutoLineRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSNForLink(struct soap *soap, struct __ns1__GetSNForLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSNForLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSNForLink(struct soap *soap, const struct __ns1__GetSNForLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetSNForLink(soap, &a->ns1__GetSNForLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSNForLink(struct soap *soap, const char *tag, int id, const struct __ns1__GetSNForLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetSNForLink(soap, "ns1:GetSNForLink", -1, &a->ns1__GetSNForLink, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSNForLink * SOAP_FMAC4 soap_in___ns1__GetSNForLink(struct soap *soap, const char *tag, struct __ns1__GetSNForLink *a, const char *type)
{
	size_t soap_flag_ns1__GetSNForLink = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetSNForLink *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSNForLink, sizeof(struct __ns1__GetSNForLink), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSNForLink(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSNForLink && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetSNForLink(soap, "ns1:GetSNForLink", &a->ns1__GetSNForLink, ""))
				{	soap_flag_ns1__GetSNForLink--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetSNForLink * SOAP_FMAC2 soap_instantiate___ns1__GetSNForLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSNForLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetSNForLink *p;
	size_t k = sizeof(struct __ns1__GetSNForLink);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetSNForLink);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetSNForLink, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetSNForLink location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetSNForLink, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSNForLink(struct soap *soap, const struct __ns1__GetSNForLink *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetSNForLink(soap, tag ? tag : "-ns1:GetSNForLink", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSNForLink * SOAP_FMAC4 soap_get___ns1__GetSNForLink(struct soap *soap, struct __ns1__GetSNForLink *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSNForLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetFlatnessFruitRec(struct soap *soap, struct __ns1__SetFlatnessFruitRec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetFlatnessFruitRec = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetFlatnessFruitRec(struct soap *soap, const struct __ns1__SetFlatnessFruitRec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetFlatnessFruitRec(soap, &a->ns1__SetFlatnessFruitRec);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetFlatnessFruitRec(struct soap *soap, const char *tag, int id, const struct __ns1__SetFlatnessFruitRec *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetFlatnessFruitRec(soap, "ns1:SetFlatnessFruitRec", -1, &a->ns1__SetFlatnessFruitRec, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFlatnessFruitRec * SOAP_FMAC4 soap_in___ns1__SetFlatnessFruitRec(struct soap *soap, const char *tag, struct __ns1__SetFlatnessFruitRec *a, const char *type)
{
	size_t soap_flag_ns1__SetFlatnessFruitRec = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetFlatnessFruitRec *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetFlatnessFruitRec, sizeof(struct __ns1__SetFlatnessFruitRec), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetFlatnessFruitRec(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetFlatnessFruitRec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetFlatnessFruitRec(soap, "ns1:SetFlatnessFruitRec", &a->ns1__SetFlatnessFruitRec, ""))
				{	soap_flag_ns1__SetFlatnessFruitRec--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetFlatnessFruitRec * SOAP_FMAC2 soap_instantiate___ns1__SetFlatnessFruitRec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetFlatnessFruitRec(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetFlatnessFruitRec *p;
	size_t k = sizeof(struct __ns1__SetFlatnessFruitRec);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SetFlatnessFruitRec);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SetFlatnessFruitRec, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetFlatnessFruitRec location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SetFlatnessFruitRec, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetFlatnessFruitRec(struct soap *soap, const struct __ns1__SetFlatnessFruitRec *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetFlatnessFruitRec(soap, tag ? tag : "-ns1:SetFlatnessFruitRec", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFlatnessFruitRec * SOAP_FMAC4 soap_get___ns1__SetFlatnessFruitRec(struct soap *soap, struct __ns1__SetFlatnessFruitRec *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetFlatnessFruitRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStationByMoForTestPad(struct soap *soap, struct __ns1__getStationByMoForTestPad *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStationByMoForTestPad = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStationByMoForTestPad(struct soap *soap, const struct __ns1__getStationByMoForTestPad *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getStationByMoForTestPad(soap, &a->ns1__getStationByMoForTestPad);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStationByMoForTestPad(struct soap *soap, const char *tag, int id, const struct __ns1__getStationByMoForTestPad *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getStationByMoForTestPad(soap, "ns1:getStationByMoForTestPad", -1, &a->ns1__getStationByMoForTestPad, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMoForTestPad * SOAP_FMAC4 soap_in___ns1__getStationByMoForTestPad(struct soap *soap, const char *tag, struct __ns1__getStationByMoForTestPad *a, const char *type)
{
	size_t soap_flag_ns1__getStationByMoForTestPad = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getStationByMoForTestPad *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStationByMoForTestPad, sizeof(struct __ns1__getStationByMoForTestPad), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStationByMoForTestPad(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStationByMoForTestPad && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getStationByMoForTestPad(soap, "ns1:getStationByMoForTestPad", &a->ns1__getStationByMoForTestPad, ""))
				{	soap_flag_ns1__getStationByMoForTestPad--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getStationByMoForTestPad * SOAP_FMAC2 soap_instantiate___ns1__getStationByMoForTestPad(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStationByMoForTestPad(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getStationByMoForTestPad *p;
	size_t k = sizeof(struct __ns1__getStationByMoForTestPad);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getStationByMoForTestPad);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getStationByMoForTestPad, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getStationByMoForTestPad location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getStationByMoForTestPad, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStationByMoForTestPad(struct soap *soap, const struct __ns1__getStationByMoForTestPad *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getStationByMoForTestPad(soap, tag ? tag : "-ns1:getStationByMoForTestPad", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStationByMoForTestPad * SOAP_FMAC4 soap_get___ns1__getStationByMoForTestPad(struct soap *soap, struct __ns1__getStationByMoForTestPad *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStationByMoForTestPad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingWeight(struct soap *soap, struct __ns1__GetShippingWeight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingWeight = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingWeight(struct soap *soap, const struct __ns1__GetShippingWeight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingWeight(soap, &a->ns1__GetShippingWeight);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingWeight(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingWeight *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingWeight(soap, "ns1:GetShippingWeight", -1, &a->ns1__GetShippingWeight, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingWeight * SOAP_FMAC4 soap_in___ns1__GetShippingWeight(struct soap *soap, const char *tag, struct __ns1__GetShippingWeight *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingWeight = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingWeight *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingWeight, sizeof(struct __ns1__GetShippingWeight), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingWeight(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingWeight && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingWeight(soap, "ns1:GetShippingWeight", &a->ns1__GetShippingWeight, ""))
				{	soap_flag_ns1__GetShippingWeight--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingWeight * SOAP_FMAC2 soap_instantiate___ns1__GetShippingWeight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingWeight(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingWeight *p;
	size_t k = sizeof(struct __ns1__GetShippingWeight);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingWeight);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingWeight, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingWeight location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingWeight, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingWeight(struct soap *soap, const struct __ns1__GetShippingWeight *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingWeight(soap, tag ? tag : "-ns1:GetShippingWeight", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingWeight * SOAP_FMAC4 soap_get___ns1__GetShippingWeight(struct soap *soap, struct __ns1__GetShippingWeight *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingWeight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingForBerth(struct soap *soap, struct __ns1__GetShippingForBerth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingForBerth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingForBerth(struct soap *soap, const struct __ns1__GetShippingForBerth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingForBerth(soap, &a->ns1__GetShippingForBerth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingForBerth(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingForBerth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingForBerth(soap, "ns1:GetShippingForBerth", -1, &a->ns1__GetShippingForBerth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingForBerth * SOAP_FMAC4 soap_in___ns1__GetShippingForBerth(struct soap *soap, const char *tag, struct __ns1__GetShippingForBerth *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingForBerth = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingForBerth *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingForBerth, sizeof(struct __ns1__GetShippingForBerth), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingForBerth(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingForBerth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingForBerth(soap, "ns1:GetShippingForBerth", &a->ns1__GetShippingForBerth, ""))
				{	soap_flag_ns1__GetShippingForBerth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingForBerth * SOAP_FMAC2 soap_instantiate___ns1__GetShippingForBerth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingForBerth(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingForBerth *p;
	size_t k = sizeof(struct __ns1__GetShippingForBerth);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingForBerth);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingForBerth, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingForBerth location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingForBerth, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingForBerth(struct soap *soap, const struct __ns1__GetShippingForBerth *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingForBerth(soap, tag ? tag : "-ns1:GetShippingForBerth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingForBerth * SOAP_FMAC4 soap_get___ns1__GetShippingForBerth(struct soap *soap, struct __ns1__GetShippingForBerth *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingForBerth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsShippingBerth(struct soap *soap, struct __ns1__InsShippingBerth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsShippingBerth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsShippingBerth(struct soap *soap, const struct __ns1__InsShippingBerth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsShippingBerth(soap, &a->ns1__InsShippingBerth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsShippingBerth(struct soap *soap, const char *tag, int id, const struct __ns1__InsShippingBerth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsShippingBerth(soap, "ns1:InsShippingBerth", -1, &a->ns1__InsShippingBerth, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingBerth * SOAP_FMAC4 soap_in___ns1__InsShippingBerth(struct soap *soap, const char *tag, struct __ns1__InsShippingBerth *a, const char *type)
{
	size_t soap_flag_ns1__InsShippingBerth = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsShippingBerth *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsShippingBerth, sizeof(struct __ns1__InsShippingBerth), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsShippingBerth(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsShippingBerth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsShippingBerth(soap, "ns1:InsShippingBerth", &a->ns1__InsShippingBerth, ""))
				{	soap_flag_ns1__InsShippingBerth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsShippingBerth * SOAP_FMAC2 soap_instantiate___ns1__InsShippingBerth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsShippingBerth(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsShippingBerth *p;
	size_t k = sizeof(struct __ns1__InsShippingBerth);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsShippingBerth);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsShippingBerth, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsShippingBerth location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsShippingBerth, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsShippingBerth(struct soap *soap, const struct __ns1__InsShippingBerth *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsShippingBerth(soap, tag ? tag : "-ns1:InsShippingBerth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingBerth * SOAP_FMAC4 soap_get___ns1__InsShippingBerth(struct soap *soap, struct __ns1__InsShippingBerth *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsShippingBerth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsShippingPalle(struct soap *soap, struct __ns1__InsShippingPalle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsShippingPalle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsShippingPalle(struct soap *soap, const struct __ns1__InsShippingPalle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsShippingPalle(soap, &a->ns1__InsShippingPalle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsShippingPalle(struct soap *soap, const char *tag, int id, const struct __ns1__InsShippingPalle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsShippingPalle(soap, "ns1:InsShippingPalle", -1, &a->ns1__InsShippingPalle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingPalle * SOAP_FMAC4 soap_in___ns1__InsShippingPalle(struct soap *soap, const char *tag, struct __ns1__InsShippingPalle *a, const char *type)
{
	size_t soap_flag_ns1__InsShippingPalle = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsShippingPalle *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsShippingPalle, sizeof(struct __ns1__InsShippingPalle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsShippingPalle(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsShippingPalle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsShippingPalle(soap, "ns1:InsShippingPalle", &a->ns1__InsShippingPalle, ""))
				{	soap_flag_ns1__InsShippingPalle--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsShippingPalle * SOAP_FMAC2 soap_instantiate___ns1__InsShippingPalle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsShippingPalle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsShippingPalle *p;
	size_t k = sizeof(struct __ns1__InsShippingPalle);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsShippingPalle);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsShippingPalle, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsShippingPalle location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsShippingPalle, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsShippingPalle(struct soap *soap, const struct __ns1__InsShippingPalle *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsShippingPalle(soap, tag ? tag : "-ns1:InsShippingPalle", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsShippingPalle * SOAP_FMAC4 soap_get___ns1__InsShippingPalle(struct soap *soap, struct __ns1__InsShippingPalle *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsShippingPalle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingPalle(struct soap *soap, struct __ns1__GetShippingPalle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingPalle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingPalle(struct soap *soap, const struct __ns1__GetShippingPalle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingPalle(soap, &a->ns1__GetShippingPalle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingPalle(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingPalle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingPalle(soap, "ns1:GetShippingPalle", -1, &a->ns1__GetShippingPalle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingPalle * SOAP_FMAC4 soap_in___ns1__GetShippingPalle(struct soap *soap, const char *tag, struct __ns1__GetShippingPalle *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingPalle = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingPalle *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingPalle, sizeof(struct __ns1__GetShippingPalle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingPalle(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingPalle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingPalle(soap, "ns1:GetShippingPalle", &a->ns1__GetShippingPalle, ""))
				{	soap_flag_ns1__GetShippingPalle--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingPalle * SOAP_FMAC2 soap_instantiate___ns1__GetShippingPalle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingPalle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingPalle *p;
	size_t k = sizeof(struct __ns1__GetShippingPalle);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingPalle);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingPalle, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingPalle location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingPalle, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingPalle(struct soap *soap, const struct __ns1__GetShippingPalle *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingPalle(soap, tag ? tag : "-ns1:GetShippingPalle", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingPalle * SOAP_FMAC4 soap_get___ns1__GetShippingPalle(struct soap *soap, struct __ns1__GetShippingPalle *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingPalle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdShipping(struct soap *soap, struct __ns1__UpdShipping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdShipping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdShipping(struct soap *soap, const struct __ns1__UpdShipping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdShipping(soap, &a->ns1__UpdShipping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdShipping(struct soap *soap, const char *tag, int id, const struct __ns1__UpdShipping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdShipping(soap, "ns1:UpdShipping", -1, &a->ns1__UpdShipping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdShipping * SOAP_FMAC4 soap_in___ns1__UpdShipping(struct soap *soap, const char *tag, struct __ns1__UpdShipping *a, const char *type)
{
	size_t soap_flag_ns1__UpdShipping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdShipping *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdShipping, sizeof(struct __ns1__UpdShipping), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdShipping(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdShipping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdShipping(soap, "ns1:UpdShipping", &a->ns1__UpdShipping, ""))
				{	soap_flag_ns1__UpdShipping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdShipping * SOAP_FMAC2 soap_instantiate___ns1__UpdShipping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdShipping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdShipping *p;
	size_t k = sizeof(struct __ns1__UpdShipping);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdShipping);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdShipping, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdShipping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UpdShipping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdShipping(struct soap *soap, const struct __ns1__UpdShipping *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdShipping(soap, tag ? tag : "-ns1:UpdShipping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdShipping * SOAP_FMAC4 soap_get___ns1__UpdShipping(struct soap *soap, struct __ns1__UpdShipping *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdShipping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingBerthList(struct soap *soap, struct __ns1__GetShippingBerthList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingBerthList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingBerthList(struct soap *soap, const struct __ns1__GetShippingBerthList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingBerthList(soap, &a->ns1__GetShippingBerthList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingBerthList(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingBerthList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingBerthList(soap, "ns1:GetShippingBerthList", -1, &a->ns1__GetShippingBerthList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingBerthList * SOAP_FMAC4 soap_in___ns1__GetShippingBerthList(struct soap *soap, const char *tag, struct __ns1__GetShippingBerthList *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingBerthList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingBerthList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingBerthList, sizeof(struct __ns1__GetShippingBerthList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingBerthList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingBerthList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingBerthList(soap, "ns1:GetShippingBerthList", &a->ns1__GetShippingBerthList, ""))
				{	soap_flag_ns1__GetShippingBerthList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingBerthList * SOAP_FMAC2 soap_instantiate___ns1__GetShippingBerthList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingBerthList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingBerthList *p;
	size_t k = sizeof(struct __ns1__GetShippingBerthList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingBerthList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingBerthList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingBerthList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingBerthList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingBerthList(struct soap *soap, const struct __ns1__GetShippingBerthList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingBerthList(soap, tag ? tag : "-ns1:GetShippingBerthList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingBerthList * SOAP_FMAC4 soap_get___ns1__GetShippingBerthList(struct soap *soap, struct __ns1__GetShippingBerthList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingBerthList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShippingList(struct soap *soap, struct __ns1__GetShippingList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShippingList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShippingList(struct soap *soap, const struct __ns1__GetShippingList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShippingList(soap, &a->ns1__GetShippingList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShippingList(struct soap *soap, const char *tag, int id, const struct __ns1__GetShippingList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShippingList(soap, "ns1:GetShippingList", -1, &a->ns1__GetShippingList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingList * SOAP_FMAC4 soap_in___ns1__GetShippingList(struct soap *soap, const char *tag, struct __ns1__GetShippingList *a, const char *type)
{
	size_t soap_flag_ns1__GetShippingList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShippingList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShippingList, sizeof(struct __ns1__GetShippingList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShippingList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShippingList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShippingList(soap, "ns1:GetShippingList", &a->ns1__GetShippingList, ""))
				{	soap_flag_ns1__GetShippingList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShippingList * SOAP_FMAC2 soap_instantiate___ns1__GetShippingList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShippingList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShippingList *p;
	size_t k = sizeof(struct __ns1__GetShippingList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetShippingList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetShippingList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShippingList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetShippingList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShippingList(struct soap *soap, const struct __ns1__GetShippingList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShippingList(soap, tag ? tag : "-ns1:GetShippingList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShippingList * SOAP_FMAC4 soap_get___ns1__GetShippingList(struct soap *soap, struct __ns1__GetShippingList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShippingList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doLotLinkForApple(struct soap *soap, struct __ns1__doLotLinkForApple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doLotLinkForApple = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doLotLinkForApple(struct soap *soap, const struct __ns1__doLotLinkForApple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doLotLinkForApple(soap, &a->ns1__doLotLinkForApple);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doLotLinkForApple(struct soap *soap, const char *tag, int id, const struct __ns1__doLotLinkForApple *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doLotLinkForApple(soap, "ns1:doLotLinkForApple", -1, &a->ns1__doLotLinkForApple, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLotLinkForApple * SOAP_FMAC4 soap_in___ns1__doLotLinkForApple(struct soap *soap, const char *tag, struct __ns1__doLotLinkForApple *a, const char *type)
{
	size_t soap_flag_ns1__doLotLinkForApple = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doLotLinkForApple *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doLotLinkForApple, sizeof(struct __ns1__doLotLinkForApple), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doLotLinkForApple(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doLotLinkForApple && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doLotLinkForApple(soap, "ns1:doLotLinkForApple", &a->ns1__doLotLinkForApple, ""))
				{	soap_flag_ns1__doLotLinkForApple--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doLotLinkForApple * SOAP_FMAC2 soap_instantiate___ns1__doLotLinkForApple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doLotLinkForApple(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doLotLinkForApple *p;
	size_t k = sizeof(struct __ns1__doLotLinkForApple);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doLotLinkForApple);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doLotLinkForApple, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doLotLinkForApple location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doLotLinkForApple, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doLotLinkForApple(struct soap *soap, const struct __ns1__doLotLinkForApple *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doLotLinkForApple(soap, tag ? tag : "-ns1:doLotLinkForApple", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doLotLinkForApple * SOAP_FMAC4 soap_get___ns1__doLotLinkForApple(struct soap *soap, struct __ns1__doLotLinkForApple *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doLotLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotLinkCount(struct soap *soap, struct __ns1__GetLotLinkCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotLinkCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotLinkCount(struct soap *soap, const struct __ns1__GetLotLinkCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLotLinkCount(soap, &a->ns1__GetLotLinkCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotLinkCount(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotLinkCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLotLinkCount(soap, "ns1:GetLotLinkCount", -1, &a->ns1__GetLotLinkCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotLinkCount * SOAP_FMAC4 soap_in___ns1__GetLotLinkCount(struct soap *soap, const char *tag, struct __ns1__GetLotLinkCount *a, const char *type)
{
	size_t soap_flag_ns1__GetLotLinkCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLotLinkCount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotLinkCount, sizeof(struct __ns1__GetLotLinkCount), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotLinkCount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotLinkCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLotLinkCount(soap, "ns1:GetLotLinkCount", &a->ns1__GetLotLinkCount, ""))
				{	soap_flag_ns1__GetLotLinkCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLotLinkCount * SOAP_FMAC2 soap_instantiate___ns1__GetLotLinkCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotLinkCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLotLinkCount *p;
	size_t k = sizeof(struct __ns1__GetLotLinkCount);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetLotLinkCount);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetLotLinkCount, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLotLinkCount location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetLotLinkCount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotLinkCount(struct soap *soap, const struct __ns1__GetLotLinkCount *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLotLinkCount(soap, tag ? tag : "-ns1:GetLotLinkCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotLinkCount * SOAP_FMAC4 soap_get___ns1__GetLotLinkCount(struct soap *soap, struct __ns1__GetLotLinkCount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotLinkCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFruitSNCheck(struct soap *soap, struct __ns1__GetFruitSNCheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFruitSNCheck = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFruitSNCheck(struct soap *soap, const struct __ns1__GetFruitSNCheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFruitSNCheck(soap, &a->ns1__GetFruitSNCheck);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFruitSNCheck(struct soap *soap, const char *tag, int id, const struct __ns1__GetFruitSNCheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFruitSNCheck(soap, "ns1:GetFruitSNCheck", -1, &a->ns1__GetFruitSNCheck, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitSNCheck * SOAP_FMAC4 soap_in___ns1__GetFruitSNCheck(struct soap *soap, const char *tag, struct __ns1__GetFruitSNCheck *a, const char *type)
{
	size_t soap_flag_ns1__GetFruitSNCheck = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFruitSNCheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFruitSNCheck, sizeof(struct __ns1__GetFruitSNCheck), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFruitSNCheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFruitSNCheck && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFruitSNCheck(soap, "ns1:GetFruitSNCheck", &a->ns1__GetFruitSNCheck, ""))
				{	soap_flag_ns1__GetFruitSNCheck--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFruitSNCheck * SOAP_FMAC2 soap_instantiate___ns1__GetFruitSNCheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFruitSNCheck(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFruitSNCheck *p;
	size_t k = sizeof(struct __ns1__GetFruitSNCheck);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetFruitSNCheck);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetFruitSNCheck, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFruitSNCheck location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetFruitSNCheck, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFruitSNCheck(struct soap *soap, const struct __ns1__GetFruitSNCheck *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFruitSNCheck(soap, tag ? tag : "-ns1:GetFruitSNCheck", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFruitSNCheck * SOAP_FMAC4 soap_get___ns1__GetFruitSNCheck(struct soap *soap, struct __ns1__GetFruitSNCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFruitSNCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetObeNW(struct soap *soap, struct __ns1__GetObeNW *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetObeNW = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetObeNW(struct soap *soap, const struct __ns1__GetObeNW *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetObeNW(soap, &a->ns1__GetObeNW);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetObeNW(struct soap *soap, const char *tag, int id, const struct __ns1__GetObeNW *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetObeNW(soap, "ns1:GetObeNW", -1, &a->ns1__GetObeNW, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObeNW * SOAP_FMAC4 soap_in___ns1__GetObeNW(struct soap *soap, const char *tag, struct __ns1__GetObeNW *a, const char *type)
{
	size_t soap_flag_ns1__GetObeNW = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetObeNW *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetObeNW, sizeof(struct __ns1__GetObeNW), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetObeNW(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetObeNW && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetObeNW(soap, "ns1:GetObeNW", &a->ns1__GetObeNW, ""))
				{	soap_flag_ns1__GetObeNW--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetObeNW * SOAP_FMAC2 soap_instantiate___ns1__GetObeNW(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetObeNW(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetObeNW *p;
	size_t k = sizeof(struct __ns1__GetObeNW);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetObeNW);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetObeNW, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetObeNW location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetObeNW, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetObeNW(struct soap *soap, const struct __ns1__GetObeNW *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetObeNW(soap, tag ? tag : "-ns1:GetObeNW", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObeNW * SOAP_FMAC4 soap_get___ns1__GetObeNW(struct soap *soap, struct __ns1__GetObeNW *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetObeNW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doSnLinkForApple(struct soap *soap, struct __ns1__doSnLinkForApple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doSnLinkForApple = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doSnLinkForApple(struct soap *soap, const struct __ns1__doSnLinkForApple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__doSnLinkForApple(soap, &a->ns1__doSnLinkForApple);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doSnLinkForApple(struct soap *soap, const char *tag, int id, const struct __ns1__doSnLinkForApple *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__doSnLinkForApple(soap, "ns1:doSnLinkForApple", -1, &a->ns1__doSnLinkForApple, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doSnLinkForApple * SOAP_FMAC4 soap_in___ns1__doSnLinkForApple(struct soap *soap, const char *tag, struct __ns1__doSnLinkForApple *a, const char *type)
{
	size_t soap_flag_ns1__doSnLinkForApple = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doSnLinkForApple *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doSnLinkForApple, sizeof(struct __ns1__doSnLinkForApple), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doSnLinkForApple(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doSnLinkForApple && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__doSnLinkForApple(soap, "ns1:doSnLinkForApple", &a->ns1__doSnLinkForApple, ""))
				{	soap_flag_ns1__doSnLinkForApple--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__doSnLinkForApple * SOAP_FMAC2 soap_instantiate___ns1__doSnLinkForApple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doSnLinkForApple(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__doSnLinkForApple *p;
	size_t k = sizeof(struct __ns1__doSnLinkForApple);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__doSnLinkForApple);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__doSnLinkForApple, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__doSnLinkForApple location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__doSnLinkForApple, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doSnLinkForApple(struct soap *soap, const struct __ns1__doSnLinkForApple *a, const char *tag, const char *type)
{
	if (soap_out___ns1__doSnLinkForApple(soap, tag ? tag : "-ns1:doSnLinkForApple", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doSnLinkForApple * SOAP_FMAC4 soap_get___ns1__doSnLinkForApple(struct soap *soap, struct __ns1__doSnLinkForApple *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doSnLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkSnLinkForApple(struct soap *soap, struct __ns1__ChkSnLinkForApple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkSnLinkForApple = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkSnLinkForApple(struct soap *soap, const struct __ns1__ChkSnLinkForApple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkSnLinkForApple(soap, &a->ns1__ChkSnLinkForApple);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkSnLinkForApple(struct soap *soap, const char *tag, int id, const struct __ns1__ChkSnLinkForApple *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkSnLinkForApple(soap, "ns1:ChkSnLinkForApple", -1, &a->ns1__ChkSnLinkForApple, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLinkForApple * SOAP_FMAC4 soap_in___ns1__ChkSnLinkForApple(struct soap *soap, const char *tag, struct __ns1__ChkSnLinkForApple *a, const char *type)
{
	size_t soap_flag_ns1__ChkSnLinkForApple = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkSnLinkForApple *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkSnLinkForApple, sizeof(struct __ns1__ChkSnLinkForApple), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkSnLinkForApple(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkSnLinkForApple && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkSnLinkForApple(soap, "ns1:ChkSnLinkForApple", &a->ns1__ChkSnLinkForApple, ""))
				{	soap_flag_ns1__ChkSnLinkForApple--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkSnLinkForApple * SOAP_FMAC2 soap_instantiate___ns1__ChkSnLinkForApple(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkSnLinkForApple(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkSnLinkForApple *p;
	size_t k = sizeof(struct __ns1__ChkSnLinkForApple);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkSnLinkForApple);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkSnLinkForApple, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkSnLinkForApple location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkSnLinkForApple, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkSnLinkForApple(struct soap *soap, const struct __ns1__ChkSnLinkForApple *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkSnLinkForApple(soap, tag ? tag : "-ns1:ChkSnLinkForApple", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkSnLinkForApple * SOAP_FMAC4 soap_get___ns1__ChkSnLinkForApple(struct soap *soap, struct __ns1__ChkSnLinkForApple *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkSnLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DelSNTest(struct soap *soap, struct __ns1__DelSNTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DelSNTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DelSNTest(struct soap *soap, const struct __ns1__DelSNTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DelSNTest(soap, &a->ns1__DelSNTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DelSNTest(struct soap *soap, const char *tag, int id, const struct __ns1__DelSNTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DelSNTest(soap, "ns1:DelSNTest", -1, &a->ns1__DelSNTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DelSNTest * SOAP_FMAC4 soap_in___ns1__DelSNTest(struct soap *soap, const char *tag, struct __ns1__DelSNTest *a, const char *type)
{
	size_t soap_flag_ns1__DelSNTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DelSNTest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DelSNTest, sizeof(struct __ns1__DelSNTest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DelSNTest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DelSNTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DelSNTest(soap, "ns1:DelSNTest", &a->ns1__DelSNTest, ""))
				{	soap_flag_ns1__DelSNTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DelSNTest * SOAP_FMAC2 soap_instantiate___ns1__DelSNTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DelSNTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DelSNTest *p;
	size_t k = sizeof(struct __ns1__DelSNTest);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DelSNTest);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DelSNTest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DelSNTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__DelSNTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DelSNTest(struct soap *soap, const struct __ns1__DelSNTest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DelSNTest(soap, tag ? tag : "-ns1:DelSNTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DelSNTest * SOAP_FMAC4 soap_get___ns1__DelSNTest(struct soap *soap, struct __ns1__DelSNTest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DelSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelSNTest(struct soap *soap, struct __ns1__SelSNTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelSNTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelSNTest(struct soap *soap, const struct __ns1__SelSNTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelSNTest(soap, &a->ns1__SelSNTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelSNTest(struct soap *soap, const char *tag, int id, const struct __ns1__SelSNTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelSNTest(soap, "ns1:SelSNTest", -1, &a->ns1__SelSNTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTest * SOAP_FMAC4 soap_in___ns1__SelSNTest(struct soap *soap, const char *tag, struct __ns1__SelSNTest *a, const char *type)
{
	size_t soap_flag_ns1__SelSNTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelSNTest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelSNTest, sizeof(struct __ns1__SelSNTest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelSNTest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelSNTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelSNTest(soap, "ns1:SelSNTest", &a->ns1__SelSNTest, ""))
				{	soap_flag_ns1__SelSNTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelSNTest * SOAP_FMAC2 soap_instantiate___ns1__SelSNTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelSNTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelSNTest *p;
	size_t k = sizeof(struct __ns1__SelSNTest);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SelSNTest);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SelSNTest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelSNTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SelSNTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelSNTest(struct soap *soap, const struct __ns1__SelSNTest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelSNTest(soap, tag ? tag : "-ns1:SelSNTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelSNTest * SOAP_FMAC4 soap_get___ns1__SelSNTest(struct soap *soap, struct __ns1__SelSNTest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsSNTest(struct soap *soap, struct __ns1__InsSNTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsSNTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsSNTest(struct soap *soap, const struct __ns1__InsSNTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsSNTest(soap, &a->ns1__InsSNTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsSNTest(struct soap *soap, const char *tag, int id, const struct __ns1__InsSNTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsSNTest(soap, "ns1:InsSNTest", -1, &a->ns1__InsSNTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTest * SOAP_FMAC4 soap_in___ns1__InsSNTest(struct soap *soap, const char *tag, struct __ns1__InsSNTest *a, const char *type)
{
	size_t soap_flag_ns1__InsSNTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsSNTest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsSNTest, sizeof(struct __ns1__InsSNTest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsSNTest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsSNTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InsSNTest(soap, "ns1:InsSNTest", &a->ns1__InsSNTest, ""))
				{	soap_flag_ns1__InsSNTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsSNTest * SOAP_FMAC2 soap_instantiate___ns1__InsSNTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsSNTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsSNTest *p;
	size_t k = sizeof(struct __ns1__InsSNTest);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsSNTest);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsSNTest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsSNTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsSNTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsSNTest(struct soap *soap, const struct __ns1__InsSNTest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsSNTest(soap, tag ? tag : "-ns1:InsSNTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsSNTest * SOAP_FMAC4 soap_get___ns1__InsSNTest(struct soap *soap, struct __ns1__InsSNTest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChkWeightTime(struct soap *soap, struct __ns1__ChkWeightTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChkWeightTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChkWeightTime(struct soap *soap, const struct __ns1__ChkWeightTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChkWeightTime(soap, &a->ns1__ChkWeightTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChkWeightTime(struct soap *soap, const char *tag, int id, const struct __ns1__ChkWeightTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChkWeightTime(soap, "ns1:ChkWeightTime", -1, &a->ns1__ChkWeightTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkWeightTime * SOAP_FMAC4 soap_in___ns1__ChkWeightTime(struct soap *soap, const char *tag, struct __ns1__ChkWeightTime *a, const char *type)
{
	size_t soap_flag_ns1__ChkWeightTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChkWeightTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChkWeightTime, sizeof(struct __ns1__ChkWeightTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChkWeightTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChkWeightTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChkWeightTime(soap, "ns1:ChkWeightTime", &a->ns1__ChkWeightTime, ""))
				{	soap_flag_ns1__ChkWeightTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChkWeightTime * SOAP_FMAC2 soap_instantiate___ns1__ChkWeightTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChkWeightTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChkWeightTime *p;
	size_t k = sizeof(struct __ns1__ChkWeightTime);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChkWeightTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChkWeightTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChkWeightTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChkWeightTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChkWeightTime(struct soap *soap, const struct __ns1__ChkWeightTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChkWeightTime(soap, tag ? tag : "-ns1:ChkWeightTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChkWeightTime * SOAP_FMAC4 soap_get___ns1__ChkWeightTime(struct soap *soap, struct __ns1__ChkWeightTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChkWeightTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdAhsBarcode(struct soap *soap, struct __ns1__UpdAhsBarcode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdAhsBarcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdAhsBarcode(struct soap *soap, const struct __ns1__UpdAhsBarcode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdAhsBarcode(soap, &a->ns1__UpdAhsBarcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdAhsBarcode(struct soap *soap, const char *tag, int id, const struct __ns1__UpdAhsBarcode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdAhsBarcode(soap, "ns1:UpdAhsBarcode", -1, &a->ns1__UpdAhsBarcode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdAhsBarcode * SOAP_FMAC4 soap_in___ns1__UpdAhsBarcode(struct soap *soap, const char *tag, struct __ns1__UpdAhsBarcode *a, const char *type)
{
	size_t soap_flag_ns1__UpdAhsBarcode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdAhsBarcode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdAhsBarcode, sizeof(struct __ns1__UpdAhsBarcode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdAhsBarcode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdAhsBarcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdAhsBarcode(soap, "ns1:UpdAhsBarcode", &a->ns1__UpdAhsBarcode, ""))
				{	soap_flag_ns1__UpdAhsBarcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdAhsBarcode * SOAP_FMAC2 soap_instantiate___ns1__UpdAhsBarcode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdAhsBarcode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdAhsBarcode *p;
	size_t k = sizeof(struct __ns1__UpdAhsBarcode);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdAhsBarcode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdAhsBarcode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdAhsBarcode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UpdAhsBarcode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdAhsBarcode(struct soap *soap, const struct __ns1__UpdAhsBarcode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdAhsBarcode(soap, tag ? tag : "-ns1:UpdAhsBarcode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdAhsBarcode * SOAP_FMAC4 soap_get___ns1__UpdAhsBarcode(struct soap *soap, struct __ns1__UpdAhsBarcode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdAhsBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAhsBarcode(struct soap *soap, struct __ns1__GetAhsBarcode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAhsBarcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAhsBarcode(struct soap *soap, const struct __ns1__GetAhsBarcode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAhsBarcode(soap, &a->ns1__GetAhsBarcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAhsBarcode(struct soap *soap, const char *tag, int id, const struct __ns1__GetAhsBarcode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAhsBarcode(soap, "ns1:GetAhsBarcode", -1, &a->ns1__GetAhsBarcode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsBarcode * SOAP_FMAC4 soap_in___ns1__GetAhsBarcode(struct soap *soap, const char *tag, struct __ns1__GetAhsBarcode *a, const char *type)
{
	size_t soap_flag_ns1__GetAhsBarcode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAhsBarcode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAhsBarcode, sizeof(struct __ns1__GetAhsBarcode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAhsBarcode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAhsBarcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAhsBarcode(soap, "ns1:GetAhsBarcode", &a->ns1__GetAhsBarcode, ""))
				{	soap_flag_ns1__GetAhsBarcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAhsBarcode * SOAP_FMAC2 soap_instantiate___ns1__GetAhsBarcode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAhsBarcode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAhsBarcode *p;
	size_t k = sizeof(struct __ns1__GetAhsBarcode);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAhsBarcode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAhsBarcode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAhsBarcode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAhsBarcode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAhsBarcode(struct soap *soap, const struct __ns1__GetAhsBarcode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAhsBarcode(soap, tag ? tag : "-ns1:GetAhsBarcode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAhsBarcode * SOAP_FMAC4 soap_get___ns1__GetAhsBarcode(struct soap *soap, struct __ns1__GetAhsBarcode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAhsBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAhsMo(struct soap *soap, _ns1__GetAhsMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAhsMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAhsMo(struct soap *soap, const char *tag, int id, _ns1__GetAhsMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAhsMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAhsMo ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAhsMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAhsMo(struct soap *soap, const char *tag, _ns1__GetAhsMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAhsMo **)soap_malloc(soap, sizeof(_ns1__GetAhsMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAhsMo *)soap_instantiate__ns1__GetAhsMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAhsMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAhsMo, sizeof(_ns1__GetAhsMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAhsMo(struct soap *soap, _ns1__GetAhsMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAhsMo(soap, tag ? tag : "ns1:GetAhsMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAhsMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAhsMo(struct soap *soap, _ns1__GetAhsMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAhsMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPackWeigth(struct soap *soap, _ns1__GetPackWeigth *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPackWeigth))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPackWeigth(struct soap *soap, const char *tag, int id, _ns1__GetPackWeigth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPackWeigth, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPackWeigth ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPackWeigth ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPackWeigth(struct soap *soap, const char *tag, _ns1__GetPackWeigth **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPackWeigth **)soap_malloc(soap, sizeof(_ns1__GetPackWeigth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPackWeigth *)soap_instantiate__ns1__GetPackWeigth(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPackWeigth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPackWeigth, sizeof(_ns1__GetPackWeigth), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPackWeigth(struct soap *soap, _ns1__GetPackWeigth *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPackWeigth(soap, tag ? tag : "ns1:GetPackWeigth", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPackWeigth ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPackWeigth(struct soap *soap, _ns1__GetPackWeigth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPackWeigth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPackStation(struct soap *soap, _ns1__GetPackStation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPackStation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPackStation(struct soap *soap, const char *tag, int id, _ns1__GetPackStation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPackStation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPackStation ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPackStation ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPackStation(struct soap *soap, const char *tag, _ns1__GetPackStation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPackStation **)soap_malloc(soap, sizeof(_ns1__GetPackStation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPackStation *)soap_instantiate__ns1__GetPackStation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPackStation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPackStation, sizeof(_ns1__GetPackStation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPackStation(struct soap *soap, _ns1__GetPackStation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPackStation(soap, tag ? tag : "ns1:GetPackStation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPackStation ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPackStation(struct soap *soap, _ns1__GetPackStation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPackStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPallentForWMS(struct soap *soap, _ns1__SetPallentForWMS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPallentForWMS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPallentForWMS(struct soap *soap, const char *tag, int id, _ns1__SetPallentForWMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPallentForWMS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetPallentForWMS ? type : NULL);
}

SOAP_FMAC3 _ns1__SetPallentForWMS ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPallentForWMS(struct soap *soap, const char *tag, _ns1__SetPallentForWMS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPallentForWMS **)soap_malloc(soap, sizeof(_ns1__SetPallentForWMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPallentForWMS *)soap_instantiate__ns1__SetPallentForWMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetPallentForWMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPallentForWMS, sizeof(_ns1__SetPallentForWMS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPallentForWMS(struct soap *soap, _ns1__SetPallentForWMS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPallentForWMS(soap, tag ? tag : "ns1:SetPallentForWMS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetPallentForWMS ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPallentForWMS(struct soap *soap, _ns1__SetPallentForWMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPallentForWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPallentToWMS(struct soap *soap, _ns1__GetPallentToWMS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPallentToWMS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPallentToWMS(struct soap *soap, const char *tag, int id, _ns1__GetPallentToWMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPallentToWMS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPallentToWMS ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPallentToWMS ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPallentToWMS(struct soap *soap, const char *tag, _ns1__GetPallentToWMS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPallentToWMS **)soap_malloc(soap, sizeof(_ns1__GetPallentToWMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPallentToWMS *)soap_instantiate__ns1__GetPallentToWMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPallentToWMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPallentToWMS, sizeof(_ns1__GetPallentToWMS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPallentToWMS(struct soap *soap, _ns1__GetPallentToWMS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPallentToWMS(soap, tag ? tag : "ns1:GetPallentToWMS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPallentToWMS ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPallentToWMS(struct soap *soap, _ns1__GetPallentToWMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPallentToWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPackToWMS(struct soap *soap, _ns1__GetPackToWMS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPackToWMS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPackToWMS(struct soap *soap, const char *tag, int id, _ns1__GetPackToWMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPackToWMS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPackToWMS ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPackToWMS ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPackToWMS(struct soap *soap, const char *tag, _ns1__GetPackToWMS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPackToWMS **)soap_malloc(soap, sizeof(_ns1__GetPackToWMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPackToWMS *)soap_instantiate__ns1__GetPackToWMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPackToWMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPackToWMS, sizeof(_ns1__GetPackToWMS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPackToWMS(struct soap *soap, _ns1__GetPackToWMS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPackToWMS(soap, tag ? tag : "ns1:GetPackToWMS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPackToWMS ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPackToWMS(struct soap *soap, _ns1__GetPackToWMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPackToWMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetWeightSet(struct soap *soap, _ns1__GetWeightSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetWeightSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetWeightSet(struct soap *soap, const char *tag, int id, _ns1__GetWeightSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetWeightSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetWeightSet ? type : NULL);
}

SOAP_FMAC3 _ns1__GetWeightSet ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetWeightSet(struct soap *soap, const char *tag, _ns1__GetWeightSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetWeightSet **)soap_malloc(soap, sizeof(_ns1__GetWeightSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetWeightSet *)soap_instantiate__ns1__GetWeightSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetWeightSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetWeightSet, sizeof(_ns1__GetWeightSet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetWeightSet(struct soap *soap, _ns1__GetWeightSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetWeightSet(soap, tag ? tag : "ns1:GetWeightSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetWeightSet ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetWeightSet(struct soap *soap, _ns1__GetWeightSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetWeightSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CancelLnkSN(struct soap *soap, _ns1__CancelLnkSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CancelLnkSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CancelLnkSN(struct soap *soap, const char *tag, int id, _ns1__CancelLnkSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CancelLnkSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CancelLnkSN ? type : NULL);
}

SOAP_FMAC3 _ns1__CancelLnkSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__CancelLnkSN(struct soap *soap, const char *tag, _ns1__CancelLnkSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CancelLnkSN **)soap_malloc(soap, sizeof(_ns1__CancelLnkSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CancelLnkSN *)soap_instantiate__ns1__CancelLnkSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CancelLnkSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CancelLnkSN, sizeof(_ns1__CancelLnkSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CancelLnkSN(struct soap *soap, _ns1__CancelLnkSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CancelLnkSN(soap, tag ? tag : "ns1:CancelLnkSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CancelLnkSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__CancelLnkSN(struct soap *soap, _ns1__CancelLnkSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CancelLnkSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CancelGrillSN(struct soap *soap, _ns1__CancelGrillSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CancelGrillSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CancelGrillSN(struct soap *soap, const char *tag, int id, _ns1__CancelGrillSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CancelGrillSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CancelGrillSN ? type : NULL);
}

SOAP_FMAC3 _ns1__CancelGrillSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__CancelGrillSN(struct soap *soap, const char *tag, _ns1__CancelGrillSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CancelGrillSN **)soap_malloc(soap, sizeof(_ns1__CancelGrillSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CancelGrillSN *)soap_instantiate__ns1__CancelGrillSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CancelGrillSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CancelGrillSN, sizeof(_ns1__CancelGrillSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CancelGrillSN(struct soap *soap, _ns1__CancelGrillSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CancelGrillSN(soap, tag ? tag : "ns1:CancelGrillSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CancelGrillSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__CancelGrillSN(struct soap *soap, _ns1__CancelGrillSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CancelGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OutGrillBySN(struct soap *soap, _ns1__OutGrillBySN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OutGrillBySN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OutGrillBySN(struct soap *soap, const char *tag, int id, _ns1__OutGrillBySN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OutGrillBySN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OutGrillBySN ? type : NULL);
}

SOAP_FMAC3 _ns1__OutGrillBySN ** SOAP_FMAC4 soap_in_PointerTo_ns1__OutGrillBySN(struct soap *soap, const char *tag, _ns1__OutGrillBySN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OutGrillBySN **)soap_malloc(soap, sizeof(_ns1__OutGrillBySN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OutGrillBySN *)soap_instantiate__ns1__OutGrillBySN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OutGrillBySN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OutGrillBySN, sizeof(_ns1__OutGrillBySN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OutGrillBySN(struct soap *soap, _ns1__OutGrillBySN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OutGrillBySN(soap, tag ? tag : "ns1:OutGrillBySN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OutGrillBySN ** SOAP_FMAC4 soap_get_PointerTo_ns1__OutGrillBySN(struct soap *soap, _ns1__OutGrillBySN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OutGrillBySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetGrillTime(struct soap *soap, _ns1__GetGrillTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetGrillTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetGrillTime(struct soap *soap, const char *tag, int id, _ns1__GetGrillTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetGrillTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetGrillTime ? type : NULL);
}

SOAP_FMAC3 _ns1__GetGrillTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetGrillTime(struct soap *soap, const char *tag, _ns1__GetGrillTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetGrillTime **)soap_malloc(soap, sizeof(_ns1__GetGrillTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetGrillTime *)soap_instantiate__ns1__GetGrillTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetGrillTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetGrillTime, sizeof(_ns1__GetGrillTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetGrillTime(struct soap *soap, _ns1__GetGrillTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetGrillTime(soap, tag ? tag : "ns1:GetGrillTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetGrillTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetGrillTime(struct soap *soap, _ns1__GetGrillTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetGrillTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsGrillBySN(struct soap *soap, _ns1__InsGrillBySN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsGrillBySN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsGrillBySN(struct soap *soap, const char *tag, int id, _ns1__InsGrillBySN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsGrillBySN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsGrillBySN ? type : NULL);
}

SOAP_FMAC3 _ns1__InsGrillBySN ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsGrillBySN(struct soap *soap, const char *tag, _ns1__InsGrillBySN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsGrillBySN **)soap_malloc(soap, sizeof(_ns1__InsGrillBySN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsGrillBySN *)soap_instantiate__ns1__InsGrillBySN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsGrillBySN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsGrillBySN, sizeof(_ns1__InsGrillBySN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsGrillBySN(struct soap *soap, _ns1__InsGrillBySN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsGrillBySN(soap, tag ? tag : "ns1:InsGrillBySN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsGrillBySN ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsGrillBySN(struct soap *soap, _ns1__InsGrillBySN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsGrillBySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CloseGrillSN(struct soap *soap, _ns1__CloseGrillSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CloseGrillSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CloseGrillSN(struct soap *soap, const char *tag, int id, _ns1__CloseGrillSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CloseGrillSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CloseGrillSN ? type : NULL);
}

SOAP_FMAC3 _ns1__CloseGrillSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__CloseGrillSN(struct soap *soap, const char *tag, _ns1__CloseGrillSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CloseGrillSN **)soap_malloc(soap, sizeof(_ns1__CloseGrillSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CloseGrillSN *)soap_instantiate__ns1__CloseGrillSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CloseGrillSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CloseGrillSN, sizeof(_ns1__CloseGrillSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CloseGrillSN(struct soap *soap, _ns1__CloseGrillSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CloseGrillSN(soap, tag ? tag : "ns1:CloseGrillSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CloseGrillSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__CloseGrillSN(struct soap *soap, _ns1__CloseGrillSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CloseGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LnkGrillSN(struct soap *soap, _ns1__LnkGrillSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LnkGrillSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LnkGrillSN(struct soap *soap, const char *tag, int id, _ns1__LnkGrillSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LnkGrillSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__LnkGrillSN ? type : NULL);
}

SOAP_FMAC3 _ns1__LnkGrillSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__LnkGrillSN(struct soap *soap, const char *tag, _ns1__LnkGrillSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LnkGrillSN **)soap_malloc(soap, sizeof(_ns1__LnkGrillSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LnkGrillSN *)soap_instantiate__ns1__LnkGrillSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LnkGrillSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LnkGrillSN, sizeof(_ns1__LnkGrillSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LnkGrillSN(struct soap *soap, _ns1__LnkGrillSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LnkGrillSN(soap, tag ? tag : "ns1:LnkGrillSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LnkGrillSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__LnkGrillSN(struct soap *soap, _ns1__LnkGrillSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LnkGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkGrillSN(struct soap *soap, _ns1__chkGrillSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkGrillSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkGrillSN(struct soap *soap, const char *tag, int id, _ns1__chkGrillSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkGrillSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkGrillSN ? type : NULL);
}

SOAP_FMAC3 _ns1__chkGrillSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkGrillSN(struct soap *soap, const char *tag, _ns1__chkGrillSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkGrillSN **)soap_malloc(soap, sizeof(_ns1__chkGrillSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkGrillSN *)soap_instantiate__ns1__chkGrillSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkGrillSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkGrillSN, sizeof(_ns1__chkGrillSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkGrillSN(struct soap *soap, _ns1__chkGrillSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkGrillSN(soap, tag ? tag : "ns1:chkGrillSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkGrillSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkGrillSN(struct soap *soap, _ns1__chkGrillSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkGrillSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LnkSideSN(struct soap *soap, _ns1__LnkSideSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LnkSideSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LnkSideSN(struct soap *soap, const char *tag, int id, _ns1__LnkSideSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LnkSideSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__LnkSideSN ? type : NULL);
}

SOAP_FMAC3 _ns1__LnkSideSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__LnkSideSN(struct soap *soap, const char *tag, _ns1__LnkSideSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LnkSideSN **)soap_malloc(soap, sizeof(_ns1__LnkSideSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LnkSideSN *)soap_instantiate__ns1__LnkSideSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LnkSideSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LnkSideSN, sizeof(_ns1__LnkSideSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LnkSideSN(struct soap *soap, _ns1__LnkSideSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LnkSideSN(soap, tag ? tag : "ns1:LnkSideSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LnkSideSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__LnkSideSN(struct soap *soap, _ns1__LnkSideSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LnkSideSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LnkZJSN(struct soap *soap, _ns1__LnkZJSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LnkZJSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LnkZJSN(struct soap *soap, const char *tag, int id, _ns1__LnkZJSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LnkZJSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__LnkZJSN ? type : NULL);
}

SOAP_FMAC3 _ns1__LnkZJSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__LnkZJSN(struct soap *soap, const char *tag, _ns1__LnkZJSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LnkZJSN **)soap_malloc(soap, sizeof(_ns1__LnkZJSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LnkZJSN *)soap_instantiate__ns1__LnkZJSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LnkZJSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LnkZJSN, sizeof(_ns1__LnkZJSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LnkZJSN(struct soap *soap, _ns1__LnkZJSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LnkZJSN(soap, tag ? tag : "ns1:LnkZJSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LnkZJSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__LnkZJSN(struct soap *soap, _ns1__LnkZJSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LnkZJSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkZJSN(struct soap *soap, _ns1__chkZJSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkZJSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkZJSN(struct soap *soap, const char *tag, int id, _ns1__chkZJSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkZJSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkZJSN ? type : NULL);
}

SOAP_FMAC3 _ns1__chkZJSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkZJSN(struct soap *soap, const char *tag, _ns1__chkZJSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkZJSN **)soap_malloc(soap, sizeof(_ns1__chkZJSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkZJSN *)soap_instantiate__ns1__chkZJSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkZJSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkZJSN, sizeof(_ns1__chkZJSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkZJSN(struct soap *soap, _ns1__chkZJSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkZJSN(soap, tag ? tag : "ns1:chkZJSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkZJSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkZJSN(struct soap *soap, _ns1__chkZJSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkZJSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkDispensing(struct soap *soap, _ns1__chkDispensing *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkDispensing))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkDispensing(struct soap *soap, const char *tag, int id, _ns1__chkDispensing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkDispensing, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkDispensing ? type : NULL);
}

SOAP_FMAC3 _ns1__chkDispensing ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkDispensing(struct soap *soap, const char *tag, _ns1__chkDispensing **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkDispensing **)soap_malloc(soap, sizeof(_ns1__chkDispensing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkDispensing *)soap_instantiate__ns1__chkDispensing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkDispensing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkDispensing, sizeof(_ns1__chkDispensing), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkDispensing(struct soap *soap, _ns1__chkDispensing *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkDispensing(soap, tag ? tag : "ns1:chkDispensing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkDispensing ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkDispensing(struct soap *soap, _ns1__chkDispensing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkDispensing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsIotTestData(struct soap *soap, _ns1__InsIotTestData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsIotTestData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsIotTestData(struct soap *soap, const char *tag, int id, _ns1__InsIotTestData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsIotTestData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsIotTestData ? type : NULL);
}

SOAP_FMAC3 _ns1__InsIotTestData ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsIotTestData(struct soap *soap, const char *tag, _ns1__InsIotTestData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsIotTestData **)soap_malloc(soap, sizeof(_ns1__InsIotTestData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsIotTestData *)soap_instantiate__ns1__InsIotTestData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsIotTestData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsIotTestData, sizeof(_ns1__InsIotTestData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsIotTestData(struct soap *soap, _ns1__InsIotTestData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsIotTestData(soap, tag ? tag : "ns1:InsIotTestData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsIotTestData ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsIotTestData(struct soap *soap, _ns1__InsIotTestData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsIotTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsIotMachineRec(struct soap *soap, _ns1__InsIotMachineRec *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsIotMachineRec))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsIotMachineRec(struct soap *soap, const char *tag, int id, _ns1__InsIotMachineRec *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsIotMachineRec, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsIotMachineRec ? type : NULL);
}

SOAP_FMAC3 _ns1__InsIotMachineRec ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsIotMachineRec(struct soap *soap, const char *tag, _ns1__InsIotMachineRec **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsIotMachineRec **)soap_malloc(soap, sizeof(_ns1__InsIotMachineRec *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsIotMachineRec *)soap_instantiate__ns1__InsIotMachineRec(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsIotMachineRec **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsIotMachineRec, sizeof(_ns1__InsIotMachineRec), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsIotMachineRec(struct soap *soap, _ns1__InsIotMachineRec *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsIotMachineRec(soap, tag ? tag : "ns1:InsIotMachineRec", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsIotMachineRec ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsIotMachineRec(struct soap *soap, _ns1__InsIotMachineRec **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsIotMachineRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLnkData(struct soap *soap, _ns1__GetLnkData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLnkData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLnkData(struct soap *soap, const char *tag, int id, _ns1__GetLnkData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLnkData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetLnkData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLnkData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLnkData(struct soap *soap, const char *tag, _ns1__GetLnkData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLnkData **)soap_malloc(soap, sizeof(_ns1__GetLnkData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLnkData *)soap_instantiate__ns1__GetLnkData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLnkData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLnkData, sizeof(_ns1__GetLnkData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLnkData(struct soap *soap, _ns1__GetLnkData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLnkData(soap, tag ? tag : "ns1:GetLnkData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLnkData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLnkData(struct soap *soap, _ns1__GetLnkData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLnkData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTestValue(struct soap *soap, _ns1__GetTestValue *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTestValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTestValue(struct soap *soap, const char *tag, int id, _ns1__GetTestValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTestValue, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetTestValue ? type : NULL);
}

SOAP_FMAC3 _ns1__GetTestValue ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTestValue(struct soap *soap, const char *tag, _ns1__GetTestValue **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTestValue **)soap_malloc(soap, sizeof(_ns1__GetTestValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTestValue *)soap_instantiate__ns1__GetTestValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetTestValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTestValue, sizeof(_ns1__GetTestValue), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTestValue(struct soap *soap, _ns1__GetTestValue *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTestValue(soap, tag ? tag : "ns1:GetTestValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTestValue ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTestValue(struct soap *soap, _ns1__GetTestValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTestValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMoBase(struct soap *soap, _ns1__GetMoBase *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMoBase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMoBase(struct soap *soap, const char *tag, int id, _ns1__GetMoBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMoBase, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMoBase ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMoBase ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMoBase(struct soap *soap, const char *tag, _ns1__GetMoBase **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMoBase **)soap_malloc(soap, sizeof(_ns1__GetMoBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMoBase *)soap_instantiate__ns1__GetMoBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMoBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMoBase, sizeof(_ns1__GetMoBase), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMoBase(struct soap *soap, _ns1__GetMoBase *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMoBase(soap, tag ? tag : "ns1:GetMoBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMoBase ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMoBase(struct soap *soap, _ns1__GetMoBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdSnRecInfo(struct soap *soap, _ns1__UpdSnRecInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdSnRecInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdSnRecInfo(struct soap *soap, const char *tag, int id, _ns1__UpdSnRecInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdSnRecInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UpdSnRecInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__UpdSnRecInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdSnRecInfo(struct soap *soap, const char *tag, _ns1__UpdSnRecInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdSnRecInfo **)soap_malloc(soap, sizeof(_ns1__UpdSnRecInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdSnRecInfo *)soap_instantiate__ns1__UpdSnRecInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdSnRecInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdSnRecInfo, sizeof(_ns1__UpdSnRecInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdSnRecInfo(struct soap *soap, _ns1__UpdSnRecInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdSnRecInfo(soap, tag ? tag : "ns1:UpdSnRecInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdSnRecInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdSnRecInfo(struct soap *soap, _ns1__UpdSnRecInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdSnRecInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsBoxInfo(struct soap *soap, _ns1__InsBoxInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsBoxInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsBoxInfo(struct soap *soap, const char *tag, int id, _ns1__InsBoxInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsBoxInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsBoxInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__InsBoxInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsBoxInfo(struct soap *soap, const char *tag, _ns1__InsBoxInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsBoxInfo **)soap_malloc(soap, sizeof(_ns1__InsBoxInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsBoxInfo *)soap_instantiate__ns1__InsBoxInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsBoxInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsBoxInfo, sizeof(_ns1__InsBoxInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsBoxInfo(struct soap *soap, _ns1__InsBoxInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsBoxInfo(soap, tag ? tag : "ns1:InsBoxInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsBoxInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsBoxInfo(struct soap *soap, _ns1__InsBoxInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsBoxInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsLnkOutSN(struct soap *soap, _ns1__InsLnkOutSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsLnkOutSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsLnkOutSN(struct soap *soap, const char *tag, int id, _ns1__InsLnkOutSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsLnkOutSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsLnkOutSN ? type : NULL);
}

SOAP_FMAC3 _ns1__InsLnkOutSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsLnkOutSN(struct soap *soap, const char *tag, _ns1__InsLnkOutSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsLnkOutSN **)soap_malloc(soap, sizeof(_ns1__InsLnkOutSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsLnkOutSN *)soap_instantiate__ns1__InsLnkOutSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsLnkOutSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsLnkOutSN, sizeof(_ns1__InsLnkOutSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsLnkOutSN(struct soap *soap, _ns1__InsLnkOutSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsLnkOutSN(soap, tag ? tag : "ns1:InsLnkOutSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsLnkOutSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsLnkOutSN(struct soap *soap, _ns1__InsLnkOutSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsLnkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsSNStationEmp(struct soap *soap, _ns1__InsSNStationEmp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsSNStationEmp))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsSNStationEmp(struct soap *soap, const char *tag, int id, _ns1__InsSNStationEmp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsSNStationEmp, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsSNStationEmp ? type : NULL);
}

SOAP_FMAC3 _ns1__InsSNStationEmp ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsSNStationEmp(struct soap *soap, const char *tag, _ns1__InsSNStationEmp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsSNStationEmp **)soap_malloc(soap, sizeof(_ns1__InsSNStationEmp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsSNStationEmp *)soap_instantiate__ns1__InsSNStationEmp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsSNStationEmp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsSNStationEmp, sizeof(_ns1__InsSNStationEmp), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsSNStationEmp(struct soap *soap, _ns1__InsSNStationEmp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsSNStationEmp(soap, tag ? tag : "ns1:InsSNStationEmp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsSNStationEmp ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsSNStationEmp(struct soap *soap, _ns1__InsSNStationEmp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsSNStationEmp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CancelBoxLnk(struct soap *soap, _ns1__CancelBoxLnk *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CancelBoxLnk))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CancelBoxLnk(struct soap *soap, const char *tag, int id, _ns1__CancelBoxLnk *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CancelBoxLnk, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CancelBoxLnk ? type : NULL);
}

SOAP_FMAC3 _ns1__CancelBoxLnk ** SOAP_FMAC4 soap_in_PointerTo_ns1__CancelBoxLnk(struct soap *soap, const char *tag, _ns1__CancelBoxLnk **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CancelBoxLnk **)soap_malloc(soap, sizeof(_ns1__CancelBoxLnk *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CancelBoxLnk *)soap_instantiate__ns1__CancelBoxLnk(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CancelBoxLnk **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CancelBoxLnk, sizeof(_ns1__CancelBoxLnk), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CancelBoxLnk(struct soap *soap, _ns1__CancelBoxLnk *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CancelBoxLnk(soap, tag ? tag : "ns1:CancelBoxLnk", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CancelBoxLnk ** SOAP_FMAC4 soap_get_PointerTo_ns1__CancelBoxLnk(struct soap *soap, _ns1__CancelBoxLnk **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CancelBoxLnk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OutStationbyBox(struct soap *soap, _ns1__OutStationbyBox *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OutStationbyBox))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OutStationbyBox(struct soap *soap, const char *tag, int id, _ns1__OutStationbyBox *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OutStationbyBox, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OutStationbyBox ? type : NULL);
}

SOAP_FMAC3 _ns1__OutStationbyBox ** SOAP_FMAC4 soap_in_PointerTo_ns1__OutStationbyBox(struct soap *soap, const char *tag, _ns1__OutStationbyBox **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OutStationbyBox **)soap_malloc(soap, sizeof(_ns1__OutStationbyBox *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OutStationbyBox *)soap_instantiate__ns1__OutStationbyBox(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OutStationbyBox **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OutStationbyBox, sizeof(_ns1__OutStationbyBox), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OutStationbyBox(struct soap *soap, _ns1__OutStationbyBox *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OutStationbyBox(soap, tag ? tag : "ns1:OutStationbyBox", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OutStationbyBox ** SOAP_FMAC4 soap_get_PointerTo_ns1__OutStationbyBox(struct soap *soap, _ns1__OutStationbyBox **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OutStationbyBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InStationbyBox(struct soap *soap, _ns1__InStationbyBox *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InStationbyBox))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InStationbyBox(struct soap *soap, const char *tag, int id, _ns1__InStationbyBox *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InStationbyBox, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InStationbyBox ? type : NULL);
}

SOAP_FMAC3 _ns1__InStationbyBox ** SOAP_FMAC4 soap_in_PointerTo_ns1__InStationbyBox(struct soap *soap, const char *tag, _ns1__InStationbyBox **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InStationbyBox **)soap_malloc(soap, sizeof(_ns1__InStationbyBox *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InStationbyBox *)soap_instantiate__ns1__InStationbyBox(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InStationbyBox **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InStationbyBox, sizeof(_ns1__InStationbyBox), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InStationbyBox(struct soap *soap, _ns1__InStationbyBox *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InStationbyBox(soap, tag ? tag : "ns1:InStationbyBox", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InStationbyBox ** SOAP_FMAC4 soap_get_PointerTo_ns1__InStationbyBox(struct soap *soap, _ns1__InStationbyBox **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InStationbyBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EndSNtoBox(struct soap *soap, _ns1__EndSNtoBox *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EndSNtoBox))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EndSNtoBox(struct soap *soap, const char *tag, int id, _ns1__EndSNtoBox *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EndSNtoBox, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__EndSNtoBox ? type : NULL);
}

SOAP_FMAC3 _ns1__EndSNtoBox ** SOAP_FMAC4 soap_in_PointerTo_ns1__EndSNtoBox(struct soap *soap, const char *tag, _ns1__EndSNtoBox **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndSNtoBox **)soap_malloc(soap, sizeof(_ns1__EndSNtoBox *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EndSNtoBox *)soap_instantiate__ns1__EndSNtoBox(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__EndSNtoBox **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndSNtoBox, sizeof(_ns1__EndSNtoBox), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EndSNtoBox(struct soap *soap, _ns1__EndSNtoBox *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EndSNtoBox(soap, tag ? tag : "ns1:EndSNtoBox", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndSNtoBox ** SOAP_FMAC4 soap_get_PointerTo_ns1__EndSNtoBox(struct soap *soap, _ns1__EndSNtoBox **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EndSNtoBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InSNtoBox(struct soap *soap, _ns1__InSNtoBox *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InSNtoBox))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InSNtoBox(struct soap *soap, const char *tag, int id, _ns1__InSNtoBox *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InSNtoBox, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InSNtoBox ? type : NULL);
}

SOAP_FMAC3 _ns1__InSNtoBox ** SOAP_FMAC4 soap_in_PointerTo_ns1__InSNtoBox(struct soap *soap, const char *tag, _ns1__InSNtoBox **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InSNtoBox **)soap_malloc(soap, sizeof(_ns1__InSNtoBox *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InSNtoBox *)soap_instantiate__ns1__InSNtoBox(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InSNtoBox **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InSNtoBox, sizeof(_ns1__InSNtoBox), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InSNtoBox(struct soap *soap, _ns1__InSNtoBox *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InSNtoBox(soap, tag ? tag : "ns1:InSNtoBox", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InSNtoBox ** SOAP_FMAC4 soap_get_PointerTo_ns1__InSNtoBox(struct soap *soap, _ns1__InSNtoBox **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InSNtoBox(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkBoxNo(struct soap *soap, _ns1__chkBoxNo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkBoxNo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkBoxNo(struct soap *soap, const char *tag, int id, _ns1__chkBoxNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkBoxNo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkBoxNo ? type : NULL);
}

SOAP_FMAC3 _ns1__chkBoxNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkBoxNo(struct soap *soap, const char *tag, _ns1__chkBoxNo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkBoxNo **)soap_malloc(soap, sizeof(_ns1__chkBoxNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkBoxNo *)soap_instantiate__ns1__chkBoxNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkBoxNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkBoxNo, sizeof(_ns1__chkBoxNo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkBoxNo(struct soap *soap, _ns1__chkBoxNo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkBoxNo(soap, tag ? tag : "ns1:chkBoxNo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkBoxNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkBoxNo(struct soap *soap, _ns1__chkBoxNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkBoxNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsBoxNOTime(struct soap *soap, _ns1__InsBoxNOTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsBoxNOTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsBoxNOTime(struct soap *soap, const char *tag, int id, _ns1__InsBoxNOTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsBoxNOTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsBoxNOTime ? type : NULL);
}

SOAP_FMAC3 _ns1__InsBoxNOTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsBoxNOTime(struct soap *soap, const char *tag, _ns1__InsBoxNOTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsBoxNOTime **)soap_malloc(soap, sizeof(_ns1__InsBoxNOTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsBoxNOTime *)soap_instantiate__ns1__InsBoxNOTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsBoxNOTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsBoxNOTime, sizeof(_ns1__InsBoxNOTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsBoxNOTime(struct soap *soap, _ns1__InsBoxNOTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsBoxNOTime(soap, tag ? tag : "ns1:InsBoxNOTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsBoxNOTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsBoxNOTime(struct soap *soap, _ns1__InsBoxNOTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsBoxNOTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLinkZJCount(struct soap *soap, _ns1__GetLinkZJCount *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLinkZJCount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLinkZJCount(struct soap *soap, const char *tag, int id, _ns1__GetLinkZJCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLinkZJCount, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetLinkZJCount ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLinkZJCount ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLinkZJCount(struct soap *soap, const char *tag, _ns1__GetLinkZJCount **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLinkZJCount **)soap_malloc(soap, sizeof(_ns1__GetLinkZJCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLinkZJCount *)soap_instantiate__ns1__GetLinkZJCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLinkZJCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLinkZJCount, sizeof(_ns1__GetLinkZJCount), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLinkZJCount(struct soap *soap, _ns1__GetLinkZJCount *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLinkZJCount(soap, tag ? tag : "ns1:GetLinkZJCount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLinkZJCount ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLinkZJCount(struct soap *soap, _ns1__GetLinkZJCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLinkZJCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsLinkSN(struct soap *soap, _ns1__InsLinkSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsLinkSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsLinkSN(struct soap *soap, const char *tag, int id, _ns1__InsLinkSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsLinkSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsLinkSN ? type : NULL);
}

SOAP_FMAC3 _ns1__InsLinkSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsLinkSN(struct soap *soap, const char *tag, _ns1__InsLinkSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsLinkSN **)soap_malloc(soap, sizeof(_ns1__InsLinkSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsLinkSN *)soap_instantiate__ns1__InsLinkSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsLinkSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsLinkSN, sizeof(_ns1__InsLinkSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsLinkSN(struct soap *soap, _ns1__InsLinkSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsLinkSN(soap, tag ? tag : "ns1:InsLinkSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsLinkSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsLinkSN(struct soap *soap, _ns1__InsLinkSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsLinkSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doLinkOutSN(struct soap *soap, _ns1__doLinkOutSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doLinkOutSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doLinkOutSN(struct soap *soap, const char *tag, int id, _ns1__doLinkOutSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doLinkOutSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doLinkOutSN ? type : NULL);
}

SOAP_FMAC3 _ns1__doLinkOutSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__doLinkOutSN(struct soap *soap, const char *tag, _ns1__doLinkOutSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doLinkOutSN **)soap_malloc(soap, sizeof(_ns1__doLinkOutSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doLinkOutSN *)soap_instantiate__ns1__doLinkOutSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doLinkOutSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doLinkOutSN, sizeof(_ns1__doLinkOutSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doLinkOutSN(struct soap *soap, _ns1__doLinkOutSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doLinkOutSN(soap, tag ? tag : "ns1:doLinkOutSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doLinkOutSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__doLinkOutSN(struct soap *soap, _ns1__doLinkOutSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doLinkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChkLinkOutSN(struct soap *soap, _ns1__ChkLinkOutSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChkLinkOutSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChkLinkOutSN(struct soap *soap, const char *tag, int id, _ns1__ChkLinkOutSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChkLinkOutSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChkLinkOutSN ? type : NULL);
}

SOAP_FMAC3 _ns1__ChkLinkOutSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChkLinkOutSN(struct soap *soap, const char *tag, _ns1__ChkLinkOutSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChkLinkOutSN **)soap_malloc(soap, sizeof(_ns1__ChkLinkOutSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChkLinkOutSN *)soap_instantiate__ns1__ChkLinkOutSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChkLinkOutSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChkLinkOutSN, sizeof(_ns1__ChkLinkOutSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChkLinkOutSN(struct soap *soap, _ns1__ChkLinkOutSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChkLinkOutSN(soap, tag ? tag : "ns1:ChkLinkOutSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChkLinkOutSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChkLinkOutSN(struct soap *soap, _ns1__ChkLinkOutSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChkLinkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkOutSN(struct soap *soap, _ns1__chkOutSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkOutSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkOutSN(struct soap *soap, const char *tag, int id, _ns1__chkOutSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkOutSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkOutSN ? type : NULL);
}

SOAP_FMAC3 _ns1__chkOutSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkOutSN(struct soap *soap, const char *tag, _ns1__chkOutSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkOutSN **)soap_malloc(soap, sizeof(_ns1__chkOutSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkOutSN *)soap_instantiate__ns1__chkOutSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkOutSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkOutSN, sizeof(_ns1__chkOutSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkOutSN(struct soap *soap, _ns1__chkOutSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkOutSN(soap, tag ? tag : "ns1:chkOutSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkOutSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkOutSN(struct soap *soap, _ns1__chkOutSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLintOutQty(struct soap *soap, _ns1__GetLintOutQty *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLintOutQty))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLintOutQty(struct soap *soap, const char *tag, int id, _ns1__GetLintOutQty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLintOutQty, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetLintOutQty ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLintOutQty ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLintOutQty(struct soap *soap, const char *tag, _ns1__GetLintOutQty **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLintOutQty **)soap_malloc(soap, sizeof(_ns1__GetLintOutQty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLintOutQty *)soap_instantiate__ns1__GetLintOutQty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLintOutQty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLintOutQty, sizeof(_ns1__GetLintOutQty), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLintOutQty(struct soap *soap, _ns1__GetLintOutQty *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLintOutQty(soap, tag ? tag : "ns1:GetLintOutQty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLintOutQty ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLintOutQty(struct soap *soap, _ns1__GetLintOutQty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLintOutQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SNLinkZJ(struct soap *soap, _ns1__SNLinkZJ *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SNLinkZJ))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SNLinkZJ(struct soap *soap, const char *tag, int id, _ns1__SNLinkZJ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SNLinkZJ, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SNLinkZJ ? type : NULL);
}

SOAP_FMAC3 _ns1__SNLinkZJ ** SOAP_FMAC4 soap_in_PointerTo_ns1__SNLinkZJ(struct soap *soap, const char *tag, _ns1__SNLinkZJ **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SNLinkZJ **)soap_malloc(soap, sizeof(_ns1__SNLinkZJ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SNLinkZJ *)soap_instantiate__ns1__SNLinkZJ(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SNLinkZJ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SNLinkZJ, sizeof(_ns1__SNLinkZJ), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SNLinkZJ(struct soap *soap, _ns1__SNLinkZJ *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SNLinkZJ(soap, tag ? tag : "ns1:SNLinkZJ", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SNLinkZJ ** SOAP_FMAC4 soap_get_PointerTo_ns1__SNLinkZJ(struct soap *soap, _ns1__SNLinkZJ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SNLinkZJ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsZJTestData(struct soap *soap, _ns1__InsZJTestData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsZJTestData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsZJTestData(struct soap *soap, const char *tag, int id, _ns1__InsZJTestData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsZJTestData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsZJTestData ? type : NULL);
}

SOAP_FMAC3 _ns1__InsZJTestData ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsZJTestData(struct soap *soap, const char *tag, _ns1__InsZJTestData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsZJTestData **)soap_malloc(soap, sizeof(_ns1__InsZJTestData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsZJTestData *)soap_instantiate__ns1__InsZJTestData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsZJTestData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsZJTestData, sizeof(_ns1__InsZJTestData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsZJTestData(struct soap *soap, _ns1__InsZJTestData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsZJTestData(soap, tag ? tag : "ns1:InsZJTestData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsZJTestData ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsZJTestData(struct soap *soap, _ns1__InsZJTestData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsZJTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doPmcSNLink(struct soap *soap, _ns1__doPmcSNLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doPmcSNLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doPmcSNLink(struct soap *soap, const char *tag, int id, _ns1__doPmcSNLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doPmcSNLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doPmcSNLink ? type : NULL);
}

SOAP_FMAC3 _ns1__doPmcSNLink ** SOAP_FMAC4 soap_in_PointerTo_ns1__doPmcSNLink(struct soap *soap, const char *tag, _ns1__doPmcSNLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doPmcSNLink **)soap_malloc(soap, sizeof(_ns1__doPmcSNLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doPmcSNLink *)soap_instantiate__ns1__doPmcSNLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doPmcSNLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doPmcSNLink, sizeof(_ns1__doPmcSNLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doPmcSNLink(struct soap *soap, _ns1__doPmcSNLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doPmcSNLink(soap, tag ? tag : "ns1:doPmcSNLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doPmcSNLink ** SOAP_FMAC4 soap_get_PointerTo_ns1__doPmcSNLink(struct soap *soap, _ns1__doPmcSNLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doPmcSNLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPmcSNPart(struct soap *soap, _ns1__GetPmcSNPart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPmcSNPart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPmcSNPart(struct soap *soap, const char *tag, int id, _ns1__GetPmcSNPart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPmcSNPart, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPmcSNPart ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPmcSNPart ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPmcSNPart(struct soap *soap, const char *tag, _ns1__GetPmcSNPart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPmcSNPart **)soap_malloc(soap, sizeof(_ns1__GetPmcSNPart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPmcSNPart *)soap_instantiate__ns1__GetPmcSNPart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPmcSNPart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPmcSNPart, sizeof(_ns1__GetPmcSNPart), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPmcSNPart(struct soap *soap, _ns1__GetPmcSNPart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPmcSNPart(soap, tag ? tag : "ns1:GetPmcSNPart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPmcSNPart ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPmcSNPart(struct soap *soap, _ns1__GetPmcSNPart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPmcSNPart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPmcPartAssyList(struct soap *soap, _ns1__getPmcPartAssyList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPmcPartAssyList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPmcPartAssyList(struct soap *soap, const char *tag, int id, _ns1__getPmcPartAssyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPmcPartAssyList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPmcPartAssyList ? type : NULL);
}

SOAP_FMAC3 _ns1__getPmcPartAssyList ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPmcPartAssyList(struct soap *soap, const char *tag, _ns1__getPmcPartAssyList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPmcPartAssyList **)soap_malloc(soap, sizeof(_ns1__getPmcPartAssyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPmcPartAssyList *)soap_instantiate__ns1__getPmcPartAssyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPmcPartAssyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPmcPartAssyList, sizeof(_ns1__getPmcPartAssyList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPmcPartAssyList(struct soap *soap, _ns1__getPmcPartAssyList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPmcPartAssyList(soap, tag ? tag : "ns1:getPmcPartAssyList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPmcPartAssyList ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPmcPartAssyList(struct soap *soap, _ns1__getPmcPartAssyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPmcPartAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPmcAssyList(struct soap *soap, _ns1__getPmcAssyList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPmcAssyList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPmcAssyList(struct soap *soap, const char *tag, int id, _ns1__getPmcAssyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPmcAssyList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPmcAssyList ? type : NULL);
}

SOAP_FMAC3 _ns1__getPmcAssyList ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPmcAssyList(struct soap *soap, const char *tag, _ns1__getPmcAssyList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPmcAssyList **)soap_malloc(soap, sizeof(_ns1__getPmcAssyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPmcAssyList *)soap_instantiate__ns1__getPmcAssyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPmcAssyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPmcAssyList, sizeof(_ns1__getPmcAssyList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPmcAssyList(struct soap *soap, _ns1__getPmcAssyList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPmcAssyList(soap, tag ? tag : "ns1:getPmcAssyList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPmcAssyList ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPmcAssyList(struct soap *soap, _ns1__getPmcAssyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPmcAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doAssy(struct soap *soap, _ns1__doAssy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doAssy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doAssy(struct soap *soap, const char *tag, int id, _ns1__doAssy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doAssy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doAssy ? type : NULL);
}

SOAP_FMAC3 _ns1__doAssy ** SOAP_FMAC4 soap_in_PointerTo_ns1__doAssy(struct soap *soap, const char *tag, _ns1__doAssy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doAssy **)soap_malloc(soap, sizeof(_ns1__doAssy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doAssy *)soap_instantiate__ns1__doAssy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doAssy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doAssy, sizeof(_ns1__doAssy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doAssy(struct soap *soap, _ns1__doAssy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doAssy(soap, tag ? tag : "ns1:doAssy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doAssy ** SOAP_FMAC4 soap_get_PointerTo_ns1__doAssy(struct soap *soap, _ns1__doAssy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doAssy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkAssySN(struct soap *soap, _ns1__chkAssySN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkAssySN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkAssySN(struct soap *soap, const char *tag, int id, _ns1__chkAssySN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkAssySN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkAssySN ? type : NULL);
}

SOAP_FMAC3 _ns1__chkAssySN ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkAssySN(struct soap *soap, const char *tag, _ns1__chkAssySN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkAssySN **)soap_malloc(soap, sizeof(_ns1__chkAssySN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkAssySN *)soap_instantiate__ns1__chkAssySN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkAssySN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkAssySN, sizeof(_ns1__chkAssySN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkAssySN(struct soap *soap, _ns1__chkAssySN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkAssySN(soap, tag ? tag : "ns1:chkAssySN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkAssySN ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkAssySN(struct soap *soap, _ns1__chkAssySN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkAssySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPNbySN(struct soap *soap, _ns1__getPNbySN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPNbySN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPNbySN(struct soap *soap, const char *tag, int id, _ns1__getPNbySN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPNbySN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPNbySN ? type : NULL);
}

SOAP_FMAC3 _ns1__getPNbySN ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPNbySN(struct soap *soap, const char *tag, _ns1__getPNbySN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPNbySN **)soap_malloc(soap, sizeof(_ns1__getPNbySN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPNbySN *)soap_instantiate__ns1__getPNbySN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPNbySN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPNbySN, sizeof(_ns1__getPNbySN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPNbySN(struct soap *soap, _ns1__getPNbySN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPNbySN(soap, tag ? tag : "ns1:getPNbySN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPNbySN ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPNbySN(struct soap *soap, _ns1__getPNbySN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPNbySN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMoAssyCount(struct soap *soap, _ns1__getMoAssyCount *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMoAssyCount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMoAssyCount(struct soap *soap, const char *tag, int id, _ns1__getMoAssyCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMoAssyCount, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getMoAssyCount ? type : NULL);
}

SOAP_FMAC3 _ns1__getMoAssyCount ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMoAssyCount(struct soap *soap, const char *tag, _ns1__getMoAssyCount **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMoAssyCount **)soap_malloc(soap, sizeof(_ns1__getMoAssyCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMoAssyCount *)soap_instantiate__ns1__getMoAssyCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getMoAssyCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMoAssyCount, sizeof(_ns1__getMoAssyCount), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMoAssyCount(struct soap *soap, _ns1__getMoAssyCount *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getMoAssyCount(soap, tag ? tag : "ns1:getMoAssyCount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMoAssyCount ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMoAssyCount(struct soap *soap, _ns1__getMoAssyCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMoAssyCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLinkOutSn(struct soap *soap, _ns1__GetLinkOutSn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLinkOutSn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLinkOutSn(struct soap *soap, const char *tag, int id, _ns1__GetLinkOutSn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLinkOutSn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetLinkOutSn ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLinkOutSn ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLinkOutSn(struct soap *soap, const char *tag, _ns1__GetLinkOutSn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLinkOutSn **)soap_malloc(soap, sizeof(_ns1__GetLinkOutSn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLinkOutSn *)soap_instantiate__ns1__GetLinkOutSn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLinkOutSn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLinkOutSn, sizeof(_ns1__GetLinkOutSn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLinkOutSn(struct soap *soap, _ns1__GetLinkOutSn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLinkOutSn(soap, tag ? tag : "ns1:GetLinkOutSn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLinkOutSn ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLinkOutSn(struct soap *soap, _ns1__GetLinkOutSn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLinkOutSn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsPartAssy(struct soap *soap, _ns1__InsPartAssy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsPartAssy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsPartAssy(struct soap *soap, const char *tag, int id, _ns1__InsPartAssy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsPartAssy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsPartAssy ? type : NULL);
}

SOAP_FMAC3 _ns1__InsPartAssy ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsPartAssy(struct soap *soap, const char *tag, _ns1__InsPartAssy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsPartAssy **)soap_malloc(soap, sizeof(_ns1__InsPartAssy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsPartAssy *)soap_instantiate__ns1__InsPartAssy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsPartAssy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsPartAssy, sizeof(_ns1__InsPartAssy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsPartAssy(struct soap *soap, _ns1__InsPartAssy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsPartAssy(soap, tag ? tag : "ns1:InsPartAssy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsPartAssy ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsPartAssy(struct soap *soap, _ns1__InsPartAssy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsPartAssy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPartBomExt(struct soap *soap, _ns1__getPartBomExt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPartBomExt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPartBomExt(struct soap *soap, const char *tag, int id, _ns1__getPartBomExt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPartBomExt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPartBomExt ? type : NULL);
}

SOAP_FMAC3 _ns1__getPartBomExt ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPartBomExt(struct soap *soap, const char *tag, _ns1__getPartBomExt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPartBomExt **)soap_malloc(soap, sizeof(_ns1__getPartBomExt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPartBomExt *)soap_instantiate__ns1__getPartBomExt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPartBomExt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPartBomExt, sizeof(_ns1__getPartBomExt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPartBomExt(struct soap *soap, _ns1__getPartBomExt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPartBomExt(soap, tag ? tag : "ns1:getPartBomExt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPartBomExt ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPartBomExt(struct soap *soap, _ns1__getPartBomExt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPartBomExt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMoAssyList(struct soap *soap, _ns1__getMoAssyList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMoAssyList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMoAssyList(struct soap *soap, const char *tag, int id, _ns1__getMoAssyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMoAssyList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getMoAssyList ? type : NULL);
}

SOAP_FMAC3 _ns1__getMoAssyList ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMoAssyList(struct soap *soap, const char *tag, _ns1__getMoAssyList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMoAssyList **)soap_malloc(soap, sizeof(_ns1__getMoAssyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMoAssyList *)soap_instantiate__ns1__getMoAssyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getMoAssyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMoAssyList, sizeof(_ns1__getMoAssyList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMoAssyList(struct soap *soap, _ns1__getMoAssyList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getMoAssyList(soap, tag ? tag : "ns1:getMoAssyList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMoAssyList ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMoAssyList(struct soap *soap, _ns1__getMoAssyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMoAssyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkSnMapping(struct soap *soap, _ns1__chkSnMapping *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkSnMapping))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkSnMapping(struct soap *soap, const char *tag, int id, _ns1__chkSnMapping *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkSnMapping, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkSnMapping ? type : NULL);
}

SOAP_FMAC3 _ns1__chkSnMapping ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkSnMapping(struct soap *soap, const char *tag, _ns1__chkSnMapping **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkSnMapping **)soap_malloc(soap, sizeof(_ns1__chkSnMapping *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkSnMapping *)soap_instantiate__ns1__chkSnMapping(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkSnMapping **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkSnMapping, sizeof(_ns1__chkSnMapping), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkSnMapping(struct soap *soap, _ns1__chkSnMapping *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkSnMapping(soap, tag ? tag : "ns1:chkSnMapping", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkSnMapping ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkSnMapping(struct soap *soap, _ns1__chkSnMapping **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkSnMapping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getStationTypeDesc(struct soap *soap, _ns1__getStationTypeDesc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getStationTypeDesc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getStationTypeDesc(struct soap *soap, const char *tag, int id, _ns1__getStationTypeDesc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getStationTypeDesc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getStationTypeDesc ? type : NULL);
}

SOAP_FMAC3 _ns1__getStationTypeDesc ** SOAP_FMAC4 soap_in_PointerTo_ns1__getStationTypeDesc(struct soap *soap, const char *tag, _ns1__getStationTypeDesc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getStationTypeDesc **)soap_malloc(soap, sizeof(_ns1__getStationTypeDesc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getStationTypeDesc *)soap_instantiate__ns1__getStationTypeDesc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getStationTypeDesc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getStationTypeDesc, sizeof(_ns1__getStationTypeDesc), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getStationTypeDesc(struct soap *soap, _ns1__getStationTypeDesc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getStationTypeDesc(soap, tag ? tag : "ns1:getStationTypeDesc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getStationTypeDesc ** SOAP_FMAC4 soap_get_PointerTo_ns1__getStationTypeDesc(struct soap *soap, _ns1__getStationTypeDesc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getStationTypeDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getStationByMo(struct soap *soap, _ns1__getStationByMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getStationByMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getStationByMo(struct soap *soap, const char *tag, int id, _ns1__getStationByMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getStationByMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getStationByMo ? type : NULL);
}

SOAP_FMAC3 _ns1__getStationByMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__getStationByMo(struct soap *soap, const char *tag, _ns1__getStationByMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getStationByMo **)soap_malloc(soap, sizeof(_ns1__getStationByMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getStationByMo *)soap_instantiate__ns1__getStationByMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getStationByMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getStationByMo, sizeof(_ns1__getStationByMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getStationByMo(struct soap *soap, _ns1__getStationByMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getStationByMo(soap, tag ? tag : "ns1:getStationByMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getStationByMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__getStationByMo(struct soap *soap, _ns1__getStationByMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getStationByMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SnDoMapping(struct soap *soap, _ns1__SnDoMapping *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SnDoMapping))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SnDoMapping(struct soap *soap, const char *tag, int id, _ns1__SnDoMapping *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SnDoMapping, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SnDoMapping ? type : NULL);
}

SOAP_FMAC3 _ns1__SnDoMapping ** SOAP_FMAC4 soap_in_PointerTo_ns1__SnDoMapping(struct soap *soap, const char *tag, _ns1__SnDoMapping **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SnDoMapping **)soap_malloc(soap, sizeof(_ns1__SnDoMapping *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SnDoMapping *)soap_instantiate__ns1__SnDoMapping(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SnDoMapping **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SnDoMapping, sizeof(_ns1__SnDoMapping), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SnDoMapping(struct soap *soap, _ns1__SnDoMapping *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SnDoMapping(soap, tag ? tag : "ns1:SnDoMapping", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SnDoMapping ** SOAP_FMAC4 soap_get_PointerTo_ns1__SnDoMapping(struct soap *soap, _ns1__SnDoMapping **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SnDoMapping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__eMesNextMo(struct soap *soap, _ns1__eMesNextMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__eMesNextMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__eMesNextMo(struct soap *soap, const char *tag, int id, _ns1__eMesNextMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__eMesNextMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__eMesNextMo ? type : NULL);
}

SOAP_FMAC3 _ns1__eMesNextMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__eMesNextMo(struct soap *soap, const char *tag, _ns1__eMesNextMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__eMesNextMo **)soap_malloc(soap, sizeof(_ns1__eMesNextMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__eMesNextMo *)soap_instantiate__ns1__eMesNextMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__eMesNextMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__eMesNextMo, sizeof(_ns1__eMesNextMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__eMesNextMo(struct soap *soap, _ns1__eMesNextMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__eMesNextMo(soap, tag ? tag : "ns1:eMesNextMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__eMesNextMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__eMesNextMo(struct soap *soap, _ns1__eMesNextMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__eMesNextMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sendResultForStationNumber(struct soap *soap, _ns1__sendResultForStationNumber *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sendResultForStationNumber))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sendResultForStationNumber(struct soap *soap, const char *tag, int id, _ns1__sendResultForStationNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__sendResultForStationNumber, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__sendResultForStationNumber ? type : NULL);
}

SOAP_FMAC3 _ns1__sendResultForStationNumber ** SOAP_FMAC4 soap_in_PointerTo_ns1__sendResultForStationNumber(struct soap *soap, const char *tag, _ns1__sendResultForStationNumber **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__sendResultForStationNumber **)soap_malloc(soap, sizeof(_ns1__sendResultForStationNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__sendResultForStationNumber *)soap_instantiate__ns1__sendResultForStationNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__sendResultForStationNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__sendResultForStationNumber, sizeof(_ns1__sendResultForStationNumber), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sendResultForStationNumber(struct soap *soap, _ns1__sendResultForStationNumber *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__sendResultForStationNumber(soap, tag ? tag : "ns1:sendResultForStationNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__sendResultForStationNumber ** SOAP_FMAC4 soap_get_PointerTo_ns1__sendResultForStationNumber(struct soap *soap, _ns1__sendResultForStationNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sendResultForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sendDataForStationNumber(struct soap *soap, _ns1__sendDataForStationNumber *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sendDataForStationNumber))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sendDataForStationNumber(struct soap *soap, const char *tag, int id, _ns1__sendDataForStationNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__sendDataForStationNumber, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__sendDataForStationNumber ? type : NULL);
}

SOAP_FMAC3 _ns1__sendDataForStationNumber ** SOAP_FMAC4 soap_in_PointerTo_ns1__sendDataForStationNumber(struct soap *soap, const char *tag, _ns1__sendDataForStationNumber **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__sendDataForStationNumber **)soap_malloc(soap, sizeof(_ns1__sendDataForStationNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__sendDataForStationNumber *)soap_instantiate__ns1__sendDataForStationNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__sendDataForStationNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__sendDataForStationNumber, sizeof(_ns1__sendDataForStationNumber), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sendDataForStationNumber(struct soap *soap, _ns1__sendDataForStationNumber *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__sendDataForStationNumber(soap, tag ? tag : "ns1:sendDataForStationNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__sendDataForStationNumber ** SOAP_FMAC4 soap_get_PointerTo_ns1__sendDataForStationNumber(struct soap *soap, _ns1__sendDataForStationNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sendDataForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkEmpForStationNumber(struct soap *soap, _ns1__checkEmpForStationNumber *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkEmpForStationNumber))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkEmpForStationNumber(struct soap *soap, const char *tag, int id, _ns1__checkEmpForStationNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkEmpForStationNumber, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__checkEmpForStationNumber ? type : NULL);
}

SOAP_FMAC3 _ns1__checkEmpForStationNumber ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkEmpForStationNumber(struct soap *soap, const char *tag, _ns1__checkEmpForStationNumber **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkEmpForStationNumber **)soap_malloc(soap, sizeof(_ns1__checkEmpForStationNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkEmpForStationNumber *)soap_instantiate__ns1__checkEmpForStationNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkEmpForStationNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkEmpForStationNumber, sizeof(_ns1__checkEmpForStationNumber), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkEmpForStationNumber(struct soap *soap, _ns1__checkEmpForStationNumber *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkEmpForStationNumber(soap, tag ? tag : "ns1:checkEmpForStationNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkEmpForStationNumber ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkEmpForStationNumber(struct soap *soap, _ns1__checkEmpForStationNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkEmpForStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkSN_USCOREStationNumber(struct soap *soap, _ns1__checkSN_USCOREStationNumber *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkSN_USCOREStationNumber))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *tag, int id, _ns1__checkSN_USCOREStationNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkSN_USCOREStationNumber, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__checkSN_USCOREStationNumber ? type : NULL);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationNumber ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkSN_USCOREStationNumber(struct soap *soap, const char *tag, _ns1__checkSN_USCOREStationNumber **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkSN_USCOREStationNumber **)soap_malloc(soap, sizeof(_ns1__checkSN_USCOREStationNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkSN_USCOREStationNumber *)soap_instantiate__ns1__checkSN_USCOREStationNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkSN_USCOREStationNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkSN_USCOREStationNumber, sizeof(_ns1__checkSN_USCOREStationNumber), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkSN_USCOREStationNumber(struct soap *soap, _ns1__checkSN_USCOREStationNumber *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkSN_USCOREStationNumber(soap, tag ? tag : "ns1:checkSN_StationNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStationNumber ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkSN_USCOREStationNumber(struct soap *soap, _ns1__checkSN_USCOREStationNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkSN_USCOREStationNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChkSnNextMo(struct soap *soap, _ns1__ChkSnNextMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChkSnNextMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChkSnNextMo(struct soap *soap, const char *tag, int id, _ns1__ChkSnNextMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChkSnNextMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChkSnNextMo ? type : NULL);
}

SOAP_FMAC3 _ns1__ChkSnNextMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChkSnNextMo(struct soap *soap, const char *tag, _ns1__ChkSnNextMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChkSnNextMo **)soap_malloc(soap, sizeof(_ns1__ChkSnNextMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChkSnNextMo *)soap_instantiate__ns1__ChkSnNextMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChkSnNextMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChkSnNextMo, sizeof(_ns1__ChkSnNextMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChkSnNextMo(struct soap *soap, _ns1__ChkSnNextMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChkSnNextMo(soap, tag ? tag : "ns1:ChkSnNextMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChkSnNextMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChkSnNextMo(struct soap *soap, _ns1__ChkSnNextMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChkSnNextMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChkSnMo(struct soap *soap, _ns1__ChkSnMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChkSnMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChkSnMo(struct soap *soap, const char *tag, int id, _ns1__ChkSnMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChkSnMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChkSnMo ? type : NULL);
}

SOAP_FMAC3 _ns1__ChkSnMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChkSnMo(struct soap *soap, const char *tag, _ns1__ChkSnMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChkSnMo **)soap_malloc(soap, sizeof(_ns1__ChkSnMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChkSnMo *)soap_instantiate__ns1__ChkSnMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChkSnMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChkSnMo, sizeof(_ns1__ChkSnMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChkSnMo(struct soap *soap, _ns1__ChkSnMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChkSnMo(soap, tag ? tag : "ns1:ChkSnMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChkSnMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChkSnMo(struct soap *soap, _ns1__ChkSnMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChkSnMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkMoStation(struct soap *soap, _ns1__chkMoStation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkMoStation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkMoStation(struct soap *soap, const char *tag, int id, _ns1__chkMoStation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkMoStation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkMoStation ? type : NULL);
}

SOAP_FMAC3 _ns1__chkMoStation ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkMoStation(struct soap *soap, const char *tag, _ns1__chkMoStation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkMoStation **)soap_malloc(soap, sizeof(_ns1__chkMoStation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkMoStation *)soap_instantiate__ns1__chkMoStation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkMoStation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkMoStation, sizeof(_ns1__chkMoStation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkMoStation(struct soap *soap, _ns1__chkMoStation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkMoStation(soap, tag ? tag : "ns1:chkMoStation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkMoStation ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkMoStation(struct soap *soap, _ns1__chkMoStation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkMoStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetEnergyStat(struct soap *soap, _ns1__SetEnergyStat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetEnergyStat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetEnergyStat(struct soap *soap, const char *tag, int id, _ns1__SetEnergyStat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetEnergyStat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetEnergyStat ? type : NULL);
}

SOAP_FMAC3 _ns1__SetEnergyStat ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetEnergyStat(struct soap *soap, const char *tag, _ns1__SetEnergyStat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetEnergyStat **)soap_malloc(soap, sizeof(_ns1__SetEnergyStat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetEnergyStat *)soap_instantiate__ns1__SetEnergyStat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetEnergyStat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetEnergyStat, sizeof(_ns1__SetEnergyStat), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetEnergyStat(struct soap *soap, _ns1__SetEnergyStat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetEnergyStat(soap, tag ? tag : "ns1:SetEnergyStat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetEnergyStat ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetEnergyStat(struct soap *soap, _ns1__SetEnergyStat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetEnergyStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getInfoByMo(struct soap *soap, _ns1__getInfoByMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getInfoByMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getInfoByMo(struct soap *soap, const char *tag, int id, _ns1__getInfoByMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getInfoByMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getInfoByMo ? type : NULL);
}

SOAP_FMAC3 _ns1__getInfoByMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__getInfoByMo(struct soap *soap, const char *tag, _ns1__getInfoByMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getInfoByMo **)soap_malloc(soap, sizeof(_ns1__getInfoByMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getInfoByMo *)soap_instantiate__ns1__getInfoByMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getInfoByMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getInfoByMo, sizeof(_ns1__getInfoByMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getInfoByMo(struct soap *soap, _ns1__getInfoByMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getInfoByMo(soap, tag ? tag : "ns1:getInfoByMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getInfoByMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__getInfoByMo(struct soap *soap, _ns1__getInfoByMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getInfoByMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsThermalNew(struct soap *soap, _ns1__InsThermalNew *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsThermalNew))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsThermalNew(struct soap *soap, const char *tag, int id, _ns1__InsThermalNew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsThermalNew, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsThermalNew ? type : NULL);
}

SOAP_FMAC3 _ns1__InsThermalNew ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsThermalNew(struct soap *soap, const char *tag, _ns1__InsThermalNew **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsThermalNew **)soap_malloc(soap, sizeof(_ns1__InsThermalNew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsThermalNew *)soap_instantiate__ns1__InsThermalNew(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsThermalNew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsThermalNew, sizeof(_ns1__InsThermalNew), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsThermalNew(struct soap *soap, _ns1__InsThermalNew *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsThermalNew(soap, tag ? tag : "ns1:InsThermalNew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsThermalNew ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsThermalNew(struct soap *soap, _ns1__InsThermalNew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsThermalNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChkSnLink(struct soap *soap, _ns1__ChkSnLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChkSnLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChkSnLink(struct soap *soap, const char *tag, int id, _ns1__ChkSnLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChkSnLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChkSnLink ? type : NULL);
}

SOAP_FMAC3 _ns1__ChkSnLink ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChkSnLink(struct soap *soap, const char *tag, _ns1__ChkSnLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChkSnLink **)soap_malloc(soap, sizeof(_ns1__ChkSnLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChkSnLink *)soap_instantiate__ns1__ChkSnLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChkSnLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChkSnLink, sizeof(_ns1__ChkSnLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChkSnLink(struct soap *soap, _ns1__ChkSnLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChkSnLink(soap, tag ? tag : "ns1:ChkSnLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChkSnLink ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChkSnLink(struct soap *soap, _ns1__ChkSnLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChkSnLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsThermal(struct soap *soap, _ns1__InsThermal *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsThermal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsThermal(struct soap *soap, const char *tag, int id, _ns1__InsThermal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsThermal, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsThermal ? type : NULL);
}

SOAP_FMAC3 _ns1__InsThermal ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsThermal(struct soap *soap, const char *tag, _ns1__InsThermal **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsThermal **)soap_malloc(soap, sizeof(_ns1__InsThermal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsThermal *)soap_instantiate__ns1__InsThermal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsThermal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsThermal, sizeof(_ns1__InsThermal), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsThermal(struct soap *soap, _ns1__InsThermal *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsThermal(soap, tag ? tag : "ns1:InsThermal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsThermal ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsThermal(struct soap *soap, _ns1__InsThermal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsThermal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsWHDetection(struct soap *soap, _ns1__InsWHDetection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsWHDetection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsWHDetection(struct soap *soap, const char *tag, int id, _ns1__InsWHDetection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsWHDetection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsWHDetection ? type : NULL);
}

SOAP_FMAC3 _ns1__InsWHDetection ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsWHDetection(struct soap *soap, const char *tag, _ns1__InsWHDetection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsWHDetection **)soap_malloc(soap, sizeof(_ns1__InsWHDetection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsWHDetection *)soap_instantiate__ns1__InsWHDetection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsWHDetection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsWHDetection, sizeof(_ns1__InsWHDetection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsWHDetection(struct soap *soap, _ns1__InsWHDetection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsWHDetection(soap, tag ? tag : "ns1:InsWHDetection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsWHDetection ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsWHDetection(struct soap *soap, _ns1__InsWHDetection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsWHDetection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsFlatNessForCL(struct soap *soap, _ns1__InsFlatNessForCL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsFlatNessForCL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsFlatNessForCL(struct soap *soap, const char *tag, int id, _ns1__InsFlatNessForCL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsFlatNessForCL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsFlatNessForCL ? type : NULL);
}

SOAP_FMAC3 _ns1__InsFlatNessForCL ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsFlatNessForCL(struct soap *soap, const char *tag, _ns1__InsFlatNessForCL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsFlatNessForCL **)soap_malloc(soap, sizeof(_ns1__InsFlatNessForCL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsFlatNessForCL *)soap_instantiate__ns1__InsFlatNessForCL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsFlatNessForCL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsFlatNessForCL, sizeof(_ns1__InsFlatNessForCL), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsFlatNessForCL(struct soap *soap, _ns1__InsFlatNessForCL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsFlatNessForCL(soap, tag ? tag : "ns1:InsFlatNessForCL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsFlatNessForCL ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsFlatNessForCL(struct soap *soap, _ns1__InsFlatNessForCL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsFlatNessForCL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsFlatNessForLSD(struct soap *soap, _ns1__InsFlatNessForLSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsFlatNessForLSD))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsFlatNessForLSD(struct soap *soap, const char *tag, int id, _ns1__InsFlatNessForLSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsFlatNessForLSD, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsFlatNessForLSD ? type : NULL);
}

SOAP_FMAC3 _ns1__InsFlatNessForLSD ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsFlatNessForLSD(struct soap *soap, const char *tag, _ns1__InsFlatNessForLSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsFlatNessForLSD **)soap_malloc(soap, sizeof(_ns1__InsFlatNessForLSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsFlatNessForLSD *)soap_instantiate__ns1__InsFlatNessForLSD(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsFlatNessForLSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsFlatNessForLSD, sizeof(_ns1__InsFlatNessForLSD), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsFlatNessForLSD(struct soap *soap, _ns1__InsFlatNessForLSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsFlatNessForLSD(soap, tag ? tag : "ns1:InsFlatNessForLSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsFlatNessForLSD ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsFlatNessForLSD(struct soap *soap, _ns1__InsFlatNessForLSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsFlatNessForLSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsFlatNess(struct soap *soap, _ns1__InsFlatNess *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsFlatNess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsFlatNess(struct soap *soap, const char *tag, int id, _ns1__InsFlatNess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsFlatNess, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsFlatNess ? type : NULL);
}

SOAP_FMAC3 _ns1__InsFlatNess ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsFlatNess(struct soap *soap, const char *tag, _ns1__InsFlatNess **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsFlatNess **)soap_malloc(soap, sizeof(_ns1__InsFlatNess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsFlatNess *)soap_instantiate__ns1__InsFlatNess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsFlatNess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsFlatNess, sizeof(_ns1__InsFlatNess), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsFlatNess(struct soap *soap, _ns1__InsFlatNess *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsFlatNess(soap, tag ? tag : "ns1:InsFlatNess", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsFlatNess ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsFlatNess(struct soap *soap, _ns1__InsFlatNess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsFlatNess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ImpMesAteTestData(struct soap *soap, _ns1__ImpMesAteTestData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ImpMesAteTestData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ImpMesAteTestData(struct soap *soap, const char *tag, int id, _ns1__ImpMesAteTestData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ImpMesAteTestData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ImpMesAteTestData ? type : NULL);
}

SOAP_FMAC3 _ns1__ImpMesAteTestData ** SOAP_FMAC4 soap_in_PointerTo_ns1__ImpMesAteTestData(struct soap *soap, const char *tag, _ns1__ImpMesAteTestData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ImpMesAteTestData **)soap_malloc(soap, sizeof(_ns1__ImpMesAteTestData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ImpMesAteTestData *)soap_instantiate__ns1__ImpMesAteTestData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ImpMesAteTestData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ImpMesAteTestData, sizeof(_ns1__ImpMesAteTestData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ImpMesAteTestData(struct soap *soap, _ns1__ImpMesAteTestData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ImpMesAteTestData(soap, tag ? tag : "ns1:ImpMesAteTestData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ImpMesAteTestData ** SOAP_FMAC4 soap_get_PointerTo_ns1__ImpMesAteTestData(struct soap *soap, _ns1__ImpMesAteTestData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ImpMesAteTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkStationTime(struct soap *soap, _ns1__chkStationTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkStationTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkStationTime(struct soap *soap, const char *tag, int id, _ns1__chkStationTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkStationTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkStationTime ? type : NULL);
}

SOAP_FMAC3 _ns1__chkStationTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkStationTime(struct soap *soap, const char *tag, _ns1__chkStationTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkStationTime **)soap_malloc(soap, sizeof(_ns1__chkStationTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkStationTime *)soap_instantiate__ns1__chkStationTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkStationTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkStationTime, sizeof(_ns1__chkStationTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkStationTime(struct soap *soap, _ns1__chkStationTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkStationTime(soap, tag ? tag : "ns1:chkStationTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkStationTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkStationTime(struct soap *soap, _ns1__chkStationTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkStationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InFruitsOrtQty(struct soap *soap, _ns1__InFruitsOrtQty *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InFruitsOrtQty))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InFruitsOrtQty(struct soap *soap, const char *tag, int id, _ns1__InFruitsOrtQty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InFruitsOrtQty, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InFruitsOrtQty ? type : NULL);
}

SOAP_FMAC3 _ns1__InFruitsOrtQty ** SOAP_FMAC4 soap_in_PointerTo_ns1__InFruitsOrtQty(struct soap *soap, const char *tag, _ns1__InFruitsOrtQty **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InFruitsOrtQty **)soap_malloc(soap, sizeof(_ns1__InFruitsOrtQty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InFruitsOrtQty *)soap_instantiate__ns1__InFruitsOrtQty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InFruitsOrtQty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InFruitsOrtQty, sizeof(_ns1__InFruitsOrtQty), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InFruitsOrtQty(struct soap *soap, _ns1__InFruitsOrtQty *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InFruitsOrtQty(soap, tag ? tag : "ns1:InFruitsOrtQty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InFruitsOrtQty ** SOAP_FMAC4 soap_get_PointerTo_ns1__InFruitsOrtQty(struct soap *soap, _ns1__InFruitsOrtQty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InFruitsOrtQty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sendTestResult(struct soap *soap, _ns1__sendTestResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sendTestResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sendTestResult(struct soap *soap, const char *tag, int id, _ns1__sendTestResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__sendTestResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__sendTestResult ? type : NULL);
}

SOAP_FMAC3 _ns1__sendTestResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__sendTestResult(struct soap *soap, const char *tag, _ns1__sendTestResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__sendTestResult **)soap_malloc(soap, sizeof(_ns1__sendTestResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__sendTestResult *)soap_instantiate__ns1__sendTestResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__sendTestResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__sendTestResult, sizeof(_ns1__sendTestResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sendTestResult(struct soap *soap, _ns1__sendTestResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__sendTestResult(soap, tag ? tag : "ns1:sendTestResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__sendTestResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__sendTestResult(struct soap *soap, _ns1__sendTestResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sendTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sendTestData(struct soap *soap, _ns1__sendTestData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sendTestData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sendTestData(struct soap *soap, const char *tag, int id, _ns1__sendTestData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__sendTestData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__sendTestData ? type : NULL);
}

SOAP_FMAC3 _ns1__sendTestData ** SOAP_FMAC4 soap_in_PointerTo_ns1__sendTestData(struct soap *soap, const char *tag, _ns1__sendTestData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__sendTestData **)soap_malloc(soap, sizeof(_ns1__sendTestData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__sendTestData *)soap_instantiate__ns1__sendTestData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__sendTestData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__sendTestData, sizeof(_ns1__sendTestData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sendTestData(struct soap *soap, _ns1__sendTestData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__sendTestData(soap, tag ? tag : "ns1:sendTestData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__sendTestData ** SOAP_FMAC4 soap_get_PointerTo_ns1__sendTestData(struct soap *soap, _ns1__sendTestData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sendTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkSN_USCOREStation(struct soap *soap, _ns1__checkSN_USCOREStation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkSN_USCOREStation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkSN_USCOREStation(struct soap *soap, const char *tag, int id, _ns1__checkSN_USCOREStation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkSN_USCOREStation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__checkSN_USCOREStation ? type : NULL);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStation ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkSN_USCOREStation(struct soap *soap, const char *tag, _ns1__checkSN_USCOREStation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkSN_USCOREStation **)soap_malloc(soap, sizeof(_ns1__checkSN_USCOREStation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkSN_USCOREStation *)soap_instantiate__ns1__checkSN_USCOREStation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkSN_USCOREStation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkSN_USCOREStation, sizeof(_ns1__checkSN_USCOREStation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkSN_USCOREStation(struct soap *soap, _ns1__checkSN_USCOREStation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkSN_USCOREStation(soap, tag ? tag : "ns1:checkSN_Station", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkSN_USCOREStation ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkSN_USCOREStation(struct soap *soap, _ns1__checkSN_USCOREStation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkSN_USCOREStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkEmpNo(struct soap *soap, _ns1__checkEmpNo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkEmpNo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkEmpNo(struct soap *soap, const char *tag, int id, _ns1__checkEmpNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkEmpNo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__checkEmpNo ? type : NULL);
}

SOAP_FMAC3 _ns1__checkEmpNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkEmpNo(struct soap *soap, const char *tag, _ns1__checkEmpNo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkEmpNo **)soap_malloc(soap, sizeof(_ns1__checkEmpNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkEmpNo *)soap_instantiate__ns1__checkEmpNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkEmpNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkEmpNo, sizeof(_ns1__checkEmpNo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkEmpNo(struct soap *soap, _ns1__checkEmpNo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkEmpNo(soap, tag ? tag : "ns1:checkEmpNo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkEmpNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkEmpNo(struct soap *soap, _ns1__checkEmpNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkEmpNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkTestData(struct soap *soap, _ns1__checkTestData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkTestData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkTestData(struct soap *soap, const char *tag, int id, _ns1__checkTestData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkTestData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__checkTestData ? type : NULL);
}

SOAP_FMAC3 _ns1__checkTestData ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkTestData(struct soap *soap, const char *tag, _ns1__checkTestData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkTestData **)soap_malloc(soap, sizeof(_ns1__checkTestData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkTestData *)soap_instantiate__ns1__checkTestData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkTestData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkTestData, sizeof(_ns1__checkTestData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkTestData(struct soap *soap, _ns1__checkTestData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkTestData(soap, tag ? tag : "ns1:checkTestData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkTestData ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkTestData(struct soap *soap, _ns1__checkTestData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsZjList(struct soap *soap, _ns1__InsZjList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsZjList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsZjList(struct soap *soap, const char *tag, int id, _ns1__InsZjList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsZjList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsZjList ? type : NULL);
}

SOAP_FMAC3 _ns1__InsZjList ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsZjList(struct soap *soap, const char *tag, _ns1__InsZjList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsZjList **)soap_malloc(soap, sizeof(_ns1__InsZjList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsZjList *)soap_instantiate__ns1__InsZjList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsZjList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsZjList, sizeof(_ns1__InsZjList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsZjList(struct soap *soap, _ns1__InsZjList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsZjList(soap, tag ? tag : "ns1:InsZjList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsZjList ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsZjList(struct soap *soap, _ns1__InsZjList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsZjList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFruitMachineChk(struct soap *soap, _ns1__GetFruitMachineChk *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFruitMachineChk))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFruitMachineChk(struct soap *soap, const char *tag, int id, _ns1__GetFruitMachineChk *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFruitMachineChk, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetFruitMachineChk ? type : NULL);
}

SOAP_FMAC3 _ns1__GetFruitMachineChk ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFruitMachineChk(struct soap *soap, const char *tag, _ns1__GetFruitMachineChk **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFruitMachineChk **)soap_malloc(soap, sizeof(_ns1__GetFruitMachineChk *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFruitMachineChk *)soap_instantiate__ns1__GetFruitMachineChk(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetFruitMachineChk **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFruitMachineChk, sizeof(_ns1__GetFruitMachineChk), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFruitMachineChk(struct soap *soap, _ns1__GetFruitMachineChk *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFruitMachineChk(soap, tag ? tag : "ns1:GetFruitMachineChk", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFruitMachineChk ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFruitMachineChk(struct soap *soap, _ns1__GetFruitMachineChk **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFruitMachineChk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsFruitMachineChk(struct soap *soap, _ns1__InsFruitMachineChk *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsFruitMachineChk))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsFruitMachineChk(struct soap *soap, const char *tag, int id, _ns1__InsFruitMachineChk *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsFruitMachineChk, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsFruitMachineChk ? type : NULL);
}

SOAP_FMAC3 _ns1__InsFruitMachineChk ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsFruitMachineChk(struct soap *soap, const char *tag, _ns1__InsFruitMachineChk **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsFruitMachineChk **)soap_malloc(soap, sizeof(_ns1__InsFruitMachineChk *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsFruitMachineChk *)soap_instantiate__ns1__InsFruitMachineChk(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsFruitMachineChk **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsFruitMachineChk, sizeof(_ns1__InsFruitMachineChk), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsFruitMachineChk(struct soap *soap, _ns1__InsFruitMachineChk *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsFruitMachineChk(soap, tag ? tag : "ns1:InsFruitMachineChk", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsFruitMachineChk ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsFruitMachineChk(struct soap *soap, _ns1__InsFruitMachineChk **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsFruitMachineChk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SnLnkOutSN(struct soap *soap, _ns1__SnLnkOutSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SnLnkOutSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SnLnkOutSN(struct soap *soap, const char *tag, int id, _ns1__SnLnkOutSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SnLnkOutSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SnLnkOutSN ? type : NULL);
}

SOAP_FMAC3 _ns1__SnLnkOutSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__SnLnkOutSN(struct soap *soap, const char *tag, _ns1__SnLnkOutSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SnLnkOutSN **)soap_malloc(soap, sizeof(_ns1__SnLnkOutSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SnLnkOutSN *)soap_instantiate__ns1__SnLnkOutSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SnLnkOutSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SnLnkOutSN, sizeof(_ns1__SnLnkOutSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SnLnkOutSN(struct soap *soap, _ns1__SnLnkOutSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SnLnkOutSN(soap, tag ? tag : "ns1:SnLnkOutSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SnLnkOutSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__SnLnkOutSN(struct soap *soap, _ns1__SnLnkOutSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SnLnkOutSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMoBase(struct soap *soap, _ns1__getMoBase *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMoBase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMoBase(struct soap *soap, const char *tag, int id, _ns1__getMoBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMoBase, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getMoBase ? type : NULL);
}

SOAP_FMAC3 _ns1__getMoBase ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMoBase(struct soap *soap, const char *tag, _ns1__getMoBase **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMoBase **)soap_malloc(soap, sizeof(_ns1__getMoBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMoBase *)soap_instantiate__ns1__getMoBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getMoBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMoBase, sizeof(_ns1__getMoBase), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMoBase(struct soap *soap, _ns1__getMoBase *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getMoBase(soap, tag ? tag : "ns1:getMoBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMoBase ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMoBase(struct soap *soap, _ns1__getMoBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNgCode(struct soap *soap, _ns1__GetNgCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNgCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNgCode(struct soap *soap, const char *tag, int id, _ns1__GetNgCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNgCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetNgCode ? type : NULL);
}

SOAP_FMAC3 _ns1__GetNgCode ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNgCode(struct soap *soap, const char *tag, _ns1__GetNgCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNgCode **)soap_malloc(soap, sizeof(_ns1__GetNgCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNgCode *)soap_instantiate__ns1__GetNgCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetNgCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNgCode, sizeof(_ns1__GetNgCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNgCode(struct soap *soap, _ns1__GetNgCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNgCode(soap, tag ? tag : "ns1:GetNgCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNgCode ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNgCode(struct soap *soap, _ns1__GetNgCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNgCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetDiecastSN(struct soap *soap, _ns1__SetDiecastSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetDiecastSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetDiecastSN(struct soap *soap, const char *tag, int id, _ns1__SetDiecastSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetDiecastSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetDiecastSN ? type : NULL);
}

SOAP_FMAC3 _ns1__SetDiecastSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetDiecastSN(struct soap *soap, const char *tag, _ns1__SetDiecastSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetDiecastSN **)soap_malloc(soap, sizeof(_ns1__SetDiecastSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetDiecastSN *)soap_instantiate__ns1__SetDiecastSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetDiecastSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetDiecastSN, sizeof(_ns1__SetDiecastSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetDiecastSN(struct soap *soap, _ns1__SetDiecastSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetDiecastSN(soap, tag ? tag : "ns1:SetDiecastSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetDiecastSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetDiecastSN(struct soap *soap, _ns1__SetDiecastSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetDiecastSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMachineForGroup(struct soap *soap, _ns1__GetMachineForGroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMachineForGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMachineForGroup(struct soap *soap, const char *tag, int id, _ns1__GetMachineForGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMachineForGroup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMachineForGroup ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMachineForGroup ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMachineForGroup(struct soap *soap, const char *tag, _ns1__GetMachineForGroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMachineForGroup **)soap_malloc(soap, sizeof(_ns1__GetMachineForGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMachineForGroup *)soap_instantiate__ns1__GetMachineForGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMachineForGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMachineForGroup, sizeof(_ns1__GetMachineForGroup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMachineForGroup(struct soap *soap, _ns1__GetMachineForGroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMachineForGroup(soap, tag ? tag : "ns1:GetMachineForGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMachineForGroup ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMachineForGroup(struct soap *soap, _ns1__GetMachineForGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMachineForGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadForHP(struct soap *soap, _ns1__UploadForHP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadForHP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadForHP(struct soap *soap, const char *tag, int id, _ns1__UploadForHP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadForHP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UploadForHP ? type : NULL);
}

SOAP_FMAC3 _ns1__UploadForHP ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadForHP(struct soap *soap, const char *tag, _ns1__UploadForHP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadForHP **)soap_malloc(soap, sizeof(_ns1__UploadForHP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadForHP *)soap_instantiate__ns1__UploadForHP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UploadForHP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadForHP, sizeof(_ns1__UploadForHP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadForHP(struct soap *soap, _ns1__UploadForHP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UploadForHP(soap, tag ? tag : "ns1:UploadForHP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadForHP ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadForHP(struct soap *soap, _ns1__UploadForHP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadForHP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SelShelfLink(struct soap *soap, _ns1__SelShelfLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SelShelfLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SelShelfLink(struct soap *soap, const char *tag, int id, _ns1__SelShelfLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SelShelfLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SelShelfLink ? type : NULL);
}

SOAP_FMAC3 _ns1__SelShelfLink ** SOAP_FMAC4 soap_in_PointerTo_ns1__SelShelfLink(struct soap *soap, const char *tag, _ns1__SelShelfLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SelShelfLink **)soap_malloc(soap, sizeof(_ns1__SelShelfLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SelShelfLink *)soap_instantiate__ns1__SelShelfLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SelShelfLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SelShelfLink, sizeof(_ns1__SelShelfLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SelShelfLink(struct soap *soap, _ns1__SelShelfLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SelShelfLink(soap, tag ? tag : "ns1:SelShelfLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SelShelfLink ** SOAP_FMAC4 soap_get_PointerTo_ns1__SelShelfLink(struct soap *soap, _ns1__SelShelfLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SelShelfLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SNLinkShelf(struct soap *soap, _ns1__SNLinkShelf *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SNLinkShelf))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SNLinkShelf(struct soap *soap, const char *tag, int id, _ns1__SNLinkShelf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SNLinkShelf, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SNLinkShelf ? type : NULL);
}

SOAP_FMAC3 _ns1__SNLinkShelf ** SOAP_FMAC4 soap_in_PointerTo_ns1__SNLinkShelf(struct soap *soap, const char *tag, _ns1__SNLinkShelf **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SNLinkShelf **)soap_malloc(soap, sizeof(_ns1__SNLinkShelf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SNLinkShelf *)soap_instantiate__ns1__SNLinkShelf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SNLinkShelf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SNLinkShelf, sizeof(_ns1__SNLinkShelf), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SNLinkShelf(struct soap *soap, _ns1__SNLinkShelf *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SNLinkShelf(soap, tag ? tag : "ns1:SNLinkShelf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SNLinkShelf ** SOAP_FMAC4 soap_get_PointerTo_ns1__SNLinkShelf(struct soap *soap, _ns1__SNLinkShelf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SNLinkShelf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SelSNTestForFruit(struct soap *soap, _ns1__SelSNTestForFruit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SelSNTestForFruit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SelSNTestForFruit(struct soap *soap, const char *tag, int id, _ns1__SelSNTestForFruit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SelSNTestForFruit, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SelSNTestForFruit ? type : NULL);
}

SOAP_FMAC3 _ns1__SelSNTestForFruit ** SOAP_FMAC4 soap_in_PointerTo_ns1__SelSNTestForFruit(struct soap *soap, const char *tag, _ns1__SelSNTestForFruit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SelSNTestForFruit **)soap_malloc(soap, sizeof(_ns1__SelSNTestForFruit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SelSNTestForFruit *)soap_instantiate__ns1__SelSNTestForFruit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SelSNTestForFruit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SelSNTestForFruit, sizeof(_ns1__SelSNTestForFruit), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SelSNTestForFruit(struct soap *soap, _ns1__SelSNTestForFruit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SelSNTestForFruit(soap, tag ? tag : "ns1:SelSNTestForFruit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SelSNTestForFruit ** SOAP_FMAC4 soap_get_PointerTo_ns1__SelSNTestForFruit(struct soap *soap, _ns1__SelSNTestForFruit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SelSNTestForFruit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsSNTestForFruit(struct soap *soap, _ns1__InsSNTestForFruit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsSNTestForFruit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsSNTestForFruit(struct soap *soap, const char *tag, int id, _ns1__InsSNTestForFruit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsSNTestForFruit, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsSNTestForFruit ? type : NULL);
}

SOAP_FMAC3 _ns1__InsSNTestForFruit ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsSNTestForFruit(struct soap *soap, const char *tag, _ns1__InsSNTestForFruit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsSNTestForFruit **)soap_malloc(soap, sizeof(_ns1__InsSNTestForFruit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsSNTestForFruit *)soap_instantiate__ns1__InsSNTestForFruit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsSNTestForFruit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsSNTestForFruit, sizeof(_ns1__InsSNTestForFruit), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsSNTestForFruit(struct soap *soap, _ns1__InsSNTestForFruit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsSNTestForFruit(soap, tag ? tag : "ns1:InsSNTestForFruit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsSNTestForFruit ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsSNTestForFruit(struct soap *soap, _ns1__InsSNTestForFruit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsSNTestForFruit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStationNumberForSN(struct soap *soap, _ns1__GetStationNumberForSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStationNumberForSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStationNumberForSN(struct soap *soap, const char *tag, int id, _ns1__GetStationNumberForSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStationNumberForSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetStationNumberForSN ? type : NULL);
}

SOAP_FMAC3 _ns1__GetStationNumberForSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStationNumberForSN(struct soap *soap, const char *tag, _ns1__GetStationNumberForSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStationNumberForSN **)soap_malloc(soap, sizeof(_ns1__GetStationNumberForSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStationNumberForSN *)soap_instantiate__ns1__GetStationNumberForSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetStationNumberForSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStationNumberForSN, sizeof(_ns1__GetStationNumberForSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStationNumberForSN(struct soap *soap, _ns1__GetStationNumberForSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStationNumberForSN(soap, tag ? tag : "ns1:GetStationNumberForSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStationNumberForSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStationNumberForSN(struct soap *soap, _ns1__GetStationNumberForSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStationNumberForSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTestValueResult(struct soap *soap, _ns1__GetTestValueResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTestValueResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTestValueResult(struct soap *soap, const char *tag, int id, _ns1__GetTestValueResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTestValueResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetTestValueResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetTestValueResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTestValueResult(struct soap *soap, const char *tag, _ns1__GetTestValueResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTestValueResult **)soap_malloc(soap, sizeof(_ns1__GetTestValueResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTestValueResult *)soap_instantiate__ns1__GetTestValueResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetTestValueResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTestValueResult, sizeof(_ns1__GetTestValueResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTestValueResult(struct soap *soap, _ns1__GetTestValueResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTestValueResult(soap, tag ? tag : "ns1:GetTestValueResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTestValueResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTestValueResult(struct soap *soap, _ns1__GetTestValueResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTestValueResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsCLScada(struct soap *soap, _ns1__InsCLScada *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsCLScada))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsCLScada(struct soap *soap, const char *tag, int id, _ns1__InsCLScada *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsCLScada, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsCLScada ? type : NULL);
}

SOAP_FMAC3 _ns1__InsCLScada ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsCLScada(struct soap *soap, const char *tag, _ns1__InsCLScada **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsCLScada **)soap_malloc(soap, sizeof(_ns1__InsCLScada *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsCLScada *)soap_instantiate__ns1__InsCLScada(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsCLScada **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsCLScada, sizeof(_ns1__InsCLScada), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsCLScada(struct soap *soap, _ns1__InsCLScada *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsCLScada(soap, tag ? tag : "ns1:InsCLScada", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsCLScada ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsCLScada(struct soap *soap, _ns1__InsCLScada **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsCLScada(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsAoiMo(struct soap *soap, _ns1__InsAoiMo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsAoiMo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsAoiMo(struct soap *soap, const char *tag, int id, _ns1__InsAoiMo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsAoiMo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsAoiMo ? type : NULL);
}

SOAP_FMAC3 _ns1__InsAoiMo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsAoiMo(struct soap *soap, const char *tag, _ns1__InsAoiMo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsAoiMo **)soap_malloc(soap, sizeof(_ns1__InsAoiMo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsAoiMo *)soap_instantiate__ns1__InsAoiMo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsAoiMo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsAoiMo, sizeof(_ns1__InsAoiMo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsAoiMo(struct soap *soap, _ns1__InsAoiMo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsAoiMo(soap, tag ? tag : "ns1:InsAoiMo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsAoiMo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsAoiMo(struct soap *soap, _ns1__InsAoiMo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsAoiMo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__chkMoSNForAOI(struct soap *soap, _ns1__chkMoSNForAOI *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__chkMoSNForAOI))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__chkMoSNForAOI(struct soap *soap, const char *tag, int id, _ns1__chkMoSNForAOI *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__chkMoSNForAOI, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__chkMoSNForAOI ? type : NULL);
}

SOAP_FMAC3 _ns1__chkMoSNForAOI ** SOAP_FMAC4 soap_in_PointerTo_ns1__chkMoSNForAOI(struct soap *soap, const char *tag, _ns1__chkMoSNForAOI **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__chkMoSNForAOI **)soap_malloc(soap, sizeof(_ns1__chkMoSNForAOI *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__chkMoSNForAOI *)soap_instantiate__ns1__chkMoSNForAOI(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__chkMoSNForAOI **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__chkMoSNForAOI, sizeof(_ns1__chkMoSNForAOI), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__chkMoSNForAOI(struct soap *soap, _ns1__chkMoSNForAOI *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__chkMoSNForAOI(soap, tag ? tag : "ns1:chkMoSNForAOI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__chkMoSNForAOI ** SOAP_FMAC4 soap_get_PointerTo_ns1__chkMoSNForAOI(struct soap *soap, _ns1__chkMoSNForAOI **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__chkMoSNForAOI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PunchOut(struct soap *soap, _ns1__PunchOut *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PunchOut))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PunchOut(struct soap *soap, const char *tag, int id, _ns1__PunchOut *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PunchOut, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__PunchOut ? type : NULL);
}

SOAP_FMAC3 _ns1__PunchOut ** SOAP_FMAC4 soap_in_PointerTo_ns1__PunchOut(struct soap *soap, const char *tag, _ns1__PunchOut **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PunchOut **)soap_malloc(soap, sizeof(_ns1__PunchOut *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PunchOut *)soap_instantiate__ns1__PunchOut(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__PunchOut **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PunchOut, sizeof(_ns1__PunchOut), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PunchOut(struct soap *soap, _ns1__PunchOut *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__PunchOut(soap, tag ? tag : "ns1:PunchOut", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PunchOut ** SOAP_FMAC4 soap_get_PointerTo_ns1__PunchOut(struct soap *soap, _ns1__PunchOut **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PunchOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BasketLinkPunch(struct soap *soap, _ns1__BasketLinkPunch *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BasketLinkPunch))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BasketLinkPunch(struct soap *soap, const char *tag, int id, _ns1__BasketLinkPunch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BasketLinkPunch, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BasketLinkPunch ? type : NULL);
}

SOAP_FMAC3 _ns1__BasketLinkPunch ** SOAP_FMAC4 soap_in_PointerTo_ns1__BasketLinkPunch(struct soap *soap, const char *tag, _ns1__BasketLinkPunch **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BasketLinkPunch **)soap_malloc(soap, sizeof(_ns1__BasketLinkPunch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BasketLinkPunch *)soap_instantiate__ns1__BasketLinkPunch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BasketLinkPunch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BasketLinkPunch, sizeof(_ns1__BasketLinkPunch), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BasketLinkPunch(struct soap *soap, _ns1__BasketLinkPunch *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BasketLinkPunch(soap, tag ? tag : "ns1:BasketLinkPunch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BasketLinkPunch ** SOAP_FMAC4 soap_get_PointerTo_ns1__BasketLinkPunch(struct soap *soap, _ns1__BasketLinkPunch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BasketLinkPunch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__HPSNLinkBasket(struct soap *soap, _ns1__HPSNLinkBasket *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__HPSNLinkBasket))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__HPSNLinkBasket(struct soap *soap, const char *tag, int id, _ns1__HPSNLinkBasket *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__HPSNLinkBasket, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__HPSNLinkBasket ? type : NULL);
}

SOAP_FMAC3 _ns1__HPSNLinkBasket ** SOAP_FMAC4 soap_in_PointerTo_ns1__HPSNLinkBasket(struct soap *soap, const char *tag, _ns1__HPSNLinkBasket **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__HPSNLinkBasket **)soap_malloc(soap, sizeof(_ns1__HPSNLinkBasket *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__HPSNLinkBasket *)soap_instantiate__ns1__HPSNLinkBasket(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__HPSNLinkBasket **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__HPSNLinkBasket, sizeof(_ns1__HPSNLinkBasket), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__HPSNLinkBasket(struct soap *soap, _ns1__HPSNLinkBasket *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__HPSNLinkBasket(soap, tag ? tag : "ns1:HPSNLinkBasket", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__HPSNLinkBasket ** SOAP_FMAC4 soap_get_PointerTo_ns1__HPSNLinkBasket(struct soap *soap, _ns1__HPSNLinkBasket **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__HPSNLinkBasket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetAutoLineRec(struct soap *soap, _ns1__SetAutoLineRec *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetAutoLineRec))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetAutoLineRec(struct soap *soap, const char *tag, int id, _ns1__SetAutoLineRec *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetAutoLineRec, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetAutoLineRec ? type : NULL);
}

SOAP_FMAC3 _ns1__SetAutoLineRec ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetAutoLineRec(struct soap *soap, const char *tag, _ns1__SetAutoLineRec **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetAutoLineRec **)soap_malloc(soap, sizeof(_ns1__SetAutoLineRec *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetAutoLineRec *)soap_instantiate__ns1__SetAutoLineRec(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetAutoLineRec **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetAutoLineRec, sizeof(_ns1__SetAutoLineRec), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetAutoLineRec(struct soap *soap, _ns1__SetAutoLineRec *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetAutoLineRec(soap, tag ? tag : "ns1:SetAutoLineRec", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetAutoLineRec ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetAutoLineRec(struct soap *soap, _ns1__SetAutoLineRec **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetAutoLineRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSNForLink(struct soap *soap, _ns1__GetSNForLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSNForLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSNForLink(struct soap *soap, const char *tag, int id, _ns1__GetSNForLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSNForLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetSNForLink ? type : NULL);
}

SOAP_FMAC3 _ns1__GetSNForLink ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSNForLink(struct soap *soap, const char *tag, _ns1__GetSNForLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSNForLink **)soap_malloc(soap, sizeof(_ns1__GetSNForLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSNForLink *)soap_instantiate__ns1__GetSNForLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetSNForLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSNForLink, sizeof(_ns1__GetSNForLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSNForLink(struct soap *soap, _ns1__GetSNForLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSNForLink(soap, tag ? tag : "ns1:GetSNForLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSNForLink ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSNForLink(struct soap *soap, _ns1__GetSNForLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSNForLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetFlatnessFruitRec(struct soap *soap, _ns1__SetFlatnessFruitRec *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetFlatnessFruitRec))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetFlatnessFruitRec(struct soap *soap, const char *tag, int id, _ns1__SetFlatnessFruitRec *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetFlatnessFruitRec, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetFlatnessFruitRec ? type : NULL);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetFlatnessFruitRec(struct soap *soap, const char *tag, _ns1__SetFlatnessFruitRec **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetFlatnessFruitRec **)soap_malloc(soap, sizeof(_ns1__SetFlatnessFruitRec *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetFlatnessFruitRec *)soap_instantiate__ns1__SetFlatnessFruitRec(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetFlatnessFruitRec **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetFlatnessFruitRec, sizeof(_ns1__SetFlatnessFruitRec), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetFlatnessFruitRec(struct soap *soap, _ns1__SetFlatnessFruitRec *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetFlatnessFruitRec(soap, tag ? tag : "ns1:SetFlatnessFruitRec", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetFlatnessFruitRec(struct soap *soap, _ns1__SetFlatnessFruitRec **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetFlatnessFruitRec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getStationByMoForTestPad(struct soap *soap, _ns1__getStationByMoForTestPad *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getStationByMoForTestPad))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getStationByMoForTestPad(struct soap *soap, const char *tag, int id, _ns1__getStationByMoForTestPad *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getStationByMoForTestPad, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getStationByMoForTestPad ? type : NULL);
}

SOAP_FMAC3 _ns1__getStationByMoForTestPad ** SOAP_FMAC4 soap_in_PointerTo_ns1__getStationByMoForTestPad(struct soap *soap, const char *tag, _ns1__getStationByMoForTestPad **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getStationByMoForTestPad **)soap_malloc(soap, sizeof(_ns1__getStationByMoForTestPad *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getStationByMoForTestPad *)soap_instantiate__ns1__getStationByMoForTestPad(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getStationByMoForTestPad **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getStationByMoForTestPad, sizeof(_ns1__getStationByMoForTestPad), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getStationByMoForTestPad(struct soap *soap, _ns1__getStationByMoForTestPad *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getStationByMoForTestPad(soap, tag ? tag : "ns1:getStationByMoForTestPad", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getStationByMoForTestPad ** SOAP_FMAC4 soap_get_PointerTo_ns1__getStationByMoForTestPad(struct soap *soap, _ns1__getStationByMoForTestPad **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getStationByMoForTestPad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingWeight(struct soap *soap, _ns1__GetShippingWeight *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingWeight))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingWeight(struct soap *soap, const char *tag, int id, _ns1__GetShippingWeight *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingWeight, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingWeight ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingWeight ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingWeight(struct soap *soap, const char *tag, _ns1__GetShippingWeight **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingWeight **)soap_malloc(soap, sizeof(_ns1__GetShippingWeight *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingWeight *)soap_instantiate__ns1__GetShippingWeight(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingWeight **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingWeight, sizeof(_ns1__GetShippingWeight), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingWeight(struct soap *soap, _ns1__GetShippingWeight *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingWeight(soap, tag ? tag : "ns1:GetShippingWeight", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingWeight ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingWeight(struct soap *soap, _ns1__GetShippingWeight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingWeight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingForBerth(struct soap *soap, _ns1__GetShippingForBerth *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingForBerth))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingForBerth(struct soap *soap, const char *tag, int id, _ns1__GetShippingForBerth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingForBerth, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingForBerth ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingForBerth ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingForBerth(struct soap *soap, const char *tag, _ns1__GetShippingForBerth **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingForBerth **)soap_malloc(soap, sizeof(_ns1__GetShippingForBerth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingForBerth *)soap_instantiate__ns1__GetShippingForBerth(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingForBerth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingForBerth, sizeof(_ns1__GetShippingForBerth), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingForBerth(struct soap *soap, _ns1__GetShippingForBerth *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingForBerth(soap, tag ? tag : "ns1:GetShippingForBerth", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingForBerth ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingForBerth(struct soap *soap, _ns1__GetShippingForBerth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingForBerth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsShippingBerth(struct soap *soap, _ns1__InsShippingBerth *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsShippingBerth))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsShippingBerth(struct soap *soap, const char *tag, int id, _ns1__InsShippingBerth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsShippingBerth, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsShippingBerth ? type : NULL);
}

SOAP_FMAC3 _ns1__InsShippingBerth ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsShippingBerth(struct soap *soap, const char *tag, _ns1__InsShippingBerth **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsShippingBerth **)soap_malloc(soap, sizeof(_ns1__InsShippingBerth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsShippingBerth *)soap_instantiate__ns1__InsShippingBerth(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsShippingBerth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsShippingBerth, sizeof(_ns1__InsShippingBerth), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsShippingBerth(struct soap *soap, _ns1__InsShippingBerth *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsShippingBerth(soap, tag ? tag : "ns1:InsShippingBerth", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsShippingBerth ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsShippingBerth(struct soap *soap, _ns1__InsShippingBerth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsShippingBerth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsShippingPalle(struct soap *soap, _ns1__InsShippingPalle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsShippingPalle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsShippingPalle(struct soap *soap, const char *tag, int id, _ns1__InsShippingPalle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsShippingPalle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsShippingPalle ? type : NULL);
}

SOAP_FMAC3 _ns1__InsShippingPalle ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsShippingPalle(struct soap *soap, const char *tag, _ns1__InsShippingPalle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsShippingPalle **)soap_malloc(soap, sizeof(_ns1__InsShippingPalle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsShippingPalle *)soap_instantiate__ns1__InsShippingPalle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsShippingPalle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsShippingPalle, sizeof(_ns1__InsShippingPalle), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsShippingPalle(struct soap *soap, _ns1__InsShippingPalle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsShippingPalle(soap, tag ? tag : "ns1:InsShippingPalle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsShippingPalle ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsShippingPalle(struct soap *soap, _ns1__InsShippingPalle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsShippingPalle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingPalle(struct soap *soap, _ns1__GetShippingPalle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingPalle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingPalle(struct soap *soap, const char *tag, int id, _ns1__GetShippingPalle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingPalle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingPalle ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingPalle ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingPalle(struct soap *soap, const char *tag, _ns1__GetShippingPalle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingPalle **)soap_malloc(soap, sizeof(_ns1__GetShippingPalle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingPalle *)soap_instantiate__ns1__GetShippingPalle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingPalle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingPalle, sizeof(_ns1__GetShippingPalle), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingPalle(struct soap *soap, _ns1__GetShippingPalle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingPalle(soap, tag ? tag : "ns1:GetShippingPalle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingPalle ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingPalle(struct soap *soap, _ns1__GetShippingPalle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingPalle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdShipping(struct soap *soap, _ns1__UpdShipping *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdShipping))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdShipping(struct soap *soap, const char *tag, int id, _ns1__UpdShipping *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdShipping, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UpdShipping ? type : NULL);
}

SOAP_FMAC3 _ns1__UpdShipping ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdShipping(struct soap *soap, const char *tag, _ns1__UpdShipping **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdShipping **)soap_malloc(soap, sizeof(_ns1__UpdShipping *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdShipping *)soap_instantiate__ns1__UpdShipping(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdShipping **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdShipping, sizeof(_ns1__UpdShipping), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdShipping(struct soap *soap, _ns1__UpdShipping *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdShipping(soap, tag ? tag : "ns1:UpdShipping", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdShipping ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdShipping(struct soap *soap, _ns1__UpdShipping **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdShipping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingBerthList(struct soap *soap, _ns1__GetShippingBerthList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingBerthList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingBerthList(struct soap *soap, const char *tag, int id, _ns1__GetShippingBerthList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingBerthList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingBerthList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingBerthList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingBerthList(struct soap *soap, const char *tag, _ns1__GetShippingBerthList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingBerthList **)soap_malloc(soap, sizeof(_ns1__GetShippingBerthList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingBerthList *)soap_instantiate__ns1__GetShippingBerthList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingBerthList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingBerthList, sizeof(_ns1__GetShippingBerthList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingBerthList(struct soap *soap, _ns1__GetShippingBerthList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingBerthList(soap, tag ? tag : "ns1:GetShippingBerthList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingBerthList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingBerthList(struct soap *soap, _ns1__GetShippingBerthList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingBerthList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingList(struct soap *soap, _ns1__GetShippingList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingList(struct soap *soap, const char *tag, int id, _ns1__GetShippingList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingList(struct soap *soap, const char *tag, _ns1__GetShippingList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingList **)soap_malloc(soap, sizeof(_ns1__GetShippingList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingList *)soap_instantiate__ns1__GetShippingList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingList, sizeof(_ns1__GetShippingList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingList(struct soap *soap, _ns1__GetShippingList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingList(soap, tag ? tag : "ns1:GetShippingList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingList(struct soap *soap, _ns1__GetShippingList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doLotLinkForApple(struct soap *soap, _ns1__doLotLinkForApple *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doLotLinkForApple))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doLotLinkForApple(struct soap *soap, const char *tag, int id, _ns1__doLotLinkForApple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doLotLinkForApple, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doLotLinkForApple ? type : NULL);
}

SOAP_FMAC3 _ns1__doLotLinkForApple ** SOAP_FMAC4 soap_in_PointerTo_ns1__doLotLinkForApple(struct soap *soap, const char *tag, _ns1__doLotLinkForApple **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doLotLinkForApple **)soap_malloc(soap, sizeof(_ns1__doLotLinkForApple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doLotLinkForApple *)soap_instantiate__ns1__doLotLinkForApple(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doLotLinkForApple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doLotLinkForApple, sizeof(_ns1__doLotLinkForApple), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doLotLinkForApple(struct soap *soap, _ns1__doLotLinkForApple *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doLotLinkForApple(soap, tag ? tag : "ns1:doLotLinkForApple", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doLotLinkForApple ** SOAP_FMAC4 soap_get_PointerTo_ns1__doLotLinkForApple(struct soap *soap, _ns1__doLotLinkForApple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doLotLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotLinkCount(struct soap *soap, _ns1__GetLotLinkCount *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotLinkCount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotLinkCount(struct soap *soap, const char *tag, int id, _ns1__GetLotLinkCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotLinkCount, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetLotLinkCount ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLotLinkCount ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotLinkCount(struct soap *soap, const char *tag, _ns1__GetLotLinkCount **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotLinkCount **)soap_malloc(soap, sizeof(_ns1__GetLotLinkCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotLinkCount *)soap_instantiate__ns1__GetLotLinkCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLotLinkCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotLinkCount, sizeof(_ns1__GetLotLinkCount), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotLinkCount(struct soap *soap, _ns1__GetLotLinkCount *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLotLinkCount(soap, tag ? tag : "ns1:GetLotLinkCount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotLinkCount ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotLinkCount(struct soap *soap, _ns1__GetLotLinkCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotLinkCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFruitSNCheck(struct soap *soap, _ns1__GetFruitSNCheck *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFruitSNCheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFruitSNCheck(struct soap *soap, const char *tag, int id, _ns1__GetFruitSNCheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFruitSNCheck, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetFruitSNCheck ? type : NULL);
}

SOAP_FMAC3 _ns1__GetFruitSNCheck ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFruitSNCheck(struct soap *soap, const char *tag, _ns1__GetFruitSNCheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFruitSNCheck **)soap_malloc(soap, sizeof(_ns1__GetFruitSNCheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFruitSNCheck *)soap_instantiate__ns1__GetFruitSNCheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetFruitSNCheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFruitSNCheck, sizeof(_ns1__GetFruitSNCheck), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFruitSNCheck(struct soap *soap, _ns1__GetFruitSNCheck *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFruitSNCheck(soap, tag ? tag : "ns1:GetFruitSNCheck", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFruitSNCheck ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFruitSNCheck(struct soap *soap, _ns1__GetFruitSNCheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFruitSNCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObeNW(struct soap *soap, _ns1__GetObeNW *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObeNW))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObeNW(struct soap *soap, const char *tag, int id, _ns1__GetObeNW *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObeNW, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetObeNW ? type : NULL);
}

SOAP_FMAC3 _ns1__GetObeNW ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObeNW(struct soap *soap, const char *tag, _ns1__GetObeNW **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObeNW **)soap_malloc(soap, sizeof(_ns1__GetObeNW *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObeNW *)soap_instantiate__ns1__GetObeNW(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetObeNW **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObeNW, sizeof(_ns1__GetObeNW), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObeNW(struct soap *soap, _ns1__GetObeNW *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetObeNW(soap, tag ? tag : "ns1:GetObeNW", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObeNW ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObeNW(struct soap *soap, _ns1__GetObeNW **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObeNW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doSnLinkForApple(struct soap *soap, _ns1__doSnLinkForApple *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doSnLinkForApple))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doSnLinkForApple(struct soap *soap, const char *tag, int id, _ns1__doSnLinkForApple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doSnLinkForApple, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doSnLinkForApple ? type : NULL);
}

SOAP_FMAC3 _ns1__doSnLinkForApple ** SOAP_FMAC4 soap_in_PointerTo_ns1__doSnLinkForApple(struct soap *soap, const char *tag, _ns1__doSnLinkForApple **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doSnLinkForApple **)soap_malloc(soap, sizeof(_ns1__doSnLinkForApple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doSnLinkForApple *)soap_instantiate__ns1__doSnLinkForApple(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doSnLinkForApple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doSnLinkForApple, sizeof(_ns1__doSnLinkForApple), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doSnLinkForApple(struct soap *soap, _ns1__doSnLinkForApple *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doSnLinkForApple(soap, tag ? tag : "ns1:doSnLinkForApple", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doSnLinkForApple ** SOAP_FMAC4 soap_get_PointerTo_ns1__doSnLinkForApple(struct soap *soap, _ns1__doSnLinkForApple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doSnLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChkSnLinkForApple(struct soap *soap, _ns1__ChkSnLinkForApple *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChkSnLinkForApple))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChkSnLinkForApple(struct soap *soap, const char *tag, int id, _ns1__ChkSnLinkForApple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChkSnLinkForApple, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChkSnLinkForApple ? type : NULL);
}

SOAP_FMAC3 _ns1__ChkSnLinkForApple ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChkSnLinkForApple(struct soap *soap, const char *tag, _ns1__ChkSnLinkForApple **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChkSnLinkForApple **)soap_malloc(soap, sizeof(_ns1__ChkSnLinkForApple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChkSnLinkForApple *)soap_instantiate__ns1__ChkSnLinkForApple(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChkSnLinkForApple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChkSnLinkForApple, sizeof(_ns1__ChkSnLinkForApple), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChkSnLinkForApple(struct soap *soap, _ns1__ChkSnLinkForApple *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChkSnLinkForApple(soap, tag ? tag : "ns1:ChkSnLinkForApple", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChkSnLinkForApple ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChkSnLinkForApple(struct soap *soap, _ns1__ChkSnLinkForApple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChkSnLinkForApple(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DelSNTest(struct soap *soap, _ns1__DelSNTest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DelSNTest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DelSNTest(struct soap *soap, const char *tag, int id, _ns1__DelSNTest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DelSNTest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DelSNTest ? type : NULL);
}

SOAP_FMAC3 _ns1__DelSNTest ** SOAP_FMAC4 soap_in_PointerTo_ns1__DelSNTest(struct soap *soap, const char *tag, _ns1__DelSNTest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DelSNTest **)soap_malloc(soap, sizeof(_ns1__DelSNTest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DelSNTest *)soap_instantiate__ns1__DelSNTest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DelSNTest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DelSNTest, sizeof(_ns1__DelSNTest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DelSNTest(struct soap *soap, _ns1__DelSNTest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DelSNTest(soap, tag ? tag : "ns1:DelSNTest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DelSNTest ** SOAP_FMAC4 soap_get_PointerTo_ns1__DelSNTest(struct soap *soap, _ns1__DelSNTest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DelSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SelSNTest(struct soap *soap, _ns1__SelSNTest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SelSNTest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SelSNTest(struct soap *soap, const char *tag, int id, _ns1__SelSNTest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SelSNTest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SelSNTest ? type : NULL);
}

SOAP_FMAC3 _ns1__SelSNTest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SelSNTest(struct soap *soap, const char *tag, _ns1__SelSNTest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SelSNTest **)soap_malloc(soap, sizeof(_ns1__SelSNTest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SelSNTest *)soap_instantiate__ns1__SelSNTest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SelSNTest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SelSNTest, sizeof(_ns1__SelSNTest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SelSNTest(struct soap *soap, _ns1__SelSNTest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SelSNTest(soap, tag ? tag : "ns1:SelSNTest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SelSNTest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SelSNTest(struct soap *soap, _ns1__SelSNTest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SelSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsSNTest(struct soap *soap, _ns1__InsSNTest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsSNTest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsSNTest(struct soap *soap, const char *tag, int id, _ns1__InsSNTest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsSNTest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InsSNTest ? type : NULL);
}

SOAP_FMAC3 _ns1__InsSNTest ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsSNTest(struct soap *soap, const char *tag, _ns1__InsSNTest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsSNTest **)soap_malloc(soap, sizeof(_ns1__InsSNTest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsSNTest *)soap_instantiate__ns1__InsSNTest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsSNTest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsSNTest, sizeof(_ns1__InsSNTest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsSNTest(struct soap *soap, _ns1__InsSNTest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsSNTest(soap, tag ? tag : "ns1:InsSNTest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsSNTest ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsSNTest(struct soap *soap, _ns1__InsSNTest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsSNTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChkWeightTime(struct soap *soap, _ns1__ChkWeightTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChkWeightTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChkWeightTime(struct soap *soap, const char *tag, int id, _ns1__ChkWeightTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChkWeightTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChkWeightTime ? type : NULL);
}

SOAP_FMAC3 _ns1__ChkWeightTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChkWeightTime(struct soap *soap, const char *tag, _ns1__ChkWeightTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChkWeightTime **)soap_malloc(soap, sizeof(_ns1__ChkWeightTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChkWeightTime *)soap_instantiate__ns1__ChkWeightTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChkWeightTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChkWeightTime, sizeof(_ns1__ChkWeightTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChkWeightTime(struct soap *soap, _ns1__ChkWeightTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChkWeightTime(soap, tag ? tag : "ns1:ChkWeightTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChkWeightTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChkWeightTime(struct soap *soap, _ns1__ChkWeightTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChkWeightTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdAhsBarcode(struct soap *soap, _ns1__UpdAhsBarcode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdAhsBarcode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdAhsBarcode(struct soap *soap, const char *tag, int id, _ns1__UpdAhsBarcode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdAhsBarcode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UpdAhsBarcode ? type : NULL);
}

SOAP_FMAC3 _ns1__UpdAhsBarcode ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdAhsBarcode(struct soap *soap, const char *tag, _ns1__UpdAhsBarcode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdAhsBarcode **)soap_malloc(soap, sizeof(_ns1__UpdAhsBarcode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdAhsBarcode *)soap_instantiate__ns1__UpdAhsBarcode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdAhsBarcode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdAhsBarcode, sizeof(_ns1__UpdAhsBarcode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdAhsBarcode(struct soap *soap, _ns1__UpdAhsBarcode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdAhsBarcode(soap, tag ? tag : "ns1:UpdAhsBarcode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdAhsBarcode ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdAhsBarcode(struct soap *soap, _ns1__UpdAhsBarcode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdAhsBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAhsBarcode(struct soap *soap, _ns1__GetAhsBarcode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAhsBarcode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAhsBarcode(struct soap *soap, const char *tag, int id, _ns1__GetAhsBarcode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAhsBarcode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAhsBarcode ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAhsBarcode ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAhsBarcode(struct soap *soap, const char *tag, _ns1__GetAhsBarcode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAhsBarcode **)soap_malloc(soap, sizeof(_ns1__GetAhsBarcode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAhsBarcode *)soap_instantiate__ns1__GetAhsBarcode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAhsBarcode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAhsBarcode, sizeof(_ns1__GetAhsBarcode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAhsBarcode(struct soap *soap, _ns1__GetAhsBarcode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAhsBarcode(soap, tag ? tag : "ns1:GetAhsBarcode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAhsBarcode ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAhsBarcode(struct soap *soap, _ns1__GetAhsBarcode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAhsBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, _ns1__GetAhsMoResponse_GetAhsMoResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, const char *tag, int id, _ns1__GetAhsMoResponse_GetAhsMoResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAhsMoResponse_GetAhsMoResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, const char *tag, _ns1__GetAhsMoResponse_GetAhsMoResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAhsMoResponse_GetAhsMoResult **)soap_malloc(soap, sizeof(_ns1__GetAhsMoResponse_GetAhsMoResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAhsMoResponse_GetAhsMoResult *)soap_instantiate__ns1__GetAhsMoResponse_GetAhsMoResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAhsMoResponse_GetAhsMoResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAhsMoResponse_GetAhsMoResult, sizeof(_ns1__GetAhsMoResponse_GetAhsMoResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, _ns1__GetAhsMoResponse_GetAhsMoResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag ? tag : "ns1:GetAhsMoResponse-GetAhsMoResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAhsMoResponse_GetAhsMoResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(struct soap *soap, _ns1__GetAhsMoResponse_GetAhsMoResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAhsMoResponse_GetAhsMoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, const char *tag, int id, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPallentToWMSResponse_GetPallentToWMSResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, const char *tag, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult **)soap_malloc(soap, sizeof(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult *)soap_instantiate__ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPallentToWMSResponse_GetPallentToWMSResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPallentToWMSResponse_GetPallentToWMSResult, sizeof(_ns1__GetPallentToWMSResponse_GetPallentToWMSResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag ? tag : "ns1:GetPallentToWMSResponse-GetPallentToWMSResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPallentToWMSResponse_GetPallentToWMSResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(struct soap *soap, _ns1__GetPallentToWMSResponse_GetPallentToWMSResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPallentToWMSResponse_GetPallentToWMSResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doLinkOutSN_assyDt(struct soap *soap, _ns1__doLinkOutSN_assyDt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doLinkOutSN_assyDt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doLinkOutSN_assyDt(struct soap *soap, const char *tag, int id, _ns1__doLinkOutSN_assyDt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doLinkOutSN_assyDt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doLinkOutSN_assyDt ? type : NULL);
}

SOAP_FMAC3 _ns1__doLinkOutSN_assyDt ** SOAP_FMAC4 soap_in_PointerTo_ns1__doLinkOutSN_assyDt(struct soap *soap, const char *tag, _ns1__doLinkOutSN_assyDt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doLinkOutSN_assyDt **)soap_malloc(soap, sizeof(_ns1__doLinkOutSN_assyDt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doLinkOutSN_assyDt *)soap_instantiate__ns1__doLinkOutSN_assyDt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doLinkOutSN_assyDt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doLinkOutSN_assyDt, sizeof(_ns1__doLinkOutSN_assyDt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doLinkOutSN_assyDt(struct soap *soap, _ns1__doLinkOutSN_assyDt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doLinkOutSN_assyDt(soap, tag ? tag : "ns1:doLinkOutSN-assyDt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doLinkOutSN_assyDt ** SOAP_FMAC4 soap_get_PointerTo_ns1__doLinkOutSN_assyDt(struct soap *soap, _ns1__doLinkOutSN_assyDt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doLinkOutSN_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doPmcSNLink_assyDt(struct soap *soap, _ns1__doPmcSNLink_assyDt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doPmcSNLink_assyDt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doPmcSNLink_assyDt(struct soap *soap, const char *tag, int id, _ns1__doPmcSNLink_assyDt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doPmcSNLink_assyDt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doPmcSNLink_assyDt ? type : NULL);
}

SOAP_FMAC3 _ns1__doPmcSNLink_assyDt ** SOAP_FMAC4 soap_in_PointerTo_ns1__doPmcSNLink_assyDt(struct soap *soap, const char *tag, _ns1__doPmcSNLink_assyDt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doPmcSNLink_assyDt **)soap_malloc(soap, sizeof(_ns1__doPmcSNLink_assyDt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doPmcSNLink_assyDt *)soap_instantiate__ns1__doPmcSNLink_assyDt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doPmcSNLink_assyDt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doPmcSNLink_assyDt, sizeof(_ns1__doPmcSNLink_assyDt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doPmcSNLink_assyDt(struct soap *soap, _ns1__doPmcSNLink_assyDt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doPmcSNLink_assyDt(soap, tag ? tag : "ns1:doPmcSNLink-assyDt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doPmcSNLink_assyDt ** SOAP_FMAC4 soap_get_PointerTo_ns1__doPmcSNLink_assyDt(struct soap *soap, _ns1__doPmcSNLink_assyDt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doPmcSNLink_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, const char *tag, int id, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult ? type : NULL);
}

SOAP_FMAC3 _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, const char *tag, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult **)soap_malloc(soap, sizeof(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *)soap_instantiate__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult, sizeof(_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag ? tag : "ns1:getPmcPartAssyListResponse-getPmcPartAssyListResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(struct soap *soap, _ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPmcPartAssyListResponse_getPmcPartAssyListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, _ns1__getPmcAssyListResponse_getPmcAssyListResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, const char *tag, int id, _ns1__getPmcAssyListResponse_getPmcAssyListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult ? type : NULL);
}

SOAP_FMAC3 _ns1__getPmcAssyListResponse_getPmcAssyListResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, const char *tag, _ns1__getPmcAssyListResponse_getPmcAssyListResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPmcAssyListResponse_getPmcAssyListResult **)soap_malloc(soap, sizeof(_ns1__getPmcAssyListResponse_getPmcAssyListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPmcAssyListResponse_getPmcAssyListResult *)soap_instantiate__ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPmcAssyListResponse_getPmcAssyListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPmcAssyListResponse_getPmcAssyListResult, sizeof(_ns1__getPmcAssyListResponse_getPmcAssyListResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, _ns1__getPmcAssyListResponse_getPmcAssyListResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag ? tag : "ns1:getPmcAssyListResponse-getPmcAssyListResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPmcAssyListResponse_getPmcAssyListResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(struct soap *soap, _ns1__getPmcAssyListResponse_getPmcAssyListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPmcAssyListResponse_getPmcAssyListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doAssy_assyDt(struct soap *soap, _ns1__doAssy_assyDt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doAssy_assyDt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doAssy_assyDt(struct soap *soap, const char *tag, int id, _ns1__doAssy_assyDt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doAssy_assyDt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doAssy_assyDt ? type : NULL);
}

SOAP_FMAC3 _ns1__doAssy_assyDt ** SOAP_FMAC4 soap_in_PointerTo_ns1__doAssy_assyDt(struct soap *soap, const char *tag, _ns1__doAssy_assyDt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doAssy_assyDt **)soap_malloc(soap, sizeof(_ns1__doAssy_assyDt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doAssy_assyDt *)soap_instantiate__ns1__doAssy_assyDt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doAssy_assyDt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doAssy_assyDt, sizeof(_ns1__doAssy_assyDt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doAssy_assyDt(struct soap *soap, _ns1__doAssy_assyDt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doAssy_assyDt(soap, tag ? tag : "ns1:doAssy-assyDt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doAssy_assyDt ** SOAP_FMAC4 soap_get_PointerTo_ns1__doAssy_assyDt(struct soap *soap, _ns1__doAssy_assyDt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doAssy_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, const char *tag, int id, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLinkOutSnResponse_GetLinkOutSnResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, const char *tag, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult **)soap_malloc(soap, sizeof(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult *)soap_instantiate__ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLinkOutSnResponse_GetLinkOutSnResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLinkOutSnResponse_GetLinkOutSnResult, sizeof(_ns1__GetLinkOutSnResponse_GetLinkOutSnResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag ? tag : "ns1:GetLinkOutSnResponse-GetLinkOutSnResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLinkOutSnResponse_GetLinkOutSnResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(struct soap *soap, _ns1__GetLinkOutSnResponse_GetLinkOutSnResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLinkOutSnResponse_GetLinkOutSnResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, _ns1__getPartBomExtResponse_getPartBomExtResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, const char *tag, int id, _ns1__getPartBomExtResponse_getPartBomExtResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult ? type : NULL);
}

SOAP_FMAC3 _ns1__getPartBomExtResponse_getPartBomExtResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, const char *tag, _ns1__getPartBomExtResponse_getPartBomExtResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPartBomExtResponse_getPartBomExtResult **)soap_malloc(soap, sizeof(_ns1__getPartBomExtResponse_getPartBomExtResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPartBomExtResponse_getPartBomExtResult *)soap_instantiate__ns1__getPartBomExtResponse_getPartBomExtResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getPartBomExtResponse_getPartBomExtResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPartBomExtResponse_getPartBomExtResult, sizeof(_ns1__getPartBomExtResponse_getPartBomExtResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, _ns1__getPartBomExtResponse_getPartBomExtResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag ? tag : "ns1:getPartBomExtResponse-getPartBomExtResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPartBomExtResponse_getPartBomExtResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(struct soap *soap, _ns1__getPartBomExtResponse_getPartBomExtResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPartBomExtResponse_getPartBomExtResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, _ns1__getMoAssyListResponse_getMoAssyListResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, const char *tag, int id, _ns1__getMoAssyListResponse_getMoAssyListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult ? type : NULL);
}

SOAP_FMAC3 _ns1__getMoAssyListResponse_getMoAssyListResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, const char *tag, _ns1__getMoAssyListResponse_getMoAssyListResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMoAssyListResponse_getMoAssyListResult **)soap_malloc(soap, sizeof(_ns1__getMoAssyListResponse_getMoAssyListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMoAssyListResponse_getMoAssyListResult *)soap_instantiate__ns1__getMoAssyListResponse_getMoAssyListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getMoAssyListResponse_getMoAssyListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMoAssyListResponse_getMoAssyListResult, sizeof(_ns1__getMoAssyListResponse_getMoAssyListResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, _ns1__getMoAssyListResponse_getMoAssyListResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag ? tag : "ns1:getMoAssyListResponse-getMoAssyListResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMoAssyListResponse_getMoAssyListResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(struct soap *soap, _ns1__getMoAssyListResponse_getMoAssyListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMoAssyListResponse_getMoAssyListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, _ns1__getInfoByMoResponse_getInfoByMoResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, const char *tag, int id, _ns1__getInfoByMoResponse_getInfoByMoResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult ? type : NULL);
}

SOAP_FMAC3 _ns1__getInfoByMoResponse_getInfoByMoResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, const char *tag, _ns1__getInfoByMoResponse_getInfoByMoResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getInfoByMoResponse_getInfoByMoResult **)soap_malloc(soap, sizeof(_ns1__getInfoByMoResponse_getInfoByMoResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getInfoByMoResponse_getInfoByMoResult *)soap_instantiate__ns1__getInfoByMoResponse_getInfoByMoResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getInfoByMoResponse_getInfoByMoResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getInfoByMoResponse_getInfoByMoResult, sizeof(_ns1__getInfoByMoResponse_getInfoByMoResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, _ns1__getInfoByMoResponse_getInfoByMoResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag ? tag : "ns1:getInfoByMoResponse-getInfoByMoResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getInfoByMoResponse_getInfoByMoResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(struct soap *soap, _ns1__getInfoByMoResponse_getInfoByMoResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getInfoByMoResponse_getInfoByMoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfString ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfString(soap, tag ? tag : "ns1:ArrayOfString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, const char *tag, int id, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMachineForGroupResponse_GetMachineForGroupResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, const char *tag, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult **)soap_malloc(soap, sizeof(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult *)soap_instantiate__ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMachineForGroupResponse_GetMachineForGroupResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMachineForGroupResponse_GetMachineForGroupResult, sizeof(_ns1__GetMachineForGroupResponse_GetMachineForGroupResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag ? tag : "ns1:GetMachineForGroupResponse-GetMachineForGroupResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMachineForGroupResponse_GetMachineForGroupResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(struct soap *soap, _ns1__GetMachineForGroupResponse_GetMachineForGroupResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMachineForGroupResponse_GetMachineForGroupResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetFlatnessFruitRec_dt(struct soap *soap, _ns1__SetFlatnessFruitRec_dt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetFlatnessFruitRec_dt(struct soap *soap, const char *tag, int id, _ns1__SetFlatnessFruitRec_dt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetFlatnessFruitRec_dt ? type : NULL);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec_dt ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetFlatnessFruitRec_dt(struct soap *soap, const char *tag, _ns1__SetFlatnessFruitRec_dt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetFlatnessFruitRec_dt **)soap_malloc(soap, sizeof(_ns1__SetFlatnessFruitRec_dt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetFlatnessFruitRec_dt *)soap_instantiate__ns1__SetFlatnessFruitRec_dt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetFlatnessFruitRec_dt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetFlatnessFruitRec_dt, sizeof(_ns1__SetFlatnessFruitRec_dt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetFlatnessFruitRec_dt(struct soap *soap, _ns1__SetFlatnessFruitRec_dt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, tag ? tag : "ns1:SetFlatnessFruitRec-dt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetFlatnessFruitRec_dt ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetFlatnessFruitRec_dt(struct soap *soap, _ns1__SetFlatnessFruitRec_dt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetFlatnessFruitRec_dt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, _ns1__GetShippingWeightResponse_GetShippingWeightResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, const char *tag, int id, _ns1__GetShippingWeightResponse_GetShippingWeightResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingWeightResponse_GetShippingWeightResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, const char *tag, _ns1__GetShippingWeightResponse_GetShippingWeightResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingWeightResponse_GetShippingWeightResult **)soap_malloc(soap, sizeof(_ns1__GetShippingWeightResponse_GetShippingWeightResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingWeightResponse_GetShippingWeightResult *)soap_instantiate__ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingWeightResponse_GetShippingWeightResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingWeightResponse_GetShippingWeightResult, sizeof(_ns1__GetShippingWeightResponse_GetShippingWeightResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, _ns1__GetShippingWeightResponse_GetShippingWeightResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag ? tag : "ns1:GetShippingWeightResponse-GetShippingWeightResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingWeightResponse_GetShippingWeightResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(struct soap *soap, _ns1__GetShippingWeightResponse_GetShippingWeightResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingWeightResponse_GetShippingWeightResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, const char *tag, int id, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingForBerthResponse_GetShippingForBerthResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, const char *tag, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult **)soap_malloc(soap, sizeof(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult *)soap_instantiate__ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingForBerthResponse_GetShippingForBerthResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingForBerthResponse_GetShippingForBerthResult, sizeof(_ns1__GetShippingForBerthResponse_GetShippingForBerthResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag ? tag : "ns1:GetShippingForBerthResponse-GetShippingForBerthResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingForBerthResponse_GetShippingForBerthResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(struct soap *soap, _ns1__GetShippingForBerthResponse_GetShippingForBerthResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingForBerthResponse_GetShippingForBerthResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, const char *tag, int id, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingBerthListResponse_GetShippingBerthListResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, const char *tag, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult **)soap_malloc(soap, sizeof(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult *)soap_instantiate__ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingBerthListResponse_GetShippingBerthListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingBerthListResponse_GetShippingBerthListResult, sizeof(_ns1__GetShippingBerthListResponse_GetShippingBerthListResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag ? tag : "ns1:GetShippingBerthListResponse-GetShippingBerthListResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingBerthListResponse_GetShippingBerthListResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(struct soap *soap, _ns1__GetShippingBerthListResponse_GetShippingBerthListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingBerthListResponse_GetShippingBerthListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, _ns1__GetShippingListResponse_GetShippingListResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, const char *tag, int id, _ns1__GetShippingListResponse_GetShippingListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShippingListResponse_GetShippingListResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, const char *tag, _ns1__GetShippingListResponse_GetShippingListResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShippingListResponse_GetShippingListResult **)soap_malloc(soap, sizeof(_ns1__GetShippingListResponse_GetShippingListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShippingListResponse_GetShippingListResult *)soap_instantiate__ns1__GetShippingListResponse_GetShippingListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShippingListResponse_GetShippingListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShippingListResponse_GetShippingListResult, sizeof(_ns1__GetShippingListResponse_GetShippingListResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, _ns1__GetShippingListResponse_GetShippingListResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, tag ? tag : "ns1:GetShippingListResponse-GetShippingListResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShippingListResponse_GetShippingListResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(struct soap *soap, _ns1__GetShippingListResponse_GetShippingListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShippingListResponse_GetShippingListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doLotLinkForApple_assyDt(struct soap *soap, _ns1__doLotLinkForApple_assyDt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doLotLinkForApple_assyDt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doLotLinkForApple_assyDt(struct soap *soap, const char *tag, int id, _ns1__doLotLinkForApple_assyDt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doLotLinkForApple_assyDt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doLotLinkForApple_assyDt ? type : NULL);
}

SOAP_FMAC3 _ns1__doLotLinkForApple_assyDt ** SOAP_FMAC4 soap_in_PointerTo_ns1__doLotLinkForApple_assyDt(struct soap *soap, const char *tag, _ns1__doLotLinkForApple_assyDt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doLotLinkForApple_assyDt **)soap_malloc(soap, sizeof(_ns1__doLotLinkForApple_assyDt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doLotLinkForApple_assyDt *)soap_instantiate__ns1__doLotLinkForApple_assyDt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doLotLinkForApple_assyDt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doLotLinkForApple_assyDt, sizeof(_ns1__doLotLinkForApple_assyDt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doLotLinkForApple_assyDt(struct soap *soap, _ns1__doLotLinkForApple_assyDt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doLotLinkForApple_assyDt(soap, tag ? tag : "ns1:doLotLinkForApple-assyDt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doLotLinkForApple_assyDt ** SOAP_FMAC4 soap_get_PointerTo_ns1__doLotLinkForApple_assyDt(struct soap *soap, _ns1__doLotLinkForApple_assyDt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doLotLinkForApple_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__doSnLinkForApple_assyDt(struct soap *soap, _ns1__doSnLinkForApple_assyDt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__doSnLinkForApple_assyDt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__doSnLinkForApple_assyDt(struct soap *soap, const char *tag, int id, _ns1__doSnLinkForApple_assyDt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__doSnLinkForApple_assyDt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__doSnLinkForApple_assyDt ? type : NULL);
}

SOAP_FMAC3 _ns1__doSnLinkForApple_assyDt ** SOAP_FMAC4 soap_in_PointerTo_ns1__doSnLinkForApple_assyDt(struct soap *soap, const char *tag, _ns1__doSnLinkForApple_assyDt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__doSnLinkForApple_assyDt **)soap_malloc(soap, sizeof(_ns1__doSnLinkForApple_assyDt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__doSnLinkForApple_assyDt *)soap_instantiate__ns1__doSnLinkForApple_assyDt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__doSnLinkForApple_assyDt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__doSnLinkForApple_assyDt, sizeof(_ns1__doSnLinkForApple_assyDt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__doSnLinkForApple_assyDt(struct soap *soap, _ns1__doSnLinkForApple_assyDt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__doSnLinkForApple_assyDt(soap, tag ? tag : "ns1:doSnLinkForApple-assyDt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__doSnLinkForApple_assyDt ** SOAP_FMAC4 soap_get_PointerTo_ns1__doSnLinkForApple_assyDt(struct soap *soap, _ns1__doSnLinkForApple_assyDt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__doSnLinkForApple_assyDt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, const char *tag, int id, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, const char *tag, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult **)soap_malloc(soap, sizeof(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *)soap_instantiate__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult, sizeof(_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag ? tag : "ns1:GetAhsBarcodeResponse-GetAhsBarcodeResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(struct soap *soap, _ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAhsBarcodeResponse_GetAhsBarcodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
